'use strict';

var require$$0$7 = require('electron');
var require$$0$4 = require('fs');
var require$$0$3 = require('constants');
var Stream$3 = require('stream');
var require$$4$2 = require('util');
var require$$5$2 = require('assert');
var require$$1$3 = require('path');
var require$$2$3 = require('url');
var http = require('http');
var https = require('https');
var zlib$1 = require('zlib');
var require$$0$5 = require('buffer');
var require$$2$2 = require('string_decoder');
var require$$4$4 = require('crypto');
var require$$0$6 = require('os');
var require$$4$3 = require('fs/promises');
var require$$0$8 = require('events');
var require$$2$4 = require('child_process');
var require$$8$1 = require('net');
var require$$10$2 = require('tls');
var require$$0$9 = require('original-fs');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
	if (e && e.__esModule) return e;
	var n = Object.create(null);
	if (e) {
		Object.keys(e).forEach(function (k) {
			if (k !== 'default') {
				var d = Object.getOwnPropertyDescriptor(e, k);
				Object.defineProperty(n, k, d.get ? d : {
					enumerable: true,
					get: function () { return e[k]; }
				});
			}
		});
	}
	n["default"] = e;
	return Object.freeze(n);
}

var require$$0__default$4 = /*#__PURE__*/_interopDefaultLegacy(require$$0$7);
var require$$0__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$0$4);
var require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0$3);
var Stream__default = /*#__PURE__*/_interopDefaultLegacy(Stream$3);
var require$$4__default = /*#__PURE__*/_interopDefaultLegacy(require$$4$2);
var require$$5__default = /*#__PURE__*/_interopDefaultLegacy(require$$5$2);
var require$$1__default = /*#__PURE__*/_interopDefaultLegacy(require$$1$3);
var require$$2__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$2$3);
var http__namespace = /*#__PURE__*/_interopNamespace(http);
var http__default = /*#__PURE__*/_interopDefaultLegacy(http);
var https__namespace = /*#__PURE__*/_interopNamespace(https);
var https__default = /*#__PURE__*/_interopDefaultLegacy(https);
var zlib__namespace = /*#__PURE__*/_interopNamespace(zlib$1);
var zlib__default = /*#__PURE__*/_interopDefaultLegacy(zlib$1);
var require$$0__default$2 = /*#__PURE__*/_interopDefaultLegacy(require$$0$5);
var require$$2__default = /*#__PURE__*/_interopDefaultLegacy(require$$2$2);
var require$$4__default$2 = /*#__PURE__*/_interopDefaultLegacy(require$$4$4);
var require$$0__default$3 = /*#__PURE__*/_interopDefaultLegacy(require$$0$6);
var require$$4__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$4$3);
var require$$0__default$5 = /*#__PURE__*/_interopDefaultLegacy(require$$0$8);
var require$$2__default$2 = /*#__PURE__*/_interopDefaultLegacy(require$$2$4);
var require$$8__default = /*#__PURE__*/_interopDefaultLegacy(require$$8$1);
var require$$10__default = /*#__PURE__*/_interopDefaultLegacy(require$$10$2);
var require$$0__default$6 = /*#__PURE__*/_interopDefaultLegacy(require$$0$9);

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getAugmentedNamespace(n) {
	if (n.__esModule) return n;
	var a = Object.defineProperty({}, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

function commonjsRequire (path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var main$1 = {};

var fs$r = {};

var universalify$1 = {};

universalify$1.fromCallback = function (fn) {
  return Object.defineProperty(function (...args) {
    if (typeof args[args.length - 1] === 'function') fn.apply(this, args);
    else {
      return new Promise((resolve, reject) => {
        fn.call(
          this,
          ...args,
          (err, res) => (err != null) ? reject(err) : resolve(res)
        );
      })
    }
  }, 'name', { value: fn.name })
};

universalify$1.fromPromise = function (fn) {
  return Object.defineProperty(function (...args) {
    const cb = args[args.length - 1];
    if (typeof cb !== 'function') return fn.apply(this, args)
    else fn.apply(this, args.slice(0, -1)).then(r => cb(null, r), cb);
  }, 'name', { value: fn.name })
};

var constants$1 = require$$0__default["default"];

var origCwd = process.cwd;
var cwd = null;

var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;

process.cwd = function() {
  if (!cwd)
    cwd = origCwd.call(process);
  return cwd
};
try {
  process.cwd();
} catch (er) {}

// This check is needed until node.js 12 is required
if (typeof process.chdir === 'function') {
  var chdir = process.chdir;
  process.chdir = function (d) {
    cwd = null;
    chdir.call(process, d);
  };
  if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
}

var polyfills$1 = patch$2;

function patch$2 (fs) {
  // (re-)implement some things that are known busted or missing.

  // lchmod, broken prior to 0.6.2
  // back-port the fix here.
  if (constants$1.hasOwnProperty('O_SYMLINK') &&
      process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
    patchLchmod(fs);
  }

  // lutimes implementation, or no-op
  if (!fs.lutimes) {
    patchLutimes(fs);
  }

  // https://github.com/isaacs/node-graceful-fs/issues/4
  // Chown should not fail on einval or eperm if non-root.
  // It should not fail on enosys ever, as this just indicates
  // that a fs doesn't support the intended operation.

  fs.chown = chownFix(fs.chown);
  fs.fchown = chownFix(fs.fchown);
  fs.lchown = chownFix(fs.lchown);

  fs.chmod = chmodFix(fs.chmod);
  fs.fchmod = chmodFix(fs.fchmod);
  fs.lchmod = chmodFix(fs.lchmod);

  fs.chownSync = chownFixSync(fs.chownSync);
  fs.fchownSync = chownFixSync(fs.fchownSync);
  fs.lchownSync = chownFixSync(fs.lchownSync);

  fs.chmodSync = chmodFixSync(fs.chmodSync);
  fs.fchmodSync = chmodFixSync(fs.fchmodSync);
  fs.lchmodSync = chmodFixSync(fs.lchmodSync);

  fs.stat = statFix(fs.stat);
  fs.fstat = statFix(fs.fstat);
  fs.lstat = statFix(fs.lstat);

  fs.statSync = statFixSync(fs.statSync);
  fs.fstatSync = statFixSync(fs.fstatSync);
  fs.lstatSync = statFixSync(fs.lstatSync);

  // if lchmod/lchown do not exist, then make them no-ops
  if (!fs.lchmod) {
    fs.lchmod = function (path, mode, cb) {
      if (cb) process.nextTick(cb);
    };
    fs.lchmodSync = function () {};
  }
  if (!fs.lchown) {
    fs.lchown = function (path, uid, gid, cb) {
      if (cb) process.nextTick(cb);
    };
    fs.lchownSync = function () {};
  }

  // on Windows, A/V software can lock the directory, causing this
  // to fail with an EACCES or EPERM if the directory contains newly
  // created files.  Try again on failure, for up to 60 seconds.

  // Set the timeout this long because some Windows Anti-Virus, such as Parity
  // bit9, may lock files for up to a minute, causing npm package install
  // failures. Also, take care to yield the scheduler. Windows scheduling gives
  // CPU to a busy looping process, which can cause the program causing the lock
  // contention to be starved of CPU by node, so the contention doesn't resolve.
  if (platform === "win32") {
    fs.rename = (function (fs$rename) { return function (from, to, cb) {
      var start = Date.now();
      var backoff = 0;
      fs$rename(from, to, function CB (er) {
        if (er
            && (er.code === "EACCES" || er.code === "EPERM")
            && Date.now() - start < 60000) {
          setTimeout(function() {
            fs.stat(to, function (stater, st) {
              if (stater && stater.code === "ENOENT")
                fs$rename(from, to, CB);
              else
                cb(er);
            });
          }, backoff);
          if (backoff < 100)
            backoff += 10;
          return;
        }
        if (cb) cb(er);
      });
    }})(fs.rename);
  }

  // if read() returns EAGAIN, then just try it again.
  fs.read = (function (fs$read) {
    function read (fd, buffer, offset, length, position, callback_) {
      var callback;
      if (callback_ && typeof callback_ === 'function') {
        var eagCounter = 0;
        callback = function (er, _, __) {
          if (er && er.code === 'EAGAIN' && eagCounter < 10) {
            eagCounter ++;
            return fs$read.call(fs, fd, buffer, offset, length, position, callback)
          }
          callback_.apply(this, arguments);
        };
      }
      return fs$read.call(fs, fd, buffer, offset, length, position, callback)
    }

    // This ensures `util.promisify` works as it does for native `fs.read`.
    if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
    return read
  })(fs.read);

  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {
    var eagCounter = 0;
    while (true) {
      try {
        return fs$readSync.call(fs, fd, buffer, offset, length, position)
      } catch (er) {
        if (er.code === 'EAGAIN' && eagCounter < 10) {
          eagCounter ++;
          continue
        }
        throw er
      }
    }
  }})(fs.readSync);

  function patchLchmod (fs) {
    fs.lchmod = function (path, mode, callback) {
      fs.open( path
             , constants$1.O_WRONLY | constants$1.O_SYMLINK
             , mode
             , function (err, fd) {
        if (err) {
          if (callback) callback(err);
          return
        }
        // prefer to return the chmod error, if one occurs,
        // but still try to close, and report closing errors if they occur.
        fs.fchmod(fd, mode, function (err) {
          fs.close(fd, function(err2) {
            if (callback) callback(err || err2);
          });
        });
      });
    };

    fs.lchmodSync = function (path, mode) {
      var fd = fs.openSync(path, constants$1.O_WRONLY | constants$1.O_SYMLINK, mode);

      // prefer to return the chmod error, if one occurs,
      // but still try to close, and report closing errors if they occur.
      var threw = true;
      var ret;
      try {
        ret = fs.fchmodSync(fd, mode);
        threw = false;
      } finally {
        if (threw) {
          try {
            fs.closeSync(fd);
          } catch (er) {}
        } else {
          fs.closeSync(fd);
        }
      }
      return ret
    };
  }

  function patchLutimes (fs) {
    if (constants$1.hasOwnProperty("O_SYMLINK")) {
      fs.lutimes = function (path, at, mt, cb) {
        fs.open(path, constants$1.O_SYMLINK, function (er, fd) {
          if (er) {
            if (cb) cb(er);
            return
          }
          fs.futimes(fd, at, mt, function (er) {
            fs.close(fd, function (er2) {
              if (cb) cb(er || er2);
            });
          });
        });
      };

      fs.lutimesSync = function (path, at, mt) {
        var fd = fs.openSync(path, constants$1.O_SYMLINK);
        var ret;
        var threw = true;
        try {
          ret = fs.futimesSync(fd, at, mt);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs.closeSync(fd);
            } catch (er) {}
          } else {
            fs.closeSync(fd);
          }
        }
        return ret
      };

    } else {
      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb); };
      fs.lutimesSync = function () {};
    }
  }

  function chmodFix (orig) {
    if (!orig) return orig
    return function (target, mode, cb) {
      return orig.call(fs, target, mode, function (er) {
        if (chownErOk(er)) er = null;
        if (cb) cb.apply(this, arguments);
      })
    }
  }

  function chmodFixSync (orig) {
    if (!orig) return orig
    return function (target, mode) {
      try {
        return orig.call(fs, target, mode)
      } catch (er) {
        if (!chownErOk(er)) throw er
      }
    }
  }


  function chownFix (orig) {
    if (!orig) return orig
    return function (target, uid, gid, cb) {
      return orig.call(fs, target, uid, gid, function (er) {
        if (chownErOk(er)) er = null;
        if (cb) cb.apply(this, arguments);
      })
    }
  }

  function chownFixSync (orig) {
    if (!orig) return orig
    return function (target, uid, gid) {
      try {
        return orig.call(fs, target, uid, gid)
      } catch (er) {
        if (!chownErOk(er)) throw er
      }
    }
  }

  function statFix (orig) {
    if (!orig) return orig
    // Older versions of Node erroneously returned signed integers for
    // uid + gid.
    return function (target, options, cb) {
      if (typeof options === 'function') {
        cb = options;
        options = null;
      }
      function callback (er, stats) {
        if (stats) {
          if (stats.uid < 0) stats.uid += 0x100000000;
          if (stats.gid < 0) stats.gid += 0x100000000;
        }
        if (cb) cb.apply(this, arguments);
      }
      return options ? orig.call(fs, target, options, callback)
        : orig.call(fs, target, callback)
    }
  }

  function statFixSync (orig) {
    if (!orig) return orig
    // Older versions of Node erroneously returned signed integers for
    // uid + gid.
    return function (target, options) {
      var stats = options ? orig.call(fs, target, options)
        : orig.call(fs, target);
      if (stats) {
        if (stats.uid < 0) stats.uid += 0x100000000;
        if (stats.gid < 0) stats.gid += 0x100000000;
      }
      return stats;
    }
  }

  // ENOSYS means that the fs doesn't support the op. Just ignore
  // that, because it doesn't matter.
  //
  // if there's no getuid, or if getuid() is something other
  // than 0, and the error is EINVAL or EPERM, then just ignore
  // it.
  //
  // This specific case is a silent failure in cp, install, tar,
  // and most other unix tools that manage permissions.
  //
  // When running as root, or if other types of errors are
  // encountered, then it's strict.
  function chownErOk (er) {
    if (!er)
      return true

    if (er.code === "ENOSYS")
      return true

    var nonroot = !process.getuid || process.getuid() !== 0;
    if (nonroot) {
      if (er.code === "EINVAL" || er.code === "EPERM")
        return true
    }

    return false
  }
}

var Stream$2 = Stream__default["default"].Stream;

var legacyStreams = legacy$1;

function legacy$1 (fs) {
  return {
    ReadStream: ReadStream,
    WriteStream: WriteStream
  }

  function ReadStream (path, options) {
    if (!(this instanceof ReadStream)) return new ReadStream(path, options);

    Stream$2.call(this);

    var self = this;

    this.path = path;
    this.fd = null;
    this.readable = true;
    this.paused = false;

    this.flags = 'r';
    this.mode = 438; /*=0666*/
    this.bufferSize = 64 * 1024;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.encoding) this.setEncoding(this.encoding);

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.end === undefined) {
        this.end = Infinity;
      } else if ('number' !== typeof this.end) {
        throw TypeError('end must be a Number');
      }

      if (this.start > this.end) {
        throw new Error('start must be <= end');
      }

      this.pos = this.start;
    }

    if (this.fd !== null) {
      process.nextTick(function() {
        self._read();
      });
      return;
    }

    fs.open(this.path, this.flags, this.mode, function (err, fd) {
      if (err) {
        self.emit('error', err);
        self.readable = false;
        return;
      }

      self.fd = fd;
      self.emit('open', fd);
      self._read();
    });
  }

  function WriteStream (path, options) {
    if (!(this instanceof WriteStream)) return new WriteStream(path, options);

    Stream$2.call(this);

    this.path = path;
    this.fd = null;
    this.writable = true;

    this.flags = 'w';
    this.encoding = 'binary';
    this.mode = 438; /*=0666*/
    this.bytesWritten = 0;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.start < 0) {
        throw new Error('start must be >= zero');
      }

      this.pos = this.start;
    }

    this.busy = false;
    this._queue = [];

    if (this.fd === null) {
      this._open = fs.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
      this.flush();
    }
  }
}

var clone_1 = clone$2;

var getPrototypeOf = Object.getPrototypeOf || function (obj) {
  return obj.__proto__
};

function clone$2 (obj) {
  if (obj === null || typeof obj !== 'object')
    return obj

  if (obj instanceof Object)
    var copy = { __proto__: getPrototypeOf(obj) };
  else
    var copy = Object.create(null);

  Object.getOwnPropertyNames(obj).forEach(function (key) {
    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
  });

  return copy
}

var fs$q = require$$0__default$1["default"];
var polyfills = polyfills$1;
var legacy = legacyStreams;
var clone$1 = clone_1;

var util$d = require$$4__default["default"];

/* istanbul ignore next - node 0.x polyfill */
var gracefulQueue;
var previousSymbol;

/* istanbul ignore else - node 0.x polyfill */
if (typeof Symbol === 'function' && typeof Symbol.for === 'function') {
  gracefulQueue = Symbol.for('graceful-fs.queue');
  // This is used in testing by future versions
  previousSymbol = Symbol.for('graceful-fs.previous');
} else {
  gracefulQueue = '___graceful-fs.queue';
  previousSymbol = '___graceful-fs.previous';
}

function noop$1 () {}

function publishQueue(context, queue) {
  Object.defineProperty(context, gracefulQueue, {
    get: function() {
      return queue
    }
  });
}

var debug$4 = noop$1;
if (util$d.debuglog)
  debug$4 = util$d.debuglog('gfs4');
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ''))
  debug$4 = function() {
    var m = util$d.format.apply(util$d, arguments);
    m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ');
    console.error(m);
  };

// Once time initialization
if (!fs$q[gracefulQueue]) {
  // This queue can be shared by multiple loaded instances
  var queue = commonjsGlobal[gracefulQueue] || [];
  publishQueue(fs$q, queue);

  // Patch fs.close/closeSync to shared queue version, because we need
  // to retry() whenever a close happens *anywhere* in the program.
  // This is essential when multiple graceful-fs instances are
  // in play at the same time.
  fs$q.close = (function (fs$close) {
    function close (fd, cb) {
      return fs$close.call(fs$q, fd, function (err) {
        // This function uses the graceful-fs shared queue
        if (!err) {
          resetQueue();
        }

        if (typeof cb === 'function')
          cb.apply(this, arguments);
      })
    }

    Object.defineProperty(close, previousSymbol, {
      value: fs$close
    });
    return close
  })(fs$q.close);

  fs$q.closeSync = (function (fs$closeSync) {
    function closeSync (fd) {
      // This function uses the graceful-fs shared queue
      fs$closeSync.apply(fs$q, arguments);
      resetQueue();
    }

    Object.defineProperty(closeSync, previousSymbol, {
      value: fs$closeSync
    });
    return closeSync
  })(fs$q.closeSync);

  if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
    process.on('exit', function() {
      debug$4(fs$q[gracefulQueue]);
      require$$5__default["default"].equal(fs$q[gracefulQueue].length, 0);
    });
  }
}

if (!commonjsGlobal[gracefulQueue]) {
  publishQueue(commonjsGlobal, fs$q[gracefulQueue]);
}

var gracefulFs = patch$1(clone$1(fs$q));
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs$q.__patched) {
    gracefulFs = patch$1(fs$q);
    fs$q.__patched = true;
}

function patch$1 (fs) {
  // Everything that references the open() function needs to be in here
  polyfills(fs);
  fs.gracefulify = patch$1;

  fs.createReadStream = createReadStream;
  fs.createWriteStream = createWriteStream;
  var fs$readFile = fs.readFile;
  fs.readFile = readFile;
  function readFile (path, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null;

    return go$readFile(path, options, cb)

    function go$readFile (path, options, cb, startTime) {
      return fs$readFile(path, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$readFile, [path, options, cb], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments);
        }
      })
    }
  }

  var fs$writeFile = fs.writeFile;
  fs.writeFile = writeFile;
  function writeFile (path, data, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null;

    return go$writeFile(path, data, options, cb)

    function go$writeFile (path, data, options, cb, startTime) {
      return fs$writeFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$writeFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments);
        }
      })
    }
  }

  var fs$appendFile = fs.appendFile;
  if (fs$appendFile)
    fs.appendFile = appendFile;
  function appendFile (path, data, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null;

    return go$appendFile(path, data, options, cb)

    function go$appendFile (path, data, options, cb, startTime) {
      return fs$appendFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$appendFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments);
        }
      })
    }
  }

  var fs$copyFile = fs.copyFile;
  if (fs$copyFile)
    fs.copyFile = copyFile;
  function copyFile (src, dest, flags, cb) {
    if (typeof flags === 'function') {
      cb = flags;
      flags = 0;
    }
    return go$copyFile(src, dest, flags, cb)

    function go$copyFile (src, dest, flags, cb, startTime) {
      return fs$copyFile(src, dest, flags, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$copyFile, [src, dest, flags, cb], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments);
        }
      })
    }
  }

  var fs$readdir = fs.readdir;
  fs.readdir = readdir;
  function readdir (path, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null;

    return go$readdir(path, options, cb)

    function go$readdir (path, options, cb, startTime) {
      return fs$readdir(path, options, function (err, files) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$readdir, [path, options, cb], err, startTime || Date.now(), Date.now()]);
        else {
          if (files && files.sort)
            files.sort();

          if (typeof cb === 'function')
            cb.call(this, err, files);
        }
      })
    }
  }

  if (process.version.substr(0, 4) === 'v0.8') {
    var legStreams = legacy(fs);
    ReadStream = legStreams.ReadStream;
    WriteStream = legStreams.WriteStream;
  }

  var fs$ReadStream = fs.ReadStream;
  if (fs$ReadStream) {
    ReadStream.prototype = Object.create(fs$ReadStream.prototype);
    ReadStream.prototype.open = ReadStream$open;
  }

  var fs$WriteStream = fs.WriteStream;
  if (fs$WriteStream) {
    WriteStream.prototype = Object.create(fs$WriteStream.prototype);
    WriteStream.prototype.open = WriteStream$open;
  }

  Object.defineProperty(fs, 'ReadStream', {
    get: function () {
      return ReadStream
    },
    set: function (val) {
      ReadStream = val;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(fs, 'WriteStream', {
    get: function () {
      return WriteStream
    },
    set: function (val) {
      WriteStream = val;
    },
    enumerable: true,
    configurable: true
  });

  // legacy names
  var FileReadStream = ReadStream;
  Object.defineProperty(fs, 'FileReadStream', {
    get: function () {
      return FileReadStream
    },
    set: function (val) {
      FileReadStream = val;
    },
    enumerable: true,
    configurable: true
  });
  var FileWriteStream = WriteStream;
  Object.defineProperty(fs, 'FileWriteStream', {
    get: function () {
      return FileWriteStream
    },
    set: function (val) {
      FileWriteStream = val;
    },
    enumerable: true,
    configurable: true
  });

  function ReadStream (path, options) {
    if (this instanceof ReadStream)
      return fs$ReadStream.apply(this, arguments), this
    else
      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
  }

  function ReadStream$open () {
    var that = this;
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        if (that.autoClose)
          that.destroy();

        that.emit('error', err);
      } else {
        that.fd = fd;
        that.emit('open', fd);
        that.read();
      }
    });
  }

  function WriteStream (path, options) {
    if (this instanceof WriteStream)
      return fs$WriteStream.apply(this, arguments), this
    else
      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)
  }

  function WriteStream$open () {
    var that = this;
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        that.destroy();
        that.emit('error', err);
      } else {
        that.fd = fd;
        that.emit('open', fd);
      }
    });
  }

  function createReadStream (path, options) {
    return new fs.ReadStream(path, options)
  }

  function createWriteStream (path, options) {
    return new fs.WriteStream(path, options)
  }

  var fs$open = fs.open;
  fs.open = open;
  function open (path, flags, mode, cb) {
    if (typeof mode === 'function')
      cb = mode, mode = null;

    return go$open(path, flags, mode, cb)

    function go$open (path, flags, mode, cb, startTime) {
      return fs$open(path, flags, mode, function (err, fd) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$open, [path, flags, mode, cb], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments);
        }
      })
    }
  }

  return fs
}

function enqueue (elem) {
  debug$4('ENQUEUE', elem[0].name, elem[1]);
  fs$q[gracefulQueue].push(elem);
  retry();
}

// keep track of the timeout between retry() calls
var retryTimer;

// reset the startTime and lastTime to now
// this resets the start of the 60 second overall timeout as well as the
// delay between attempts so that we'll retry these jobs sooner
function resetQueue () {
  var now = Date.now();
  for (var i = 0; i < fs$q[gracefulQueue].length; ++i) {
    // entries that are only a length of 2 are from an older version, don't
    // bother modifying those since they'll be retried anyway.
    if (fs$q[gracefulQueue][i].length > 2) {
      fs$q[gracefulQueue][i][3] = now; // startTime
      fs$q[gracefulQueue][i][4] = now; // lastTime
    }
  }
  // call retry to make sure we're actively processing the queue
  retry();
}

function retry () {
  // clear the timer and remove it to help prevent unintended concurrency
  clearTimeout(retryTimer);
  retryTimer = undefined;

  if (fs$q[gracefulQueue].length === 0)
    return

  var elem = fs$q[gracefulQueue].shift();
  var fn = elem[0];
  var args = elem[1];
  // these items may be unset if they were added by an older graceful-fs
  var err = elem[2];
  var startTime = elem[3];
  var lastTime = elem[4];

  // if we don't have a startTime we have no way of knowing if we've waited
  // long enough, so go ahead and retry this item now
  if (startTime === undefined) {
    debug$4('RETRY', fn.name, args);
    fn.apply(null, args);
  } else if (Date.now() - startTime >= 60000) {
    // it's been more than 60 seconds total, bail now
    debug$4('TIMEOUT', fn.name, args);
    var cb = args.pop();
    if (typeof cb === 'function')
      cb.call(null, err);
  } else {
    // the amount of time between the last attempt and right now
    var sinceAttempt = Date.now() - lastTime;
    // the amount of time between when we first tried, and when we last tried
    // rounded up to at least 1
    var sinceStart = Math.max(lastTime - startTime, 1);
    // backoff. wait longer than the total time we've been retrying, but only
    // up to a maximum of 100ms
    var desiredDelay = Math.min(sinceStart * 1.2, 100);
    // it's been long enough since the last retry, do it again
    if (sinceAttempt >= desiredDelay) {
      debug$4('RETRY', fn.name, args);
      fn.apply(null, args.concat([startTime]));
    } else {
      // if we can't do this job yet, push it to the end of the queue
      // and let the next iteration check again
      fs$q[gracefulQueue].push(elem);
    }
  }

  // schedule our next run if one isn't already scheduled
  if (retryTimer === undefined) {
    retryTimer = setTimeout(retry, 0);
  }
}

(function (exports) {
// This is adapted from https://github.com/normalize/mz
// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors
const u = universalify$1.fromCallback;
const fs = gracefulFs;

const api = [
  'access',
  'appendFile',
  'chmod',
  'chown',
  'close',
  'copyFile',
  'fchmod',
  'fchown',
  'fdatasync',
  'fstat',
  'fsync',
  'ftruncate',
  'futimes',
  'lchmod',
  'lchown',
  'link',
  'lstat',
  'mkdir',
  'mkdtemp',
  'open',
  'opendir',
  'readdir',
  'readFile',
  'readlink',
  'realpath',
  'rename',
  'rm',
  'rmdir',
  'stat',
  'symlink',
  'truncate',
  'unlink',
  'utimes',
  'writeFile'
].filter(key => {
  // Some commands are not available on some systems. Ex:
  // fs.opendir was added in Node.js v12.12.0
  // fs.rm was added in Node.js v14.14.0
  // fs.lchown is not available on at least some Linux
  return typeof fs[key] === 'function'
});

// Export cloned fs:
Object.assign(exports, fs);

// Universalify async methods:
api.forEach(method => {
  exports[method] = u(fs[method]);
});
exports.realpath.native = u(fs.realpath.native);

// We differ from mz/fs in that we still ship the old, broken, fs.exists()
// since we are a drop-in replacement for the native module
exports.exists = function (filename, callback) {
  if (typeof callback === 'function') {
    return fs.exists(filename, callback)
  }
  return new Promise(resolve => {
    return fs.exists(filename, resolve)
  })
};

// fs.read(), fs.write(), & fs.writev() need special treatment due to multiple callback args

exports.read = function (fd, buffer, offset, length, position, callback) {
  if (typeof callback === 'function') {
    return fs.read(fd, buffer, offset, length, position, callback)
  }
  return new Promise((resolve, reject) => {
    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {
      if (err) return reject(err)
      resolve({ bytesRead, buffer });
    });
  })
};

// Function signature can be
// fs.write(fd, buffer[, offset[, length[, position]]], callback)
// OR
// fs.write(fd, string[, position[, encoding]], callback)
// We need to handle both cases, so we use ...args
exports.write = function (fd, buffer, ...args) {
  if (typeof args[args.length - 1] === 'function') {
    return fs.write(fd, buffer, ...args)
  }

  return new Promise((resolve, reject) => {
    fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {
      if (err) return reject(err)
      resolve({ bytesWritten, buffer });
    });
  })
};

// fs.writev only available in Node v12.9.0+
if (typeof fs.writev === 'function') {
  // Function signature is
  // s.writev(fd, buffers[, position], callback)
  // We need to handle the optional arg, so we use ...args
  exports.writev = function (fd, buffers, ...args) {
    if (typeof args[args.length - 1] === 'function') {
      return fs.writev(fd, buffers, ...args)
    }

    return new Promise((resolve, reject) => {
      fs.writev(fd, buffers, ...args, (err, bytesWritten, buffers) => {
        if (err) return reject(err)
        resolve({ bytesWritten, buffers });
      });
    })
  };
}
}(fs$r));

var makeDir$1 = {};

var utils$2 = {};

const path$j = require$$1__default["default"];

// https://github.com/nodejs/node/issues/8987
// https://github.com/libuv/libuv/pull/1088
utils$2.checkPath = function checkPath (pth) {
  if (process.platform === 'win32') {
    const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path$j.parse(pth).root, ''));

    if (pathHasInvalidWinCharacters) {
      const error = new Error(`Path contains invalid characters: ${pth}`);
      error.code = 'EINVAL';
      throw error
    }
  }
};

const fs$p = fs$r;
const { checkPath } = utils$2;

const getMode = options => {
  const defaults = { mode: 0o777 };
  if (typeof options === 'number') return options
  return ({ ...defaults, ...options }).mode
};

makeDir$1.makeDir = async (dir, options) => {
  checkPath(dir);

  return fs$p.mkdir(dir, {
    mode: getMode(options),
    recursive: true
  })
};

makeDir$1.makeDirSync = (dir, options) => {
  checkPath(dir);

  return fs$p.mkdirSync(dir, {
    mode: getMode(options),
    recursive: true
  })
};

const u$b = universalify$1.fromPromise;
const { makeDir: _makeDir, makeDirSync } = makeDir$1;
const makeDir = u$b(_makeDir);

var mkdirs$2 = {
  mkdirs: makeDir,
  mkdirsSync: makeDirSync,
  // alias
  mkdirp: makeDir,
  mkdirpSync: makeDirSync,
  ensureDir: makeDir,
  ensureDirSync: makeDirSync
};

const fs$o = gracefulFs;

function utimesMillis$1 (path, atime, mtime, callback) {
  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)
  fs$o.open(path, 'r+', (err, fd) => {
    if (err) return callback(err)
    fs$o.futimes(fd, atime, mtime, futimesErr => {
      fs$o.close(fd, closeErr => {
        if (callback) callback(futimesErr || closeErr);
      });
    });
  });
}

function utimesMillisSync$1 (path, atime, mtime) {
  const fd = fs$o.openSync(path, 'r+');
  fs$o.futimesSync(fd, atime, mtime);
  return fs$o.closeSync(fd)
}

var utimes = {
  utimesMillis: utimesMillis$1,
  utimesMillisSync: utimesMillisSync$1
};

const fs$n = fs$r;
const path$i = require$$1__default["default"];
const util$c = require$$4__default["default"];

function getStats$2 (src, dest, opts) {
  const statFunc = opts.dereference
    ? (file) => fs$n.stat(file, { bigint: true })
    : (file) => fs$n.lstat(file, { bigint: true });
  return Promise.all([
    statFunc(src),
    statFunc(dest).catch(err => {
      if (err.code === 'ENOENT') return null
      throw err
    })
  ]).then(([srcStat, destStat]) => ({ srcStat, destStat }))
}

function getStatsSync (src, dest, opts) {
  let destStat;
  const statFunc = opts.dereference
    ? (file) => fs$n.statSync(file, { bigint: true })
    : (file) => fs$n.lstatSync(file, { bigint: true });
  const srcStat = statFunc(src);
  try {
    destStat = statFunc(dest);
  } catch (err) {
    if (err.code === 'ENOENT') return { srcStat, destStat: null }
    throw err
  }
  return { srcStat, destStat }
}

function checkPaths (src, dest, funcName, opts, cb) {
  util$c.callbackify(getStats$2)(src, dest, opts, (err, stats) => {
    if (err) return cb(err)
    const { srcStat, destStat } = stats;

    if (destStat) {
      if (areIdentical$2(srcStat, destStat)) {
        const srcBaseName = path$i.basename(src);
        const destBaseName = path$i.basename(dest);
        if (funcName === 'move' &&
          srcBaseName !== destBaseName &&
          srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
          return cb(null, { srcStat, destStat, isChangingCase: true })
        }
        return cb(new Error('Source and destination must not be the same.'))
      }
      if (srcStat.isDirectory() && !destStat.isDirectory()) {
        return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))
      }
      if (!srcStat.isDirectory() && destStat.isDirectory()) {
        return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`))
      }
    }

    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
      return cb(new Error(errMsg(src, dest, funcName)))
    }
    return cb(null, { srcStat, destStat })
  });
}

function checkPathsSync (src, dest, funcName, opts) {
  const { srcStat, destStat } = getStatsSync(src, dest, opts);

  if (destStat) {
    if (areIdentical$2(srcStat, destStat)) {
      const srcBaseName = path$i.basename(src);
      const destBaseName = path$i.basename(dest);
      if (funcName === 'move' &&
        srcBaseName !== destBaseName &&
        srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
        return { srcStat, destStat, isChangingCase: true }
      }
      throw new Error('Source and destination must not be the same.')
    }
    if (srcStat.isDirectory() && !destStat.isDirectory()) {
      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)
    }
    if (!srcStat.isDirectory() && destStat.isDirectory()) {
      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`)
    }
  }

  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
    throw new Error(errMsg(src, dest, funcName))
  }
  return { srcStat, destStat }
}

// recursively check if dest parent is a subdirectory of src.
// It works for all file types including symlinks since it
// checks the src and dest inodes. It starts from the deepest
// parent and stops once it reaches the src parent or the root path.
function checkParentPaths (src, srcStat, dest, funcName, cb) {
  const srcParent = path$i.resolve(path$i.dirname(src));
  const destParent = path$i.resolve(path$i.dirname(dest));
  if (destParent === srcParent || destParent === path$i.parse(destParent).root) return cb()
  fs$n.stat(destParent, { bigint: true }, (err, destStat) => {
    if (err) {
      if (err.code === 'ENOENT') return cb()
      return cb(err)
    }
    if (areIdentical$2(srcStat, destStat)) {
      return cb(new Error(errMsg(src, dest, funcName)))
    }
    return checkParentPaths(src, srcStat, destParent, funcName, cb)
  });
}

function checkParentPathsSync (src, srcStat, dest, funcName) {
  const srcParent = path$i.resolve(path$i.dirname(src));
  const destParent = path$i.resolve(path$i.dirname(dest));
  if (destParent === srcParent || destParent === path$i.parse(destParent).root) return
  let destStat;
  try {
    destStat = fs$n.statSync(destParent, { bigint: true });
  } catch (err) {
    if (err.code === 'ENOENT') return
    throw err
  }
  if (areIdentical$2(srcStat, destStat)) {
    throw new Error(errMsg(src, dest, funcName))
  }
  return checkParentPathsSync(src, srcStat, destParent, funcName)
}

function areIdentical$2 (srcStat, destStat) {
  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev
}

// return true if dest is a subdir of src, otherwise false.
// It only checks the path strings.
function isSrcSubdir (src, dest) {
  const srcArr = path$i.resolve(src).split(path$i.sep).filter(i => i);
  const destArr = path$i.resolve(dest).split(path$i.sep).filter(i => i);
  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true)
}

function errMsg (src, dest, funcName) {
  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`
}

var stat$4 = {
  checkPaths,
  checkPathsSync,
  checkParentPaths,
  checkParentPathsSync,
  isSrcSubdir,
  areIdentical: areIdentical$2
};

const fs$m = gracefulFs;
const path$h = require$$1__default["default"];
const mkdirsSync$1 = mkdirs$2.mkdirsSync;
const utimesMillisSync = utimes.utimesMillisSync;
const stat$3 = stat$4;

function copySync$2 (src, dest, opts) {
  if (typeof opts === 'function') {
    opts = { filter: opts };
  }

  opts = opts || {};
  opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now
  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber

  // Warn about using preserveTimestamps on 32-bit node
  if (opts.preserveTimestamps && process.arch === 'ia32') {
    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`);
  }

  const { srcStat, destStat } = stat$3.checkPathsSync(src, dest, 'copy', opts);
  stat$3.checkParentPathsSync(src, srcStat, dest, 'copy');
  return handleFilterAndCopy(destStat, src, dest, opts)
}

function handleFilterAndCopy (destStat, src, dest, opts) {
  if (opts.filter && !opts.filter(src, dest)) return
  const destParent = path$h.dirname(dest);
  if (!fs$m.existsSync(destParent)) mkdirsSync$1(destParent);
  return getStats$1(destStat, src, dest, opts)
}

function startCopy$1 (destStat, src, dest, opts) {
  if (opts.filter && !opts.filter(src, dest)) return
  return getStats$1(destStat, src, dest, opts)
}

function getStats$1 (destStat, src, dest, opts) {
  const statSync = opts.dereference ? fs$m.statSync : fs$m.lstatSync;
  const srcStat = statSync(src);

  if (srcStat.isDirectory()) return onDir$1(srcStat, destStat, src, dest, opts)
  else if (srcStat.isFile() ||
           srcStat.isCharacterDevice() ||
           srcStat.isBlockDevice()) return onFile$1(srcStat, destStat, src, dest, opts)
  else if (srcStat.isSymbolicLink()) return onLink$1(destStat, src, dest, opts)
  else if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`)
  else if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`)
  throw new Error(`Unknown file: ${src}`)
}

function onFile$1 (srcStat, destStat, src, dest, opts) {
  if (!destStat) return copyFile$1(srcStat, src, dest, opts)
  return mayCopyFile$1(srcStat, src, dest, opts)
}

function mayCopyFile$1 (srcStat, src, dest, opts) {
  if (opts.overwrite) {
    fs$m.unlinkSync(dest);
    return copyFile$1(srcStat, src, dest, opts)
  } else if (opts.errorOnExist) {
    throw new Error(`'${dest}' already exists`)
  }
}

function copyFile$1 (srcStat, src, dest, opts) {
  fs$m.copyFileSync(src, dest);
  if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest);
  return setDestMode$1(dest, srcStat.mode)
}

function handleTimestamps (srcMode, src, dest) {
  // Make sure the file is writable before setting the timestamp
  // otherwise open fails with EPERM when invoked with 'r+'
  // (through utimes call)
  if (fileIsNotWritable$1(srcMode)) makeFileWritable$1(dest, srcMode);
  return setDestTimestamps$1(src, dest)
}

function fileIsNotWritable$1 (srcMode) {
  return (srcMode & 0o200) === 0
}

function makeFileWritable$1 (dest, srcMode) {
  return setDestMode$1(dest, srcMode | 0o200)
}

function setDestMode$1 (dest, srcMode) {
  return fs$m.chmodSync(dest, srcMode)
}

function setDestTimestamps$1 (src, dest) {
  // The initial srcStat.atime cannot be trusted
  // because it is modified by the read(2) system call
  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)
  const updatedSrcStat = fs$m.statSync(src);
  return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime)
}

function onDir$1 (srcStat, destStat, src, dest, opts) {
  if (!destStat) return mkDirAndCopy$1(srcStat.mode, src, dest, opts)
  return copyDir$1(src, dest, opts)
}

function mkDirAndCopy$1 (srcMode, src, dest, opts) {
  fs$m.mkdirSync(dest);
  copyDir$1(src, dest, opts);
  return setDestMode$1(dest, srcMode)
}

function copyDir$1 (src, dest, opts) {
  fs$m.readdirSync(src).forEach(item => copyDirItem$1(item, src, dest, opts));
}

function copyDirItem$1 (item, src, dest, opts) {
  const srcItem = path$h.join(src, item);
  const destItem = path$h.join(dest, item);
  const { destStat } = stat$3.checkPathsSync(srcItem, destItem, 'copy', opts);
  return startCopy$1(destStat, srcItem, destItem, opts)
}

function onLink$1 (destStat, src, dest, opts) {
  let resolvedSrc = fs$m.readlinkSync(src);
  if (opts.dereference) {
    resolvedSrc = path$h.resolve(process.cwd(), resolvedSrc);
  }

  if (!destStat) {
    return fs$m.symlinkSync(resolvedSrc, dest)
  } else {
    let resolvedDest;
    try {
      resolvedDest = fs$m.readlinkSync(dest);
    } catch (err) {
      // dest exists and is a regular file or directory,
      // Windows may throw UNKNOWN error. If dest already exists,
      // fs throws error anyway, so no need to guard against it here.
      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs$m.symlinkSync(resolvedSrc, dest)
      throw err
    }
    if (opts.dereference) {
      resolvedDest = path$h.resolve(process.cwd(), resolvedDest);
    }
    if (stat$3.isSrcSubdir(resolvedSrc, resolvedDest)) {
      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)
    }

    // prevent copy if src is a subdir of dest since unlinking
    // dest in this case would result in removing src contents
    // and therefore a broken symlink would be created.
    if (fs$m.statSync(dest).isDirectory() && stat$3.isSrcSubdir(resolvedDest, resolvedSrc)) {
      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)
    }
    return copyLink$1(resolvedSrc, dest)
  }
}

function copyLink$1 (resolvedSrc, dest) {
  fs$m.unlinkSync(dest);
  return fs$m.symlinkSync(resolvedSrc, dest)
}

var copySync_1 = copySync$2;

var copySync$1 = {
  copySync: copySync_1
};

const u$a = universalify$1.fromPromise;
const fs$l = fs$r;

function pathExists$6 (path) {
  return fs$l.access(path).then(() => true).catch(() => false)
}

var pathExists_1 = {
  pathExists: u$a(pathExists$6),
  pathExistsSync: fs$l.existsSync
};

const fs$k = gracefulFs;
const path$g = require$$1__default["default"];
const mkdirs$1 = mkdirs$2.mkdirs;
const pathExists$5 = pathExists_1.pathExists;
const utimesMillis = utimes.utimesMillis;
const stat$2 = stat$4;

function copy$3 (src, dest, opts, cb) {
  if (typeof opts === 'function' && !cb) {
    cb = opts;
    opts = {};
  } else if (typeof opts === 'function') {
    opts = { filter: opts };
  }

  cb = cb || function () {};
  opts = opts || {};

  opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now
  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber

  // Warn about using preserveTimestamps on 32-bit node
  if (opts.preserveTimestamps && process.arch === 'ia32') {
    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`);
  }

  stat$2.checkPaths(src, dest, 'copy', opts, (err, stats) => {
    if (err) return cb(err)
    const { srcStat, destStat } = stats;
    stat$2.checkParentPaths(src, srcStat, dest, 'copy', err => {
      if (err) return cb(err)
      if (opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts, cb)
      return checkParentDir(destStat, src, dest, opts, cb)
    });
  });
}

function checkParentDir (destStat, src, dest, opts, cb) {
  const destParent = path$g.dirname(dest);
  pathExists$5(destParent, (err, dirExists) => {
    if (err) return cb(err)
    if (dirExists) return getStats(destStat, src, dest, opts, cb)
    mkdirs$1(destParent, err => {
      if (err) return cb(err)
      return getStats(destStat, src, dest, opts, cb)
    });
  });
}

function handleFilter (onInclude, destStat, src, dest, opts, cb) {
  Promise.resolve(opts.filter(src, dest)).then(include => {
    if (include) return onInclude(destStat, src, dest, opts, cb)
    return cb()
  }, error => cb(error));
}

function startCopy (destStat, src, dest, opts, cb) {
  if (opts.filter) return handleFilter(getStats, destStat, src, dest, opts, cb)
  return getStats(destStat, src, dest, opts, cb)
}

function getStats (destStat, src, dest, opts, cb) {
  const stat = opts.dereference ? fs$k.stat : fs$k.lstat;
  stat(src, (err, srcStat) => {
    if (err) return cb(err)

    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb)
    else if (srcStat.isFile() ||
             srcStat.isCharacterDevice() ||
             srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb)
    else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb)
    else if (srcStat.isSocket()) return cb(new Error(`Cannot copy a socket file: ${src}`))
    else if (srcStat.isFIFO()) return cb(new Error(`Cannot copy a FIFO pipe: ${src}`))
    return cb(new Error(`Unknown file: ${src}`))
  });
}

function onFile (srcStat, destStat, src, dest, opts, cb) {
  if (!destStat) return copyFile(srcStat, src, dest, opts, cb)
  return mayCopyFile(srcStat, src, dest, opts, cb)
}

function mayCopyFile (srcStat, src, dest, opts, cb) {
  if (opts.overwrite) {
    fs$k.unlink(dest, err => {
      if (err) return cb(err)
      return copyFile(srcStat, src, dest, opts, cb)
    });
  } else if (opts.errorOnExist) {
    return cb(new Error(`'${dest}' already exists`))
  } else return cb()
}

function copyFile (srcStat, src, dest, opts, cb) {
  fs$k.copyFile(src, dest, err => {
    if (err) return cb(err)
    if (opts.preserveTimestamps) return handleTimestampsAndMode(srcStat.mode, src, dest, cb)
    return setDestMode(dest, srcStat.mode, cb)
  });
}

function handleTimestampsAndMode (srcMode, src, dest, cb) {
  // Make sure the file is writable before setting the timestamp
  // otherwise open fails with EPERM when invoked with 'r+'
  // (through utimes call)
  if (fileIsNotWritable(srcMode)) {
    return makeFileWritable(dest, srcMode, err => {
      if (err) return cb(err)
      return setDestTimestampsAndMode(srcMode, src, dest, cb)
    })
  }
  return setDestTimestampsAndMode(srcMode, src, dest, cb)
}

function fileIsNotWritable (srcMode) {
  return (srcMode & 0o200) === 0
}

function makeFileWritable (dest, srcMode, cb) {
  return setDestMode(dest, srcMode | 0o200, cb)
}

function setDestTimestampsAndMode (srcMode, src, dest, cb) {
  setDestTimestamps(src, dest, err => {
    if (err) return cb(err)
    return setDestMode(dest, srcMode, cb)
  });
}

function setDestMode (dest, srcMode, cb) {
  return fs$k.chmod(dest, srcMode, cb)
}

function setDestTimestamps (src, dest, cb) {
  // The initial srcStat.atime cannot be trusted
  // because it is modified by the read(2) system call
  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)
  fs$k.stat(src, (err, updatedSrcStat) => {
    if (err) return cb(err)
    return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb)
  });
}

function onDir (srcStat, destStat, src, dest, opts, cb) {
  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts, cb)
  return copyDir(src, dest, opts, cb)
}

function mkDirAndCopy (srcMode, src, dest, opts, cb) {
  fs$k.mkdir(dest, err => {
    if (err) return cb(err)
    copyDir(src, dest, opts, err => {
      if (err) return cb(err)
      return setDestMode(dest, srcMode, cb)
    });
  });
}

function copyDir (src, dest, opts, cb) {
  fs$k.readdir(src, (err, items) => {
    if (err) return cb(err)
    return copyDirItems(items, src, dest, opts, cb)
  });
}

function copyDirItems (items, src, dest, opts, cb) {
  const item = items.pop();
  if (!item) return cb()
  return copyDirItem(items, item, src, dest, opts, cb)
}

function copyDirItem (items, item, src, dest, opts, cb) {
  const srcItem = path$g.join(src, item);
  const destItem = path$g.join(dest, item);
  stat$2.checkPaths(srcItem, destItem, 'copy', opts, (err, stats) => {
    if (err) return cb(err)
    const { destStat } = stats;
    startCopy(destStat, srcItem, destItem, opts, err => {
      if (err) return cb(err)
      return copyDirItems(items, src, dest, opts, cb)
    });
  });
}

function onLink (destStat, src, dest, opts, cb) {
  fs$k.readlink(src, (err, resolvedSrc) => {
    if (err) return cb(err)
    if (opts.dereference) {
      resolvedSrc = path$g.resolve(process.cwd(), resolvedSrc);
    }

    if (!destStat) {
      return fs$k.symlink(resolvedSrc, dest, cb)
    } else {
      fs$k.readlink(dest, (err, resolvedDest) => {
        if (err) {
          // dest exists and is a regular file or directory,
          // Windows may throw UNKNOWN error. If dest already exists,
          // fs throws error anyway, so no need to guard against it here.
          if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs$k.symlink(resolvedSrc, dest, cb)
          return cb(err)
        }
        if (opts.dereference) {
          resolvedDest = path$g.resolve(process.cwd(), resolvedDest);
        }
        if (stat$2.isSrcSubdir(resolvedSrc, resolvedDest)) {
          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`))
        }

        // do not copy if src is a subdir of dest since unlinking
        // dest in this case would result in removing src contents
        // and therefore a broken symlink would be created.
        if (destStat.isDirectory() && stat$2.isSrcSubdir(resolvedDest, resolvedSrc)) {
          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`))
        }
        return copyLink(resolvedSrc, dest, cb)
      });
    }
  });
}

function copyLink (resolvedSrc, dest, cb) {
  fs$k.unlink(dest, err => {
    if (err) return cb(err)
    return fs$k.symlink(resolvedSrc, dest, cb)
  });
}

var copy_1 = copy$3;

const u$9 = universalify$1.fromCallback;
var copy$2 = {
  copy: u$9(copy_1)
};

const fs$j = gracefulFs;
const path$f = require$$1__default["default"];
const assert = require$$5__default["default"];

const isWindows = (process.platform === 'win32');

function defaults (options) {
  const methods = [
    'unlink',
    'chmod',
    'stat',
    'lstat',
    'rmdir',
    'readdir'
  ];
  methods.forEach(m => {
    options[m] = options[m] || fs$j[m];
    m = m + 'Sync';
    options[m] = options[m] || fs$j[m];
  });

  options.maxBusyTries = options.maxBusyTries || 3;
}

function rimraf$1 (p, options, cb) {
  let busyTries = 0;

  if (typeof options === 'function') {
    cb = options;
    options = {};
  }

  assert(p, 'rimraf: missing path');
  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string');
  assert.strictEqual(typeof cb, 'function', 'rimraf: callback function required');
  assert(options, 'rimraf: invalid options argument provided');
  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object');

  defaults(options);

  rimraf_(p, options, function CB (er) {
    if (er) {
      if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') &&
          busyTries < options.maxBusyTries) {
        busyTries++;
        const time = busyTries * 100;
        // try again, with the same exact callback as this one.
        return setTimeout(() => rimraf_(p, options, CB), time)
      }

      // already gone
      if (er.code === 'ENOENT') er = null;
    }

    cb(er);
  });
}

// Two possible strategies.
// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
//
// Both result in an extra syscall when you guess wrong.  However, there
// are likely far more normal files in the world than directories.  This
// is based on the assumption that a the average number of files per
// directory is >= 1.
//
// If anyone ever complains about this, then I guess the strategy could
// be made configurable somehow.  But until then, YAGNI.
function rimraf_ (p, options, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === 'function');

  // sunos lets the root user unlink directories, which is... weird.
  // so we have to lstat here and make sure it's not a dir.
  options.lstat(p, (er, st) => {
    if (er && er.code === 'ENOENT') {
      return cb(null)
    }

    // Windows can EPERM on stat.  Life is suffering.
    if (er && er.code === 'EPERM' && isWindows) {
      return fixWinEPERM(p, options, er, cb)
    }

    if (st && st.isDirectory()) {
      return rmdir(p, options, er, cb)
    }

    options.unlink(p, er => {
      if (er) {
        if (er.code === 'ENOENT') {
          return cb(null)
        }
        if (er.code === 'EPERM') {
          return (isWindows)
            ? fixWinEPERM(p, options, er, cb)
            : rmdir(p, options, er, cb)
        }
        if (er.code === 'EISDIR') {
          return rmdir(p, options, er, cb)
        }
      }
      return cb(er)
    });
  });
}

function fixWinEPERM (p, options, er, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === 'function');

  options.chmod(p, 0o666, er2 => {
    if (er2) {
      cb(er2.code === 'ENOENT' ? null : er);
    } else {
      options.stat(p, (er3, stats) => {
        if (er3) {
          cb(er3.code === 'ENOENT' ? null : er);
        } else if (stats.isDirectory()) {
          rmdir(p, options, er, cb);
        } else {
          options.unlink(p, cb);
        }
      });
    }
  });
}

function fixWinEPERMSync (p, options, er) {
  let stats;

  assert(p);
  assert(options);

  try {
    options.chmodSync(p, 0o666);
  } catch (er2) {
    if (er2.code === 'ENOENT') {
      return
    } else {
      throw er
    }
  }

  try {
    stats = options.statSync(p);
  } catch (er3) {
    if (er3.code === 'ENOENT') {
      return
    } else {
      throw er
    }
  }

  if (stats.isDirectory()) {
    rmdirSync(p, options, er);
  } else {
    options.unlinkSync(p);
  }
}

function rmdir (p, options, originalEr, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === 'function');

  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
  // if we guessed wrong, and it's not a directory, then
  // raise the original error.
  options.rmdir(p, er => {
    if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {
      rmkids(p, options, cb);
    } else if (er && er.code === 'ENOTDIR') {
      cb(originalEr);
    } else {
      cb(er);
    }
  });
}

function rmkids (p, options, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === 'function');

  options.readdir(p, (er, files) => {
    if (er) return cb(er)

    let n = files.length;
    let errState;

    if (n === 0) return options.rmdir(p, cb)

    files.forEach(f => {
      rimraf$1(path$f.join(p, f), options, er => {
        if (errState) {
          return
        }
        if (er) return cb(errState = er)
        if (--n === 0) {
          options.rmdir(p, cb);
        }
      });
    });
  });
}

// this looks simpler, and is strictly *faster*, but will
// tie up the JavaScript thread and fail on excessively
// deep directory trees.
function rimrafSync (p, options) {
  let st;

  options = options || {};
  defaults(options);

  assert(p, 'rimraf: missing path');
  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string');
  assert(options, 'rimraf: missing options');
  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object');

  try {
    st = options.lstatSync(p);
  } catch (er) {
    if (er.code === 'ENOENT') {
      return
    }

    // Windows can EPERM on stat.  Life is suffering.
    if (er.code === 'EPERM' && isWindows) {
      fixWinEPERMSync(p, options, er);
    }
  }

  try {
    // sunos lets the root user unlink directories, which is... weird.
    if (st && st.isDirectory()) {
      rmdirSync(p, options, null);
    } else {
      options.unlinkSync(p);
    }
  } catch (er) {
    if (er.code === 'ENOENT') {
      return
    } else if (er.code === 'EPERM') {
      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
    } else if (er.code !== 'EISDIR') {
      throw er
    }
    rmdirSync(p, options, er);
  }
}

function rmdirSync (p, options, originalEr) {
  assert(p);
  assert(options);

  try {
    options.rmdirSync(p);
  } catch (er) {
    if (er.code === 'ENOTDIR') {
      throw originalEr
    } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {
      rmkidsSync(p, options);
    } else if (er.code !== 'ENOENT') {
      throw er
    }
  }
}

function rmkidsSync (p, options) {
  assert(p);
  assert(options);
  options.readdirSync(p).forEach(f => rimrafSync(path$f.join(p, f), options));

  if (isWindows) {
    // We only end up here once we got ENOTEMPTY at least once, and
    // at this point, we are guaranteed to have removed all the kids.
    // So, we know that it won't be ENOENT or ENOTDIR or anything else.
    // try really hard to delete stuff on windows, because it has a
    // PROFOUNDLY annoying habit of not closing handles promptly when
    // files are deleted, resulting in spurious ENOTEMPTY errors.
    const startTime = Date.now();
    do {
      try {
        const ret = options.rmdirSync(p, options);
        return ret
      } catch {}
    } while (Date.now() - startTime < 500) // give up after 500ms
  } else {
    const ret = options.rmdirSync(p, options);
    return ret
  }
}

var rimraf_1 = rimraf$1;
rimraf$1.sync = rimrafSync;

const fs$i = gracefulFs;
const u$8 = universalify$1.fromCallback;
const rimraf = rimraf_1;

function remove$2 (path, callback) {
  // Node 14.14.0+
  if (fs$i.rm) return fs$i.rm(path, { recursive: true, force: true }, callback)
  rimraf(path, callback);
}

function removeSync$1 (path) {
  // Node 14.14.0+
  if (fs$i.rmSync) return fs$i.rmSync(path, { recursive: true, force: true })
  rimraf.sync(path);
}

var remove_1 = {
  remove: u$8(remove$2),
  removeSync: removeSync$1
};

const u$7 = universalify$1.fromPromise;
const fs$h = fs$r;
const path$e = require$$1__default["default"];
const mkdir$3 = mkdirs$2;
const remove$1 = remove_1;

const emptyDir = u$7(async function emptyDir (dir) {
  let items;
  try {
    items = await fs$h.readdir(dir);
  } catch {
    return mkdir$3.mkdirs(dir)
  }

  return Promise.all(items.map(item => remove$1.remove(path$e.join(dir, item))))
});

function emptyDirSync (dir) {
  let items;
  try {
    items = fs$h.readdirSync(dir);
  } catch {
    return mkdir$3.mkdirsSync(dir)
  }

  items.forEach(item => {
    item = path$e.join(dir, item);
    remove$1.removeSync(item);
  });
}

var empty = {
  emptyDirSync,
  emptydirSync: emptyDirSync,
  emptyDir,
  emptydir: emptyDir
};

const u$6 = universalify$1.fromCallback;
const path$d = require$$1__default["default"];
const fs$g = gracefulFs;
const mkdir$2 = mkdirs$2;

function createFile (file, callback) {
  function makeFile () {
    fs$g.writeFile(file, '', err => {
      if (err) return callback(err)
      callback();
    });
  }

  fs$g.stat(file, (err, stats) => { // eslint-disable-line handle-callback-err
    if (!err && stats.isFile()) return callback()
    const dir = path$d.dirname(file);
    fs$g.stat(dir, (err, stats) => {
      if (err) {
        // if the directory doesn't exist, make it
        if (err.code === 'ENOENT') {
          return mkdir$2.mkdirs(dir, err => {
            if (err) return callback(err)
            makeFile();
          })
        }
        return callback(err)
      }

      if (stats.isDirectory()) makeFile();
      else {
        // parent is not a directory
        // This is just to cause an internal ENOTDIR error to be thrown
        fs$g.readdir(dir, err => {
          if (err) return callback(err)
        });
      }
    });
  });
}

function createFileSync (file) {
  let stats;
  try {
    stats = fs$g.statSync(file);
  } catch {}
  if (stats && stats.isFile()) return

  const dir = path$d.dirname(file);
  try {
    if (!fs$g.statSync(dir).isDirectory()) {
      // parent is not a directory
      // This is just to cause an internal ENOTDIR error to be thrown
      fs$g.readdirSync(dir);
    }
  } catch (err) {
    // If the stat call above failed because the directory doesn't exist, create it
    if (err && err.code === 'ENOENT') mkdir$2.mkdirsSync(dir);
    else throw err
  }

  fs$g.writeFileSync(file, '');
}

var file$1 = {
  createFile: u$6(createFile),
  createFileSync
};

const u$5 = universalify$1.fromCallback;
const path$c = require$$1__default["default"];
const fs$f = gracefulFs;
const mkdir$1 = mkdirs$2;
const pathExists$4 = pathExists_1.pathExists;
const { areIdentical: areIdentical$1 } = stat$4;

function createLink (srcpath, dstpath, callback) {
  function makeLink (srcpath, dstpath) {
    fs$f.link(srcpath, dstpath, err => {
      if (err) return callback(err)
      callback(null);
    });
  }

  fs$f.lstat(dstpath, (_, dstStat) => {
    fs$f.lstat(srcpath, (err, srcStat) => {
      if (err) {
        err.message = err.message.replace('lstat', 'ensureLink');
        return callback(err)
      }
      if (dstStat && areIdentical$1(srcStat, dstStat)) return callback(null)

      const dir = path$c.dirname(dstpath);
      pathExists$4(dir, (err, dirExists) => {
        if (err) return callback(err)
        if (dirExists) return makeLink(srcpath, dstpath)
        mkdir$1.mkdirs(dir, err => {
          if (err) return callback(err)
          makeLink(srcpath, dstpath);
        });
      });
    });
  });
}

function createLinkSync (srcpath, dstpath) {
  let dstStat;
  try {
    dstStat = fs$f.lstatSync(dstpath);
  } catch {}

  try {
    const srcStat = fs$f.lstatSync(srcpath);
    if (dstStat && areIdentical$1(srcStat, dstStat)) return
  } catch (err) {
    err.message = err.message.replace('lstat', 'ensureLink');
    throw err
  }

  const dir = path$c.dirname(dstpath);
  const dirExists = fs$f.existsSync(dir);
  if (dirExists) return fs$f.linkSync(srcpath, dstpath)
  mkdir$1.mkdirsSync(dir);

  return fs$f.linkSync(srcpath, dstpath)
}

var link$1 = {
  createLink: u$5(createLink),
  createLinkSync
};

const path$b = require$$1__default["default"];
const fs$e = gracefulFs;
const pathExists$3 = pathExists_1.pathExists;

/**
 * Function that returns two types of paths, one relative to symlink, and one
 * relative to the current working directory. Checks if path is absolute or
 * relative. If the path is relative, this function checks if the path is
 * relative to symlink or relative to current working directory. This is an
 * initiative to find a smarter `srcpath` to supply when building symlinks.
 * This allows you to determine which path to use out of one of three possible
 * types of source paths. The first is an absolute path. This is detected by
 * `path.isAbsolute()`. When an absolute path is provided, it is checked to
 * see if it exists. If it does it's used, if not an error is returned
 * (callback)/ thrown (sync). The other two options for `srcpath` are a
 * relative url. By default Node's `fs.symlink` works by creating a symlink
 * using `dstpath` and expects the `srcpath` to be relative to the newly
 * created symlink. If you provide a `srcpath` that does not exist on the file
 * system it results in a broken symlink. To minimize this, the function
 * checks to see if the 'relative to symlink' source file exists, and if it
 * does it will use it. If it does not, it checks if there's a file that
 * exists that is relative to the current working directory, if does its used.
 * This preserves the expectations of the original fs.symlink spec and adds
 * the ability to pass in `relative to current working direcotry` paths.
 */

function symlinkPaths$1 (srcpath, dstpath, callback) {
  if (path$b.isAbsolute(srcpath)) {
    return fs$e.lstat(srcpath, (err) => {
      if (err) {
        err.message = err.message.replace('lstat', 'ensureSymlink');
        return callback(err)
      }
      return callback(null, {
        toCwd: srcpath,
        toDst: srcpath
      })
    })
  } else {
    const dstdir = path$b.dirname(dstpath);
    const relativeToDst = path$b.join(dstdir, srcpath);
    return pathExists$3(relativeToDst, (err, exists) => {
      if (err) return callback(err)
      if (exists) {
        return callback(null, {
          toCwd: relativeToDst,
          toDst: srcpath
        })
      } else {
        return fs$e.lstat(srcpath, (err) => {
          if (err) {
            err.message = err.message.replace('lstat', 'ensureSymlink');
            return callback(err)
          }
          return callback(null, {
            toCwd: srcpath,
            toDst: path$b.relative(dstdir, srcpath)
          })
        })
      }
    })
  }
}

function symlinkPathsSync$1 (srcpath, dstpath) {
  let exists;
  if (path$b.isAbsolute(srcpath)) {
    exists = fs$e.existsSync(srcpath);
    if (!exists) throw new Error('absolute srcpath does not exist')
    return {
      toCwd: srcpath,
      toDst: srcpath
    }
  } else {
    const dstdir = path$b.dirname(dstpath);
    const relativeToDst = path$b.join(dstdir, srcpath);
    exists = fs$e.existsSync(relativeToDst);
    if (exists) {
      return {
        toCwd: relativeToDst,
        toDst: srcpath
      }
    } else {
      exists = fs$e.existsSync(srcpath);
      if (!exists) throw new Error('relative srcpath does not exist')
      return {
        toCwd: srcpath,
        toDst: path$b.relative(dstdir, srcpath)
      }
    }
  }
}

var symlinkPaths_1 = {
  symlinkPaths: symlinkPaths$1,
  symlinkPathsSync: symlinkPathsSync$1
};

const fs$d = gracefulFs;

function symlinkType$1 (srcpath, type, callback) {
  callback = (typeof type === 'function') ? type : callback;
  type = (typeof type === 'function') ? false : type;
  if (type) return callback(null, type)
  fs$d.lstat(srcpath, (err, stats) => {
    if (err) return callback(null, 'file')
    type = (stats && stats.isDirectory()) ? 'dir' : 'file';
    callback(null, type);
  });
}

function symlinkTypeSync$1 (srcpath, type) {
  let stats;

  if (type) return type
  try {
    stats = fs$d.lstatSync(srcpath);
  } catch {
    return 'file'
  }
  return (stats && stats.isDirectory()) ? 'dir' : 'file'
}

var symlinkType_1 = {
  symlinkType: symlinkType$1,
  symlinkTypeSync: symlinkTypeSync$1
};

const u$4 = universalify$1.fromCallback;
const path$a = require$$1__default["default"];
const fs$c = fs$r;
const _mkdirs = mkdirs$2;
const mkdirs = _mkdirs.mkdirs;
const mkdirsSync = _mkdirs.mkdirsSync;

const _symlinkPaths = symlinkPaths_1;
const symlinkPaths = _symlinkPaths.symlinkPaths;
const symlinkPathsSync = _symlinkPaths.symlinkPathsSync;

const _symlinkType = symlinkType_1;
const symlinkType = _symlinkType.symlinkType;
const symlinkTypeSync = _symlinkType.symlinkTypeSync;

const pathExists$2 = pathExists_1.pathExists;

const { areIdentical } = stat$4;

function createSymlink (srcpath, dstpath, type, callback) {
  callback = (typeof type === 'function') ? type : callback;
  type = (typeof type === 'function') ? false : type;

  fs$c.lstat(dstpath, (err, stats) => {
    if (!err && stats.isSymbolicLink()) {
      Promise.all([
        fs$c.stat(srcpath),
        fs$c.stat(dstpath)
      ]).then(([srcStat, dstStat]) => {
        if (areIdentical(srcStat, dstStat)) return callback(null)
        _createSymlink(srcpath, dstpath, type, callback);
      });
    } else _createSymlink(srcpath, dstpath, type, callback);
  });
}

function _createSymlink (srcpath, dstpath, type, callback) {
  symlinkPaths(srcpath, dstpath, (err, relative) => {
    if (err) return callback(err)
    srcpath = relative.toDst;
    symlinkType(relative.toCwd, type, (err, type) => {
      if (err) return callback(err)
      const dir = path$a.dirname(dstpath);
      pathExists$2(dir, (err, dirExists) => {
        if (err) return callback(err)
        if (dirExists) return fs$c.symlink(srcpath, dstpath, type, callback)
        mkdirs(dir, err => {
          if (err) return callback(err)
          fs$c.symlink(srcpath, dstpath, type, callback);
        });
      });
    });
  });
}

function createSymlinkSync (srcpath, dstpath, type) {
  let stats;
  try {
    stats = fs$c.lstatSync(dstpath);
  } catch {}
  if (stats && stats.isSymbolicLink()) {
    const srcStat = fs$c.statSync(srcpath);
    const dstStat = fs$c.statSync(dstpath);
    if (areIdentical(srcStat, dstStat)) return
  }

  const relative = symlinkPathsSync(srcpath, dstpath);
  srcpath = relative.toDst;
  type = symlinkTypeSync(relative.toCwd, type);
  const dir = path$a.dirname(dstpath);
  const exists = fs$c.existsSync(dir);
  if (exists) return fs$c.symlinkSync(srcpath, dstpath, type)
  mkdirsSync(dir);
  return fs$c.symlinkSync(srcpath, dstpath, type)
}

var symlink$1 = {
  createSymlink: u$4(createSymlink),
  createSymlinkSync
};

const file = file$1;
const link = link$1;
const symlink = symlink$1;

var ensure = {
  // file
  createFile: file.createFile,
  createFileSync: file.createFileSync,
  ensureFile: file.createFile,
  ensureFileSync: file.createFileSync,
  // link
  createLink: link.createLink,
  createLinkSync: link.createLinkSync,
  ensureLink: link.createLink,
  ensureLinkSync: link.createLinkSync,
  // symlink
  createSymlink: symlink.createSymlink,
  createSymlinkSync: symlink.createSymlinkSync,
  ensureSymlink: symlink.createSymlink,
  ensureSymlinkSync: symlink.createSymlinkSync
};

function stringify$3 (obj, { EOL = '\n', finalEOL = true, replacer = null, spaces } = {}) {
  const EOF = finalEOL ? EOL : '';
  const str = JSON.stringify(obj, replacer, spaces);

  return str.replace(/\n/g, EOL) + EOF
}

function stripBom$1 (content) {
  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified
  if (Buffer.isBuffer(content)) content = content.toString('utf8');
  return content.replace(/^\uFEFF/, '')
}

var utils$1 = { stringify: stringify$3, stripBom: stripBom$1 };

let _fs$1;
try {
  _fs$1 = require('graceful-fs');
} catch (_) {
  _fs$1 = require$$0__default$1["default"];
}
const universalify = universalify$1;
const { stringify: stringify$2, stripBom } = utils$1;

async function _readFile (file, options = {}) {
  if (typeof options === 'string') {
    options = { encoding: options };
  }

  const fs = options.fs || _fs$1;

  const shouldThrow = 'throws' in options ? options.throws : true;

  let data = await universalify.fromCallback(fs.readFile)(file, options);

  data = stripBom(data);

  let obj;
  try {
    obj = JSON.parse(data, options ? options.reviver : null);
  } catch (err) {
    if (shouldThrow) {
      err.message = `${file}: ${err.message}`;
      throw err
    } else {
      return null
    }
  }

  return obj
}

const readFile = universalify.fromPromise(_readFile);

function readFileSync (file, options = {}) {
  if (typeof options === 'string') {
    options = { encoding: options };
  }

  const fs = options.fs || _fs$1;

  const shouldThrow = 'throws' in options ? options.throws : true;

  try {
    let content = fs.readFileSync(file, options);
    content = stripBom(content);
    return JSON.parse(content, options.reviver)
  } catch (err) {
    if (shouldThrow) {
      err.message = `${file}: ${err.message}`;
      throw err
    } else {
      return null
    }
  }
}

async function _writeFile (file, obj, options = {}) {
  const fs = options.fs || _fs$1;

  const str = stringify$2(obj, options);

  await universalify.fromCallback(fs.writeFile)(file, str, options);
}

const writeFile = universalify.fromPromise(_writeFile);

function writeFileSync (file, obj, options = {}) {
  const fs = options.fs || _fs$1;

  const str = stringify$2(obj, options);
  // not sure if fs.writeFileSync returns anything, but just in case
  return fs.writeFileSync(file, str, options)
}

const jsonfile$1 = {
  readFile,
  readFileSync,
  writeFile,
  writeFileSync
};

var jsonfile_1 = jsonfile$1;

const jsonFile$1 = jsonfile_1;

var jsonfile = {
  // jsonfile exports
  readJson: jsonFile$1.readFile,
  readJsonSync: jsonFile$1.readFileSync,
  writeJson: jsonFile$1.writeFile,
  writeJsonSync: jsonFile$1.writeFileSync
};

const u$3 = universalify$1.fromCallback;
const fs$b = gracefulFs;
const path$9 = require$$1__default["default"];
const mkdir = mkdirs$2;
const pathExists$1 = pathExists_1.pathExists;

function outputFile$1 (file, data, encoding, callback) {
  if (typeof encoding === 'function') {
    callback = encoding;
    encoding = 'utf8';
  }

  const dir = path$9.dirname(file);
  pathExists$1(dir, (err, itDoes) => {
    if (err) return callback(err)
    if (itDoes) return fs$b.writeFile(file, data, encoding, callback)

    mkdir.mkdirs(dir, err => {
      if (err) return callback(err)

      fs$b.writeFile(file, data, encoding, callback);
    });
  });
}

function outputFileSync$1 (file, ...args) {
  const dir = path$9.dirname(file);
  if (fs$b.existsSync(dir)) {
    return fs$b.writeFileSync(file, ...args)
  }
  mkdir.mkdirsSync(dir);
  fs$b.writeFileSync(file, ...args);
}

var output = {
  outputFile: u$3(outputFile$1),
  outputFileSync: outputFileSync$1
};

const { stringify: stringify$1 } = utils$1;
const { outputFile } = output;

async function outputJson (file, data, options = {}) {
  const str = stringify$1(data, options);

  await outputFile(file, str, options);
}

var outputJson_1 = outputJson;

const { stringify } = utils$1;
const { outputFileSync } = output;

function outputJsonSync (file, data, options) {
  const str = stringify(data, options);

  outputFileSync(file, str, options);
}

var outputJsonSync_1 = outputJsonSync;

const u$2 = universalify$1.fromPromise;
const jsonFile = jsonfile;

jsonFile.outputJson = u$2(outputJson_1);
jsonFile.outputJsonSync = outputJsonSync_1;
// aliases
jsonFile.outputJSON = jsonFile.outputJson;
jsonFile.outputJSONSync = jsonFile.outputJsonSync;
jsonFile.writeJSON = jsonFile.writeJson;
jsonFile.writeJSONSync = jsonFile.writeJsonSync;
jsonFile.readJSON = jsonFile.readJson;
jsonFile.readJSONSync = jsonFile.readJsonSync;

var json = jsonFile;

const fs$a = gracefulFs;
const path$8 = require$$1__default["default"];
const copySync = copySync$1.copySync;
const removeSync = remove_1.removeSync;
const mkdirpSync = mkdirs$2.mkdirpSync;
const stat$1 = stat$4;

function moveSync$1 (src, dest, opts) {
  opts = opts || {};
  const overwrite = opts.overwrite || opts.clobber || false;

  const { srcStat, isChangingCase = false } = stat$1.checkPathsSync(src, dest, 'move', opts);
  stat$1.checkParentPathsSync(src, srcStat, dest, 'move');
  if (!isParentRoot$1(dest)) mkdirpSync(path$8.dirname(dest));
  return doRename$1(src, dest, overwrite, isChangingCase)
}

function isParentRoot$1 (dest) {
  const parent = path$8.dirname(dest);
  const parsedPath = path$8.parse(parent);
  return parsedPath.root === parent
}

function doRename$1 (src, dest, overwrite, isChangingCase) {
  if (isChangingCase) return rename$1(src, dest, overwrite)
  if (overwrite) {
    removeSync(dest);
    return rename$1(src, dest, overwrite)
  }
  if (fs$a.existsSync(dest)) throw new Error('dest already exists.')
  return rename$1(src, dest, overwrite)
}

function rename$1 (src, dest, overwrite) {
  try {
    fs$a.renameSync(src, dest);
  } catch (err) {
    if (err.code !== 'EXDEV') throw err
    return moveAcrossDevice$1(src, dest, overwrite)
  }
}

function moveAcrossDevice$1 (src, dest, overwrite) {
  const opts = {
    overwrite,
    errorOnExist: true
  };
  copySync(src, dest, opts);
  return removeSync(src)
}

var moveSync_1 = moveSync$1;

var moveSync = {
  moveSync: moveSync_1
};

const fs$9 = gracefulFs;
const path$7 = require$$1__default["default"];
const copy$1 = copy$2.copy;
const remove = remove_1.remove;
const mkdirp = mkdirs$2.mkdirp;
const pathExists = pathExists_1.pathExists;
const stat = stat$4;

function move$1 (src, dest, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts;
    opts = {};
  }

  const overwrite = opts.overwrite || opts.clobber || false;

  stat.checkPaths(src, dest, 'move', opts, (err, stats) => {
    if (err) return cb(err)
    const { srcStat, isChangingCase = false } = stats;
    stat.checkParentPaths(src, srcStat, dest, 'move', err => {
      if (err) return cb(err)
      if (isParentRoot(dest)) return doRename(src, dest, overwrite, isChangingCase, cb)
      mkdirp(path$7.dirname(dest), err => {
        if (err) return cb(err)
        return doRename(src, dest, overwrite, isChangingCase, cb)
      });
    });
  });
}

function isParentRoot (dest) {
  const parent = path$7.dirname(dest);
  const parsedPath = path$7.parse(parent);
  return parsedPath.root === parent
}

function doRename (src, dest, overwrite, isChangingCase, cb) {
  if (isChangingCase) return rename(src, dest, overwrite, cb)
  if (overwrite) {
    return remove(dest, err => {
      if (err) return cb(err)
      return rename(src, dest, overwrite, cb)
    })
  }
  pathExists(dest, (err, destExists) => {
    if (err) return cb(err)
    if (destExists) return cb(new Error('dest already exists.'))
    return rename(src, dest, overwrite, cb)
  });
}

function rename (src, dest, overwrite, cb) {
  fs$9.rename(src, dest, err => {
    if (!err) return cb()
    if (err.code !== 'EXDEV') return cb(err)
    return moveAcrossDevice(src, dest, overwrite, cb)
  });
}

function moveAcrossDevice (src, dest, overwrite, cb) {
  const opts = {
    overwrite,
    errorOnExist: true
  };
  copy$1(src, dest, opts, err => {
    if (err) return cb(err)
    return remove(src, cb)
  });
}

var move_1 = move$1;

const u$1 = universalify$1.fromCallback;
var move = {
  move: u$1(move_1)
};

var lib$1 = {
  // Export promiseified graceful-fs:
  ...fs$r,
  // Export extra methods:
  ...copySync$1,
  ...copy$2,
  ...empty,
  ...ensure,
  ...json,
  ...mkdirs$2,
  ...moveSync,
  ...move,
  ...output,
  ...pathExists_1,
  ...remove_1
};

var lib = {exports: {}};

/* eslint-disable node/no-deprecated-api */

var buffer = require$$0__default$2["default"];
var Buffer$b = buffer.Buffer;

var safer = {};

var key;

for (key in buffer) {
  if (!buffer.hasOwnProperty(key)) continue
  if (key === 'SlowBuffer' || key === 'Buffer') continue
  safer[key] = buffer[key];
}

var Safer = safer.Buffer = {};
for (key in Buffer$b) {
  if (!Buffer$b.hasOwnProperty(key)) continue
  if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue
  Safer[key] = Buffer$b[key];
}

safer.Buffer.prototype = Buffer$b.prototype;

if (!Safer.from || Safer.from === Uint8Array.from) {
  Safer.from = function (value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value)
    }
    if (value && typeof value.length === 'undefined') {
      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value)
    }
    return Buffer$b(value, encodingOrOffset, length)
  };
}

if (!Safer.alloc) {
  Safer.alloc = function (size, fill, encoding) {
    if (typeof size !== 'number') {
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size)
    }
    if (size < 0 || size >= 2 * (1 << 30)) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"')
    }
    var buf = Buffer$b(size);
    if (!fill || fill.length === 0) {
      buf.fill(0);
    } else if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
    return buf
  };
}

if (!safer.kStringMaxLength) {
  try {
    safer.kStringMaxLength = process.binding('buffer').kStringMaxLength;
  } catch (e) {
    // we can't determine kStringMaxLength in environments where process.binding
    // is unsupported, so let's not set it
  }
}

if (!safer.constants) {
  safer.constants = {
    MAX_LENGTH: safer.kMaxLength
  };
  if (safer.kStringMaxLength) {
    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
  }
}

var safer_1 = safer;

var bomHandling = {};

var BOMChar = '\uFEFF';

bomHandling.PrependBOM = PrependBOMWrapper;
function PrependBOMWrapper(encoder, options) {
    this.encoder = encoder;
    this.addBOM = true;
}

PrependBOMWrapper.prototype.write = function(str) {
    if (this.addBOM) {
        str = BOMChar + str;
        this.addBOM = false;
    }

    return this.encoder.write(str);
};

PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
};


//------------------------------------------------------------------------------

bomHandling.StripBOM = StripBOMWrapper;
function StripBOMWrapper(decoder, options) {
    this.decoder = decoder;
    this.pass = false;
    this.options = options || {};
}

StripBOMWrapper.prototype.write = function(buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res)
        return res;

    if (res[0] === BOMChar) {
        res = res.slice(1);
        if (typeof this.options.stripBOM === 'function')
            this.options.stripBOM();
    }

    this.pass = true;
    return res;
};

StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
};

var encodings = {};

var Buffer$a = safer_1.Buffer;

// Export Node.js internal encodings.

var internal = {
    // Encodings
    utf8:   { type: "_internal", bomAware: true},
    cesu8:  { type: "_internal", bomAware: true},
    unicode11utf8: "utf8",

    ucs2:   { type: "_internal", bomAware: true},
    utf16le: "ucs2",

    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex:    { type: "_internal" },

    // Codec.
    _internal: InternalCodec,
};

//------------------------------------------------------------------------------

function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;

    if (this.enc === "base64")
        this.encoder = InternalEncoderBase64;
    else if (this.enc === "cesu8") {
        this.enc = "utf8"; // Use utf8 for decoding.
        this.encoder = InternalEncoderCesu8;

        // Add decoder for versions of Node not supporting CESU-8
        if (Buffer$a.from('eda0bdedb2a9', 'hex').toString() !== '') {
            this.decoder = InternalDecoderCesu8;
            this.defaultCharUnicode = iconv.defaultCharUnicode;
        }
    }
}

InternalCodec.prototype.encoder = InternalEncoder;
InternalCodec.prototype.decoder = InternalDecoder;

//------------------------------------------------------------------------------

// We use node.js internal decoder. Its signature is the same as ours.
var StringDecoder = require$$2__default["default"].StringDecoder;

if (!StringDecoder.prototype.end) // Node v0.8 doesn't have this method.
    StringDecoder.prototype.end = function() {};


function InternalDecoder(options, codec) {
    this.decoder = new StringDecoder(codec.enc);
}

InternalDecoder.prototype.write = function(buf) {
    if (!Buffer$a.isBuffer(buf)) {
        buf = Buffer$a.from(buf);
    }

    return this.decoder.write(buf);
};

InternalDecoder.prototype.end = function() {
    return this.decoder.end();
};


//------------------------------------------------------------------------------
// Encoder is mostly trivial

function InternalEncoder(options, codec) {
    this.enc = codec.enc;
}

InternalEncoder.prototype.write = function(str) {
    return Buffer$a.from(str, this.enc);
};

InternalEncoder.prototype.end = function() {
};


//------------------------------------------------------------------------------
// Except base64 encoder, which must keep its state.

function InternalEncoderBase64(options, codec) {
    this.prevStr = '';
}

InternalEncoderBase64.prototype.write = function(str) {
    str = this.prevStr + str;
    var completeQuads = str.length - (str.length % 4);
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);

    return Buffer$a.from(str, "base64");
};

InternalEncoderBase64.prototype.end = function() {
    return Buffer$a.from(this.prevStr, "base64");
};


//------------------------------------------------------------------------------
// CESU-8 encoder is also special.

function InternalEncoderCesu8(options, codec) {
}

InternalEncoderCesu8.prototype.write = function(str) {
    var buf = Buffer$a.alloc(str.length * 3), bufIdx = 0;
    for (var i = 0; i < str.length; i++) {
        var charCode = str.charCodeAt(i);
        // Naive implementation, but it works because CESU-8 is especially easy
        // to convert from UTF-16 (which all JS strings are encoded in).
        if (charCode < 0x80)
            buf[bufIdx++] = charCode;
        else if (charCode < 0x800) {
            buf[bufIdx++] = 0xC0 + (charCode >>> 6);
            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
        }
        else { // charCode will always be < 0x10000 in javascript.
            buf[bufIdx++] = 0xE0 + (charCode >>> 12);
            buf[bufIdx++] = 0x80 + ((charCode >>> 6) & 0x3f);
            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
        }
    }
    return buf.slice(0, bufIdx);
};

InternalEncoderCesu8.prototype.end = function() {
};

//------------------------------------------------------------------------------
// CESU-8 decoder is not implemented in Node v4.0+

function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
}

InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, 
        res = '';
    for (var i = 0; i < buf.length; i++) {
        var curByte = buf[i];
        if ((curByte & 0xC0) !== 0x80) { // Leading byte
            if (contBytes > 0) { // Previous code is invalid
                res += this.defaultCharUnicode;
                contBytes = 0;
            }

            if (curByte < 0x80) { // Single-byte code
                res += String.fromCharCode(curByte);
            } else if (curByte < 0xE0) { // Two-byte code
                acc = curByte & 0x1F;
                contBytes = 1; accBytes = 1;
            } else if (curByte < 0xF0) { // Three-byte code
                acc = curByte & 0x0F;
                contBytes = 2; accBytes = 1;
            } else { // Four or more are not supported for CESU-8.
                res += this.defaultCharUnicode;
            }
        } else { // Continuation byte
            if (contBytes > 0) { // We're waiting for it.
                acc = (acc << 6) | (curByte & 0x3f);
                contBytes--; accBytes++;
                if (contBytes === 0) {
                    // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)
                    if (accBytes === 2 && acc < 0x80 && acc > 0)
                        res += this.defaultCharUnicode;
                    else if (accBytes === 3 && acc < 0x800)
                        res += this.defaultCharUnicode;
                    else
                        // Actually add character.
                        res += String.fromCharCode(acc);
                }
            } else { // Unexpected continuation byte
                res += this.defaultCharUnicode;
            }
        }
    }
    this.acc = acc; this.contBytes = contBytes; this.accBytes = accBytes;
    return res;
};

InternalDecoderCesu8.prototype.end = function() {
    var res = 0;
    if (this.contBytes > 0)
        res += this.defaultCharUnicode;
    return res;
};

var utf32 = {};

var Buffer$9 = safer_1.Buffer;

// == UTF32-LE/BE codec. ==========================================================

utf32._utf32 = Utf32Codec;

function Utf32Codec(codecOptions, iconv) {
    this.iconv = iconv;
    this.bomAware = true;
    this.isLE = codecOptions.isLE;
}

utf32.utf32le = { type: '_utf32', isLE: true };
utf32.utf32be = { type: '_utf32', isLE: false };

// Aliases
utf32.ucs4le = 'utf32le';
utf32.ucs4be = 'utf32be';

Utf32Codec.prototype.encoder = Utf32Encoder;
Utf32Codec.prototype.decoder = Utf32Decoder;

// -- Encoding

function Utf32Encoder(options, codec) {
    this.isLE = codec.isLE;
    this.highSurrogate = 0;
}

Utf32Encoder.prototype.write = function(str) {
    var src = Buffer$9.from(str, 'ucs2');
    var dst = Buffer$9.alloc(src.length * 2);
    var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
    var offset = 0;

    for (var i = 0; i < src.length; i += 2) {
        var code = src.readUInt16LE(i);
        var isHighSurrogate = (0xD800 <= code && code < 0xDC00);
        var isLowSurrogate = (0xDC00 <= code && code < 0xE000);

        if (this.highSurrogate) {
            if (isHighSurrogate || !isLowSurrogate) {
                // There shouldn't be two high surrogates in a row, nor a high surrogate which isn't followed by a low
                // surrogate. If this happens, keep the pending high surrogate as a stand-alone semi-invalid character
                // (technically wrong, but expected by some applications, like Windows file names).
                write32.call(dst, this.highSurrogate, offset);
                offset += 4;
            }
            else {
                // Create 32-bit value from high and low surrogates;
                var codepoint = (((this.highSurrogate - 0xD800) << 10) | (code - 0xDC00)) + 0x10000;

                write32.call(dst, codepoint, offset);
                offset += 4;
                this.highSurrogate = 0;

                continue;
            }
        }

        if (isHighSurrogate)
            this.highSurrogate = code;
        else {
            // Even if the current character is a low surrogate, with no previous high surrogate, we'll
            // encode it as a semi-invalid stand-alone character for the same reasons expressed above for
            // unpaired high surrogates.
            write32.call(dst, code, offset);
            offset += 4;
            this.highSurrogate = 0;
        }
    }

    if (offset < dst.length)
        dst = dst.slice(0, offset);

    return dst;
};

Utf32Encoder.prototype.end = function() {
    // Treat any leftover high surrogate as a semi-valid independent character.
    if (!this.highSurrogate)
        return;

    var buf = Buffer$9.alloc(4);

    if (this.isLE)
        buf.writeUInt32LE(this.highSurrogate, 0);
    else
        buf.writeUInt32BE(this.highSurrogate, 0);

    this.highSurrogate = 0;

    return buf;
};

// -- Decoding

function Utf32Decoder(options, codec) {
    this.isLE = codec.isLE;
    this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
    this.overflow = [];
}

Utf32Decoder.prototype.write = function(src) {
    if (src.length === 0)
        return '';

    var i = 0;
    var codepoint = 0;
    var dst = Buffer$9.alloc(src.length + 4);
    var offset = 0;
    var isLE = this.isLE;
    var overflow = this.overflow;
    var badChar = this.badChar;

    if (overflow.length > 0) {
        for (; i < src.length && overflow.length < 4; i++)
            overflow.push(src[i]);
        
        if (overflow.length === 4) {
            // NOTE: codepoint is a signed int32 and can be negative.
            // NOTE: We copied this block from below to help V8 optimize it (it works with array, not buffer).
            if (isLE) {
                codepoint = overflow[i] | (overflow[i+1] << 8) | (overflow[i+2] << 16) | (overflow[i+3] << 24);
            } else {
                codepoint = overflow[i+3] | (overflow[i+2] << 8) | (overflow[i+1] << 16) | (overflow[i] << 24);
            }
            overflow.length = 0;

            offset = _writeCodepoint(dst, offset, codepoint, badChar);
        }
    }

    // Main loop. Should be as optimized as possible.
    for (; i < src.length - 3; i += 4) {
        // NOTE: codepoint is a signed int32 and can be negative.
        if (isLE) {
            codepoint = src[i] | (src[i+1] << 8) | (src[i+2] << 16) | (src[i+3] << 24);
        } else {
            codepoint = src[i+3] | (src[i+2] << 8) | (src[i+1] << 16) | (src[i] << 24);
        }
        offset = _writeCodepoint(dst, offset, codepoint, badChar);
    }

    // Keep overflowing bytes.
    for (; i < src.length; i++) {
        overflow.push(src[i]);
    }

    return dst.slice(0, offset).toString('ucs2');
};

function _writeCodepoint(dst, offset, codepoint, badChar) {
    // NOTE: codepoint is signed int32 and can be negative. We keep it that way to help V8 with optimizations.
    if (codepoint < 0 || codepoint > 0x10FFFF) {
        // Not a valid Unicode codepoint
        codepoint = badChar;
    } 

    // Ephemeral Planes: Write high surrogate.
    if (codepoint >= 0x10000) {
        codepoint -= 0x10000;

        var high = 0xD800 | (codepoint >> 10);
        dst[offset++] = high & 0xff;
        dst[offset++] = high >> 8;

        // Low surrogate is written below.
        var codepoint = 0xDC00 | (codepoint & 0x3FF);
    }

    // Write BMP char or low surrogate.
    dst[offset++] = codepoint & 0xff;
    dst[offset++] = codepoint >> 8;

    return offset;
}
Utf32Decoder.prototype.end = function() {
    this.overflow.length = 0;
};

// == UTF-32 Auto codec =============================================================
// Decoder chooses automatically from UTF-32LE and UTF-32BE using BOM and space-based heuristic.
// Defaults to UTF-32LE. http://en.wikipedia.org/wiki/UTF-32
// Encoder/decoder default can be changed: iconv.decode(buf, 'utf32', {defaultEncoding: 'utf-32be'});

// Encoder prepends BOM (which can be overridden with (addBOM: false}).

utf32.utf32 = Utf32AutoCodec;
utf32.ucs4 = 'utf32';

function Utf32AutoCodec(options, iconv) {
    this.iconv = iconv;
}

Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;

// -- Encoding

function Utf32AutoEncoder(options, codec) {
    options = options || {};

    if (options.addBOM === undefined)
        options.addBOM = true;

    this.encoder = codec.iconv.getEncoder(options.defaultEncoding || 'utf-32le', options);
}

Utf32AutoEncoder.prototype.write = function(str) {
    return this.encoder.write(str);
};

Utf32AutoEncoder.prototype.end = function() {
    return this.encoder.end();
};

// -- Decoding

function Utf32AutoDecoder(options, codec) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
}

Utf32AutoDecoder.prototype.write = function(buf) {
    if (!this.decoder) { 
        // Codec is not chosen yet. Accumulate initial bytes.
        this.initialBufs.push(buf);
        this.initialBufsLen += buf.length;

        if (this.initialBufsLen < 32) // We need more bytes to use space heuristic (see below)
            return '';

        // We have enough bytes -> detect endianness.
        var encoding = detectEncoding$1(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);

        var resStr = '';
        for (var i = 0; i < this.initialBufs.length; i++)
            resStr += this.decoder.write(this.initialBufs[i]);

        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
    }

    return this.decoder.write(buf);
};

Utf32AutoDecoder.prototype.end = function() {
    if (!this.decoder) {
        var encoding = detectEncoding$1(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);

        var resStr = '';
        for (var i = 0; i < this.initialBufs.length; i++)
            resStr += this.decoder.write(this.initialBufs[i]);

        var trail = this.decoder.end();
        if (trail)
            resStr += trail;

        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
    }

    return this.decoder.end();
};

function detectEncoding$1(bufs, defaultEncoding) {
    var b = [];
    var charsProcessed = 0;
    var invalidLE = 0, invalidBE = 0;   // Number of invalid chars when decoded as LE or BE.
    var bmpCharsLE = 0, bmpCharsBE = 0; // Number of BMP chars when decoded as LE or BE.

    outer_loop:
    for (var i = 0; i < bufs.length; i++) {
        var buf = bufs[i];
        for (var j = 0; j < buf.length; j++) {
            b.push(buf[j]);
            if (b.length === 4) {
                if (charsProcessed === 0) {
                    // Check BOM first.
                    if (b[0] === 0xFF && b[1] === 0xFE && b[2] === 0 && b[3] === 0) {
                        return 'utf-32le';
                    }
                    if (b[0] === 0 && b[1] === 0 && b[2] === 0xFE && b[3] === 0xFF) {
                        return 'utf-32be';
                    }
                }

                if (b[0] !== 0 || b[1] > 0x10) invalidBE++;
                if (b[3] !== 0 || b[2] > 0x10) invalidLE++;

                if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0)) bmpCharsBE++;
                if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0) bmpCharsLE++;

                b.length = 0;
                charsProcessed++;

                if (charsProcessed >= 100) {
                    break outer_loop;
                }
            }
        }
    }

    // Make decisions.
    if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE)  return 'utf-32be';
    if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE)  return 'utf-32le';

    // Couldn't decide (likely all zeros or not enough data).
    return defaultEncoding || 'utf-32le';
}

var utf16 = {};

var Buffer$8 = safer_1.Buffer;

// Note: UTF16-LE (or UCS2) codec is Node.js native. See encodings/internal.js

// == UTF16-BE codec. ==========================================================

utf16.utf16be = Utf16BECodec;
function Utf16BECodec() {
}

Utf16BECodec.prototype.encoder = Utf16BEEncoder;
Utf16BECodec.prototype.decoder = Utf16BEDecoder;
Utf16BECodec.prototype.bomAware = true;


// -- Encoding

function Utf16BEEncoder() {
}

Utf16BEEncoder.prototype.write = function(str) {
    var buf = Buffer$8.from(str, 'ucs2');
    for (var i = 0; i < buf.length; i += 2) {
        var tmp = buf[i]; buf[i] = buf[i+1]; buf[i+1] = tmp;
    }
    return buf;
};

Utf16BEEncoder.prototype.end = function() {
};


// -- Decoding

function Utf16BEDecoder() {
    this.overflowByte = -1;
}

Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0)
        return '';

    var buf2 = Buffer$8.alloc(buf.length + 1),
        i = 0, j = 0;

    if (this.overflowByte !== -1) {
        buf2[0] = buf[0];
        buf2[1] = this.overflowByte;
        i = 1; j = 2;
    }

    for (; i < buf.length-1; i += 2, j+= 2) {
        buf2[j] = buf[i+1];
        buf2[j+1] = buf[i];
    }

    this.overflowByte = (i == buf.length-1) ? buf[buf.length-1] : -1;

    return buf2.slice(0, j).toString('ucs2');
};

Utf16BEDecoder.prototype.end = function() {
    this.overflowByte = -1;
};


// == UTF-16 codec =============================================================
// Decoder chooses automatically from UTF-16LE and UTF-16BE using BOM and space-based heuristic.
// Defaults to UTF-16LE, as it's prevalent and default in Node.
// http://en.wikipedia.org/wiki/UTF-16 and http://encoding.spec.whatwg.org/#utf-16le
// Decoder default can be changed: iconv.decode(buf, 'utf16', {defaultEncoding: 'utf-16be'});

// Encoder uses UTF-16LE and prepends BOM (which can be overridden with addBOM: false).

utf16.utf16 = Utf16Codec;
function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
}

Utf16Codec.prototype.encoder = Utf16Encoder;
Utf16Codec.prototype.decoder = Utf16Decoder;


// -- Encoding (pass-through)

function Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === undefined)
        options.addBOM = true;
    this.encoder = codec.iconv.getEncoder('utf-16le', options);
}

Utf16Encoder.prototype.write = function(str) {
    return this.encoder.write(str);
};

Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
};


// -- Decoding

function Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;

    this.options = options || {};
    this.iconv = codec.iconv;
}

Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
        // Codec is not chosen yet. Accumulate initial bytes.
        this.initialBufs.push(buf);
        this.initialBufsLen += buf.length;
        
        if (this.initialBufsLen < 16) // We need more bytes to use space heuristic (see below)
            return '';

        // We have enough bytes -> detect endianness.
        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);

        var resStr = '';
        for (var i = 0; i < this.initialBufs.length; i++)
            resStr += this.decoder.write(this.initialBufs[i]);

        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
    }

    return this.decoder.write(buf);
};

Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);

        var resStr = '';
        for (var i = 0; i < this.initialBufs.length; i++)
            resStr += this.decoder.write(this.initialBufs[i]);

        var trail = this.decoder.end();
        if (trail)
            resStr += trail;

        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
    }
    return this.decoder.end();
};

function detectEncoding(bufs, defaultEncoding) {
    var b = [];
    var charsProcessed = 0;
    var asciiCharsLE = 0, asciiCharsBE = 0; // Number of ASCII chars when decoded as LE or BE.

    outer_loop:
    for (var i = 0; i < bufs.length; i++) {
        var buf = bufs[i];
        for (var j = 0; j < buf.length; j++) {
            b.push(buf[j]);
            if (b.length === 2) {
                if (charsProcessed === 0) {
                    // Check BOM first.
                    if (b[0] === 0xFF && b[1] === 0xFE) return 'utf-16le';
                    if (b[0] === 0xFE && b[1] === 0xFF) return 'utf-16be';
                }

                if (b[0] === 0 && b[1] !== 0) asciiCharsBE++;
                if (b[0] !== 0 && b[1] === 0) asciiCharsLE++;

                b.length = 0;
                charsProcessed++;

                if (charsProcessed >= 100) {
                    break outer_loop;
                }
            }
        }
    }

    // Make decisions.
    // Most of the time, the content has ASCII chars (U+00**), but the opposite (U+**00) is uncommon.
    // So, we count ASCII as if it was LE or BE, and decide from that.
    if (asciiCharsBE > asciiCharsLE) return 'utf-16be';
    if (asciiCharsBE < asciiCharsLE) return 'utf-16le';

    // Couldn't decide (likely all zeros or not enough data).
    return defaultEncoding || 'utf-16le';
}

var utf7 = {};

var Buffer$7 = safer_1.Buffer;

// UTF-7 codec, according to https://tools.ietf.org/html/rfc2152
// See also below a UTF-7-IMAP codec, according to http://tools.ietf.org/html/rfc3501#section-5.1.3

utf7.utf7 = Utf7Codec;
utf7.unicode11utf7 = 'utf7'; // Alias UNICODE-1-1-UTF-7
function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
}
Utf7Codec.prototype.encoder = Utf7Encoder;
Utf7Codec.prototype.decoder = Utf7Decoder;
Utf7Codec.prototype.bomAware = true;


// -- Encoding

var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;

function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
}

Utf7Encoder.prototype.write = function(str) {
    // Naive implementation.
    // Non-direct chars are encoded as "+<base64>-"; single "+" char is encoded as "+-".
    return Buffer$7.from(str.replace(nonDirectChars, function(chunk) {
        return "+" + (chunk === '+' ? '' : 
            this.iconv.encode(chunk, 'utf16-be').toString('base64').replace(/=+$/, '')) 
            + "-";
    }.bind(this)));
};

Utf7Encoder.prototype.end = function() {
};


// -- Decoding

function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = '';
}

var base64Regex = /[A-Za-z0-9\/+]/;
var base64Chars = [];
for (var i$2 = 0; i$2 < 256; i$2++)
    base64Chars[i$2] = base64Regex.test(String.fromCharCode(i$2));

var plusChar = '+'.charCodeAt(0), 
    minusChar = '-'.charCodeAt(0),
    andChar = '&'.charCodeAt(0);

Utf7Decoder.prototype.write = function(buf) {
    var res = "", lastI = 0,
        inBase64 = this.inBase64,
        base64Accum = this.base64Accum;

    // The decoder is more involved as we must handle chunks in stream.

    for (var i = 0; i < buf.length; i++) {
        if (!inBase64) { // We're in direct mode.
            // Write direct chars until '+'
            if (buf[i] == plusChar) {
                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
                lastI = i+1;
                inBase64 = true;
            }
        } else { // We decode base64.
            if (!base64Chars[buf[i]]) { // Base64 ended.
                if (i == lastI && buf[i] == minusChar) {// "+-" -> "+"
                    res += "+";
                } else {
                    var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i), "ascii");
                    res += this.iconv.decode(Buffer$7.from(b64str, 'base64'), "utf16-be");
                }

                if (buf[i] != minusChar) // Minus is absorbed after base64.
                    i--;

                lastI = i+1;
                inBase64 = false;
                base64Accum = '';
            }
        }
    }

    if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
    } else {
        var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");

        var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
        b64str = b64str.slice(0, canBeDecoded);

        res += this.iconv.decode(Buffer$7.from(b64str, 'base64'), "utf16-be");
    }

    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;

    return res;
};

Utf7Decoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer$7.from(this.base64Accum, 'base64'), "utf16-be");

    this.inBase64 = false;
    this.base64Accum = '';
    return res;
};


// UTF-7-IMAP codec.
// RFC3501 Sec. 5.1.3 Modified UTF-7 (http://tools.ietf.org/html/rfc3501#section-5.1.3)
// Differences:
//  * Base64 part is started by "&" instead of "+"
//  * Direct characters are 0x20-0x7E, except "&" (0x26)
//  * In Base64, "," is used instead of "/"
//  * Base64 must not be used to represent direct characters.
//  * No implicit shift back from Base64 (should always end with '-')
//  * String must end in non-shifted position.
//  * "-&" while in base64 is not allowed.


utf7.utf7imap = Utf7IMAPCodec;
function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
}
Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
Utf7IMAPCodec.prototype.bomAware = true;


// -- Encoding

function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer$7.alloc(6);
    this.base64AccumIdx = 0;
}

Utf7IMAPEncoder.prototype.write = function(str) {
    var inBase64 = this.inBase64,
        base64Accum = this.base64Accum,
        base64AccumIdx = this.base64AccumIdx,
        buf = Buffer$7.alloc(str.length*5 + 10), bufIdx = 0;

    for (var i = 0; i < str.length; i++) {
        var uChar = str.charCodeAt(i);
        if (0x20 <= uChar && uChar <= 0x7E) { // Direct character or '&'.
            if (inBase64) {
                if (base64AccumIdx > 0) {
                    bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
                    base64AccumIdx = 0;
                }

                buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
                inBase64 = false;
            }

            if (!inBase64) {
                buf[bufIdx++] = uChar; // Write direct character

                if (uChar === andChar)  // Ampersand -> '&-'
                    buf[bufIdx++] = minusChar;
            }

        } else { // Non-direct character
            if (!inBase64) {
                buf[bufIdx++] = andChar; // Write '&', then go to base64 mode.
                inBase64 = true;
            }
            if (inBase64) {
                base64Accum[base64AccumIdx++] = uChar >> 8;
                base64Accum[base64AccumIdx++] = uChar & 0xFF;

                if (base64AccumIdx == base64Accum.length) {
                    bufIdx += buf.write(base64Accum.toString('base64').replace(/\//g, ','), bufIdx);
                    base64AccumIdx = 0;
                }
            }
        }
    }

    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;

    return buf.slice(0, bufIdx);
};

Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer$7.alloc(10), bufIdx = 0;
    if (this.inBase64) {
        if (this.base64AccumIdx > 0) {
            bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
            this.base64AccumIdx = 0;
        }

        buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
        this.inBase64 = false;
    }

    return buf.slice(0, bufIdx);
};


// -- Decoding

function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = '';
}

var base64IMAPChars = base64Chars.slice();
base64IMAPChars[','.charCodeAt(0)] = true;

Utf7IMAPDecoder.prototype.write = function(buf) {
    var res = "", lastI = 0,
        inBase64 = this.inBase64,
        base64Accum = this.base64Accum;

    // The decoder is more involved as we must handle chunks in stream.
    // It is forgiving, closer to standard UTF-7 (for example, '-' is optional at the end).

    for (var i = 0; i < buf.length; i++) {
        if (!inBase64) { // We're in direct mode.
            // Write direct chars until '&'
            if (buf[i] == andChar) {
                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
                lastI = i+1;
                inBase64 = true;
            }
        } else { // We decode base64.
            if (!base64IMAPChars[buf[i]]) { // Base64 ended.
                if (i == lastI && buf[i] == minusChar) { // "&-" -> "&"
                    res += "&";
                } else {
                    var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i), "ascii").replace(/,/g, '/');
                    res += this.iconv.decode(Buffer$7.from(b64str, 'base64'), "utf16-be");
                }

                if (buf[i] != minusChar) // Minus may be absorbed after base64.
                    i--;

                lastI = i+1;
                inBase64 = false;
                base64Accum = '';
            }
        }
    }

    if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
    } else {
        var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, '/');

        var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
        b64str = b64str.slice(0, canBeDecoded);

        res += this.iconv.decode(Buffer$7.from(b64str, 'base64'), "utf16-be");
    }

    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;

    return res;
};

Utf7IMAPDecoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer$7.from(this.base64Accum, 'base64'), "utf16-be");

    this.inBase64 = false;
    this.base64Accum = '';
    return res;
};

var sbcsCodec = {};

var Buffer$6 = safer_1.Buffer;

// Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that
// correspond to encoded bytes (if 128 - then lower half is ASCII). 

sbcsCodec._sbcs = SBCSCodec;
function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions)
        throw new Error("SBCS codec is called without the data.")
    
    // Prepare char buffer for decoding.
    if (!codecOptions.chars || (codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256))
        throw new Error("Encoding '"+codecOptions.type+"' has incorrect 'chars' (must be of len 128 or 256)");
    
    if (codecOptions.chars.length === 128) {
        var asciiString = "";
        for (var i = 0; i < 128; i++)
            asciiString += String.fromCharCode(i);
        codecOptions.chars = asciiString + codecOptions.chars;
    }

    this.decodeBuf = Buffer$6.from(codecOptions.chars, 'ucs2');
    
    // Encoding buffer.
    var encodeBuf = Buffer$6.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));

    for (var i = 0; i < codecOptions.chars.length; i++)
        encodeBuf[codecOptions.chars.charCodeAt(i)] = i;

    this.encodeBuf = encodeBuf;
}

SBCSCodec.prototype.encoder = SBCSEncoder;
SBCSCodec.prototype.decoder = SBCSDecoder;


function SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
}

SBCSEncoder.prototype.write = function(str) {
    var buf = Buffer$6.alloc(str.length);
    for (var i = 0; i < str.length; i++)
        buf[i] = this.encodeBuf[str.charCodeAt(i)];
    
    return buf;
};

SBCSEncoder.prototype.end = function() {
};


function SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
}

SBCSDecoder.prototype.write = function(buf) {
    // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer$6.alloc(buf.length*2);
    var idx1 = 0, idx2 = 0;
    for (var i = 0; i < buf.length; i++) {
        idx1 = buf[i]*2; idx2 = i*2;
        newBuf[idx2] = decodeBuf[idx1];
        newBuf[idx2+1] = decodeBuf[idx1+1];
    }
    return newBuf.toString('ucs2');
};

SBCSDecoder.prototype.end = function() {
};

// Manually added data to be used by sbcs codec in addition to generated one.

var sbcsData = {
    // Not supported by iconv, not sure why.
    "10029": "maccenteuro",
    "maccenteuro": {
        "type": "_sbcs",
        "chars": ""
    },

    "808": "cp808",
    "ibm808": "cp808",
    "cp808": {
        "type": "_sbcs",
        "chars": ""
    },

    "mik": {
        "type": "_sbcs",
        "chars": ""
    },

    "cp720": {
        "type": "_sbcs",
        "chars": "\x80\x81\x84\x86\x8d\x8e\x8f\x90\u0651\u0652\u064b\u064c\u064d\u064e\u064f\u0650\u00a0"
    },

    // Aliases of generated encodings.
    "ascii8bit": "ascii",
    "usascii": "ascii",
    "ansix34": "ascii",
    "ansix341968": "ascii",
    "ansix341986": "ascii",
    "csascii": "ascii",
    "cp367": "ascii",
    "ibm367": "ascii",
    "isoir6": "ascii",
    "iso646us": "ascii",
    "iso646irv": "ascii",
    "us": "ascii",

    "latin1": "iso88591",
    "latin2": "iso88592",
    "latin3": "iso88593",
    "latin4": "iso88594",
    "latin5": "iso88599",
    "latin6": "iso885910",
    "latin7": "iso885913",
    "latin8": "iso885914",
    "latin9": "iso885915",
    "latin10": "iso885916",

    "csisolatin1": "iso88591",
    "csisolatin2": "iso88592",
    "csisolatin3": "iso88593",
    "csisolatin4": "iso88594",
    "csisolatincyrillic": "iso88595",
    "csisolatinarabic": "iso88596",
    "csisolatingreek" : "iso88597",
    "csisolatinhebrew": "iso88598",
    "csisolatin5": "iso88599",
    "csisolatin6": "iso885910",

    "l1": "iso88591",
    "l2": "iso88592",
    "l3": "iso88593",
    "l4": "iso88594",
    "l5": "iso88599",
    "l6": "iso885910",
    "l7": "iso885913",
    "l8": "iso885914",
    "l9": "iso885915",
    "l10": "iso885916",

    "isoir14": "iso646jp",
    "isoir57": "iso646cn",
    "isoir100": "iso88591",
    "isoir101": "iso88592",
    "isoir109": "iso88593",
    "isoir110": "iso88594",
    "isoir144": "iso88595",
    "isoir127": "iso88596",
    "isoir126": "iso88597",
    "isoir138": "iso88598",
    "isoir148": "iso88599",
    "isoir157": "iso885910",
    "isoir166": "tis620",
    "isoir179": "iso885913",
    "isoir199": "iso885914",
    "isoir203": "iso885915",
    "isoir226": "iso885916",

    "cp819": "iso88591",
    "ibm819": "iso88591",

    "cyrillic": "iso88595",

    "arabic": "iso88596",
    "arabic8": "iso88596",
    "ecma114": "iso88596",
    "asmo708": "iso88596",

    "greek" : "iso88597",
    "greek8" : "iso88597",
    "ecma118" : "iso88597",
    "elot928" : "iso88597",

    "hebrew": "iso88598",
    "hebrew8": "iso88598",

    "turkish": "iso88599",
    "turkish8": "iso88599",

    "thai": "iso885911",
    "thai8": "iso885911",

    "celtic": "iso885914",
    "celtic8": "iso885914",
    "isoceltic": "iso885914",

    "tis6200": "tis620",
    "tis62025291": "tis620",
    "tis62025330": "tis620",

    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",

    "cspc8codepage437": "cp437",
    "cspc775baltic": "cp775",
    "cspc850multilingual": "cp850",
    "cspcp852": "cp852",
    "cspc862latinhebrew": "cp862",
    "cpgr": "cp869",

    "msee": "cp1250",
    "mscyrl": "cp1251",
    "msansi": "cp1252",
    "msgreek": "cp1253",
    "msturk": "cp1254",
    "mshebr": "cp1255",
    "msarab": "cp1256",
    "winbaltrim": "cp1257",

    "cp20866": "koi8r",
    "20866": "koi8r",
    "ibm878": "koi8r",
    "cskoi8r": "koi8r",

    "cp21866": "koi8u",
    "21866": "koi8u",
    "ibm1168": "koi8u",

    "strk10482002": "rk1048",

    "tcvn5712": "tcvn",
    "tcvn57121": "tcvn",

    "gb198880": "iso646cn",
    "cn": "iso646cn",

    "csiso14jisc6220ro": "iso646jp",
    "jisc62201969ro": "iso646jp",
    "jp": "iso646jp",

    "cshproman8": "hproman8",
    "r8": "hproman8",
    "roman8": "hproman8",
    "xroman8": "hproman8",
    "ibm1051": "hproman8",

    "mac": "macintosh",
    "csmacintosh": "macintosh",
};

// Generated data for sbcs codec. Don't edit manually. Regenerate using generation/gen-sbcs.js script.
var sbcsDataGenerated = {
  "437": "cp437",
  "737": "cp737",
  "775": "cp775",
  "850": "cp850",
  "852": "cp852",
  "855": "cp855",
  "856": "cp856",
  "857": "cp857",
  "858": "cp858",
  "860": "cp860",
  "861": "cp861",
  "862": "cp862",
  "863": "cp863",
  "864": "cp864",
  "865": "cp865",
  "866": "cp866",
  "869": "cp869",
  "874": "windows874",
  "922": "cp922",
  "1046": "cp1046",
  "1124": "cp1124",
  "1125": "cp1125",
  "1129": "cp1129",
  "1133": "cp1133",
  "1161": "cp1161",
  "1162": "cp1162",
  "1163": "cp1163",
  "1250": "windows1250",
  "1251": "windows1251",
  "1252": "windows1252",
  "1253": "windows1253",
  "1254": "windows1254",
  "1255": "windows1255",
  "1256": "windows1256",
  "1257": "windows1257",
  "1258": "windows1258",
  "28591": "iso88591",
  "28592": "iso88592",
  "28593": "iso88593",
  "28594": "iso88594",
  "28595": "iso88595",
  "28596": "iso88596",
  "28597": "iso88597",
  "28598": "iso88598",
  "28599": "iso88599",
  "28600": "iso885910",
  "28601": "iso885911",
  "28603": "iso885913",
  "28604": "iso885914",
  "28605": "iso885915",
  "28606": "iso885916",
  "windows874": {
    "type": "_sbcs",
    "chars": ""
  },
  "win874": "windows874",
  "cp874": "windows874",
  "windows1250": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1250": "windows1250",
  "cp1250": "windows1250",
  "windows1251": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1251": "windows1251",
  "cp1251": "windows1251",
  "windows1252": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1252": "windows1252",
  "cp1252": "windows1252",
  "windows1253": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1253": "windows1253",
  "cp1253": "windows1253",
  "windows1254": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1254": "windows1254",
  "cp1254": "windows1254",
  "windows1255": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1255": "windows1255",
  "cp1255": "windows1255",
  "windows1256": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1256": "windows1256",
  "cp1256": "windows1256",
  "windows1257": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1257": "windows1257",
  "cp1257": "windows1257",
  "windows1258": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1258": "windows1258",
  "cp1258": "windows1258",
  "iso88591": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28591": "iso88591",
  "iso88592": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28592": "iso88592",
  "iso88593": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28593": "iso88593",
  "iso88594": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28594": "iso88594",
  "iso88595": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28595": "iso88595",
  "iso88596": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28596": "iso88596",
  "iso88597": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28597": "iso88597",
  "iso88598": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28598": "iso88598",
  "iso88599": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28599": "iso88599",
  "iso885910": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28600": "iso885910",
  "iso885911": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28601": "iso885911",
  "iso885913": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28603": "iso885913",
  "iso885914": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28604": "iso885914",
  "iso885915": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28605": "iso885915",
  "iso885916": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28606": "iso885916",
  "cp437": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm437": "cp437",
  "csibm437": "cp437",
  "cp737": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm737": "cp737",
  "csibm737": "cp737",
  "cp775": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm775": "cp775",
  "csibm775": "cp775",
  "cp850": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm850": "cp850",
  "csibm850": "cp850",
  "cp852": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm852": "cp852",
  "csibm852": "cp852",
  "cp855": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm855": "cp855",
  "csibm855": "cp855",
  "cp856": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm856": "cp856",
  "csibm856": "cp856",
  "cp857": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm857": "cp857",
  "csibm857": "cp857",
  "cp858": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm858": "cp858",
  "csibm858": "cp858",
  "cp860": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm860": "cp860",
  "csibm860": "cp860",
  "cp861": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm861": "cp861",
  "csibm861": "cp861",
  "cp862": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm862": "cp862",
  "csibm862": "cp862",
  "cp863": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm863": "cp863",
  "csibm863": "cp863",
  "cp864": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
  },
  "ibm864": "cp864",
  "csibm864": "cp864",
  "cp865": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm865": "cp865",
  "csibm865": "cp865",
  "cp866": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm866": "cp866",
  "csibm866": "cp866",
  "cp869": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm869": "cp869",
  "csibm869": "cp869",
  "cp922": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm922": "cp922",
  "csibm922": "cp922",
  "cp1046": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1046": "cp1046",
  "csibm1046": "cp1046",
  "cp1124": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1124": "cp1124",
  "csibm1124": "cp1124",
  "cp1125": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1125": "cp1125",
  "csibm1125": "cp1125",
  "cp1129": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1129": "cp1129",
  "csibm1129": "cp1129",
  "cp1133": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1133": "cp1133",
  "csibm1133": "cp1133",
  "cp1161": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1161": "cp1161",
  "csibm1161": "cp1161",
  "cp1162": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1162": "cp1162",
  "csibm1162": "cp1162",
  "cp1163": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1163": "cp1163",
  "csibm1163": "cp1163",
  "maccroatian": {
    "type": "_sbcs",
    "chars": ""
  },
  "maccyrillic": {
    "type": "_sbcs",
    "chars": ""
  },
  "macgreek": {
    "type": "_sbcs",
    "chars": ""
  },
  "maciceland": {
    "type": "_sbcs",
    "chars": ""
  },
  "macroman": {
    "type": "_sbcs",
    "chars": ""
  },
  "macromania": {
    "type": "_sbcs",
    "chars": ""
  },
  "macthai": {
    "type": "_sbcs",
    "chars": ""
  },
  "macturkish": {
    "type": "_sbcs",
    "chars": ""
  },
  "macukraine": {
    "type": "_sbcs",
    "chars": ""
  },
  "koi8r": {
    "type": "_sbcs",
    "chars": ""
  },
  "koi8u": {
    "type": "_sbcs",
    "chars": ""
  },
  "koi8ru": {
    "type": "_sbcs",
    "chars": ""
  },
  "koi8t": {
    "type": "_sbcs",
    "chars": ""
  },
  "armscii8": {
    "type": "_sbcs",
    "chars": ")(.,-"
  },
  "rk1048": {
    "type": "_sbcs",
    "chars": ""
  },
  "tcvn": {
    "type": "_sbcs",
    "chars": "\u0000\u0003\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
  },
  "georgianacademy": {
    "type": "_sbcs",
    "chars": ""
  },
  "georgianps": {
    "type": "_sbcs",
    "chars": ""
  },
  "pt154": {
    "type": "_sbcs",
    "chars": ""
  },
  "viscii": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0003\u0004\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0015\u0016\u0017\u0018\u001a\u001b\u001c\u001d\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
  },
  "iso646cn": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
  },
  "iso646jp": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
  },
  "hproman8": {
    "type": "_sbcs",
    "chars": ""
  },
  "macintosh": {
    "type": "_sbcs",
    "chars": ""
  },
  "ascii": {
    "type": "_sbcs",
    "chars": ""
  },
  "tis620": {
    "type": "_sbcs",
    "chars": ""
  }
};

var dbcsCodec = {};

var Buffer$5 = safer_1.Buffer;

// Multibyte codec. In this scheme, a character is represented by 1 or more bytes.
// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.
// To save memory and loading time, we read table files only when requested.

dbcsCodec._dbcs = DBCSCodec;

var UNASSIGNED = -1,
    GB18030_CODE = -2,
    SEQ_START  = -10,
    NODE_START = -1000,
    UNASSIGNED_NODE = new Array(0x100),
    DEF_CHAR = -1;

for (var i$1 = 0; i$1 < 0x100; i$1++)
    UNASSIGNED_NODE[i$1] = UNASSIGNED;


// Class DBCSCodec reads and initializes mapping tables.
function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions)
        throw new Error("DBCS codec is called without the data.")
    if (!codecOptions.table)
        throw new Error("Encoding '" + this.encodingName + "' has no data.");

    // Load tables.
    var mappingTable = codecOptions.table();


    // Decode tables: MBCS -> Unicode.

    // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.
    // Trie root is decodeTables[0].
    // Values: >=  0 -> unicode character code. can be > 0xFFFF
    //         == UNASSIGNED -> unknown/unassigned sequence.
    //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.
    //         <= NODE_START -> index of the next node in our trie to process next byte.
    //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.

    // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. 
    this.decodeTableSeq = [];

    // Actual mapping tables consist of chunks. Use them to fill up decode tables.
    for (var i = 0; i < mappingTable.length; i++)
        this._addDecodeChunk(mappingTable[i]);

    // Load & create GB18030 tables when needed.
    if (typeof codecOptions.gb18030 === 'function') {
        this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.

        // Add GB18030 common decode nodes.
        var commonThirdByteNodeIdx = this.decodeTables.length;
        this.decodeTables.push(UNASSIGNED_NODE.slice(0));

        var commonFourthByteNodeIdx = this.decodeTables.length;
        this.decodeTables.push(UNASSIGNED_NODE.slice(0));

        // Fill out the tree
        var firstByteNode = this.decodeTables[0];
        for (var i = 0x81; i <= 0xFE; i++) {
            var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i]];
            for (var j = 0x30; j <= 0x39; j++) {
                if (secondByteNode[j] === UNASSIGNED) {
                    secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;
                } else if (secondByteNode[j] > NODE_START) {
                    throw new Error("gb18030 decode tables conflict at byte 2");
                }

                var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];
                for (var k = 0x81; k <= 0xFE; k++) {
                    if (thirdByteNode[k] === UNASSIGNED) {
                        thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;
                    } else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) {
                        continue;
                    } else if (thirdByteNode[k] > NODE_START) {
                        throw new Error("gb18030 decode tables conflict at byte 3");
                    }

                    var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];
                    for (var l = 0x30; l <= 0x39; l++) {
                        if (fourthByteNode[l] === UNASSIGNED)
                            fourthByteNode[l] = GB18030_CODE;
                    }
                }
            }
        }
    }

    this.defaultCharUnicode = iconv.defaultCharUnicode;

    
    // Encode tables: Unicode -> DBCS.

    // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.
    // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.
    // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).
    //         == UNASSIGNED -> no conversion found. Output a default char.
    //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.
    this.encodeTable = [];
    
    // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of
    // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key
    // means end of sequence (needed when one sequence is a strict subsequence of another).
    // Objects are kept separately from encodeTable to increase performance.
    this.encodeTableSeq = [];

    // Some chars can be decoded, but need not be encoded.
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
        for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {
            var val = codecOptions.encodeSkipVals[i];
            if (typeof val === 'number')
                skipEncodeChars[val] = true;
            else
                for (var j = val.from; j <= val.to; j++)
                    skipEncodeChars[j] = true;
        }
        
    // Use decode trie to recursively fill out encode tables.
    this._fillEncodeTable(0, 0, skipEncodeChars);

    // Add more encoding pairs when needed.
    if (codecOptions.encodeAdd) {
        for (var uChar in codecOptions.encodeAdd)
            if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
                this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }

    this.defCharSB  = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
}

DBCSCodec.prototype.encoder = DBCSEncoder;
DBCSCodec.prototype.decoder = DBCSDecoder;

// Decoder helpers
DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes = [];
    for (; addr > 0; addr >>>= 8)
        bytes.push(addr & 0xFF);
    if (bytes.length == 0)
        bytes.push(0);

    var node = this.decodeTables[0];
    for (var i = bytes.length-1; i > 0; i--) { // Traverse nodes deeper into the trie.
        var val = node[bytes[i]];

        if (val == UNASSIGNED) { // Create new node.
            node[bytes[i]] = NODE_START - this.decodeTables.length;
            this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
        }
        else if (val <= NODE_START) { // Existing node.
            node = this.decodeTables[NODE_START - val];
        }
        else
            throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node;
};


DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    // First element of chunk is the hex mbcs code where we start.
    var curAddr = parseInt(chunk[0], 16);

    // Choose the decoding node where we'll write our chars.
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 0xFF;

    // Write all other elements of the chunk to the table.
    for (var k = 1; k < chunk.length; k++) {
        var part = chunk[k];
        if (typeof part === "string") { // String, write as-is.
            for (var l = 0; l < part.length;) {
                var code = part.charCodeAt(l++);
                if (0xD800 <= code && code < 0xDC00) { // Decode surrogate
                    var codeTrail = part.charCodeAt(l++);
                    if (0xDC00 <= codeTrail && codeTrail < 0xE000)
                        writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);
                    else
                        throw new Error("Incorrect surrogate pair in "  + this.encodingName + " at chunk " + chunk[0]);
                }
                else if (0x0FF0 < code && code <= 0x0FFF) { // Character sequence (our own encoding used)
                    var len = 0xFFF - code + 2;
                    var seq = [];
                    for (var m = 0; m < len; m++)
                        seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.

                    writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
                    this.decodeTableSeq.push(seq);
                }
                else
                    writeTable[curAddr++] = code; // Basic char
            }
        } 
        else if (typeof part === "number") { // Integer, meaning increasing sequence starting with prev character.
            var charCode = writeTable[curAddr - 1] + 1;
            for (var l = 0; l < part; l++)
                writeTable[curAddr++] = charCode++;
        }
        else
            throw new Error("Incorrect type '" + typeof part + "' given in "  + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 0xFF)
        throw new Error("Incorrect chunk in "  + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
};

// Encoder helpers
DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8; // This could be > 0xFF because of astral characters.
    if (this.encodeTable[high] === undefined)
        this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.
    return this.encodeTable[high];
};

DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 0xFF;
    if (bucket[low] <= SEQ_START)
        this.encodeTableSeq[SEQ_START-bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.
    else if (bucket[low] == UNASSIGNED)
        bucket[low] = dbcsCode;
};

DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
    
    // Get the root of character tree according to first character of the sequence.
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 0xFF;

    var node;
    if (bucket[low] <= SEQ_START) {
        // There's already a sequence with  - use it.
        node = this.encodeTableSeq[SEQ_START-bucket[low]];
    }
    else {
        // There was no sequence object - allocate a new one.
        node = {};
        if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.
        bucket[low] = SEQ_START - this.encodeTableSeq.length;
        this.encodeTableSeq.push(node);
    }

    // Traverse the character tree, allocating new nodes as needed.
    for (var j = 1; j < seq.length-1; j++) {
        var oldVal = node[uCode];
        if (typeof oldVal === 'object')
            node = oldVal;
        else {
            node = node[uCode] = {};
            if (oldVal !== undefined)
                node[DEF_CHAR] = oldVal;
        }
    }

    // Set the leaf to given dbcsCode.
    uCode = seq[seq.length-1];
    node[uCode] = dbcsCode;
};

DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node = this.decodeTables[nodeIdx];
    var hasValues = false;
    var subNodeEmpty = {};
    for (var i = 0; i < 0x100; i++) {
        var uCode = node[i];
        var mbCode = prefix + i;
        if (skipEncodeChars[mbCode])
            continue;

        if (uCode >= 0) {
            this._setEncodeChar(uCode, mbCode);
            hasValues = true;
        } else if (uCode <= NODE_START) {
            var subNodeIdx = NODE_START - uCode;
            if (!subNodeEmpty[subNodeIdx]) {  // Skip empty subtrees (they are too large in gb18030).
                var newPrefix = (mbCode << 8) >>> 0;  // NOTE: '>>> 0' keeps 32-bit num positive.
                if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars))
                    hasValues = true;
                else
                    subNodeEmpty[subNodeIdx] = true;
            }
        } else if (uCode <= SEQ_START) {
            this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
            hasValues = true;
        }
    }
    return hasValues;
};



// == Encoder ==================================================================

function DBCSEncoder(options, codec) {
    // Encoder state
    this.leadSurrogate = -1;
    this.seqObj = undefined;
    
    // Static data
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
}

DBCSEncoder.prototype.write = function(str) {
    var newBuf = Buffer$5.alloc(str.length * (this.gb18030 ? 4 : 3)),
        leadSurrogate = this.leadSurrogate,
        seqObj = this.seqObj, nextChar = -1,
        i = 0, j = 0;

    while (true) {
        // 0. Get next character.
        if (nextChar === -1) {
            if (i == str.length) break;
            var uCode = str.charCodeAt(i++);
        }
        else {
            var uCode = nextChar;
            nextChar = -1;    
        }

        // 1. Handle surrogates.
        if (0xD800 <= uCode && uCode < 0xE000) { // Char is one of surrogates.
            if (uCode < 0xDC00) { // We've got lead surrogate.
                if (leadSurrogate === -1) {
                    leadSurrogate = uCode;
                    continue;
                } else {
                    leadSurrogate = uCode;
                    // Double lead surrogate found.
                    uCode = UNASSIGNED;
                }
            } else { // We've got trail surrogate.
                if (leadSurrogate !== -1) {
                    uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);
                    leadSurrogate = -1;
                } else {
                    // Incomplete surrogate pair - only trail surrogate found.
                    uCode = UNASSIGNED;
                }
                
            }
        }
        else if (leadSurrogate !== -1) {
            // Incomplete surrogate pair - only lead surrogate found.
            nextChar = uCode; uCode = UNASSIGNED; // Write an error, then current char.
            leadSurrogate = -1;
        }

        // 2. Convert uCode character.
        var dbcsCode = UNASSIGNED;
        if (seqObj !== undefined && uCode != UNASSIGNED) { // We are in the middle of the sequence
            var resCode = seqObj[uCode];
            if (typeof resCode === 'object') { // Sequence continues.
                seqObj = resCode;
                continue;

            } else if (typeof resCode == 'number') { // Sequence finished. Write it.
                dbcsCode = resCode;

            } else if (resCode == undefined) { // Current character is not part of the sequence.

                // Try default character for this sequence
                resCode = seqObj[DEF_CHAR];
                if (resCode !== undefined) {
                    dbcsCode = resCode; // Found. Write it.
                    nextChar = uCode; // Current character will be written too in the next iteration.

                }
            }
            seqObj = undefined;
        }
        else if (uCode >= 0) {  // Regular character
            var subtable = this.encodeTable[uCode >> 8];
            if (subtable !== undefined)
                dbcsCode = subtable[uCode & 0xFF];
            
            if (dbcsCode <= SEQ_START) { // Sequence start
                seqObj = this.encodeTableSeq[SEQ_START-dbcsCode];
                continue;
            }

            if (dbcsCode == UNASSIGNED && this.gb18030) {
                // Use GB18030 algorithm to find character(s) to write.
                var idx = findIdx(this.gb18030.uChars, uCode);
                if (idx != -1) {
                    var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600); dbcsCode = dbcsCode % 12600;
                    newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260); dbcsCode = dbcsCode % 1260;
                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10); dbcsCode = dbcsCode % 10;
                    newBuf[j++] = 0x30 + dbcsCode;
                    continue;
                }
            }
        }

        // 3. Write dbcsCode character.
        if (dbcsCode === UNASSIGNED)
            dbcsCode = this.defaultCharSingleByte;
        
        if (dbcsCode < 0x100) {
            newBuf[j++] = dbcsCode;
        }
        else if (dbcsCode < 0x10000) {
            newBuf[j++] = dbcsCode >> 8;   // high byte
            newBuf[j++] = dbcsCode & 0xFF; // low byte
        }
        else if (dbcsCode < 0x1000000) {
            newBuf[j++] = dbcsCode >> 16;
            newBuf[j++] = (dbcsCode >> 8) & 0xFF;
            newBuf[j++] = dbcsCode & 0xFF;
        } else {
            newBuf[j++] = dbcsCode >>> 24;
            newBuf[j++] = (dbcsCode >>> 16) & 0xFF;
            newBuf[j++] = (dbcsCode >>> 8) & 0xFF;
            newBuf[j++] = dbcsCode & 0xFF;
        }
    }

    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j);
};

DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === undefined)
        return; // All clean. Most often case.

    var newBuf = Buffer$5.alloc(10), j = 0;

    if (this.seqObj) { // We're in the sequence.
        var dbcsCode = this.seqObj[DEF_CHAR];
        if (dbcsCode !== undefined) { // Write beginning of the sequence.
            if (dbcsCode < 0x100) {
                newBuf[j++] = dbcsCode;
            }
            else {
                newBuf[j++] = dbcsCode >> 8;   // high byte
                newBuf[j++] = dbcsCode & 0xFF; // low byte
            }
        }
        this.seqObj = undefined;
    }

    if (this.leadSurrogate !== -1) {
        // Incomplete surrogate pair - only lead surrogate found.
        newBuf[j++] = this.defaultCharSingleByte;
        this.leadSurrogate = -1;
    }
    
    return newBuf.slice(0, j);
};

// Export for testing
DBCSEncoder.prototype.findIdx = findIdx;


// == Decoder ==================================================================

function DBCSDecoder(options, codec) {
    // Decoder state
    this.nodeIdx = 0;
    this.prevBytes = [];

    // Static data
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
}

DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer$5.alloc(buf.length*2),
        nodeIdx = this.nodeIdx, 
        prevBytes = this.prevBytes, prevOffset = this.prevBytes.length,
        seqStart = -this.prevBytes.length, // idx of the start of current parsed sequence.
        uCode;

    for (var i = 0, j = 0; i < buf.length; i++) {
        var curByte = (i >= 0) ? buf[i] : prevBytes[i + prevOffset];

        // Lookup in current trie node.
        var uCode = this.decodeTables[nodeIdx][curByte];

        if (uCode >= 0) ;
        else if (uCode === UNASSIGNED) { // Unknown char.
            // TODO: Callback with seq.
            uCode = this.defaultCharUnicode.charCodeAt(0);
            i = seqStart; // Skip one byte ('i' will be incremented by the for loop) and try to parse again.
        }
        else if (uCode === GB18030_CODE) {
            if (i >= 3) {
                var ptr = (buf[i-3]-0x81)*12600 + (buf[i-2]-0x30)*1260 + (buf[i-1]-0x81)*10 + (curByte-0x30);
            } else {
                var ptr = (prevBytes[i-3+prevOffset]-0x81)*12600 + 
                          (((i-2 >= 0) ? buf[i-2] : prevBytes[i-2+prevOffset])-0x30)*1260 + 
                          (((i-1 >= 0) ? buf[i-1] : prevBytes[i-1+prevOffset])-0x81)*10 + 
                          (curByte-0x30);
            }
            var idx = findIdx(this.gb18030.gbChars, ptr);
            uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
        }
        else if (uCode <= NODE_START) { // Go to next trie node.
            nodeIdx = NODE_START - uCode;
            continue;
        }
        else if (uCode <= SEQ_START) { // Output a sequence of chars.
            var seq = this.decodeTableSeq[SEQ_START - uCode];
            for (var k = 0; k < seq.length - 1; k++) {
                uCode = seq[k];
                newBuf[j++] = uCode & 0xFF;
                newBuf[j++] = uCode >> 8;
            }
            uCode = seq[seq.length-1];
        }
        else
            throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);

        // Write the character to buffer, handling higher planes using surrogate pair.
        if (uCode >= 0x10000) { 
            uCode -= 0x10000;
            var uCodeLead = 0xD800 | (uCode >> 10);
            newBuf[j++] = uCodeLead & 0xFF;
            newBuf[j++] = uCodeLead >> 8;

            uCode = 0xDC00 | (uCode & 0x3FF);
        }
        newBuf[j++] = uCode & 0xFF;
        newBuf[j++] = uCode >> 8;

        // Reset trie node.
        nodeIdx = 0; seqStart = i+1;
    }

    this.nodeIdx = nodeIdx;
    this.prevBytes = (seqStart >= 0)
        ? Array.prototype.slice.call(buf, seqStart)
        : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));

    return newBuf.slice(0, j).toString('ucs2');
};

DBCSDecoder.prototype.end = function() {
    var ret = '';

    // Try to parse all remaining chars.
    while (this.prevBytes.length > 0) {
        // Skip 1 character in the buffer.
        ret += this.defaultCharUnicode;
        var bytesArr = this.prevBytes.slice(1);

        // Parse remaining as usual.
        this.prevBytes = [];
        this.nodeIdx = 0;
        if (bytesArr.length > 0)
            ret += this.write(bytesArr);
    }

    this.prevBytes = [];
    this.nodeIdx = 0;
    return ret;
};

// Binary search for GB18030. Returns largest i such that table[i] <= val.
function findIdx(table, val) {
    if (table[0] > val)
        return -1;

    var l = 0, r = table.length;
    while (l < r-1) { // always table[l] <= val < table[r]
        var mid = l + ((r-l+1) >> 1);
        if (table[mid] <= val)
            l = mid;
        else
            r = mid;
    }
    return l;
}

var require$$0$2 = [
	[
		"0",
		"\u0000",
		128
	],
	[
		"a1",
		"",
		62
	],
	[
		"8140",
		"",
		9,
		""
	],
	[
		"8180",
		""
	],
	[
		"81b8",
		""
	],
	[
		"81c8",
		""
	],
	[
		"81da",
		""
	],
	[
		"81f0",
		""
	],
	[
		"81fc",
		""
	],
	[
		"824f",
		"",
		9
	],
	[
		"8260",
		"",
		25
	],
	[
		"8281",
		"",
		25
	],
	[
		"829f",
		"",
		82
	],
	[
		"8340",
		"",
		62
	],
	[
		"8380",
		"",
		22
	],
	[
		"839f",
		"",
		16,
		"",
		6
	],
	[
		"83bf",
		"",
		16,
		"",
		6
	],
	[
		"8440",
		"",
		5,
		"",
		25
	],
	[
		"8470",
		"",
		5,
		"",
		7
	],
	[
		"8480",
		"",
		17
	],
	[
		"849f",
		""
	],
	[
		"8740",
		"",
		19,
		"",
		9
	],
	[
		"875f",
		""
	],
	[
		"877e",
		""
	],
	[
		"8780",
		"",
		4,
		""
	],
	[
		"889f",
		""
	],
	[
		"8940",
		""
	],
	[
		"8980",
		""
	],
	[
		"8a40",
		""
	],
	[
		"8a80",
		""
	],
	[
		"8b40",
		""
	],
	[
		"8b80",
		""
	],
	[
		"8c40",
		""
	],
	[
		"8c80",
		""
	],
	[
		"8d40",
		""
	],
	[
		"8d80",
		""
	],
	[
		"8e40",
		""
	],
	[
		"8e80",
		""
	],
	[
		"8f40",
		""
	],
	[
		"8f80",
		""
	],
	[
		"9040",
		""
	],
	[
		"9080",
		""
	],
	[
		"9140",
		""
	],
	[
		"9180",
		""
	],
	[
		"9240",
		""
	],
	[
		"9280",
		""
	],
	[
		"9340",
		""
	],
	[
		"9380",
		""
	],
	[
		"9440",
		""
	],
	[
		"9480",
		""
	],
	[
		"9540",
		""
	],
	[
		"9580",
		""
	],
	[
		"9640",
		""
	],
	[
		"9680",
		""
	],
	[
		"9740",
		""
	],
	[
		"9780",
		""
	],
	[
		"9840",
		""
	],
	[
		"989f",
		""
	],
	[
		"9940",
		""
	],
	[
		"9980",
		""
	],
	[
		"9a40",
		""
	],
	[
		"9a80",
		""
	],
	[
		"9b40",
		""
	],
	[
		"9b80",
		""
	],
	[
		"9c40",
		""
	],
	[
		"9c80",
		""
	],
	[
		"9d40",
		""
	],
	[
		"9d80",
		""
	],
	[
		"9e40",
		""
	],
	[
		"9e80",
		""
	],
	[
		"9f40",
		""
	],
	[
		"9f80",
		""
	],
	[
		"e040",
		""
	],
	[
		"e080",
		""
	],
	[
		"e140",
		""
	],
	[
		"e180",
		""
	],
	[
		"e240",
		""
	],
	[
		"e280",
		""
	],
	[
		"e340",
		""
	],
	[
		"e380",
		""
	],
	[
		"e440",
		""
	],
	[
		"e480",
		""
	],
	[
		"e540",
		""
	],
	[
		"e580",
		""
	],
	[
		"e640",
		""
	],
	[
		"e680",
		""
	],
	[
		"e740",
		""
	],
	[
		"e780",
		""
	],
	[
		"e840",
		""
	],
	[
		"e880",
		""
	],
	[
		"e940",
		""
	],
	[
		"e980",
		""
	],
	[
		"ea40",
		""
	],
	[
		"ea80",
		""
	],
	[
		"ed40",
		""
	],
	[
		"ed80",
		""
	],
	[
		"ee40",
		""
	],
	[
		"ee80",
		""
	],
	[
		"eeef",
		"",
		9,
		""
	],
	[
		"f040",
		"",
		62
	],
	[
		"f080",
		"",
		124
	],
	[
		"f140",
		"",
		62
	],
	[
		"f180",
		"",
		124
	],
	[
		"f240",
		"",
		62
	],
	[
		"f280",
		"",
		124
	],
	[
		"f340",
		"",
		62
	],
	[
		"f380",
		"",
		124
	],
	[
		"f440",
		"",
		62
	],
	[
		"f480",
		"",
		124
	],
	[
		"f540",
		"",
		62
	],
	[
		"f580",
		"",
		124
	],
	[
		"f640",
		"",
		62
	],
	[
		"f680",
		"",
		124
	],
	[
		"f740",
		"",
		62
	],
	[
		"f780",
		"",
		124
	],
	[
		"f840",
		"",
		62
	],
	[
		"f880",
		"",
		124
	],
	[
		"f940",
		""
	],
	[
		"fa40",
		"",
		9,
		"",
		9,
		""
	],
	[
		"fa80",
		""
	],
	[
		"fb40",
		""
	],
	[
		"fb80",
		""
	],
	[
		"fc40",
		""
	]
];

var require$$1$2 = [
	[
		"0",
		"\u0000",
		127
	],
	[
		"8ea1",
		"",
		62
	],
	[
		"a1a1",
		"",
		9,
		""
	],
	[
		"a2a1",
		""
	],
	[
		"a2ba",
		""
	],
	[
		"a2ca",
		""
	],
	[
		"a2dc",
		""
	],
	[
		"a2f2",
		""
	],
	[
		"a2fe",
		""
	],
	[
		"a3b0",
		"",
		9
	],
	[
		"a3c1",
		"",
		25
	],
	[
		"a3e1",
		"",
		25
	],
	[
		"a4a1",
		"",
		82
	],
	[
		"a5a1",
		"",
		85
	],
	[
		"a6a1",
		"",
		16,
		"",
		6
	],
	[
		"a6c1",
		"",
		16,
		"",
		6
	],
	[
		"a7a1",
		"",
		5,
		"",
		25
	],
	[
		"a7d1",
		"",
		5,
		"",
		25
	],
	[
		"a8a1",
		""
	],
	[
		"ada1",
		"",
		19,
		"",
		9
	],
	[
		"adc0",
		""
	],
	[
		"addf",
		"",
		4,
		""
	],
	[
		"b0a1",
		""
	],
	[
		"b1a1",
		""
	],
	[
		"b2a1",
		""
	],
	[
		"b3a1",
		""
	],
	[
		"b4a1",
		""
	],
	[
		"b5a1",
		""
	],
	[
		"b6a1",
		""
	],
	[
		"b7a1",
		""
	],
	[
		"b8a1",
		""
	],
	[
		"b9a1",
		""
	],
	[
		"baa1",
		""
	],
	[
		"bba1",
		""
	],
	[
		"bca1",
		""
	],
	[
		"bda1",
		""
	],
	[
		"bea1",
		""
	],
	[
		"bfa1",
		""
	],
	[
		"c0a1",
		""
	],
	[
		"c1a1",
		""
	],
	[
		"c2a1",
		""
	],
	[
		"c3a1",
		""
	],
	[
		"c4a1",
		""
	],
	[
		"c5a1",
		""
	],
	[
		"c6a1",
		""
	],
	[
		"c7a1",
		""
	],
	[
		"c8a1",
		""
	],
	[
		"c9a1",
		""
	],
	[
		"caa1",
		""
	],
	[
		"cba1",
		""
	],
	[
		"cca1",
		""
	],
	[
		"cda1",
		""
	],
	[
		"cea1",
		""
	],
	[
		"cfa1",
		""
	],
	[
		"d0a1",
		""
	],
	[
		"d1a1",
		""
	],
	[
		"d2a1",
		""
	],
	[
		"d3a1",
		""
	],
	[
		"d4a1",
		""
	],
	[
		"d5a1",
		""
	],
	[
		"d6a1",
		""
	],
	[
		"d7a1",
		""
	],
	[
		"d8a1",
		""
	],
	[
		"d9a1",
		""
	],
	[
		"daa1",
		""
	],
	[
		"dba1",
		""
	],
	[
		"dca1",
		""
	],
	[
		"dda1",
		""
	],
	[
		"dea1",
		""
	],
	[
		"dfa1",
		""
	],
	[
		"e0a1",
		""
	],
	[
		"e1a1",
		""
	],
	[
		"e2a1",
		""
	],
	[
		"e3a1",
		""
	],
	[
		"e4a1",
		""
	],
	[
		"e5a1",
		""
	],
	[
		"e6a1",
		""
	],
	[
		"e7a1",
		""
	],
	[
		"e8a1",
		""
	],
	[
		"e9a1",
		""
	],
	[
		"eaa1",
		""
	],
	[
		"eba1",
		""
	],
	[
		"eca1",
		""
	],
	[
		"eda1",
		""
	],
	[
		"eea1",
		""
	],
	[
		"efa1",
		""
	],
	[
		"f0a1",
		""
	],
	[
		"f1a1",
		""
	],
	[
		"f2a1",
		""
	],
	[
		"f3a1",
		""
	],
	[
		"f4a1",
		""
	],
	[
		"f9a1",
		""
	],
	[
		"faa1",
		""
	],
	[
		"fba1",
		""
	],
	[
		"fca1",
		""
	],
	[
		"fcf1",
		"",
		9,
		""
	],
	[
		"8fa2af",
		""
	],
	[
		"8fa2c2",
		""
	],
	[
		"8fa2eb",
		""
	],
	[
		"8fa6e1",
		""
	],
	[
		"8fa6e7",
		""
	],
	[
		"8fa6e9",
		""
	],
	[
		"8fa6ec",
		""
	],
	[
		"8fa6f1",
		""
	],
	[
		"8fa7c2",
		"",
		10,
		""
	],
	[
		"8fa7f2",
		"",
		10,
		""
	],
	[
		"8fa9a1",
		""
	],
	[
		"8fa9a4",
		""
	],
	[
		"8fa9a6",
		""
	],
	[
		"8fa9a8",
		""
	],
	[
		"8fa9ab",
		""
	],
	[
		"8fa9af",
		""
	],
	[
		"8fa9c1",
		""
	],
	[
		"8faaa1",
		""
	],
	[
		"8faaba",
		""
	],
	[
		"8faba1",
		""
	],
	[
		"8fabbd",
		""
	],
	[
		"8fabc5",
		""
	],
	[
		"8fb0a1",
		""
	],
	[
		"8fb1a1",
		""
	],
	[
		"8fb2a1",
		"",
		4,
		""
	],
	[
		"8fb3a1",
		""
	],
	[
		"8fb4a1",
		""
	],
	[
		"8fb5a1",
		""
	],
	[
		"8fb6a1",
		"",
		5,
		"",
		4,
		""
	],
	[
		"8fb7a1",
		"",
		4,
		""
	],
	[
		"8fb8a1",
		""
	],
	[
		"8fb9a1",
		""
	],
	[
		"8fbaa1",
		"",
		4,
		""
	],
	[
		"8fbba1",
		""
	],
	[
		"8fbca1",
		"",
		4,
		""
	],
	[
		"8fbda1",
		"",
		4,
		""
	],
	[
		"8fbea1",
		"",
		4,
		""
	],
	[
		"8fbfa1",
		""
	],
	[
		"8fc0a1",
		""
	],
	[
		"8fc1a1",
		""
	],
	[
		"8fc2a1",
		""
	],
	[
		"8fc3a1",
		"",
		4,
		""
	],
	[
		"8fc4a1",
		""
	],
	[
		"8fc5a1",
		""
	],
	[
		"8fc6a1",
		""
	],
	[
		"8fc7a1",
		""
	],
	[
		"8fc8a1",
		""
	],
	[
		"8fc9a1",
		"",
		4,
		"",
		4,
		""
	],
	[
		"8fcaa1",
		""
	],
	[
		"8fcba1",
		""
	],
	[
		"8fcca1",
		"",
		9,
		""
	],
	[
		"8fcda1",
		"",
		5,
		""
	],
	[
		"8fcea1",
		"",
		6,
		""
	],
	[
		"8fcfa1",
		""
	],
	[
		"8fd0a1",
		""
	],
	[
		"8fd1a1",
		""
	],
	[
		"8fd2a1",
		"",
		5
	],
	[
		"8fd3a1",
		""
	],
	[
		"8fd4a1",
		"",
		4,
		""
	],
	[
		"8fd5a1",
		""
	],
	[
		"8fd6a1",
		""
	],
	[
		"8fd7a1",
		""
	],
	[
		"8fd8a1",
		""
	],
	[
		"8fd9a1",
		"",
		4,
		"",
		6,
		""
	],
	[
		"8fdaa1",
		"",
		4,
		""
	],
	[
		"8fdba1",
		"",
		6,
		""
	],
	[
		"8fdca1",
		"",
		4,
		""
	],
	[
		"8fdda1",
		"",
		4,
		""
	],
	[
		"8fdea1",
		"",
		4,
		""
	],
	[
		"8fdfa1",
		""
	],
	[
		"8fe0a1",
		""
	],
	[
		"8fe1a1",
		"",
		4,
		""
	],
	[
		"8fe2a1",
		""
	],
	[
		"8fe3a1",
		"",
		5,
		"",
		4,
		""
	],
	[
		"8fe4a1",
		"",
		4,
		""
	],
	[
		"8fe5a1",
		"",
		4,
		""
	],
	[
		"8fe6a1",
		""
	],
	[
		"8fe7a1",
		""
	],
	[
		"8fe8a1",
		"",
		4,
		""
	],
	[
		"8fe9a1",
		"",
		4
	],
	[
		"8feaa1",
		"",
		4,
		""
	],
	[
		"8feba1",
		"",
		4,
		""
	],
	[
		"8feca1",
		""
	],
	[
		"8feda1",
		"",
		4,
		"",
		4,
		""
	]
];

var require$$2$1 = [
	[
		"0",
		"\u0000",
		127,
		""
	],
	[
		"8140",
		"",
		5,
		"",
		9,
		"",
		6,
		""
	],
	[
		"8180",
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"8240",
		"",
		4,
		"",
		8,
		"",
		4,
		"",
		11
	],
	[
		"8280",
		"",
		10,
		"",
		4,
		"",
		7,
		"",
		5,
		"",
		8,
		"",
		20,
		"",
		4,
		"",
		6,
		""
	],
	[
		"8340",
		"",
		17,
		"",
		5,
		"",
		10,
		"",
		4,
		"",
		9,
		""
	],
	[
		"8380",
		"",
		5,
		"",
		13,
		"",
		28,
		"",
		4,
		"",
		4,
		"",
		5
	],
	[
		"8440",
		"",
		5,
		"",
		5,
		""
	],
	[
		"8480",
		"",
		9,
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		9,
		"",
		5,
		"",
		10,
		"",
		7,
		""
	],
	[
		"8540",
		"",
		9,
		""
	],
	[
		"8580",
		"",
		4,
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		7,
		""
	],
	[
		"8640",
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		5,
		""
	],
	[
		"8680",
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		6,
		"",
		8,
		"",
		4,
		"",
		4,
		"",
		4,
		""
	],
	[
		"8740",
		"",
		7,
		"",
		11,
		"",
		4,
		"",
		4
	],
	[
		"8780",
		"",
		7,
		"",
		6,
		"",
		14,
		"",
		10,
		"",
		6,
		"",
		12,
		"",
		8,
		"",
		5,
		"",
		6
	],
	[
		"8840",
		"",
		9,
		"",
		4,
		"",
		4,
		""
	],
	[
		"8880",
		"",
		4,
		"",
		6,
		"",
		8,
		"",
		6,
		"",
		7,
		"",
		4,
		"",
		4,
		"",
		7
	],
	[
		"8940",
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		16,
		""
	],
	[
		"8980",
		"",
		4,
		"",
		4,
		"",
		7,
		"",
		17,
		"",
		10,
		"",
		13,
		"",
		5,
		"",
		7,
		"",
		4,
		""
	],
	[
		"8a40",
		"",
		4,
		"",
		12,
		""
	],
	[
		"8a80",
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		11,
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		9,
		"",
		5
	],
	[
		"8b40",
		"",
		8,
		"",
		17,
		"",
		6,
		"",
		13,
		""
	],
	[
		"8b80",
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		22,
		"",
		11,
		"",
		25,
		"",
		7,
		"",
		6
	],
	[
		"8c40",
		"",
		7,
		""
	],
	[
		"8c80",
		"",
		8,
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		4
	],
	[
		"8d40",
		"",
		5,
		"",
		5,
		"",
		5,
		"",
		6,
		"",
		9,
		"",
		4
	],
	[
		"8d80",
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		7,
		"",
		7,
		"",
		10,
		"",
		10,
		"",
		12,
		"",
		21,
		""
	],
	[
		"8e40",
		"",
		21,
		"",
		12,
		"",
		6,
		"",
		12,
		""
	],
	[
		"8e80",
		"",
		4,
		"",
		7,
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		14,
		"",
		4,
		"",
		4,
		"",
		6
	],
	[
		"8f40",
		"",
		5,
		"",
		11,
		"",
		8,
		""
	],
	[
		"8f80",
		"",
		6,
		"",
		14,
		"",
		5,
		"",
		5,
		"",
		4,
		""
	],
	[
		"9040",
		"",
		4,
		"",
		4,
		"",
		6,
		""
	],
	[
		"9080",
		"",
		7,
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		18,
		"",
		6
	],
	[
		"9140",
		"",
		6,
		"",
		6,
		"",
		18,
		"",
		4,
		""
	],
	[
		"9180",
		"",
		6,
		"",
		8,
		"",
		9,
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		16,
		"",
		13,
		"",
		8,
		"",
		5,
		"",
		4,
		""
	],
	[
		"9240",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9280",
		"",
		5,
		"",
		7,
		"",
		6,
		""
	],
	[
		"9340",
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"9380",
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		4,
		"",
		7,
		"",
		9,
		"",
		6,
		"",
		8,
		"",
		4,
		"",
		6,
		""
	],
	[
		"9440",
		"",
		24,
		"",
		7,
		"",
		7,
		"",
		4,
		"",
		8
	],
	[
		"9480",
		"",
		4,
		"",
		4,
		"",
		14,
		"",
		7,
		"",
		7,
		""
	],
	[
		"9540",
		"",
		4,
		"",
		4,
		"",
		6,
		""
	],
	[
		"9580",
		"",
		4,
		"",
		4,
		"",
		8,
		"",
		4,
		"",
		4,
		"",
		25,
		"",
		7,
		"",
		5,
		""
	],
	[
		"9640",
		"",
		5,
		"",
		4,
		""
	],
	[
		"9680",
		"",
		7,
		"",
		9,
		"",
		7,
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		5
	],
	[
		"9740",
		"",
		7,
		"",
		8,
		"",
		7,
		"",
		9,
		""
	],
	[
		"9780",
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		9,
		"",
		4,
		"",
		11,
		"",
		7,
		"",
		16,
		""
	],
	[
		"9840",
		"",
		4,
		"",
		5,
		"",
		9,
		""
	],
	[
		"9880",
		"",
		7,
		"",
		5,
		"",
		11,
		"",
		9,
		"",
		9,
		"",
		11,
		"",
		5,
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		7,
		"",
		6,
		""
	],
	[
		"9940",
		"",
		4,
		"",
		10,
		"",
		6,
		"",
		8,
		"",
		4,
		"",
		7,
		"",
		5
	],
	[
		"9980",
		"",
		114,
		"",
		6
	],
	[
		"9a40",
		"",
		11,
		"",
		7,
		"",
		13,
		""
	],
	[
		"9a80",
		"",
		4,
		"",
		7,
		"",
		7,
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		7,
		"",
		6,
		"",
		4,
		"",
		4,
		""
	],
	[
		"9b40",
		"",
		4,
		""
	],
	[
		"9b80",
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"9c40",
		"",
		7,
		""
	],
	[
		"9c80",
		"",
		7,
		"",
		7,
		"",
		10,
		"",
		14,
		"",
		4,
		"",
		6,
		"",
		5
	],
	[
		"9d40",
		"",
		7,
		"",
		4,
		"",
		9,
		"",
		6,
		""
	],
	[
		"9d80",
		"",
		9,
		"",
		5,
		"",
		6,
		"",
		12,
		"",
		4,
		"",
		10,
		"",
		5,
		"",
		5,
		"",
		6,
		"",
		10,
		""
	],
	[
		"9e40",
		"",
		7,
		"",
		32,
		"",
		7,
		"",
		6,
		"",
		6
	],
	[
		"9e80",
		"",
		9,
		"",
		17,
		"",
		13,
		"",
		11,
		"",
		12,
		"",
		12,
		""
	],
	[
		"9f40",
		"",
		6,
		"",
		10,
		"",
		4,
		"",
		10,
		"",
		7,
		""
	],
	[
		"9f80",
		"",
		13,
		"",
		12,
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		8,
		"",
		9,
		"",
		4
	],
	[
		"a040",
		"",
		9,
		"",
		5,
		"",
		9,
		"",
		11,
		"",
		19
	],
	[
		"a080",
		"",
		9,
		"",
		6,
		"",
		4,
		"",
		11,
		"",
		11,
		"",
		6,
		""
	],
	[
		"a1a1",
		"",
		7,
		""
	],
	[
		"a2a1",
		"",
		9
	],
	[
		"a2b1",
		"",
		19,
		"",
		19,
		"",
		9
	],
	[
		"a2e5",
		"",
		9
	],
	[
		"a2f1",
		"",
		11
	],
	[
		"a3a1",
		"",
		88,
		""
	],
	[
		"a4a1",
		"",
		82
	],
	[
		"a5a1",
		"",
		85
	],
	[
		"a6a1",
		"",
		16,
		"",
		6
	],
	[
		"a6c1",
		"",
		16,
		"",
		6
	],
	[
		"a6e0",
		""
	],
	[
		"a6ee",
		""
	],
	[
		"a6f4",
		""
	],
	[
		"a7a1",
		"",
		5,
		"",
		25
	],
	[
		"a7d1",
		"",
		5,
		"",
		25
	],
	[
		"a840",
		"",
		35,
		"",
		6
	],
	[
		"a880",
		"",
		7,
		""
	],
	[
		"a8a1",
		""
	],
	[
		"a8bd",
		""
	],
	[
		"a8c0",
		""
	],
	[
		"a8c5",
		"",
		36
	],
	[
		"a940",
		"",
		8,
		""
	],
	[
		"a959",
		""
	],
	[
		"a95c",
		""
	],
	[
		"a960",
		"",
		9,
		"",
		8
	],
	[
		"a980",
		"",
		4,
		""
	],
	[
		"a996",
		""
	],
	[
		"a9a4",
		"",
		75
	],
	[
		"aa40",
		"",
		5,
		"",
		5,
		"",
		8
	],
	[
		"aa80",
		"",
		7,
		"",
		10,
		""
	],
	[
		"ab40",
		"",
		11,
		"",
		4,
		"",
		5,
		"",
		4
	],
	[
		"ab80",
		"",
		6,
		"",
		4
	],
	[
		"ac40",
		"",
		10,
		"",
		8,
		"",
		5,
		"",
		4,
		"",
		11
	],
	[
		"ac80",
		"",
		6,
		"",
		12,
		"",
		4,
		""
	],
	[
		"ad40",
		"",
		10,
		"",
		7,
		"",
		15,
		"",
		12
	],
	[
		"ad80",
		"",
		9,
		"",
		8,
		"",
		6,
		""
	],
	[
		"ae40",
		"",
		6,
		"",
		7,
		"",
		4,
		""
	],
	[
		"ae80",
		"",
		7,
		"",
		6,
		"",
		4,
		""
	],
	[
		"af40",
		"",
		4,
		""
	],
	[
		"af80",
		""
	],
	[
		"b040",
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		7,
		""
	],
	[
		"b080",
		"",
		7,
		"",
		8,
		"",
		9,
		""
	],
	[
		"b140",
		"",
		4,
		"",
		7,
		"",
		10,
		""
	],
	[
		"b180",
		"",
		4,
		"",
		7,
		"",
		7,
		""
	],
	[
		"b240",
		"",
		11,
		"",
		5,
		"",
		11,
		"",
		4
	],
	[
		"b280",
		"",
		12,
		"",
		8,
		"",
		4,
		""
	],
	[
		"b340",
		"",
		5,
		""
	],
	[
		"b380",
		"",
		11,
		"",
		7,
		"",
		6,
		""
	],
	[
		"b440",
		"",
		7,
		"",
		9
	],
	[
		"b480",
		"",
		4,
		"",
		5,
		"",
		6,
		""
	],
	[
		"b540",
		"",
		5,
		"",
		9,
		"",
		4,
		"",
		14,
		"",
		4,
		"",
		8,
		""
	],
	[
		"b580",
		"",
		6,
		"",
		4,
		""
	],
	[
		"b640",
		"",
		6,
		"",
		11,
		"",
		10,
		"",
		4,
		"",
		5,
		""
	],
	[
		"b680",
		"",
		6,
		"",
		4,
		""
	],
	[
		"b740",
		"",
		14,
		"",
		5,
		"",
		9,
		"",
		4,
		"",
		16
	],
	[
		"b780",
		"",
		6,
		""
	],
	[
		"b840",
		"",
		4,
		"",
		10,
		"",
		10,
		"",
		9,
		"",
		5,
		""
	],
	[
		"b880",
		"",
		4,
		""
	],
	[
		"b940",
		"",
		5,
		"",
		10,
		"",
		6,
		""
	],
	[
		"b980",
		"",
		7,
		""
	],
	[
		"ba40",
		"",
		4,
		"",
		4,
		"",
		7,
		"",
		5,
		""
	],
	[
		"ba80",
		"",
		4,
		"",
		5,
		"",
		12,
		"",
		5,
		""
	],
	[
		"bb40",
		"",
		9,
		"",
		36,
		"",
		5,
		"",
		9
	],
	[
		"bb80",
		"",
		6,
		"",
		4,
		""
	],
	[
		"bc40",
		"",
		6,
		"",
		6,
		"",
		5,
		"",
		7,
		"",
		13,
		"",
		5
	],
	[
		"bc80",
		"",
		14,
		"",
		6,
		""
	],
	[
		"bd40",
		"",
		54,
		"",
		7
	],
	[
		"bd80",
		"",
		32,
		""
	],
	[
		"be40",
		"",
		12,
		"",
		6,
		"",
		42
	],
	[
		"be80",
		"",
		32,
		""
	],
	[
		"bf40",
		"",
		62
	],
	[
		"bf80",
		"",
		4,
		"",
		4,
		"",
		21,
		""
	],
	[
		"c040",
		"",
		35,
		"",
		23,
		""
	],
	[
		"c080",
		"",
		6,
		"",
		9,
		""
	],
	[
		"c140",
		"",
		4,
		"",
		7,
		"",
		4,
		"",
		4,
		"",
		6,
		""
	],
	[
		"c180",
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"c240",
		"",
		6,
		"",
		5,
		""
	],
	[
		"c280",
		"",
		13,
		"",
		5,
		"",
		11,
		""
	],
	[
		"c340",
		"",
		5,
		"",
		4,
		"",
		6,
		""
	],
	[
		"c380",
		"",
		12,
		"",
		4,
		""
	],
	[
		"c440",
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		4,
		""
	],
	[
		"c480",
		"",
		7,
		"",
		5,
		"",
		6,
		""
	],
	[
		"c540",
		"",
		14,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		5,
		""
	],
	[
		"c580",
		"",
		7,
		"",
		7,
		""
	],
	[
		"c640",
		""
	],
	[
		"c680",
		"",
		4,
		"",
		9,
		""
	],
	[
		"c740",
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		6,
		""
	],
	[
		"c780",
		""
	],
	[
		"c840",
		"",
		4,
		"",
		5,
		"",
		5,
		"",
		7,
		"",
		5,
		"",
		7,
		""
	],
	[
		"c880",
		"",
		6,
		"",
		4,
		"",
		4,
		""
	],
	[
		"c940",
		"",
		4,
		"",
		7,
		"",
		12,
		""
	],
	[
		"c980",
		"",
		4,
		"",
		4,
		"",
		10,
		""
	],
	[
		"ca40",
		"",
		8,
		"",
		8,
		"",
		9,
		"",
		4,
		"",
		10
	],
	[
		"ca80",
		"",
		4,
		"",
		8,
		""
	],
	[
		"cb40",
		"",
		6,
		"",
		10,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		6,
		"",
		4,
		""
	],
	[
		"cb80",
		"",
		5,
		"",
		6,
		"",
		14,
		""
	],
	[
		"cc40",
		"",
		4,
		"",
		10,
		"",
		15,
		"",
		13,
		""
	],
	[
		"cc80",
		"",
		11,
		"",
		4,
		"",
		7,
		""
	],
	[
		"cd40",
		"",
		6,
		"",
		6,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		4,
		""
	],
	[
		"cd80",
		""
	],
	[
		"ce40",
		"",
		6,
		"",
		5,
		"",
		7,
		""
	],
	[
		"ce80",
		"",
		4,
		"",
		6,
		"",
		4,
		""
	],
	[
		"cf40",
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		9
	],
	[
		"cf80",
		"",
		5,
		"",
		7,
		"",
		4,
		""
	],
	[
		"d040",
		"",
		13,
		"",
		5,
		"",
		5,
		"",
		5,
		"",
		6,
		""
	],
	[
		"d080",
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"d140",
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5
	],
	[
		"d180",
		"",
		4,
		"",
		4,
		"",
		4,
		""
	],
	[
		"d240",
		"",
		8,
		"",
		24,
		"",
		5,
		"",
		19,
		""
	],
	[
		"d280",
		"",
		26,
		""
	],
	[
		"d340",
		"",
		30,
		"",
		6
	],
	[
		"d380",
		"",
		4,
		"",
		5,
		"",
		21,
		""
	],
	[
		"d440",
		"",
		31,
		"",
		8,
		"",
		21
	],
	[
		"d480",
		"",
		25,
		"",
		6,
		""
	],
	[
		"d540",
		"",
		7,
		"",
		7,
		"",
		46
	],
	[
		"d580",
		"",
		32,
		""
	],
	[
		"d640",
		"",
		34,
		"",
		27
	],
	[
		"d680",
		"",
		30,
		""
	],
	[
		"d740",
		"",
		31,
		"",
		4,
		"",
		25
	],
	[
		"d780",
		"",
		24,
		""
	],
	[
		"d840",
		"",
		8,
		"",
		7,
		"",
		5,
		"",
		6,
		"",
		6,
		"",
		6,
		""
	],
	[
		"d880",
		"",
		6,
		"",
		20,
		""
	],
	[
		"d940",
		"",
		62
	],
	[
		"d980",
		"",
		32,
		""
	],
	[
		"da40",
		"",
		14,
		"",
		8,
		"",
		4,
		"",
		9,
		""
	],
	[
		"da80",
		"",
		12,
		""
	],
	[
		"db40",
		"",
		6,
		"",
		7,
		"",
		4,
		""
	],
	[
		"db80",
		"",
		4,
		"",
		5,
		"",
		11,
		""
	],
	[
		"dc40",
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		11,
		"",
		6,
		"",
		7
	],
	[
		"dc80",
		"",
		10,
		"",
		21,
		""
	],
	[
		"dd40",
		"",
		62
	],
	[
		"dd80",
		"",
		32,
		""
	],
	[
		"de40",
		"",
		32,
		""
	],
	[
		"de80",
		"",
		4,
		""
	],
	[
		"df40",
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		6,
		""
	],
	[
		"df80",
		"",
		4,
		""
	],
	[
		"e040",
		"",
		19,
		""
	],
	[
		"e080",
		"",
		10,
		"",
		6,
		"",
		8,
		""
	],
	[
		"e140",
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		5,
		""
	],
	[
		"e180",
		"",
		10,
		"",
		9,
		"",
		8,
		""
	],
	[
		"e240",
		"",
		62
	],
	[
		"e280",
		"",
		32,
		"",
		5,
		""
	],
	[
		"e340",
		"",
		45,
		"",
		16
	],
	[
		"e380",
		"",
		7,
		"",
		24,
		""
	],
	[
		"e440",
		"",
		5,
		"",
		24,
		"",
		31
	],
	[
		"e480",
		"",
		32,
		""
	],
	[
		"e540",
		"",
		51,
		"",
		10
	],
	[
		"e580",
		"",
		31,
		""
	],
	[
		"e640",
		"",
		34,
		"",
		27
	],
	[
		"e680",
		"",
		29,
		""
	],
	[
		"e740",
		"",
		7,
		"",
		54
	],
	[
		"e780",
		"",
		32,
		"",
		6,
		"",
		4,
		""
	],
	[
		"e840",
		"",
		14,
		"",
		43,
		""
	],
	[
		"e880",
		"",
		20,
		""
	],
	[
		"e940",
		"",
		7,
		"",
		42
	],
	[
		"e980",
		"",
		32,
		""
	],
	[
		"ea40",
		"",
		27,
		"",
		6,
		""
	],
	[
		"ea80",
		"",
		4,
		"",
		12,
		""
	],
	[
		"eb40",
		"",
		9,
		"",
		7,
		"",
		9,
		"",
		6,
		""
	],
	[
		"eb80",
		"",
		4,
		""
	],
	[
		"ec40",
		"",
		8,
		"",
		4,
		"",
		18,
		"",
		7
	],
	[
		"ec80",
		"",
		4,
		"",
		7,
		"",
		4,
		"",
		4,
		""
	],
	[
		"ed40",
		"",
		6,
		"",
		46
	],
	[
		"ed80",
		"",
		4,
		"",
		23,
		""
	],
	[
		"ee40",
		"",
		62
	],
	[
		"ee80",
		"",
		32,
		"",
		4,
		"",
		6,
		""
	],
	[
		"ef40",
		"",
		5,
		"",
		37,
		"",
		4
	],
	[
		"ef80",
		"",
		30,
		"",
		4,
		"",
		8,
		""
	],
	[
		"f040",
		"",
		4,
		"",
		28,
		"",
		26
	],
	[
		"f080",
		"",
		9,
		"",
		12,
		"",
		4,
		"",
		6,
		""
	],
	[
		"f140",
		"",
		10,
		"",
		47
	],
	[
		"f180",
		"",
		32,
		""
	],
	[
		"f240",
		"",
		62
	],
	[
		"f280",
		"",
		32,
		""
	],
	[
		"f340",
		"",
		17,
		"",
		6,
		"",
		4,
		""
	],
	[
		"f380",
		"",
		8,
		"",
		6,
		""
	],
	[
		"f440",
		"",
		5,
		"",
		10,
		"",
		10,
		"",
		7,
		"",
		5
	],
	[
		"f480",
		"",
		32,
		""
	],
	[
		"f540",
		"",
		62
	],
	[
		"f580",
		"",
		32,
		""
	],
	[
		"f640",
		"",
		62
	],
	[
		"f680",
		"",
		32,
		"",
		5,
		"",
		5,
		"",
		4,
		"",
		7,
		""
	],
	[
		"f740",
		"",
		62
	],
	[
		"f780",
		"",
		4,
		"",
		4,
		""
	],
	[
		"f840",
		"",
		62
	],
	[
		"f880",
		"",
		32
	],
	[
		"f940",
		"",
		62
	],
	[
		"f980",
		"",
		32
	],
	[
		"fa40",
		"",
		62
	],
	[
		"fa80",
		"",
		32
	],
	[
		"fb40",
		"",
		27,
		"",
		9,
		""
	],
	[
		"fb80",
		"",
		5,
		"",
		8,
		"",
		5,
		""
	],
	[
		"fc40",
		"",
		8,
		"",
		4,
		"",
		8,
		"",
		6
	],
	[
		"fc80",
		"",
		4,
		"",
		5,
		"",
		8,
		""
	],
	[
		"fd40",
		"",
		4,
		"",
		4,
		"",
		10,
		"",
		38
	],
	[
		"fd80",
		"",
		5,
		"",
		11,
		"",
		4,
		""
	],
	[
		"fe40",
		""
	]
];

var require$$3$1 = [
	[
		"a140",
		"",
		62
	],
	[
		"a180",
		"",
		32
	],
	[
		"a240",
		"",
		62
	],
	[
		"a280",
		"",
		32
	],
	[
		"a2ab",
		"",
		5
	],
	[
		"a2e3",
		""
	],
	[
		"a2ef",
		""
	],
	[
		"a2fd",
		""
	],
	[
		"a340",
		"",
		62
	],
	[
		"a380",
		"",
		31,
		""
	],
	[
		"a440",
		"",
		62
	],
	[
		"a480",
		"",
		32
	],
	[
		"a4f4",
		"",
		10
	],
	[
		"a540",
		"",
		62
	],
	[
		"a580",
		"",
		32
	],
	[
		"a5f7",
		"",
		7
	],
	[
		"a640",
		"",
		62
	],
	[
		"a680",
		"",
		32
	],
	[
		"a6b9",
		"",
		7
	],
	[
		"a6d9",
		"",
		6
	],
	[
		"a6ec",
		""
	],
	[
		"a6f3",
		""
	],
	[
		"a6f6",
		"",
		8
	],
	[
		"a740",
		"",
		62
	],
	[
		"a780",
		"",
		32
	],
	[
		"a7c2",
		"",
		14
	],
	[
		"a7f2",
		"",
		12
	],
	[
		"a896",
		"",
		10
	],
	[
		"a8bc",
		""
	],
	[
		"a8bf",
		""
	],
	[
		"a8c1",
		""
	],
	[
		"a8ea",
		"",
		20
	],
	[
		"a958",
		""
	],
	[
		"a95b",
		""
	],
	[
		"a95d",
		""
	],
	[
		"a989",
		"",
		11
	],
	[
		"a997",
		"",
		12
	],
	[
		"a9f0",
		"",
		14
	],
	[
		"aaa1",
		"",
		93
	],
	[
		"aba1",
		"",
		93
	],
	[
		"aca1",
		"",
		93
	],
	[
		"ada1",
		"",
		93
	],
	[
		"aea1",
		"",
		93
	],
	[
		"afa1",
		"",
		93
	],
	[
		"d7fa",
		"",
		4
	],
	[
		"f8a1",
		"",
		93
	],
	[
		"f9a1",
		"",
		93
	],
	[
		"faa1",
		"",
		93
	],
	[
		"fba1",
		"",
		93
	],
	[
		"fca1",
		"",
		93
	],
	[
		"fda1",
		"",
		93
	],
	[
		"fe50",
		""
	],
	[
		"fe80",
		"",
		6,
		"",
		93
	],
	[
		"8135f437",
		""
	]
];

var uChars = [
	128,
	165,
	169,
	178,
	184,
	216,
	226,
	235,
	238,
	244,
	248,
	251,
	253,
	258,
	276,
	284,
	300,
	325,
	329,
	334,
	364,
	463,
	465,
	467,
	469,
	471,
	473,
	475,
	477,
	506,
	594,
	610,
	712,
	716,
	730,
	930,
	938,
	962,
	970,
	1026,
	1104,
	1106,
	8209,
	8215,
	8218,
	8222,
	8231,
	8241,
	8244,
	8246,
	8252,
	8365,
	8452,
	8454,
	8458,
	8471,
	8482,
	8556,
	8570,
	8596,
	8602,
	8713,
	8720,
	8722,
	8726,
	8731,
	8737,
	8740,
	8742,
	8748,
	8751,
	8760,
	8766,
	8777,
	8781,
	8787,
	8802,
	8808,
	8816,
	8854,
	8858,
	8870,
	8896,
	8979,
	9322,
	9372,
	9548,
	9588,
	9616,
	9622,
	9634,
	9652,
	9662,
	9672,
	9676,
	9680,
	9702,
	9735,
	9738,
	9793,
	9795,
	11906,
	11909,
	11913,
	11917,
	11928,
	11944,
	11947,
	11951,
	11956,
	11960,
	11964,
	11979,
	12284,
	12292,
	12312,
	12319,
	12330,
	12351,
	12436,
	12447,
	12535,
	12543,
	12586,
	12842,
	12850,
	12964,
	13200,
	13215,
	13218,
	13253,
	13263,
	13267,
	13270,
	13384,
	13428,
	13727,
	13839,
	13851,
	14617,
	14703,
	14801,
	14816,
	14964,
	15183,
	15471,
	15585,
	16471,
	16736,
	17208,
	17325,
	17330,
	17374,
	17623,
	17997,
	18018,
	18212,
	18218,
	18301,
	18318,
	18760,
	18811,
	18814,
	18820,
	18823,
	18844,
	18848,
	18872,
	19576,
	19620,
	19738,
	19887,
	40870,
	59244,
	59336,
	59367,
	59413,
	59417,
	59423,
	59431,
	59437,
	59443,
	59452,
	59460,
	59478,
	59493,
	63789,
	63866,
	63894,
	63976,
	63986,
	64016,
	64018,
	64021,
	64025,
	64034,
	64037,
	64042,
	65074,
	65093,
	65107,
	65112,
	65127,
	65132,
	65375,
	65510,
	65536
];
var gbChars = [
	0,
	36,
	38,
	45,
	50,
	81,
	89,
	95,
	96,
	100,
	103,
	104,
	105,
	109,
	126,
	133,
	148,
	172,
	175,
	179,
	208,
	306,
	307,
	308,
	309,
	310,
	311,
	312,
	313,
	341,
	428,
	443,
	544,
	545,
	558,
	741,
	742,
	749,
	750,
	805,
	819,
	820,
	7922,
	7924,
	7925,
	7927,
	7934,
	7943,
	7944,
	7945,
	7950,
	8062,
	8148,
	8149,
	8152,
	8164,
	8174,
	8236,
	8240,
	8262,
	8264,
	8374,
	8380,
	8381,
	8384,
	8388,
	8390,
	8392,
	8393,
	8394,
	8396,
	8401,
	8406,
	8416,
	8419,
	8424,
	8437,
	8439,
	8445,
	8482,
	8485,
	8496,
	8521,
	8603,
	8936,
	8946,
	9046,
	9050,
	9063,
	9066,
	9076,
	9092,
	9100,
	9108,
	9111,
	9113,
	9131,
	9162,
	9164,
	9218,
	9219,
	11329,
	11331,
	11334,
	11336,
	11346,
	11361,
	11363,
	11366,
	11370,
	11372,
	11375,
	11389,
	11682,
	11686,
	11687,
	11692,
	11694,
	11714,
	11716,
	11723,
	11725,
	11730,
	11736,
	11982,
	11989,
	12102,
	12336,
	12348,
	12350,
	12384,
	12393,
	12395,
	12397,
	12510,
	12553,
	12851,
	12962,
	12973,
	13738,
	13823,
	13919,
	13933,
	14080,
	14298,
	14585,
	14698,
	15583,
	15847,
	16318,
	16434,
	16438,
	16481,
	16729,
	17102,
	17122,
	17315,
	17320,
	17402,
	17418,
	17859,
	17909,
	17911,
	17915,
	17916,
	17936,
	17939,
	17961,
	18664,
	18703,
	18814,
	18962,
	19043,
	33469,
	33470,
	33471,
	33484,
	33485,
	33490,
	33497,
	33501,
	33505,
	33513,
	33520,
	33536,
	33550,
	37845,
	37921,
	37948,
	38029,
	38038,
	38064,
	38065,
	38066,
	38069,
	38075,
	38076,
	38078,
	39108,
	39109,
	39113,
	39114,
	39115,
	39116,
	39265,
	39394,
	189000
];
var require$$4$1 = {
	uChars: uChars,
	gbChars: gbChars
};

var require$$5$1 = [
	[
		"0",
		"\u0000",
		127
	],
	[
		"8141",
		"",
		4,
		"",
		6,
		""
	],
	[
		"8161",
		"",
		9,
		"",
		5,
		""
	],
	[
		"8181",
		"",
		18,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		7,
		"",
		7,
		"",
		4,
		"",
		4,
		""
	],
	[
		"8241",
		"",
		7,
		"",
		5
	],
	[
		"8261",
		"",
		6,
		"",
		5,
		""
	],
	[
		"8281",
		"",
		7,
		"",
		7,
		"",
		4,
		"",
		10,
		"",
		5,
		"",
		17,
		"",
		7,
		"",
		6,
		"",
		7,
		"",
		18
	],
	[
		"8341",
		"",
		5,
		"",
		5,
		"",
		7
	],
	[
		"8361",
		"",
		18,
		""
	],
	[
		"8381",
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		5,
		"",
		46,
		"",
		6,
		"",
		5,
		"",
		8
	],
	[
		"8441",
		"",
		5,
		"",
		8
	],
	[
		"8461",
		"",
		18
	],
	[
		"8481",
		"",
		7,
		"",
		6,
		"",
		5,
		"",
		10,
		"",
		5,
		"",
		18,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		26,
		""
	],
	[
		"8541",
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		4
	],
	[
		"8561",
		"",
		5,
		"",
		5,
		"",
		6,
		""
	],
	[
		"8581",
		"",
		6,
		"",
		6,
		"",
		9,
		"",
		26,
		"",
		29,
		"",
		6,
		"",
		5,
		""
	],
	[
		"8641",
		"",
		6,
		"",
		5,
		""
	],
	[
		"8661",
		"",
		6,
		"",
		10
	],
	[
		"8681",
		"",
		22,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		22,
		"",
		4,
		""
	],
	[
		"8741",
		"",
		9,
		"",
		15
	],
	[
		"8761",
		"",
		18,
		""
	],
	[
		"8781",
		"",
		5,
		"",
		7,
		"",
		7,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		18,
		"",
		6,
		"",
		26,
		"",
		6,
		"",
		4
	],
	[
		"8841",
		"",
		4,
		"",
		5,
		"",
		6,
		"",
		4
	],
	[
		"8861",
		"",
		4,
		""
	],
	[
		"8881",
		"",
		15,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		54,
		""
	],
	[
		"8941",
		"",
		6,
		"",
		5,
		""
	],
	[
		"8961",
		"",
		10,
		"",
		5,
		""
	],
	[
		"8981",
		"",
		21,
		"",
		18,
		"",
		18,
		"",
		6,
		"",
		6,
		"",
		7,
		"",
		15
	],
	[
		"8a41",
		"",
		10,
		"",
		6,
		""
	],
	[
		"8a61",
		"",
		4,
		"",
		18,
		""
	],
	[
		"8a81",
		"",
		4,
		"",
		19,
		"",
		5,
		"",
		7,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		5,
		"",
		26,
		""
	],
	[
		"8b41",
		"",
		5,
		"",
		4,
		"",
		6,
		""
	],
	[
		"8b61",
		"",
		6,
		"",
		8
	],
	[
		"8b81",
		"",
		52,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		18,
		"",
		18
	],
	[
		"8c41",
		"",
		15,
		"",
		4
	],
	[
		"8c61",
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5
	],
	[
		"8c81",
		"",
		12,
		"",
		26,
		"",
		50,
		"",
		5,
		"",
		16
	],
	[
		"8d41",
		"",
		16,
		"",
		8
	],
	[
		"8d61",
		"",
		17,
		""
	],
	[
		"8d81",
		"",
		4,
		"",
		33,
		"",
		6,
		"",
		7,
		"",
		6,
		"",
		9,
		"",
		6,
		"",
		5,
		"",
		6,
		""
	],
	[
		"8e41",
		"",
		6,
		"",
		5,
		"",
		8
	],
	[
		"8e61",
		"",
		4,
		"",
		19
	],
	[
		"8e81",
		"",
		13,
		"",
		6,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		11,
		"",
		7,
		"",
		6,
		"",
		5,
		"",
		7
	],
	[
		"8f41",
		"",
		7,
		"",
		17
	],
	[
		"8f61",
		"",
		7,
		"",
		6,
		"",
		4
	],
	[
		"8f81",
		"",
		5,
		"",
		7,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		18,
		"",
		6,
		"",
		26,
		"",
		6,
		"",
		5
	],
	[
		"9041",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9061",
		"",
		5,
		"",
		15
	],
	[
		"9081",
		"",
		12,
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		4,
		"",
		5,
		"",
		11,
		"",
		33,
		""
	],
	[
		"9141",
		"",
		6,
		"",
		5
	],
	[
		"9161",
		"",
		9,
		"",
		5
	],
	[
		"9181",
		"",
		20,
		"",
		4,
		"",
		5,
		"",
		14,
		"",
		33,
		"",
		7,
		"",
		5,
		"",
		6
	],
	[
		"9241",
		"",
		7,
		"",
		4,
		""
	],
	[
		"9261",
		"",
		7,
		"",
		7,
		"",
		4
	],
	[
		"9281",
		"",
		21,
		"",
		18,
		"",
		6,
		"",
		7,
		"",
		6,
		"",
		35,
		""
	],
	[
		"9341",
		"",
		4,
		""
	],
	[
		"9361",
		"",
		6,
		"",
		8
	],
	[
		"9381",
		"",
		37,
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		7,
		"",
		22,
		""
	],
	[
		"9441",
		"",
		5,
		"",
		5,
		"",
		8
	],
	[
		"9461",
		"",
		5,
		"",
		6,
		"",
		12
	],
	[
		"9481",
		"",
		5,
		"",
		6,
		"",
		6,
		"",
		9,
		"",
		22,
		"",
		4,
		"",
		6,
		"",
		10,
		"",
		6,
		"",
		24
	],
	[
		"9541",
		"",
		11,
		"",
		5,
		""
	],
	[
		"9561",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9581",
		"",
		6,
		"",
		35,
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		13,
		"",
		14
	],
	[
		"9641",
		"",
		23,
		""
	],
	[
		"9661",
		"",
		6,
		"",
		5,
		"",
		8
	],
	[
		"9681",
		"",
		10,
		"",
		5,
		"",
		13,
		"",
		33,
		"",
		6,
		"",
		44
	],
	[
		"9741",
		"",
		16,
		"",
		8
	],
	[
		"9761",
		"",
		17,
		"",
		7
	],
	[
		"9781",
		"",
		11,
		"",
		5,
		"",
		6,
		"",
		89,
		""
	],
	[
		"9841",
		"",
		16,
		"",
		5,
		""
	],
	[
		"9861",
		"",
		6,
		"",
		15
	],
	[
		"9881",
		"",
		21,
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		""
	],
	[
		"9941",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9961",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9981",
		"",
		8,
		"",
		5,
		"",
		4,
		"",
		11,
		"",
		5,
		"",
		6,
		"",
		6,
		"",
		6,
		"",
		7,
		"",
		6,
		"",
		5,
		""
	],
	[
		"9a41",
		"",
		16
	],
	[
		"9a61",
		"",
		6,
		"",
		6,
		""
	],
	[
		"9a81",
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		5,
		"",
		33,
		"",
		5,
		"",
		6,
		""
	],
	[
		"9b41",
		"",
		6,
		"",
		8
	],
	[
		"9b61",
		"",
		17,
		"",
		7
	],
	[
		"9b81",
		"",
		25,
		"",
		4,
		"",
		5,
		"",
		50,
		"",
		22,
		""
	],
	[
		"9c41",
		"",
		4,
		"",
		5,
		"",
		5
	],
	[
		"9c61",
		"",
		8,
		"",
		6,
		"",
		9
	],
	[
		"9c81",
		"",
		8,
		"",
		6,
		"",
		6,
		"",
		9,
		"",
		26,
		"",
		6,
		"",
		5,
		"",
		18,
		"",
		6,
		"",
		12
	],
	[
		"9d41",
		"",
		13,
		"",
		8
	],
	[
		"9d61",
		"",
		25
	],
	[
		"9d81",
		"",
		8,
		"",
		5,
		"",
		9,
		"",
		6,
		"",
		10,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		""
	],
	[
		"9e41",
		"",
		7,
		"",
		9,
		""
	],
	[
		"9e61",
		"",
		4,
		"",
		6,
		""
	],
	[
		"9e81",
		"",
		6,
		"",
		6,
		"",
		6,
		"",
		5,
		"",
		10,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		6,
		""
	],
	[
		"9f41",
		"",
		5,
		"",
		4,
		"",
		5,
		""
	],
	[
		"9f61",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9f81",
		"",
		4,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		6,
		"",
		7,
		"",
		4,
		"",
		4,
		""
	],
	[
		"a041",
		"",
		5,
		"",
		6,
		""
	],
	[
		"a061",
		"",
		5,
		"",
		13
	],
	[
		"a081",
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		26,
		"",
		4,
		"",
		5,
		"",
		7,
		""
	],
	[
		"a141",
		"",
		18,
		""
	],
	[
		"a161",
		"",
		6,
		"",
		5,
		""
	],
	[
		"a181",
		"",
		14,
		"",
		5,
		"",
		4,
		"",
		9,
		""
	],
	[
		"a241",
		"",
		5,
		"",
		18
	],
	[
		"a261",
		"",
		6,
		"",
		18
	],
	[
		"a281",
		"",
		7,
		"",
		6,
		"",
		7,
		""
	],
	[
		"a341",
		"",
		6,
		"",
		10,
		""
	],
	[
		"a361",
		"",
		6,
		"",
		16
	],
	[
		"a381",
		"",
		16,
		"",
		4,
		"",
		58,
		"",
		32,
		""
	],
	[
		"a441",
		"",
		5,
		""
	],
	[
		"a461",
		"",
		5,
		"",
		12
	],
	[
		"a481",
		"",
		28,
		"",
		93
	],
	[
		"a541",
		"",
		4,
		"",
		6,
		"",
		5,
		""
	],
	[
		"a561",
		"",
		17,
		"",
		5,
		""
	],
	[
		"a581",
		"",
		16,
		"",
		14,
		"",
		9
	],
	[
		"a5b0",
		"",
		9
	],
	[
		"a5c1",
		"",
		16,
		"",
		6
	],
	[
		"a5e1",
		"",
		16,
		"",
		6
	],
	[
		"a641",
		"",
		19,
		""
	],
	[
		"a661",
		"",
		5,
		"",
		5,
		"",
		6
	],
	[
		"a681",
		"",
		6,
		"",
		18,
		"",
		7
	],
	[
		"a741",
		"",
		4,
		"",
		6,
		"",
		7
	],
	[
		"a761",
		"",
		22,
		""
	],
	[
		"a781",
		"",
		6,
		"",
		5,
		"",
		7,
		"",
		9,
		"",
		9,
		"",
		4,
		"",
		5,
		"",
		4,
		""
	],
	[
		"a841",
		"",
		10,
		"",
		14
	],
	[
		"a861",
		"",
		18,
		"",
		6
	],
	[
		"a881",
		"",
		19,
		"",
		11,
		""
	],
	[
		"a8a6",
		""
	],
	[
		"a8a8",
		""
	],
	[
		"a8b1",
		"",
		27,
		"",
		25,
		"",
		14,
		""
	],
	[
		"a941",
		"",
		14,
		"",
		10
	],
	[
		"a961",
		"",
		18
	],
	[
		"a981",
		"",
		14,
		"",
		6,
		"",
		27,
		"",
		25,
		"",
		14,
		""
	],
	[
		"aa41",
		"",
		6,
		"",
		4,
		""
	],
	[
		"aa61",
		"",
		4,
		"",
		5,
		"",
		6,
		""
	],
	[
		"aa81",
		"",
		29,
		"",
		82
	],
	[
		"ab41",
		"",
		6,
		"",
		5,
		""
	],
	[
		"ab61",
		"",
		6,
		"",
		5,
		"",
		5
	],
	[
		"ab81",
		"",
		8,
		"",
		6,
		"",
		12,
		"",
		85
	],
	[
		"ac41",
		"",
		5,
		"",
		6,
		""
	],
	[
		"ac61",
		"",
		11,
		"",
		4
	],
	[
		"ac81",
		"",
		28,
		"",
		5,
		"",
		25
	],
	[
		"acd1",
		"",
		5,
		"",
		25
	],
	[
		"ad41",
		"",
		6,
		"",
		5,
		"",
		7
	],
	[
		"ad61",
		"",
		6,
		"",
		10,
		""
	],
	[
		"ad81",
		"",
		5,
		"",
		18,
		""
	],
	[
		"ae41",
		"",
		5,
		"",
		16
	],
	[
		"ae61",
		"",
		5,
		"",
		6,
		"",
		4
	],
	[
		"ae81",
		"",
		6,
		"",
		5,
		""
	],
	[
		"af41",
		"",
		19
	],
	[
		"af61",
		"",
		13,
		"",
		5,
		""
	],
	[
		"af81",
		"",
		5,
		"",
		6,
		"",
		5,
		""
	],
	[
		"b041",
		"",
		5,
		"",
		5,
		"",
		12
	],
	[
		"b061",
		"",
		5,
		"",
		19
	],
	[
		"b081",
		"",
		13,
		"",
		6,
		"",
		5,
		"",
		7,
		"",
		4,
		""
	],
	[
		"b141",
		"",
		6,
		"",
		5,
		""
	],
	[
		"b161",
		"",
		6,
		"",
		5,
		"",
		11
	],
	[
		"b181",
		"",
		14,
		"",
		6,
		""
	],
	[
		"b241",
		"",
		6,
		"",
		5,
		""
	],
	[
		"b261",
		"",
		18,
		"",
		5,
		""
	],
	[
		"b281",
		"",
		5,
		"",
		18,
		"",
		6,
		""
	],
	[
		"b341",
		"",
		19,
		""
	],
	[
		"b361",
		"",
		5,
		"",
		5,
		"",
		5
	],
	[
		"b381",
		"",
		5,
		"",
		5,
		"",
		19,
		"",
		4,
		""
	],
	[
		"b441",
		"",
		5,
		"",
		6,
		"",
		5
	],
	[
		"b461",
		"",
		6,
		"",
		10,
		""
	],
	[
		"b481",
		"",
		6,
		"",
		18,
		"",
		4,
		"",
		4,
		""
	],
	[
		"b541",
		"",
		14,
		"",
		5
	],
	[
		"b561",
		"",
		5,
		"",
		5,
		"",
		4
	],
	[
		"b581",
		"",
		6,
		"",
		5,
		"",
		11,
		""
	],
	[
		"b641",
		"",
		7,
		"",
		17
	],
	[
		"b661",
		"",
		15,
		""
	],
	[
		"b681",
		"",
		5,
		"",
		6,
		"",
		5,
		""
	],
	[
		"b741",
		"",
		13,
		"",
		6,
		""
	],
	[
		"b761",
		"",
		20,
		""
	],
	[
		"b781",
		"",
		6,
		"",
		14,
		""
	],
	[
		"b841",
		"",
		7,
		"",
		17
	],
	[
		"b861",
		"",
		8,
		"",
		13
	],
	[
		"b881",
		"",
		5,
		"",
		24,
		"",
		4,
		""
	],
	[
		"b941",
		"",
		6,
		"",
		5,
		""
	],
	[
		"b961",
		"",
		14,
		"",
		6,
		""
	],
	[
		"b981",
		"",
		22,
		"",
		4,
		"",
		4,
		""
	],
	[
		"ba41",
		"",
		5,
		"",
		6,
		""
	],
	[
		"ba61",
		"",
		5,
		"",
		4,
		"",
		5
	],
	[
		"ba81",
		"",
		6,
		"",
		9,
		""
	],
	[
		"bb41",
		"",
		4,
		"",
		5,
		"",
		4,
		""
	],
	[
		"bb61",
		"",
		6,
		"",
		5,
		""
	],
	[
		"bb81",
		"",
		31,
		""
	],
	[
		"bc41",
		"",
		17,
		""
	],
	[
		"bc61",
		"",
		5,
		"",
		6,
		""
	],
	[
		"bc81",
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		5,
		"",
		4,
		""
	],
	[
		"bd41",
		"",
		7,
		"",
		7,
		""
	],
	[
		"bd61",
		"",
		5,
		"",
		13
	],
	[
		"bd81",
		"",
		5,
		"",
		25,
		""
	],
	[
		"be41",
		"",
		7,
		"",
		14
	],
	[
		"be61",
		"",
		7,
		"",
		7,
		""
	],
	[
		"be81",
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		8,
		"",
		6,
		""
	],
	[
		"bf41",
		"",
		10,
		"",
		14
	],
	[
		"bf61",
		"",
		18,
		""
	],
	[
		"bf81",
		"",
		5,
		"",
		7,
		"",
		6,
		"",
		5,
		""
	],
	[
		"c041",
		"",
		5,
		"",
		6,
		"",
		5
	],
	[
		"c061",
		"",
		25
	],
	[
		"c081",
		"",
		6,
		"",
		5,
		"",
		7,
		""
	],
	[
		"c141",
		"",
		5,
		"",
		6,
		""
	],
	[
		"c161",
		"",
		19,
		""
	],
	[
		"c181",
		"",
		31,
		""
	],
	[
		"c241",
		"",
		4,
		"",
		5,
		""
	],
	[
		"c261",
		"",
		4,
		"",
		5,
		"",
		6,
		""
	],
	[
		"c281",
		"",
		5,
		"",
		7,
		"",
		9,
		""
	],
	[
		"c341",
		"",
		4
	],
	[
		"c361",
		"",
		4,
		"",
		5,
		"",
		11
	],
	[
		"c381",
		"",
		5,
		"",
		7,
		"",
		5,
		""
	],
	[
		"c441",
		"",
		7,
		"",
		7,
		""
	],
	[
		"c461",
		"",
		5,
		"",
		4
	],
	[
		"c481",
		"",
		5,
		"",
		11,
		""
	],
	[
		"c541",
		"",
		6,
		"",
		5,
		""
	],
	[
		"c561",
		"",
		6,
		"",
		5,
		"",
		4
	],
	[
		"c581",
		"",
		6,
		"",
		5,
		""
	],
	[
		"c641",
		"",
		6,
		"",
		5
	],
	[
		"c6a1",
		""
	],
	[
		"c7a1",
		""
	],
	[
		"c8a1",
		""
	],
	[
		"caa1",
		""
	],
	[
		"cba1",
		""
	],
	[
		"cca1",
		""
	],
	[
		"cda1",
		""
	],
	[
		"cea1",
		""
	],
	[
		"cfa1",
		""
	],
	[
		"d0a1",
		""
	],
	[
		"d1a1",
		"",
		5,
		"",
		4,
		""
	],
	[
		"d2a1",
		"",
		4,
		"",
		5,
		"",
		10,
		"",
		7,
		"",
		5,
		""
	],
	[
		"d3a1",
		""
	],
	[
		"d4a1",
		""
	],
	[
		"d5a1",
		""
	],
	[
		"d6a1",
		""
	],
	[
		"d7a1",
		""
	],
	[
		"d8a1",
		""
	],
	[
		"d9a1",
		""
	],
	[
		"daa1",
		""
	],
	[
		"dba1",
		""
	],
	[
		"dca1",
		""
	],
	[
		"dda1",
		""
	],
	[
		"dea1",
		""
	],
	[
		"dfa1",
		""
	],
	[
		"e0a1",
		""
	],
	[
		"e1a1",
		""
	],
	[
		"e2a1",
		""
	],
	[
		"e3a1",
		""
	],
	[
		"e4a1",
		""
	],
	[
		"e5a1",
		""
	],
	[
		"e6a1",
		""
	],
	[
		"e7a1",
		""
	],
	[
		"e8a1",
		""
	],
	[
		"e9a1",
		""
	],
	[
		"eaa1",
		""
	],
	[
		"eba1",
		""
	],
	[
		"eca1",
		""
	],
	[
		"eda1",
		""
	],
	[
		"eea1",
		""
	],
	[
		"efa1",
		""
	],
	[
		"f0a1",
		""
	],
	[
		"f1a1",
		""
	],
	[
		"f2a1",
		""
	],
	[
		"f3a1",
		""
	],
	[
		"f4a1",
		""
	],
	[
		"f5a1",
		""
	],
	[
		"f6a1",
		""
	],
	[
		"f7a1",
		""
	],
	[
		"f8a1",
		""
	],
	[
		"f9a1",
		""
	],
	[
		"faa1",
		""
	],
	[
		"fba1",
		""
	],
	[
		"fca1",
		""
	],
	[
		"fda1",
		""
	]
];

var require$$6$2 = [
	[
		"0",
		"\u0000",
		127
	],
	[
		"a140",
		""
	],
	[
		"a1a1",
		"",
		4,
		""
	],
	[
		"a240",
		"",
		7,
		""
	],
	[
		"a2a1",
		"",
		9,
		"",
		9,
		"",
		8,
		"",
		25,
		"",
		21
	],
	[
		"a340",
		"",
		16,
		"",
		6,
		"",
		16,
		"",
		6,
		"",
		10
	],
	[
		"a3a1",
		"",
		25,
		""
	],
	[
		"a3e1",
		""
	],
	[
		"a440",
		""
	],
	[
		"a4a1",
		""
	],
	[
		"a540",
		""
	],
	[
		"a5a1",
		""
	],
	[
		"a640",
		""
	],
	[
		"a6a1",
		""
	],
	[
		"a740",
		""
	],
	[
		"a7a1",
		""
	],
	[
		"a840",
		""
	],
	[
		"a8a1",
		""
	],
	[
		"a940",
		""
	],
	[
		"a9a1",
		""
	],
	[
		"aa40",
		""
	],
	[
		"aaa1",
		""
	],
	[
		"ab40",
		""
	],
	[
		"aba1",
		""
	],
	[
		"ac40",
		""
	],
	[
		"aca1",
		""
	],
	[
		"ad40",
		""
	],
	[
		"ada1",
		""
	],
	[
		"ae40",
		""
	],
	[
		"aea1",
		""
	],
	[
		"af40",
		""
	],
	[
		"afa1",
		""
	],
	[
		"b040",
		""
	],
	[
		"b0a1",
		""
	],
	[
		"b140",
		""
	],
	[
		"b1a1",
		""
	],
	[
		"b240",
		""
	],
	[
		"b2a1",
		""
	],
	[
		"b340",
		""
	],
	[
		"b3a1",
		""
	],
	[
		"b440",
		""
	],
	[
		"b4a1",
		""
	],
	[
		"b540",
		""
	],
	[
		"b5a1",
		""
	],
	[
		"b640",
		""
	],
	[
		"b6a1",
		""
	],
	[
		"b740",
		""
	],
	[
		"b7a1",
		""
	],
	[
		"b840",
		""
	],
	[
		"b8a1",
		""
	],
	[
		"b940",
		""
	],
	[
		"b9a1",
		""
	],
	[
		"ba40",
		""
	],
	[
		"baa1",
		""
	],
	[
		"bb40",
		""
	],
	[
		"bba1",
		""
	],
	[
		"bc40",
		""
	],
	[
		"bca1",
		""
	],
	[
		"bd40",
		""
	],
	[
		"bda1",
		""
	],
	[
		"be40",
		""
	],
	[
		"bea1",
		""
	],
	[
		"bf40",
		""
	],
	[
		"bfa1",
		""
	],
	[
		"c040",
		""
	],
	[
		"c0a1",
		""
	],
	[
		"c140",
		""
	],
	[
		"c1a1",
		""
	],
	[
		"c240",
		""
	],
	[
		"c2a1",
		""
	],
	[
		"c340",
		""
	],
	[
		"c3a1",
		""
	],
	[
		"c440",
		""
	],
	[
		"c4a1",
		""
	],
	[
		"c540",
		""
	],
	[
		"c5a1",
		""
	],
	[
		"c640",
		""
	],
	[
		"c940",
		""
	],
	[
		"c9a1",
		""
	],
	[
		"ca40",
		""
	],
	[
		"caa1",
		""
	],
	[
		"cb40",
		""
	],
	[
		"cba1",
		""
	],
	[
		"cc40",
		""
	],
	[
		"cca1",
		""
	],
	[
		"cd40",
		""
	],
	[
		"cda1",
		""
	],
	[
		"ce40",
		""
	],
	[
		"cea1",
		""
	],
	[
		"cf40",
		""
	],
	[
		"cfa1",
		""
	],
	[
		"d040",
		""
	],
	[
		"d0a1",
		""
	],
	[
		"d140",
		""
	],
	[
		"d1a1",
		""
	],
	[
		"d240",
		""
	],
	[
		"d2a1",
		""
	],
	[
		"d340",
		""
	],
	[
		"d3a1",
		""
	],
	[
		"d440",
		""
	],
	[
		"d4a1",
		""
	],
	[
		"d540",
		""
	],
	[
		"d5a1",
		""
	],
	[
		"d640",
		""
	],
	[
		"d6a1",
		""
	],
	[
		"d740",
		""
	],
	[
		"d7a1",
		""
	],
	[
		"d840",
		""
	],
	[
		"d8a1",
		""
	],
	[
		"d940",
		""
	],
	[
		"d9a1",
		""
	],
	[
		"da40",
		""
	],
	[
		"daa1",
		""
	],
	[
		"db40",
		""
	],
	[
		"dba1",
		""
	],
	[
		"dc40",
		""
	],
	[
		"dca1",
		""
	],
	[
		"dd40",
		""
	],
	[
		"dda1",
		""
	],
	[
		"de40",
		""
	],
	[
		"dea1",
		""
	],
	[
		"df40",
		""
	],
	[
		"dfa1",
		""
	],
	[
		"e040",
		""
	],
	[
		"e0a1",
		""
	],
	[
		"e140",
		""
	],
	[
		"e1a1",
		""
	],
	[
		"e240",
		""
	],
	[
		"e2a1",
		""
	],
	[
		"e340",
		""
	],
	[
		"e3a1",
		""
	],
	[
		"e440",
		""
	],
	[
		"e4a1",
		""
	],
	[
		"e540",
		""
	],
	[
		"e5a1",
		""
	],
	[
		"e640",
		""
	],
	[
		"e6a1",
		""
	],
	[
		"e740",
		""
	],
	[
		"e7a1",
		""
	],
	[
		"e840",
		""
	],
	[
		"e8a1",
		""
	],
	[
		"e940",
		""
	],
	[
		"e9a1",
		""
	],
	[
		"ea40",
		""
	],
	[
		"eaa1",
		""
	],
	[
		"eb40",
		""
	],
	[
		"eba1",
		""
	],
	[
		"ec40",
		""
	],
	[
		"eca1",
		""
	],
	[
		"ed40",
		""
	],
	[
		"eda1",
		""
	],
	[
		"ee40",
		""
	],
	[
		"eea1",
		""
	],
	[
		"ef40",
		""
	],
	[
		"efa1",
		""
	],
	[
		"f040",
		""
	],
	[
		"f0a1",
		""
	],
	[
		"f140",
		""
	],
	[
		"f1a1",
		""
	],
	[
		"f240",
		""
	],
	[
		"f2a1",
		""
	],
	[
		"f340",
		""
	],
	[
		"f3a1",
		""
	],
	[
		"f440",
		""
	],
	[
		"f4a1",
		""
	],
	[
		"f540",
		""
	],
	[
		"f5a1",
		""
	],
	[
		"f640",
		""
	],
	[
		"f6a1",
		""
	],
	[
		"f740",
		""
	],
	[
		"f7a1",
		""
	],
	[
		"f840",
		""
	],
	[
		"f8a1",
		""
	],
	[
		"f940",
		""
	],
	[
		"f9a1",
		""
	]
];

var require$$7$2 = [
	[
		"8740",
		""
	],
	[
		"8767",
		""
	],
	[
		"87a1",
		""
	],
	[
		"8840",
		"",
		4,
		""
	],
	[
		"88a1",
		""
	],
	[
		"8940",
		""
	],
	[
		"8943",
		""
	],
	[
		"8946",
		""
	],
	[
		"894c",
		""
	],
	[
		"89a1",
		""
	],
	[
		"89ab",
		""
	],
	[
		"89b0",
		""
	],
	[
		"89b5",
		""
	],
	[
		"89c1",
		""
	],
	[
		"89c5",
		""
	],
	[
		"8a40",
		""
	],
	[
		"8a43",
		""
	],
	[
		"8a64",
		""
	],
	[
		"8a76",
		""
	],
	[
		"8aa1",
		""
	],
	[
		"8aac",
		""
	],
	[
		"8ab2",
		""
	],
	[
		"8abb",
		""
	],
	[
		"8ac9",
		""
	],
	[
		"8ace",
		""
	],
	[
		"8adf",
		""
	],
	[
		"8af6",
		""
	],
	[
		"8b40",
		""
	],
	[
		"8b55",
		""
	],
	[
		"8ba1",
		""
	],
	[
		"8bde",
		""
	],
	[
		"8c40",
		""
	],
	[
		"8ca1",
		""
	],
	[
		"8ca7",
		""
	],
	[
		"8cc9",
		""
	],
	[
		"8cce",
		""
	],
	[
		"8ce6",
		""
	],
	[
		"8d40",
		""
	],
	[
		"8d42",
		""
	],
	[
		"8da1",
		""
	],
	[
		"8e40",
		""
	],
	[
		"8ea1",
		""
	],
	[
		"8f40",
		""
	],
	[
		"8fa1",
		""
	],
	[
		"9040",
		""
	],
	[
		"90a1",
		""
	],
	[
		"9140",
		""
	],
	[
		"91a1",
		""
	],
	[
		"9240",
		""
	],
	[
		"92a1",
		""
	],
	[
		"9340",
		""
	],
	[
		"93a1",
		""
	],
	[
		"9440",
		""
	],
	[
		"94a1",
		""
	],
	[
		"9540",
		""
	],
	[
		"95a1",
		""
	],
	[
		"9640",
		""
	],
	[
		"96a1",
		""
	],
	[
		"9740",
		""
	],
	[
		"97a1",
		""
	],
	[
		"9840",
		""
	],
	[
		"98a1",
		""
	],
	[
		"9940",
		""
	],
	[
		"99a1",
		""
	],
	[
		"9a40",
		""
	],
	[
		"9aa1",
		""
	],
	[
		"9b40",
		""
	],
	[
		"9b62",
		""
	],
	[
		"9ba1",
		""
	],
	[
		"9c40",
		""
	],
	[
		"9ca1",
		""
	],
	[
		"9d40",
		""
	],
	[
		"9da1",
		""
	],
	[
		"9e40",
		""
	],
	[
		"9ea1",
		""
	],
	[
		"9ead",
		""
	],
	[
		"9ec5",
		""
	],
	[
		"9ef5",
		""
	],
	[
		"9f40",
		""
	],
	[
		"9f4f",
		""
	],
	[
		"9fa1",
		""
	],
	[
		"9fae",
		""
	],
	[
		"9fb2",
		""
	],
	[
		"9fc1",
		""
	],
	[
		"9fc9",
		""
	],
	[
		"9fdb",
		""
	],
	[
		"9fe7",
		""
	],
	[
		"9feb",
		""
	],
	[
		"9ff0",
		""
	],
	[
		"a040",
		""
	],
	[
		"a055",
		""
	],
	[
		"a058",
		""
	],
	[
		"a05b",
		""
	],
	[
		"a063",
		""
	],
	[
		"a073",
		""
	],
	[
		"a0a1",
		""
	],
	[
		"a0a6",
		""
	],
	[
		"a0ae",
		""
	],
	[
		"a0b0",
		""
	],
	[
		"a0d4",
		""
	],
	[
		"a0e2",
		""
	],
	[
		"a3c0",
		"",
		31,
		""
	],
	[
		"c6a1",
		"",
		9,
		"",
		9,
		"",
		9,
		"",
		23
	],
	[
		"c740",
		"",
		58,
		""
	],
	[
		"c7a1",
		"",
		81,
		"",
		5,
		"",
		4
	],
	[
		"c840",
		"",
		26,
		"",
		25,
		""
	],
	[
		"c8a1",
		""
	],
	[
		"c8cd",
		""
	],
	[
		"c8f5",
		""
	],
	[
		"f9fe",
		""
	],
	[
		"fa40",
		""
	],
	[
		"faa1",
		""
	],
	[
		"fb40",
		""
	],
	[
		"fba1",
		""
	],
	[
		"fc40",
		""
	],
	[
		"fca1",
		""
	],
	[
		"fd40",
		""
	],
	[
		"fda1",
		""
	],
	[
		"fe40",
		""
	],
	[
		"fea1",
		""
	]
];

// Description of supported double byte encodings and aliases.
// Tables are not require()-d until they are needed to speed up library load.
// require()-s are direct to support Browserify.

var dbcsData = {
    
    // == Japanese/ShiftJIS ====================================================
    // All japanese encodings are based on JIS X set of standards:
    // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
    //              Has several variations in 1978, 1983, 1990 and 1997.
    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
    //              2 planes, first is superset of 0208, second - revised 0212.
    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)

    // Byte encodings are:
    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
    //               0x00-0x7F       - lower part of 0201
    //               0x8E, 0xA1-0xDF - upper part of 0201
    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
    //               Used as-is in ISO2022 family.
    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
    //                0201-1976 Roman, 0208-1978, 0208-1983.
    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
    //
    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
    //
    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html

    'shiftjis': {
        type: '_dbcs',
        table: function() { return require$$0$2 },
        encodeAdd: {'\u00a5': 0x5C, '\u203E': 0x7E},
        encodeSkipVals: [{from: 0xED40, to: 0xF940}],
    },
    'csshiftjis': 'shiftjis',
    'mskanji': 'shiftjis',
    'sjis': 'shiftjis',
    'windows31j': 'shiftjis',
    'ms31j': 'shiftjis',
    'xsjis': 'shiftjis',
    'windows932': 'shiftjis',
    'ms932': 'shiftjis',
    '932': 'shiftjis',
    'cp932': 'shiftjis',

    'eucjp': {
        type: '_dbcs',
        table: function() { return require$$1$2 },
        encodeAdd: {'\u00a5': 0x5C, '\u203E': 0x7E},
    },

    // TODO: KDDI extension to Shift_JIS
    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.


    // == Chinese/GBK ==========================================================
    // http://en.wikipedia.org/wiki/GBK
    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder

    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
    'gb2312': 'cp936',
    'gb231280': 'cp936',
    'gb23121980': 'cp936',
    'csgb2312': 'cp936',
    'csiso58gb231280': 'cp936',
    'euccn': 'cp936',

    // Microsoft's CP936 is a subset and approximation of GBK.
    'windows936': 'cp936',
    'ms936': 'cp936',
    '936': 'cp936',
    'cp936': {
        type: '_dbcs',
        table: function() { return require$$2$1 },
    },

    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
    'gbk': {
        type: '_dbcs',
        table: function() { return require$$2$1.concat(require$$3$1) },
    },
    'xgbk': 'gbk',
    'isoir58': 'gbk',

    // GB18030 is an algorithmic extension of GBK.
    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
    // http://icu-project.org/docs/papers/gb18030.html
    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    'gb18030': {
        type: '_dbcs',
        table: function() { return require$$2$1.concat(require$$3$1) },
        gb18030: function() { return require$$4$1 },
        encodeSkipVals: [0x80],
        encodeAdd: {'': 0xA2E3},
    },

    'chinese': 'gb18030',


    // == Korean ===============================================================
    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
    'windows949': 'cp949',
    'ms949': 'cp949',
    '949': 'cp949',
    'cp949': {
        type: '_dbcs',
        table: function() { return require$$5$1 },
    },

    'cseuckr': 'cp949',
    'csksc56011987': 'cp949',
    'euckr': 'cp949',
    'isoir149': 'cp949',
    'korean': 'cp949',
    'ksc56011987': 'cp949',
    'ksc56011989': 'cp949',
    'ksc5601': 'cp949',


    // == Big5/Taiwan/Hong Kong ================================================
    // There are lots of tables for Big5 and cp950. Please see the following links for history:
    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
    // Variations, in roughly number of defined chars:
    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
    //    Plus, it has 4 combining sequences.
    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
    // 
    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.

    'windows950': 'cp950',
    'ms950': 'cp950',
    '950': 'cp950',
    'cp950': {
        type: '_dbcs',
        table: function() { return require$$6$2 },
    },

    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
    'big5': 'big5hkscs',
    'big5hkscs': {
        type: '_dbcs',
        table: function() { return require$$6$2.concat(require$$7$2) },
        encodeSkipVals: [0xa2cc],
    },

    'cnbig5': 'big5hkscs',
    'csbig5': 'big5hkscs',
    'xxbig5': 'big5hkscs',
};

(function (exports) {

// Update this array if you add/rename/remove files in this directory.
// We support Browserify by skipping automatic module discovery and requiring modules directly.
var modules = [
    internal,
    utf32,
    utf16,
    utf7,
    sbcsCodec,
    sbcsData,
    sbcsDataGenerated,
    dbcsCodec,
    dbcsData,
];

// Put all encoding/alias/codec definitions to single object and export it.
for (var i = 0; i < modules.length; i++) {
    var module = modules[i];
    for (var enc in module)
        if (Object.prototype.hasOwnProperty.call(module, enc))
            exports[enc] = module[enc];
}
}(encodings));

var Buffer$4 = safer_1.Buffer;

// NOTE: Due to 'stream' module being pretty large (~100Kb, significant in browser environments), 
// we opt to dependency-inject it instead of creating a hard dependency.
var streams = function(stream_module) {
    var Transform = stream_module.Transform;

    // == Encoder stream =======================================================

    function IconvLiteEncoderStream(conv, options) {
        this.conv = conv;
        options = options || {};
        options.decodeStrings = false; // We accept only strings, so we don't need to decode them.
        Transform.call(this, options);
    }

    IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
        constructor: { value: IconvLiteEncoderStream }
    });

    IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
        if (typeof chunk != 'string')
            return done(new Error("Iconv encoding stream needs strings as its input."));
        try {
            var res = this.conv.write(chunk);
            if (res && res.length) this.push(res);
            done();
        }
        catch (e) {
            done(e);
        }
    };

    IconvLiteEncoderStream.prototype._flush = function(done) {
        try {
            var res = this.conv.end();
            if (res && res.length) this.push(res);
            done();
        }
        catch (e) {
            done(e);
        }
    };

    IconvLiteEncoderStream.prototype.collect = function(cb) {
        var chunks = [];
        this.on('error', cb);
        this.on('data', function(chunk) { chunks.push(chunk); });
        this.on('end', function() {
            cb(null, Buffer$4.concat(chunks));
        });
        return this;
    };


    // == Decoder stream =======================================================

    function IconvLiteDecoderStream(conv, options) {
        this.conv = conv;
        options = options || {};
        options.encoding = this.encoding = 'utf8'; // We output strings.
        Transform.call(this, options);
    }

    IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
        constructor: { value: IconvLiteDecoderStream }
    });

    IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
        if (!Buffer$4.isBuffer(chunk) && !(chunk instanceof Uint8Array))
            return done(new Error("Iconv decoding stream needs buffers as its input."));
        try {
            var res = this.conv.write(chunk);
            if (res && res.length) this.push(res, this.encoding);
            done();
        }
        catch (e) {
            done(e);
        }
    };

    IconvLiteDecoderStream.prototype._flush = function(done) {
        try {
            var res = this.conv.end();
            if (res && res.length) this.push(res, this.encoding);                
            done();
        }
        catch (e) {
            done(e);
        }
    };

    IconvLiteDecoderStream.prototype.collect = function(cb) {
        var res = '';
        this.on('error', cb);
        this.on('data', function(chunk) { res += chunk; });
        this.on('end', function() {
            cb(null, res);
        });
        return this;
    };

    return {
        IconvLiteEncoderStream: IconvLiteEncoderStream,
        IconvLiteDecoderStream: IconvLiteDecoderStream,
    };
};

(function (module) {

var Buffer = safer_1.Buffer;

var bomHandling$1 = bomHandling,
    iconv = module.exports;

// All codecs and aliases are kept here, keyed by encoding name/alias.
// They are lazy loaded in `iconv.getCodec` from `encodings/index.js`.
iconv.encodings = null;

// Characters emitted in case of error.
iconv.defaultCharUnicode = '';
iconv.defaultCharSingleByte = '?';

// Public API.
iconv.encode = function encode(str, encoding, options) {
    str = "" + (str || ""); // Ensure string.

    var encoder = iconv.getEncoder(encoding, options);

    var res = encoder.write(str);
    var trail = encoder.end();
    
    return (trail && trail.length > 0) ? Buffer.concat([res, trail]) : res;
};

iconv.decode = function decode(buf, encoding, options) {
    if (typeof buf === 'string') {
        if (!iconv.skipDecodeWarning) {
            console.error('Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding');
            iconv.skipDecodeWarning = true;
        }

        buf = Buffer.from("" + (buf || ""), "binary"); // Ensure buffer.
    }

    var decoder = iconv.getDecoder(encoding, options);

    var res = decoder.write(buf);
    var trail = decoder.end();

    return trail ? (res + trail) : res;
};

iconv.encodingExists = function encodingExists(enc) {
    try {
        iconv.getCodec(enc);
        return true;
    } catch (e) {
        return false;
    }
};

// Legacy aliases to convert functions
iconv.toEncoding = iconv.encode;
iconv.fromEncoding = iconv.decode;

// Search for a codec in iconv.encodings. Cache codec data in iconv._codecDataCache.
iconv._codecDataCache = {};
iconv.getCodec = function getCodec(encoding) {
    if (!iconv.encodings)
        iconv.encodings = encodings; // Lazy load all encoding definitions.
    
    // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
    var enc = iconv._canonicalizeEncoding(encoding);

    // Traverse iconv.encodings to find actual codec.
    var codecOptions = {};
    while (true) {
        var codec = iconv._codecDataCache[enc];
        if (codec)
            return codec;

        var codecDef = iconv.encodings[enc];

        switch (typeof codecDef) {
            case "string": // Direct alias to other encoding.
                enc = codecDef;
                break;

            case "object": // Alias with options. Can be layered.
                for (var key in codecDef)
                    codecOptions[key] = codecDef[key];

                if (!codecOptions.encodingName)
                    codecOptions.encodingName = enc;
                
                enc = codecDef.type;
                break;

            case "function": // Codec itself.
                if (!codecOptions.encodingName)
                    codecOptions.encodingName = enc;

                // The codec function must load all tables and return object with .encoder and .decoder methods.
                // It'll be called only once (for each different options object).
                codec = new codecDef(codecOptions, iconv);

                iconv._codecDataCache[codecOptions.encodingName] = codec; // Save it to be reused later.
                return codec;

            default:
                throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '"+enc+"')");
        }
    }
};

iconv._canonicalizeEncoding = function(encoding) {
    // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
    return (''+encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
};

iconv.getEncoder = function getEncoder(encoding, options) {
    var codec = iconv.getCodec(encoding),
        encoder = new codec.encoder(options, codec);

    if (codec.bomAware && options && options.addBOM)
        encoder = new bomHandling$1.PrependBOM(encoder, options);

    return encoder;
};

iconv.getDecoder = function getDecoder(encoding, options) {
    var codec = iconv.getCodec(encoding),
        decoder = new codec.decoder(options, codec);

    if (codec.bomAware && !(options && options.stripBOM === false))
        decoder = new bomHandling$1.StripBOM(decoder, options);

    return decoder;
};

// Streaming API
// NOTE: Streaming API naturally depends on 'stream' module from Node.js. Unfortunately in browser environments this module can add
// up to 100Kb to the output bundle. To avoid unnecessary code bloat, we don't enable Streaming API in browser by default.
// If you would like to enable it explicitly, please add the following code to your app:
// > iconv.enableStreamingAPI(require('stream'));
iconv.enableStreamingAPI = function enableStreamingAPI(stream_module) {
    if (iconv.supportsStreams)
        return;

    // Dependency-inject stream module to create IconvLite stream classes.
    var streams$1 = streams(stream_module);

    // Not public API yet, but expose the stream classes.
    iconv.IconvLiteEncoderStream = streams$1.IconvLiteEncoderStream;
    iconv.IconvLiteDecoderStream = streams$1.IconvLiteDecoderStream;

    // Streaming API.
    iconv.encodeStream = function encodeStream(encoding, options) {
        return new iconv.IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
    };

    iconv.decodeStream = function decodeStream(encoding, options) {
        return new iconv.IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
    };

    iconv.supportsStreams = true;
};

// Enable Streaming API automatically if 'stream' module is available and non-empty (the majority of environments).
var stream_module;
try {
    stream_module = require("stream");
} catch (e) {}

if (stream_module && stream_module.Transform) {
    iconv.enableStreamingAPI(stream_module);

} else {
    // In rare cases where 'stream' module is not available by default, throw a helpful exception.
    iconv.encodeStream = iconv.decodeStream = function() {
        throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
    };
}
}(lib));

var iconvLite = lib.exports;

// Expose to the world
var convert_1 = convert;

/**
 * Convert encoding of an UTF-8 string or a buffer
 *
 * @param {String|Buffer} str String to be converted
 * @param {String} to Encoding to be converted to
 * @param {String} [from='UTF-8'] Encoding to be converted from
 * @return {Buffer} Encoded string
 */
function convert(str, to, from) {
    from = checkEncoding(from || 'UTF-8');
    to = checkEncoding(to || 'UTF-8');
    str = str || '';

    var result;

    if (from !== 'UTF-8' && typeof str === 'string') {
        str = Buffer.from(str, 'binary');
    }

    if (from === to) {
        if (typeof str === 'string') {
            result = Buffer.from(str);
        } else {
            result = str;
        }
    } else {
        try {
            result = convertIconvLite(str, to, from);
        } catch (E) {
            console.error(E);
            result = str;
        }
    }

    if (typeof result === 'string') {
        result = Buffer.from(result, 'utf-8');
    }

    return result;
}

/**
 * Convert encoding of astring with iconv-lite
 *
 * @param {String|Buffer} str String to be converted
 * @param {String} to Encoding to be converted to
 * @param {String} [from='UTF-8'] Encoding to be converted from
 * @return {Buffer} Encoded string
 */
function convertIconvLite(str, to, from) {
    if (to === 'UTF-8') {
        return iconvLite.decode(str, from);
    } else if (from === 'UTF-8') {
        return iconvLite.encode(str, to);
    } else {
        return iconvLite.encode(iconvLite.decode(str, from), to);
    }
}

/**
 * Converts charset name if needed
 *
 * @param {String} name Character set
 * @return {String} Character set name
 */
function checkEncoding(name) {
    return (name || '')
        .toString()
        .trim()
        .replace(/^latin[\-_]?(\d+)$/i, 'ISO-8859-$1')
        .replace(/^win(?:dows)?[\-_]?(\d+)$/i, 'WINDOWS-$1')
        .replace(/^utf[\-_]?(\d+)$/i, 'UTF-$1')
        .replace(/^ks_c_5601\-1987$/i, 'CP949')
        .replace(/^us[\-_]?ascii$/i, 'ASCII')
        .toUpperCase();
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js
// (MIT licensed)
const BUFFER$2 = Symbol('buffer');
const TYPE = Symbol('type');
const CLOSED$2 = Symbol('closed');
class Blob$1 {
  constructor() {
    Object.defineProperty(this, Symbol.toStringTag, {
      value: 'Blob',
      writable: false,
      enumerable: false,
      configurable: true
    });
    this[CLOSED$2] = false;
    this[TYPE] = '';
    const blobParts = arguments[0];
    const options = arguments[1];
    const buffers = [];

    if (blobParts) {
      const a = blobParts;
      const length = Number(a.length);

      for (let i = 0; i < length; i++) {
        const element = a[i];
        let buffer;

        if (element instanceof Buffer) {
          buffer = element;
        } else if (ArrayBuffer.isView(element)) {
          buffer = Buffer.from(new Uint8Array(element.buffer, element.byteOffset, element.byteLength));
        } else if (element instanceof ArrayBuffer) {
          buffer = Buffer.from(new Uint8Array(element));
        } else if (element instanceof Blob$1) {
          buffer = element[BUFFER$2];
        } else {
          buffer = Buffer.from(typeof element === 'string' ? element : String(element));
        }

        buffers.push(buffer);
      }
    }

    this[BUFFER$2] = Buffer.concat(buffers);
    const type = options && options.type !== undefined && String(options.type).toLowerCase();

    if (type && !/[^\u0020-\u007E]/.test(type)) {
      this[TYPE] = type;
    }
  }

  get size() {
    return this[CLOSED$2] ? 0 : this[BUFFER$2].length;
  }

  get type() {
    return this[TYPE];
  }

  get isClosed() {
    return this[CLOSED$2];
  }

  slice() {
    const size = this.size;
    const start = arguments[0];
    const end = arguments[1];
    let relativeStart, relativeEnd;

    if (start === undefined) {
      relativeStart = 0;
    } else if (start < 0) {
      relativeStart = Math.max(size + start, 0);
    } else {
      relativeStart = Math.min(start, size);
    }

    if (end === undefined) {
      relativeEnd = size;
    } else if (end < 0) {
      relativeEnd = Math.max(size + end, 0);
    } else {
      relativeEnd = Math.min(end, size);
    }

    const span = Math.max(relativeEnd - relativeStart, 0);
    const buffer = this[BUFFER$2];
    const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
    const blob = new Blob$1([], {
      type: arguments[2]
    });
    blob[BUFFER$2] = slicedBuffer;
    blob[CLOSED$2] = this[CLOSED$2];
    return blob;
  }

  close() {
    this[CLOSED$2] = true;
  }

}
Object.defineProperty(Blob$1.prototype, Symbol.toStringTag, {
  value: 'BlobPrototype',
  writable: false,
  enumerable: false,
  configurable: true
});

/**
 * fetch-error.js
 *
 * FetchError interface for operational errors
 */

/**
 * Create FetchError instance
 *
 * @param {string} message Error message for human
 * @param {string} type Error type for machine
 * @param {string} systemError For Node.js system error
 * @return {FetchError}
 */
const netErrorMap = {
  ERR_CONNECTION_REFUSED: 'ECONNREFUSED',
  ERR_EMPTY_RESPONSE: 'ECONNRESET',
  ERR_NAME_NOT_RESOLVED: 'ENOTFOUND',
  ERR_CONTENT_DECODING_FAILED: 'Z_DATA_ERROR',
  ERR_CONTENT_DECODING_INIT_FAILED: 'Z_DATA_ERROR'
};
function FetchError(message, type, systemError) {
  Error.call(this, message);
  const regex = /^.*net::(.*)/;

  if (regex.test(message)) {
    let errorCode = regex.exec(message)[1]; // istanbul ignore else

    if (Object.prototype.hasOwnProperty.call(netErrorMap, errorCode)) errorCode = netErrorMap[errorCode];
    systemError = {
      code: errorCode
    };
  }

  this.message = message;
  this.type = type; // when err.type is `system`, err.code contains system error code

  if (systemError) {
    this.code = this.errno = systemError.code;
  } // hide custom error implementation details from end-users


  Error.captureStackTrace(this, this.constructor);
}
FetchError.prototype = Object.create(Error.prototype);
FetchError.prototype.constructor = FetchError;
FetchError.prototype.name = 'FetchError';

const DISTURBED = Symbol('disturbed');
/**
 * Body class
 *
 * Cannot use ES6 class because Body must be called with .call().
 *
 * @param {Stream|string|Blob|Buffer|null} body Readable stream
 * @param {number} size
 * @param {number} timeout
 */

function Body(body, {
  size = 0,
  timeout = 0
} = {}) {
  if (body == null) {
    // body is undefined or null
    body = null;
  } else if (typeof body === 'string') ; else if (body instanceof Blob$1) ; else if (Buffer.isBuffer(body)) ; else if (body instanceof Stream__default["default"]) ; else {
    // none of the above
    // coerce to string
    body = String(body);
  }

  this.body = body;
  this[DISTURBED] = false;
  this.size = size;
  this.timeout = timeout;
}
Body.prototype = {
  get bodyUsed() {
    return this[DISTURBED];
  },

  /**
   * Decode response as ArrayBuffer
   *
   * @return {Promise}
   */
  arrayBuffer() {
    return consumeBody.call(this).then(buf => buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength));
  },

  /**
   * Return raw response as Blob
   *
   * @return {Promise}
   */
  blob() {
    const ct = this.headers && this.headers.get('content-type') || '';
    return consumeBody.call(this).then(buf => Object.assign( // Prevent copying
    new Blob$1([], {
      type: ct.toLowerCase()
    }), {
      [BUFFER$2]: buf
    }));
  },

  /**
   * Decode response as json
   *
   * @return {Promise}
   */
  json() {
    return consumeBody.call(this).then(buffer => JSON.parse(buffer.toString()));
  },

  /**
   * Decode response as text
   *
   * @return {Promise}
   */
  text() {
    return consumeBody.call(this).then(buffer => buffer.toString());
  },

  /**
   * Decode response as buffer (non-spec api)
   *
   * @return {Promise}
   */
  buffer() {
    return consumeBody.call(this);
  },

  /**
   * Decode response as text, while automatically detecting the encoding and
   * trying to decode to UTF-8 (non-spec api)
   *
   * @return {Promise}
   */
  textConverted() {
    return consumeBody.call(this).then(buffer => convertBody(buffer, this.headers));
  }

};

Body.mixIn = function (proto) {
  for (var _iterator = _createForOfIteratorHelperLoose(Object.getOwnPropertyNames(Body.prototype)), _step; !(_step = _iterator()).done;) {
    const name = _step.value;

    // istanbul ignore else
    if (!(name in proto)) {
      const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
      Object.defineProperty(proto, name, desc);
    }
  }
};
/**
 * Decode buffers into utf-8 string
 *
 * @return {Promise}
 */


function consumeBody() {
  if (this[DISTURBED]) {
    return Promise.reject(new Error(`body used already for: ${this.url}`));
  }

  this[DISTURBED] = true; // body is null

  if (this.body === null) {
    return Promise.resolve(Buffer.alloc(0));
  } // body is string


  if (typeof this.body === 'string') {
    return Promise.resolve(Buffer.from(this.body));
  } // body is blob


  if (this.body instanceof Blob$1) {
    return Promise.resolve(this.body[BUFFER$2]);
  } // body is buffer


  if (Buffer.isBuffer(this.body)) {
    return Promise.resolve(this.body);
  } // istanbul ignore if: should never happen


  if (!(this.body instanceof Stream__default["default"])) {
    return Promise.resolve(Buffer.alloc(0));
  } // body is stream
  // get ready to actually consume the body


  const accum = [];
  let accumBytes = 0;
  let abort = false;
  return new Promise((resolve, reject) => {
    let resTimeout; // allow timeout on slow response body

    if (this.timeout) {
      resTimeout = setTimeout(() => {
        abort = true;
        reject(new FetchError(`Response timeout while trying to fetch ${this.url} (over ${this.timeout}ms)`, 'body-timeout'));
        this.body.emit('cancel-request');
      }, this.timeout);
    } // handle stream error, such as incorrect content-encoding


    this.body.on('error', err => {
      reject(new FetchError(`Invalid response body while trying to fetch ${this.url}: ${err.message}`, 'system', err));
    });
    this.body.on('data', chunk => {
      if (abort || chunk === null) {
        return;
      }

      if (this.size && accumBytes + chunk.length > this.size) {
        abort = true;
        reject(new FetchError(`content size at ${this.url} over limit: ${this.size}`, 'max-size'));
        this.body.emit('cancel-request');
        return;
      }

      accumBytes += chunk.length;
      accum.push(chunk);
    });
    this.body.on('end', () => {
      if (abort) {
        return;
      }

      clearTimeout(resTimeout);
      resolve(Buffer.concat(accum));
    });
  });
}
/**
 * Detect buffer encoding and convert to target encoding
 * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding
 *
 * @param {Buffer} buffer   Incoming buffer
 * @param {Headers} headers
 * @return {string}
 */


function convertBody(buffer, headers) {
  const ct = headers.get('content-type');
  let charset = 'utf-8';
  let res; // header

  if (ct) {
    res = /charset=([^;]*)/i.exec(ct);
  } // no charset in content type, peek at response body for at most 1024 bytes


  const str = buffer.slice(0, 1024).toString(); // html5

  if (!res && str) {
    res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
  } // html4


  if (!res && str) {
    res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);

    if (res) {
      res = /charset=(.*)/i.exec(res.pop());
    }
  } // xml


  if (!res && str) {
    res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
  } // found charset


  if (res) {
    charset = res.pop(); // prevent decode issues when sites use incorrect encoding
    // ref: https://hsivonen.fi/encoding-menu/

    if (charset === 'gb2312' || charset === 'gbk') {
      charset = 'gb18030';
    }
  } // turn raw buffers into a single utf-8 buffer


  return convert_1(buffer, 'UTF-8', charset).toString();
}
/**
 * Clone body given Res/Req instance
 *
 * @param {Response|Request} instance Response or Request instance
 * @return {string|Blob|Buffer|Stream}
 */


function clone(instance) {
  let p1, p2;
  let body = instance.body; // don't allow cloning a used body

  if (instance.bodyUsed) {
    throw new Error('cannot clone body after it is used');
  } // check that body is a stream and not form-data object
  // note: we can't clone the form-data object without having it as a dependency


  if (body instanceof Stream__default["default"] && typeof body.getBoundary !== 'function') {
    // tee instance body
    p1 = new Stream$3.PassThrough();
    p2 = new Stream$3.PassThrough();
    body.pipe(p1);
    body.pipe(p2); // set instance body to teed body and return the other teed body

    instance.body = p1;
    body = p2;
  }

  return body;
}
/**
 * Performs the operation "extract a `Content-Type` value from |object|" as
 * specified in the specification:
 * https://fetch.spec.whatwg.org/#concept-bodyinit-extract
 *
 * This function assumes that instance.body is present and non-null.
 *
 * @param {Response|Request} instance Response or Request instance
 */

function extractContentType(instance) {
  const body = instance.body; // istanbul ignore if: Currently, because of a guard in Request, body
  // can never be null. Included here for completeness.

  if (body === null) {
    // body is null
    return null;
  } else if (typeof body === 'string') {
    // body is string
    return 'text/plain;charset=UTF-8';
  } else if (body instanceof Blob$1) {
    // body is blob
    return body.type || null;
  } else if (Buffer.isBuffer(body)) {
    // body is buffer
    return null;
  } else if (typeof body.getBoundary === 'function') {
    // detect form data input from form-data module
    return `multipart/form-data;boundary=${body.getBoundary()}`;
  } else {
    // body is stream
    // can't really do much about this
    return null;
  }
}
function getTotalBytes(instance) {
  const body = instance.body; // istanbul ignore if: included for completion

  if (body === null) {
    // body is null
    return 0;
  } else if (typeof body === 'string') {
    // body is string
    return Buffer.byteLength(body);
  } else if (body instanceof Blob$1) {
    // body is blob
    return body.size;
  } else if (Buffer.isBuffer(body)) {
    // body is buffer
    return body.length;
  } else if (body && typeof body.getLengthSync === 'function') {
    // detect form data input from form-data module
    // istanbul ignore next
    if (body._lengthRetrievers && body._lengthRetrievers.length === 0 || body.hasKnownLength && body.hasKnownLength()) {
      // 2.x
      return body.getLengthSync();
    }

    return null;
  } else {
    // body is stream
    // can't really do much about this
    return null;
  }
}
function writeToStream(dest, instance) {
  const body = instance.body;

  if (body === null) {
    // body is null
    dest.end();
  } else if (typeof body === 'string') {
    // body is string
    dest.write(body);
    dest.end();
  } else if (body instanceof Blob$1) {
    // body is blob
    dest.write(body[BUFFER$2]);
    dest.end();
  } else if (Buffer.isBuffer(body)) {
    // body is buffer
    dest.write(body);
    dest.end();
  } else {
    // body is stream
    if (instance.useElectronNet) {
      dest.chunkedEncoding = instance.chunkedEncoding; // Force a first write to start the request otherwise an empty body stream
      // will cause an error when closing the dest stream with Electron v7.

      dest.write('');
    }

    body.pipe(new Stream$3.PassThrough()) // I have to put a PassThrough because somehow, FormData streams are not eaten by electron/net
    .pipe(dest);
  }
}

/**
 * A set of utilities borrowed from Node.js' _http_common.js
 */

/**
 * Verifies that the given val is a valid HTTP token
 * per the rules defined in RFC 7230
 * See https://tools.ietf.org/html/rfc7230#section-3.2.6
 *
 * Allowed characters in an HTTP token:
 * ^_`a-z  94-122
 * A-Z     65-90
 * -       45
 * 0-9     48-57
 * !       33
 * #$%&'   35-39
 * *+      42-43
 * .       46
 * |       124
 * ~       126
 *
 * This implementation of checkIsHttpToken() loops over the string instead of
 * using a regular expression since the former is up to 180% faster with v8 4.9
 * depending on the string length (the shorter the string, the larger the
 * performance difference)
 *
 * Additionally, checkIsHttpToken() is currently designed to be inlinable by v8,
 * so take care when making changes to the implementation so that the source
 * code size does not exceed v8's default max_inlined_source_size setting.
 **/
// istanbul ignore next
function isValidTokenChar(ch) {
  if (ch >= 94 && ch <= 122) {
    return true;
  }

  if (ch >= 65 && ch <= 90) {
    return true;
  }

  if (ch === 45) {
    return true;
  }

  if (ch >= 48 && ch <= 57) {
    return true;
  }

  if (ch === 34 || ch === 40 || ch === 41 || ch === 44) {
    return false;
  }

  if (ch >= 33 && ch <= 46) {
    return true;
  }

  if (ch === 124 || ch === 126) {
    return true;
  }

  return false;
} // istanbul ignore next


function checkIsHttpToken(val) {
  if (typeof val !== 'string' || val.length === 0) {
    return false;
  }

  if (!isValidTokenChar(val.charCodeAt(0))) {
    return false;
  }

  const len = val.length;

  if (len > 1) {
    if (!isValidTokenChar(val.charCodeAt(1))) {
      return false;
    }

    if (len > 2) {
      if (!isValidTokenChar(val.charCodeAt(2))) {
        return false;
      }

      if (len > 3) {
        if (!isValidTokenChar(val.charCodeAt(3))) {
          return false;
        }

        for (let i = 4; i < len; i++) {
          if (!isValidTokenChar(val.charCodeAt(i))) {
            return false;
          }
        }
      }
    }
  }

  return true;
}
/**
 * True if val contains an invalid field-vchar
 *  field-value    = *( field-content / obs-fold )
 *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
 *  field-vchar    = VCHAR / obs-text
 *
 * checkInvalidHeaderChar() is currently designed to be inlinable by v8,
 * so take care when making changes to the implementation so that the source
 * code size does not exceed v8's default max_inlined_source_size setting.
 **/
// istanbul ignore next

function checkInvalidHeaderChar(val) {
  val += '';

  if (val.length < 1) {
    return false;
  }

  let c = val.charCodeAt(0);

  if (c <= 31 && c !== 9 || c > 255 || c === 127) {
    return true;
  }

  if (val.length < 2) {
    return false;
  }

  c = val.charCodeAt(1);

  if (c <= 31 && c !== 9 || c > 255 || c === 127) {
    return true;
  }

  if (val.length < 3) {
    return false;
  }

  c = val.charCodeAt(2);

  if (c <= 31 && c !== 9 || c > 255 || c === 127) {
    return true;
  }

  for (let i = 3; i < val.length; ++i) {
    c = val.charCodeAt(i);

    if (c <= 31 && c !== 9 || c > 255 || c === 127) {
      return true;
    }
  }

  return false;
}

function sanitizeName(name) {
  name += '';

  if (!checkIsHttpToken(name)) {
    throw new TypeError(`${name} is not a legal HTTP header name`);
  }

  return name.toLowerCase();
}

function sanitizeValue(value) {
  value += '';

  if (checkInvalidHeaderChar(value)) {
    throw new TypeError(`${value} is not a legal HTTP header value`);
  }

  return value;
}

const MAP = Symbol('map');
class Headers {
  /**
   * Headers class
   *
   * @param {Object} init Response headers
   */
  constructor(init = undefined) {
    this[MAP] = Object.create(null); // We don't worry about converting prop to ByteString here as append()
    // will handle it.

    if (init == null) ; else if (typeof init === 'object') {
      const method = init[Symbol.iterator];

      if (method != null) {
        if (typeof method !== 'function') {
          throw new TypeError('Header pairs must be iterable');
        } // sequence<sequence<ByteString>>
        // Note: per spec we have to first exhaust the lists then process them


        const pairs = [];

        for (var _iterator = _createForOfIteratorHelperLoose(init), _step; !(_step = _iterator()).done;) {
          const pair = _step.value;

          if (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {
            throw new TypeError('Each header pair must be iterable');
          }

          pairs.push(Array.from(pair));
        }

        for (var _i = 0, _pairs = pairs; _i < _pairs.length; _i++) {
          const pair = _pairs[_i];

          if (pair.length !== 2) {
            throw new TypeError('Each header pair must be a name/value tuple');
          }

          this.append(pair[0], pair[1]);
        }
      } else {
        // record<ByteString, ByteString>
        for (var _i2 = 0, _Object$keys = Object.keys(init); _i2 < _Object$keys.length; _i2++) {
          const key = _Object$keys[_i2];
          const value = init[key];
          this.append(key, value);
        }
      }
    } else {
      throw new TypeError('Provided initializer must be an object');
    }

    Object.defineProperty(this, Symbol.toStringTag, {
      value: 'Headers',
      writable: false,
      enumerable: false,
      configurable: true
    });
  }
  /**
   * Return first header value given name
   *
   * @param {string} name Header name
   * @return {string}
   */


  get(name) {
    const list = this[MAP][sanitizeName(name)];

    if (!list) {
      return null;
    }

    return list.join(',');
  }
  /**
   * Iterate over all headers
   *
   * @param {function} callback Executed for each item with parameters (value, name, thisArg)
   * @param {boolean} thisArg `this` context for callback function
   */


  forEach(callback, thisArg = undefined) {
    let pairs = getHeaderPairs(this);
    let i = 0;

    while (i < pairs.length) {
      const _pairs$i = pairs[i],
            name = _pairs$i[0],
            value = _pairs$i[1];
      callback.call(thisArg, value, name, this);
      pairs = getHeaderPairs(this);
      i++;
    }
  }
  /**
   * Overwrite header values given name
   *
   * @param {string} name Header name
   * @param {string|Array.<string|*>|*} value Header value
   */


  set(name, value) {
    this[MAP][sanitizeName(name)] = [sanitizeValue(value)];
  }
  /**
   * Append a value onto existing header
   *
   * @param {string} name Header name
   * @param {string|Array.<string|*>|*} value Header value
   */


  append(name, value) {
    if (!this.has(name)) {
      this.set(name, value);
      return;
    }

    this[MAP][sanitizeName(name)].push(sanitizeValue(value));
  }
  /**
   * Check for header name existence
   *
   * @param {string} name Header name
   * @return {boolean}
   */


  has(name) {
    return !!this[MAP][sanitizeName(name)];
  }
  /**
   * Delete all header values given name
   *
   * @param {string} name Header name
   */


  delete(name) {
    delete this[MAP][sanitizeName(name)];
  }
  /**
   * Return raw headers (non-spec api)
   *
   * @return {Object}
   */


  raw() {
    return this[MAP];
  }
  /**
   * Get an iterator on keys.
   *
   * @return {Iterator}
   */


  keys() {
    return createHeadersIterator(this, 'key');
  }
  /**
   * Get an iterator on values.
   *
   * @return {Iterator}
   */


  values() {
    return createHeadersIterator(this, 'value');
  }
  /**
   * Get an iterator on entries.
   *
   * This is the default iterator of the Headers object.
   *
   * @return {Iterator}
   */


  [Symbol.iterator]() {
    return createHeadersIterator(this, 'key+value');
  }

}
Headers.prototype.entries = Headers.prototype[Symbol.iterator];
Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
  value: 'HeadersPrototype',
  writable: false,
  enumerable: false,
  configurable: true
});

function getHeaderPairs(headers, kind) {
  if (kind === 'key') return Object.keys(headers[MAP]).sort().map(k => [k]);
  const pairs = [];

  for (var _iterator2 = _createForOfIteratorHelperLoose(Object.keys(headers[MAP]).sort()), _step2; !(_step2 = _iterator2()).done;) {
    const key = _step2.value;

    for (var _iterator3 = _createForOfIteratorHelperLoose(headers[MAP][key]), _step3; !(_step3 = _iterator3()).done;) {
      const value = _step3.value;
      pairs.push([key, value]);
    }
  }

  return pairs;
}

const INTERNAL = Symbol('internal');

function createHeadersIterator(target, kind) {
  const iterator = Object.create(HeadersIteratorPrototype);
  iterator[INTERNAL] = {
    target,
    kind,
    index: 0
  };
  return iterator;
}

const HeadersIteratorPrototype = Object.setPrototypeOf({
  next() {
    // istanbul ignore if
    if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
      throw new TypeError('Value of `this` is not a HeadersIterator');
    }

    const _this$INTERNAL = this[INTERNAL],
          target = _this$INTERNAL.target,
          kind = _this$INTERNAL.kind,
          index = _this$INTERNAL.index;
    const values = getHeaderPairs(target, kind);
    const len = values.length;

    if (index >= len) {
      return {
        value: undefined,
        done: true
      };
    }

    const pair = values[index];
    this[INTERNAL].index = index + 1;
    let result;

    if (kind === 'key') {
      result = pair[0];
    } else if (kind === 'value') {
      result = pair[1];
    } else {
      result = pair;
    }

    return {
      value: result,
      done: false
    };
  }

}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
  value: 'HeadersIterator',
  writable: false,
  enumerable: false,
  configurable: true
});

/**
 * response.js
 *
 * Response class provides content decoding
 */
/**
 * Response class
 *
 * @param {Stream} body Readable stream
 * @param {Object} opts Response options
 */

class Response {
  constructor(body = null, opts = {}) {
    Body.call(this, body, opts);
    this.url = opts.url;
    this.status = opts.status || 200;
    this.statusText = opts.statusText || http.STATUS_CODES[this.status];
    this.headers = new Headers(opts.headers);
    this.useElectronNet = opts.useElectronNet;
    Object.defineProperty(this, Symbol.toStringTag, {
      value: 'Response',
      writable: false,
      enumerable: false,
      configurable: true
    });
  }
  /**
   * Convenience property representing if the request ended normally
   */


  get ok() {
    return this.status >= 200 && this.status < 300;
  }
  /**
   * Clone this response
   *
   * @return {Response}
   */


  clone() {
    return new Response(clone(this), {
      url: this.url,
      status: this.status,
      statusText: this.statusText,
      headers: this.headers,
      ok: this.ok,
      useElectronNet: this.useElectronNet
    });
  }

}
Body.mixIn(Response.prototype);
Object.defineProperty(Response.prototype, Symbol.toStringTag, {
  value: 'ResponsePrototype',
  writable: false,
  enumerable: false,
  configurable: true
});

/**
 * request.js
 *
 * Request class contains server only options
 */
const PARSED_URL = Symbol('url');
/**
 * Request class
 *
 * @param {string|Request} input Url or Request instance
 * @param {Object} init Custom options
 */

class Request {
  constructor(input, init = {}) {
    let parsedURL; // normalize input

    if (!(input instanceof Request)) {
      if (input && input.href) {
        // in order to support Node.js' Url objects; though WHATWG's URL objects
        // will fall into this branch also (since their `toString()` will return
        // `href` property anyway)
        parsedURL = require$$2$3.parse(input.href);
      } else {
        // coerce input to a string before attempting to parse
        parsedURL = require$$2$3.parse(`${input}`);
      }

      input = {};
    } else {
      parsedURL = require$$2$3.parse(input.url);
    }

    const method = init.method || input.method || 'GET';

    if ((init.body != null || input instanceof Request && input.body !== null) && (method === 'GET' || method === 'HEAD')) {
      throw new TypeError('Request with GET/HEAD method cannot have body');
    }

    const inputBody = init.body != null ? init.body : input instanceof Request && input.body !== null ? clone(input) : null;
    Body.call(this, inputBody, {
      timeout: init.timeout || input.timeout || 0,
      size: init.size || input.size || 0
    }); // fetch spec options

    this.method = method.toUpperCase();
    this.redirect = init.redirect || input.redirect || 'follow';
    this.signal = init.signal || input.signal || null;
    this.headers = new Headers(init.headers || input.headers || {});
    this.headers.delete('Content-Length'); // user cannot set content-length themself as per fetch spec

    this.chunkedEncoding = false;
    this.useElectronNet = init.useElectronNet !== undefined // have to do this instead of || because it can be set to false
    ? init.useElectronNet : input.useElectronNet; // istanbul ignore if

    if (this.useElectronNet && !process.versions.electron) throw new Error('Cannot use Electron/net module on Node.js!');

    if (this.useElectronNet === undefined) {
      this.useElectronNet = Boolean(process.versions.electron);
    }

    if (this.useElectronNet) {
      this.useSessionCookies = init.useSessionCookies !== undefined ? init.useSessionCookies : input.useSessionCookies;
    }

    if (init.body != null) {
      const contentType = extractContentType(this);

      if (contentType !== null && !this.headers.has('Content-Type')) {
        this.headers.append('Content-Type', contentType);
      }
    } // server only options


    this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;
    this.counter = init.counter || input.counter || 0;
    this.session = init.session || input.session;
    this[PARSED_URL] = parsedURL;
    Object.defineProperty(this, Symbol.toStringTag, {
      value: 'Request',
      writable: false,
      enumerable: false,
      configurable: true
    });
  }

  get url() {
    return require$$2$3.format(this[PARSED_URL]);
  }
  /**
   * Clone this request
   *
   * @return {Request}
   */


  clone() {
    return new Request(this);
  }

}
Body.mixIn(Request.prototype);
Object.defineProperty(Request.prototype, Symbol.toStringTag, {
  value: 'RequestPrototype',
  writable: false,
  enumerable: false,
  configurable: true
});
function getNodeRequestOptions(request) {
  const parsedURL = request[PARSED_URL];
  const headers = new Headers(request.headers); // fetch step 3

  if (!headers.has('Accept')) {
    headers.set('Accept', '*/*');
  } // Basic fetch


  if (!parsedURL.protocol || !parsedURL.hostname) {
    throw new TypeError('Only absolute URLs are supported');
  }

  if (!/^https?:$/.test(parsedURL.protocol)) {
    throw new TypeError('Only HTTP(S) protocols are supported');
  } // HTTP-network-or-cache fetch steps 5-9


  let contentLengthValue = null;

  if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
    contentLengthValue = '0';
  }

  if (request.body != null) {
    const totalBytes = getTotalBytes(request);

    if (typeof totalBytes === 'number') {
      contentLengthValue = String(totalBytes);
    }
  }

  if (contentLengthValue) {
    if (!request.useElectronNet) headers.set('Content-Length', contentLengthValue);
  } else {
    request.chunkedEncoding = true;
  } // HTTP-network-or-cache fetch step 12


  if (!headers.has('User-Agent')) {
    headers.set('User-Agent', `electron-fetch/1.0 ${request.useElectronNet ? 'electron' : 'node'} (+https://github.com/arantes555/electron-fetch)`);
  } // HTTP-network-or-cache fetch step 16


  headers.set('Accept-Encoding', 'gzip,deflate');

  if (!headers.has('Connection')) {
    headers.set('Connection', 'close');
  } // HTTP-network fetch step 4
  // chunked encoding is handled by Node.js when not running in electron


  return Object.assign({}, parsedURL, {
    method: request.method,
    headers: headers.raw()
  });
}

let electron$2; // istanbul ignore else

if (process.versions.electron) {
  electron$2 = require('electron');
}

const isReady = electron$2 && electron$2.app && !electron$2.app.isReady() ? new Promise(resolve => electron$2.app.once('ready', resolve)) : Promise.resolve();
/**
 * Fetch function
 *
 * @param {string|Request} url Absolute url or Request instance
 * @param {Object} [opts] Fetch options
 * @return {Promise}
 */

function fetch$3(url, opts = {}) {
  // wrap http.request into fetch
  return isReady.then(() => new Promise((resolve$1, reject) => {
    // build request object
    const request = new Request(url, opts);
    const options = getNodeRequestOptions(request);
    const send = request.useElectronNet ? electron$2.net.request : (options.protocol === 'https:' ? https__namespace : http__namespace).request; // http.request only support string as host header, this hack make custom host header possible

    if (options.headers.host) {
      options.headers.host = options.headers.host[0];
    }

    if (request.signal && request.signal.aborted) {
      reject(new FetchError('request aborted', 'abort'));
      return;
    } // send request


    let headers;

    if (request.useElectronNet) {
      headers = options.headers;
      delete options.headers;
      options.session = opts.session || electron$2.session.defaultSession;
      options.useSessionCookies = request.useSessionCookies;
    } else {
      if (opts.agent) options.agent = opts.agent;
    }

    const req = send(options);

    if (request.useElectronNet) {
      for (const headerName in headers) {
        if (typeof headers[headerName] === 'string') req.setHeader(headerName, headers[headerName]);else {
          for (var _iterator = _createForOfIteratorHelperLoose(headers[headerName]), _step; !(_step = _iterator()).done;) {
            const headerValue = _step.value;
            req.setHeader(headerName, headerValue);
          }
        }
      }
    }

    let reqTimeout;

    const cancelRequest = () => {
      if (request.useElectronNet) {
        req.abort(); // in electron, `req.destroy()` does not send abort to server
      } else {
        req.destroy(); // in node.js, `req.abort()` is deprecated
      }
    };

    const abortRequest = () => {
      const err = new FetchError('request aborted', 'abort');
      reject(err);
      cancelRequest();
      req.emit('error', err);
    };

    if (request.signal) {
      request.signal.addEventListener('abort', abortRequest);
    }

    if (request.timeout) {
      reqTimeout = setTimeout(() => {
        const err = new FetchError(`network timeout at: ${request.url}`, 'request-timeout');
        reject(err);
        cancelRequest();
      }, request.timeout);
    }

    if (request.useElectronNet) {
      // handle authenticating proxies
      req.on('login', (authInfo, callback) => {
        if (opts.user && opts.password) {
          callback(opts.user, opts.password);
        } else {
          cancelRequest();
          reject(new FetchError(`login event received from ${authInfo.host} but no credentials provided`, 'proxy', {
            code: 'PROXY_AUTH_FAILED'
          }));
        }
      });
    }

    req.on('error', err => {
      clearTimeout(reqTimeout);

      if (request.signal) {
        request.signal.removeEventListener('abort', abortRequest);
      }

      reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));
    });
    req.on('abort', () => {
      clearTimeout(reqTimeout);

      if (request.signal) {
        request.signal.removeEventListener('abort', abortRequest);
      }
    });
    req.on('response', res => {
      clearTimeout(reqTimeout);

      if (request.signal) {
        request.signal.removeEventListener('abort', abortRequest);
      } // handle redirect


      if (fetch$3.isRedirect(res.statusCode) && request.redirect !== 'manual') {
        if (request.redirect === 'error') {
          reject(new FetchError(`redirect mode is set to error: ${request.url}`, 'no-redirect'));
          return;
        }

        if (request.counter >= request.follow) {
          reject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));
          return;
        }

        if (!res.headers.location) {
          reject(new FetchError(`redirect location header missing at: ${request.url}`, 'invalid-redirect'));
          return;
        } // per fetch spec, for POST request with 301/302 response, or any request with 303 response, use GET when following redirect


        if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {
          request.method = 'GET';
          request.body = null;
          request.headers.delete('content-length');
        }

        request.counter++;
        resolve$1(fetch$3(require$$2$3.resolve(request.url, res.headers.location), request));
        return;
      } // normalize location header for manual redirect mode


      const headers = new Headers();

      for (var _i = 0, _Object$keys = Object.keys(res.headers); _i < _Object$keys.length; _i++) {
        const name = _Object$keys[_i];

        if (Array.isArray(res.headers[name])) {
          for (var _iterator2 = _createForOfIteratorHelperLoose(res.headers[name]), _step2; !(_step2 = _iterator2()).done;) {
            const val = _step2.value;
            headers.append(name, val);
          }
        } else {
          headers.append(name, res.headers[name]);
        }
      }

      if (request.redirect === 'manual' && headers.has('location')) {
        headers.set('location', require$$2$3.resolve(request.url, headers.get('location')));
      } // prepare response


      let body = new Stream$3.PassThrough();
      res.on('error', err => body.emit('error', err));
      res.pipe(body);
      body.on('error', cancelRequest);
      body.on('cancel-request', cancelRequest);

      const abortBody = () => {
        res.destroy();
        res.emit('error', new FetchError('request aborted', 'abort')); // separated from the `.destroy()` because somehow Node's IncomingMessage streams do not emit errors on destroy
      };

      if (request.signal) {
        request.signal.addEventListener('abort', abortBody);
        res.on('end', () => {
          request.signal.removeEventListener('abort', abortBody);
        });
        res.on('error', () => {
          request.signal.removeEventListener('abort', abortBody);
        });
      }

      const responseOptions = {
        url: request.url,
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: headers,
        size: request.size,
        timeout: request.timeout,
        useElectronNet: request.useElectronNet,
        useSessionCookies: request.useSessionCookies
      }; // HTTP-network fetch step 16.1.2

      const codings = headers.get('Content-Encoding'); // HTTP-network fetch step 16.1.3: handle content codings
      // in following scenarios we ignore compression support
      // 1. running on Electron/net module (it manages it for us)
      // 2. HEAD request
      // 3. no Content-Encoding header
      // 4. no content response (204)
      // 5. content not modified response (304)

      if (!request.useElectronNet && request.method !== 'HEAD' && codings !== null && res.statusCode !== 204 && res.statusCode !== 304) {
        // Be less strict when decoding compressed responses, since sometimes
        // servers send slightly invalid responses that are still accepted
        // by common browsers.
        // Always using Z_SYNC_FLUSH is what cURL does.
        // /!\ This is disabled for now, because it seems broken in recent node
        // const zlibOptions = {
        //   flush: zlib.Z_SYNC_FLUSH,
        //   finishFlush: zlib.Z_SYNC_FLUSH
        // }
        if (codings === 'gzip' || codings === 'x-gzip') {
          // for gzip
          body = body.pipe(zlib__namespace.createGunzip());
        } else if (codings === 'deflate' || codings === 'x-deflate') {
          // for deflate
          // handle the infamous raw deflate response from old servers
          // a hack for old IIS and Apache servers
          const raw = res.pipe(new Stream$3.PassThrough());
          return raw.once('data', chunk => {
            // see http://stackoverflow.com/questions/37519828
            if ((chunk[0] & 0x0F) === 0x08) {
              body = body.pipe(zlib__namespace.createInflate());
            } else {
              body = body.pipe(zlib__namespace.createInflateRaw());
            }

            const response = new Response(body, responseOptions);
            resolve$1(response);
          });
        }
      }

      const response = new Response(body, responseOptions);
      resolve$1(response);
    });
    writeToStream(req, request);
  }));
}
/**
 * Redirect code matching
 *
 * @param {number} code Status code
 * @return {boolean}
 */

fetch$3.isRedirect = code => code === 301 || code === 302 || code === 303 || code === 307 || code === 308;

var index_es = /*#__PURE__*/Object.freeze({
	__proto__: null,
	FetchError: FetchError,
	Headers: Headers,
	Request: Request,
	Response: Response,
	'default': fetch$3
});

var require$$1$1 = /*@__PURE__*/getAugmentedNamespace(index_es);

var electronUnhandled = {exports: {}};

const os$1 = require$$0__default$3["default"];

const extractPathRegex = /\s+at.*(?:\(|\s)(.*)\)?/;
const pathRegex = /^(?:(?:(?:node|(?:internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)\.js:\d+:\d+)|native)/;
const homeDir = typeof os$1.homedir === 'undefined' ? '' : os$1.homedir();

var cleanStack$1 = (stack, options) => {
	options = Object.assign({pretty: false}, options);

	return stack.replace(/\\/g, '/')
		.split('\n')
		.filter(line => {
			const pathMatches = line.match(extractPathRegex);
			if (pathMatches === null || !pathMatches[1]) {
				return true;
			}

			const match = pathMatches[1];

			// Electron
			if (
				match.includes('.app/Contents/Resources/electron.asar') ||
				match.includes('.app/Contents/Resources/default_app.asar')
			) {
				return false;
			}

			return !pathRegex.test(match);
		})
		.filter(line => line.trim() !== '')
		.map(line => {
			if (options.pretty) {
				return line.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, '~')));
			}

			return line;
		})
		.join('\n');
};

const util$b = require$$4__default["default"];

class NonError extends Error {
	constructor(message) {
		super(util$b.inspect(message));
		this.name = 'NonError';
		Error.captureStackTrace(this, NonError);
	}
}

var ensureError$1 = input => {
	if (!(input instanceof Error)) {
		return new NonError(input);
	}

	const error = input;

	if (!error.name) {
		error.name = (error.constructor && error.constructor.name) || 'Error';
	}

	if (!error.message) {
		error.message = '<No error message>';
	}

	if (!error.stack) {
		error.stack = (new Error(error.message)).stack.replace(/\n {4}at /, '\n<Original stack missing>$&');
	}

	return error;
};

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag$2 = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal$4 = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

/** Detect free variable `self`. */
var freeSelf$2 = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root$4 = freeGlobal$4 || freeSelf$2 || Function('return this')();

/** Used for built-in method references. */
var objectProto$g = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString$3 = objectProto$g.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root$4.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce$1(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject$1(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject$1(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike$3(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike$3(value) && objectToString$3.call(value) == symbolTag$2);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject$1(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject$1(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

var lodash_debounce = debounce$1;

const electron$1 = require$$0__default$4["default"];

if (typeof electron$1 === 'string') {
	throw new TypeError('Not running in an Electron environment!');
}

const app$7 = electron$1.app || electron$1.remote.app;

const isEnvSet = 'ELECTRON_IS_DEV' in process.env;
const getFromEnv = parseInt(process.env.ELECTRON_IS_DEV, 10) === 1;

var electronIsDev = isEnvSet ? getFromEnv : !app$7.isPackaged;

const electron = require$$0__default$4["default"];
const cleanStack = cleanStack$1;
const ensureError = ensureError$1;
const debounce = lodash_debounce;
const isDev$3 = electronIsDev;

const app$6 = electron.app || electron.remote.app;
const dialog$2 = electron.dialog || electron.remote.dialog;
const clipboard$1 = electron.clipboard || electron.remote.clipboard;
const appName = 'name' in app$6 ? app$6.name : app$6.getName();

// The dialog.showMessageBox method has been split into a sync and an async variant in Electron 6.0.0
const showMessageBox = dialog$2.showMessageBoxSync || dialog$2.showMessageBox;

let installed = false;

let options = {
	logger: console.error,
	showDialog: !isDev$3
};

const handleError = (title, error) => {
	error = ensureError(error);

	try {
		options.logger(error);
	} catch (loggerError) { // eslint-disable-line unicorn/catch-error-name
		dialog$2.showErrorBox('The `logger` option function in electron-unhandled threw an error', ensureError(loggerError).stack);
		return;
	}

	if (options.showDialog) {
		const stack = cleanStack(error.stack);

		if (app$6.isReady()) {
			const buttons = [
				'OK',
				process.platform === 'darwin' ? 'Copy Error' : 'Copy error'
			];

			if (options.reportButton) {
				buttons.push('Report');
			}

			// Intentionally not using the `title` option as it's not shown on macOS
			const buttonIndex = showMessageBox({
				type: 'error',
				buttons,
				defaultId: 0,
				noLink: true,
				message: title,
				detail: cleanStack(error.stack, {pretty: true})
			});

			if (buttonIndex === 1) {
				clipboard$1.writeText(`${title}\n${stack}`);
			}

			if (buttonIndex === 2) {
				options.reportButton(error);
			}
		} else {
			dialog$2.showErrorBox(title, stack);
		}
	}
};

electronUnhandled.exports = inputOptions => {
	if (installed) {
		return;
	}

	installed = true;

	options = {
		...options,
		...inputOptions
	};

	if (process.type === 'renderer') {
		const errorHandler = debounce(error => {
			handleError('Unhandled Error', error);
		}, 200);
		window.addEventListener('error', event => {
			event.preventDefault();
			errorHandler(event.error || event);
		});

		const rejectionHandler = debounce(reason => {
			handleError('Unhandled Promise Rejection', reason);
		}, 200);
		window.addEventListener('unhandledrejection', event => {
			event.preventDefault();
			rejectionHandler(event.reason);
		});
	} else {
		process.on('uncaughtException', error => {
			handleError('Unhandled Error', error);
		});

		process.on('unhandledRejection', error => {
			handleError('Unhandled Promise Rejection', error);
		});
	}
};

electronUnhandled.exports.logError = (error, options) => {
	options = {
		title: `${appName} encountered an error`,
		...options
	};

	handleError(options.title, error);
};

var _fs;
try {
  _fs = require('graceful-fs');
} catch (_) {
  _fs = require$$0__default$1["default"];
}

/** Detect free variable `global` from Node.js. */

var freeGlobal$3 = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

var _freeGlobal = freeGlobal$3;

var freeGlobal$2 = _freeGlobal;

/** Detect free variable `self`. */
var freeSelf$1 = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root$3 = freeGlobal$2 || freeSelf$1 || Function('return this')();

var _root = root$3;

var root$2 = _root;

/** Built-in value references. */
var Symbol$5 = root$2.Symbol;

var _Symbol = Symbol$5;

var Symbol$4 = _Symbol;

/** Used for built-in method references. */
var objectProto$f = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$b = objectProto$f.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$3 = objectProto$f.toString;

/** Built-in value references. */
var symToStringTag$3 = Symbol$4 ? Symbol$4.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag$2(value) {
  var isOwn = hasOwnProperty$b.call(value, symToStringTag$3),
      tag = value[symToStringTag$3];

  try {
    value[symToStringTag$3] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString$3.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$3] = tag;
    } else {
      delete value[symToStringTag$3];
    }
  }
  return result;
}

var _getRawTag = getRawTag$2;

/** Used for built-in method references. */

var objectProto$e = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$2 = objectProto$e.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString$2(value) {
  return nativeObjectToString$2.call(value);
}

var _objectToString = objectToString$2;

var Symbol$3 = _Symbol,
    getRawTag$1 = _getRawTag,
    objectToString$1 = _objectToString;

/** `Object#toString` result references. */
var nullTag$1 = '[object Null]',
    undefinedTag$1 = '[object Undefined]';

/** Built-in value references. */
var symToStringTag$2 = Symbol$3 ? Symbol$3.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag$2(value) {
  if (value == null) {
    return value === undefined ? undefinedTag$1 : nullTag$1;
  }
  return (symToStringTag$2 && symToStringTag$2 in Object(value))
    ? getRawTag$1(value)
    : objectToString$1(value);
}

var _baseGetTag = baseGetTag$2;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */

function isObjectLike$2(value) {
  return value != null && typeof value == 'object';
}

var isObjectLike_1 = isObjectLike$2;

var src = {};

var cjs$2 = {};

var balancedMatch = balanced$1;
function balanced$1(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range$1(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced$1.range = range$1;
function range$1(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [ begs.pop(), bi ];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [ left, right ];
    }
  }

  return result;
}

var balanced = balancedMatch;

var braceExpansion = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric$1(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
            .split('\\{').join(escOpen)
            .split('\\}').join(escClose)
            .split('\\,').join(escComma)
            .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
            .split(escOpen).join('{')
            .split(escClose).join('}')
            .split(escComma).join(',')
            .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [''];

  var parts = [];
  var m = balanced('{', '}', str);

  if (!m)
    return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte$3(i, y) {
  return i <= y;
}
function gte$3(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balanced('{', '}', str);
  if (!m) return [str];

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand(m.post, false)
    : [''];

  if (/\$$/.test(m.pre)) {    
    for (var k = 0; k < post.length; k++) {
      var expansion = pre+ '{' + m.body + '}' + post[k];
      expansions.push(expansion);
    }
  } else {
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m.body.indexOf(',') >= 0;
    if (!isSequence && !isOptions) {
      // {a},b}
      if (m.post.match(/,.*\}/)) {
        str = m.pre + '{' + m.body + escClose + m.post;
        return expand(str);
      }
      return [str];
    }

    var n;
    if (isSequence) {
      n = m.body.split(/\.\./);
    } else {
      n = parseCommaParts(m.body);
      if (n.length === 1) {
        // x{{a,b}}y ==> x{a}y x{b}y
        n = expand(n[0], false).map(embrace);
        if (n.length === 1) {
          return post.map(function(p) {
            return m.pre + n[0] + p;
          });
        }
      }
    }

    // at this point, n is the parts, and we know it's not a comma set
    // with a single entry.
    var N;

    if (isSequence) {
      var x = numeric$1(n[0]);
      var y = numeric$1(n[1]);
      var width = Math.max(n[0].length, n[1].length);
      var incr = n.length == 3
        ? Math.abs(numeric$1(n[2]))
        : 1;
      var test = lte$3;
      var reverse = y < x;
      if (reverse) {
        incr *= -1;
        test = gte$3;
      }
      var pad = n.some(isPadded);

      N = [];

      for (var i = x; test(i, y); i += incr) {
        var c;
        if (isAlphaSequence) {
          c = String.fromCharCode(i);
          if (c === '\\')
            c = '';
        } else {
          c = String(i);
          if (pad) {
            var need = width - c.length;
            if (need > 0) {
              var z = new Array(need + 1).join('0');
              if (i < 0)
                c = '-' + z + c.slice(1);
              else
                c = z + c;
            }
          }
        }
        N.push(c);
      }
    } else {
      N = [];

      for (var j = 0; j < n.length; j++) {
        N.push.apply(N, expand(n[j], false));
      }
    }

    for (var j = 0; j < N.length; j++) {
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion)
          expansions.push(expansion);
      }
    }
  }

  return expansions;
}

var assertValidPattern$1 = {};

Object.defineProperty(assertValidPattern$1, "__esModule", { value: true });
assertValidPattern$1.assertValidPattern = void 0;
const MAX_PATTERN_LENGTH = 1024 * 64;
const assertValidPattern = (pattern) => {
    if (typeof pattern !== 'string') {
        throw new TypeError('invalid pattern');
    }
    if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError('pattern is too long');
    }
};
assertValidPattern$1.assertValidPattern = assertValidPattern;

var ast = {};

var braceExpressions = {};

// translate the various posix character classes into unicode properties
// this works across all unicode locales
Object.defineProperty(braceExpressions, "__esModule", { value: true });
braceExpressions.parseClass = void 0;
// { <posix class>: [<translation>, /u flag required, negated]
const posixClasses = {
    '[:alnum:]': ['\\p{L}\\p{Nl}\\p{Nd}', true],
    '[:alpha:]': ['\\p{L}\\p{Nl}', true],
    '[:ascii:]': ['\\x' + '00-\\x' + '7f', false],
    '[:blank:]': ['\\p{Zs}\\t', true],
    '[:cntrl:]': ['\\p{Cc}', true],
    '[:digit:]': ['\\p{Nd}', true],
    '[:graph:]': ['\\p{Z}\\p{C}', true, true],
    '[:lower:]': ['\\p{Ll}', true],
    '[:print:]': ['\\p{C}', true],
    '[:punct:]': ['\\p{P}', true],
    '[:space:]': ['\\p{Z}\\t\\r\\n\\v\\f', true],
    '[:upper:]': ['\\p{Lu}', true],
    '[:word:]': ['\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}', true],
    '[:xdigit:]': ['A-Fa-f0-9', false],
};
// only need to escape a few things inside of brace expressions
// escapes: [ \ ] -
const braceEscape = (s) => s.replace(/[[\]\\-]/g, '\\$&');
// escape all regexp magic characters
const regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
// everything has already been escaped, we just have to join
const rangesToString = (ranges) => ranges.join('');
// takes a glob string at a posix brace expression, and returns
// an equivalent regular expression source, and boolean indicating
// whether the /u flag needs to be applied, and the number of chars
// consumed to parse the character class.
// This also removes out of order ranges, and returns ($.) if the
// entire class just no good.
const parseClass = (glob, position) => {
    const pos = position;
    /* c8 ignore start */
    if (glob.charAt(pos) !== '[') {
        throw new Error('not in a brace expression');
    }
    /* c8 ignore stop */
    const ranges = [];
    const negs = [];
    let i = pos + 1;
    let sawStart = false;
    let uflag = false;
    let escaping = false;
    let negate = false;
    let endPos = pos;
    let rangeStart = '';
    WHILE: while (i < glob.length) {
        const c = glob.charAt(i);
        if ((c === '!' || c === '^') && i === pos + 1) {
            negate = true;
            i++;
            continue;
        }
        if (c === ']' && sawStart && !escaping) {
            endPos = i + 1;
            break;
        }
        sawStart = true;
        if (c === '\\') {
            if (!escaping) {
                escaping = true;
                i++;
                continue;
            }
            // escaped \ char, fall through and treat like normal char
        }
        if (c === '[' && !escaping) {
            // either a posix class, a collation equivalent, or just a [
            for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
                if (glob.startsWith(cls, i)) {
                    // invalid, [a-[] is fine, but not [a-[:alpha]]
                    if (rangeStart) {
                        return ['$.', false, glob.length - pos, true];
                    }
                    i += cls.length;
                    if (neg)
                        negs.push(unip);
                    else
                        ranges.push(unip);
                    uflag = uflag || u;
                    continue WHILE;
                }
            }
        }
        // now it's just a normal character, effectively
        escaping = false;
        if (rangeStart) {
            // throw this range away if it's not valid, but others
            // can still match.
            if (c > rangeStart) {
                ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c));
            }
            else if (c === rangeStart) {
                ranges.push(braceEscape(c));
            }
            rangeStart = '';
            i++;
            continue;
        }
        // now might be the start of a range.
        // can be either c-d or c-] or c<more...>] or c] at this point
        if (glob.startsWith('-]', i + 1)) {
            ranges.push(braceEscape(c + '-'));
            i += 2;
            continue;
        }
        if (glob.startsWith('-', i + 1)) {
            rangeStart = c;
            i += 2;
            continue;
        }
        // not the start of a range, just a single character
        ranges.push(braceEscape(c));
        i++;
    }
    if (endPos < i) {
        // didn't see the end of the class, not a valid class,
        // but might still be valid as a literal match.
        return ['', false, 0, false];
    }
    // if we got no ranges and no negates, then we have a range that
    // cannot possibly match anything, and that poisons the whole glob
    if (!ranges.length && !negs.length) {
        return ['$.', false, glob.length - pos, true];
    }
    // if we got one positive range, and it's a single character, then that's
    // not actually a magic pattern, it's just that one literal character.
    // we should not treat that as "magic", we should just return the literal
    // character. [_] is a perfectly valid way to escape glob magic chars.
    if (negs.length === 0 &&
        ranges.length === 1 &&
        /^\\?.$/.test(ranges[0]) &&
        !negate) {
        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
        return [regexpEscape(r), false, endPos - pos, false];
    }
    const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']';
    const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']';
    const comb = ranges.length && negs.length
        ? '(' + sranges + '|' + snegs + ')'
        : ranges.length
            ? sranges
            : snegs;
    return [comb, uflag, endPos - pos, true];
};
braceExpressions.parseClass = parseClass;

var _unescape = {};

Object.defineProperty(_unescape, "__esModule", { value: true });
_unescape.unescape = void 0;
/**
 * Un-escape a string that has been escaped with {@link escape}.
 *
 * If the {@link windowsPathsNoEscape} option is used, then square-brace
 * escapes are removed, but not backslash escapes.  For example, it will turn
 * the string `'[*]'` into `*`, but it will not turn `'\\*'` into `'*'`,
 * becuase `\` is a path separator in `windowsPathsNoEscape` mode.
 *
 * When `windowsPathsNoEscape` is not set, then both brace escapes and
 * backslash escapes are removed.
 *
 * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped
 * or unescaped.
 */
const unescape$1 = (s, { windowsPathsNoEscape = false, } = {}) => {
    return windowsPathsNoEscape
        ? s.replace(/\[([^\/\\])\]/g, '$1')
        : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, '$1$2').replace(/\\([^\/])/g, '$1');
};
_unescape.unescape = unescape$1;

// parse a single path portion
Object.defineProperty(ast, "__esModule", { value: true });
ast.AST = void 0;
const brace_expressions_js_1 = braceExpressions;
const unescape_js_1 = _unescape;
const types = new Set(['!', '?', '+', '*', '@']);
const isExtglobType = (c) => types.has(c);
// Patterns that get prepended to bind to the start of either the
// entire string, or just a single path portion, to prevent dots
// and/or traversal patterns, when needed.
// Exts don't need the ^ or / bit, because the root binds that already.
const startNoTraversal = '(?!(?:^|/)\\.\\.?(?:$|/))';
const startNoDot = '(?!\\.)';
// characters that indicate a start of pattern needs the "no dots" bit,
// because a dot *might* be matched. ( is not in the list, because in
// the case of a child extglob, it will handle the prevention itself.
const addPatternStart = new Set(['[', '.']);
// cases where traversal is A-OK, no dot prevention needed
const justDots = new Set(['..', '.']);
const reSpecials = new Set('().*{}+?[]^$\\!');
const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
// any single thing other than /
const qmark = '[^/]';
// * => any number of characters
const star = qmark + '*?';
// use + when we need to ensure that *something* matches, because the * is
// the only thing in the path portion.
const starNoEmpty = qmark + '+?';
// remove the \ chars that we added if we end up doing a nonmagic compare
// const deslash = (s: string) => s.replace(/\\(.)/g, '$1')
class AST {
    type;
    #root;
    #hasMagic;
    #uflag = false;
    #parts = [];
    #parent;
    #parentIndex;
    #negs;
    #filledNegs = false;
    #options;
    #toString;
    // set to true if it's an extglob with no children
    // (which really means one child of '')
    #emptyExt = false;
    constructor(type, parent, options = {}) {
        this.type = type;
        // extglobs are inherently magical
        if (type)
            this.#hasMagic = true;
        this.#parent = parent;
        this.#root = this.#parent ? this.#parent.#root : this;
        this.#options = this.#root === this ? options : this.#root.#options;
        this.#negs = this.#root === this ? [] : this.#root.#negs;
        if (type === '!' && !this.#root.#filledNegs)
            this.#negs.push(this);
        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
    }
    get hasMagic() {
        /* c8 ignore start */
        if (this.#hasMagic !== undefined)
            return this.#hasMagic;
        /* c8 ignore stop */
        for (const p of this.#parts) {
            if (typeof p === 'string')
                continue;
            if (p.type || p.hasMagic)
                return (this.#hasMagic = true);
        }
        // note: will be undefined until we generate the regexp src and find out
        return this.#hasMagic;
    }
    // reconstructs the pattern
    toString() {
        if (this.#toString !== undefined)
            return this.#toString;
        if (!this.type) {
            return (this.#toString = this.#parts.map(p => String(p)).join(''));
        }
        else {
            return (this.#toString =
                this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')');
        }
    }
    #fillNegs() {
        /* c8 ignore start */
        if (this !== this.#root)
            throw new Error('should only call on root');
        if (this.#filledNegs)
            return this;
        /* c8 ignore stop */
        // call toString() once to fill this out
        this.toString();
        this.#filledNegs = true;
        let n;
        while ((n = this.#negs.pop())) {
            if (n.type !== '!')
                continue;
            // walk up the tree, appending everthing that comes AFTER parentIndex
            let p = n;
            let pp = p.#parent;
            while (pp) {
                for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {
                    for (const part of n.#parts) {
                        /* c8 ignore start */
                        if (typeof part === 'string') {
                            throw new Error('string part in extglob AST??');
                        }
                        /* c8 ignore stop */
                        part.copyIn(pp.#parts[i]);
                    }
                }
                p = pp;
                pp = p.#parent;
            }
        }
        return this;
    }
    push(...parts) {
        for (const p of parts) {
            if (p === '')
                continue;
            /* c8 ignore start */
            if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {
                throw new Error('invalid part: ' + p);
            }
            /* c8 ignore stop */
            this.#parts.push(p);
        }
    }
    toJSON() {
        const ret = this.type === null
            ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))
            : [this.type, ...this.#parts.map(p => p.toJSON())];
        if (this.isStart() && !this.type)
            ret.unshift([]);
        if (this.isEnd() &&
            (this === this.#root ||
                (this.#root.#filledNegs && this.#parent?.type === '!'))) {
            ret.push({});
        }
        return ret;
    }
    isStart() {
        if (this.#root === this)
            return true;
        // if (this.type) return !!this.#parent?.isStart()
        if (!this.#parent?.isStart())
            return false;
        if (this.#parentIndex === 0)
            return true;
        // if everything AHEAD of this is a negation, then it's still the "start"
        const p = this.#parent;
        for (let i = 0; i < this.#parentIndex; i++) {
            const pp = p.#parts[i];
            if (!(pp instanceof AST && pp.type === '!')) {
                return false;
            }
        }
        return true;
    }
    isEnd() {
        if (this.#root === this)
            return true;
        if (this.#parent?.type === '!')
            return true;
        if (!this.#parent?.isEnd())
            return false;
        if (!this.type)
            return this.#parent?.isEnd();
        // if not root, it'll always have a parent
        /* c8 ignore start */
        const pl = this.#parent ? this.#parent.#parts.length : 0;
        /* c8 ignore stop */
        return this.#parentIndex === pl - 1;
    }
    copyIn(part) {
        if (typeof part === 'string')
            this.push(part);
        else
            this.push(part.clone(this));
    }
    clone(parent) {
        const c = new AST(this.type, parent);
        for (const p of this.#parts) {
            c.copyIn(p);
        }
        return c;
    }
    static #parseAST(str, ast, pos, opt) {
        let escaping = false;
        let inBrace = false;
        let braceStart = -1;
        let braceNeg = false;
        if (ast.type === null) {
            // outside of a extglob, append until we find a start
            let i = pos;
            let acc = '';
            while (i < str.length) {
                const c = str.charAt(i++);
                // still accumulate escapes at this point, but we do ignore
                // starts that are escaped
                if (escaping || c === '\\') {
                    escaping = !escaping;
                    acc += c;
                    continue;
                }
                if (inBrace) {
                    if (i === braceStart + 1) {
                        if (c === '^' || c === '!') {
                            braceNeg = true;
                        }
                    }
                    else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
                        inBrace = false;
                    }
                    acc += c;
                    continue;
                }
                else if (c === '[') {
                    inBrace = true;
                    braceStart = i;
                    braceNeg = false;
                    acc += c;
                    continue;
                }
                if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {
                    ast.push(acc);
                    acc = '';
                    const ext = new AST(c, ast);
                    i = AST.#parseAST(str, ext, i, opt);
                    ast.push(ext);
                    continue;
                }
                acc += c;
            }
            ast.push(acc);
            return i;
        }
        // some kind of extglob, pos is at the (
        // find the next | or )
        let i = pos + 1;
        let part = new AST(null, ast);
        const parts = [];
        let acc = '';
        while (i < str.length) {
            const c = str.charAt(i++);
            // still accumulate escapes at this point, but we do ignore
            // starts that are escaped
            if (escaping || c === '\\') {
                escaping = !escaping;
                acc += c;
                continue;
            }
            if (inBrace) {
                if (i === braceStart + 1) {
                    if (c === '^' || c === '!') {
                        braceNeg = true;
                    }
                }
                else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
                    inBrace = false;
                }
                acc += c;
                continue;
            }
            else if (c === '[') {
                inBrace = true;
                braceStart = i;
                braceNeg = false;
                acc += c;
                continue;
            }
            if (isExtglobType(c) && str.charAt(i) === '(') {
                part.push(acc);
                acc = '';
                const ext = new AST(c, part);
                part.push(ext);
                i = AST.#parseAST(str, ext, i, opt);
                continue;
            }
            if (c === '|') {
                part.push(acc);
                acc = '';
                parts.push(part);
                part = new AST(null, ast);
                continue;
            }
            if (c === ')') {
                if (acc === '' && ast.#parts.length === 0) {
                    ast.#emptyExt = true;
                }
                part.push(acc);
                acc = '';
                ast.push(...parts, part);
                return i;
            }
            acc += c;
        }
        // unfinished extglob
        // if we got here, it was a malformed extglob! not an extglob, but
        // maybe something else in there.
        ast.type = null;
        ast.#hasMagic = undefined;
        ast.#parts = [str.substring(pos - 1)];
        return i;
    }
    static fromGlob(pattern, options = {}) {
        const ast = new AST(null, undefined, options);
        AST.#parseAST(pattern, ast, 0, options);
        return ast;
    }
    // returns the regular expression if there's magic, or the unescaped
    // string if not.
    toMMPattern() {
        // should only be called on root
        /* c8 ignore start */
        if (this !== this.#root)
            return this.#root.toMMPattern();
        /* c8 ignore stop */
        const glob = this.toString();
        const [re, body, hasMagic, uflag] = this.toRegExpSource();
        // if we're in nocase mode, and not nocaseMagicOnly, then we do
        // still need a regular expression if we have to case-insensitively
        // match capital/lowercase characters.
        const anyMagic = hasMagic ||
            this.#hasMagic ||
            (this.#options.nocase &&
                !this.#options.nocaseMagicOnly &&
                glob.toUpperCase() !== glob.toLowerCase());
        if (!anyMagic) {
            return body;
        }
        const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');
        return Object.assign(new RegExp(`^${re}$`, flags), {
            _src: re,
            _glob: glob,
        });
    }
    // returns the string match, the regexp source, whether there's magic
    // in the regexp (so a regular expression is required) and whether or
    // not the uflag is needed for the regular expression (for posix classes)
    // TODO: instead of injecting the start/end at this point, just return
    // the BODY of the regexp, along with the start/end portions suitable
    // for binding the start/end in either a joined full-path makeRe context
    // (where we bind to (^|/), or a standalone matchPart context (where
    // we bind to ^, and not /).  Otherwise slashes get duped!
    //
    // In part-matching mode, the start is:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: ^(?!\.\.?$)
    // - if dots allowed or not possible: ^
    // - if dots possible and not allowed: ^(?!\.)
    // end is:
    // - if not isEnd(): nothing
    // - else: $
    //
    // In full-path matching mode, we put the slash at the START of the
    // pattern, so start is:
    // - if first pattern: same as part-matching mode
    // - if not isStart(): nothing
    // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
    // - if dots allowed or not possible: /
    // - if dots possible and not allowed: /(?!\.)
    // end is:
    // - if last pattern, same as part-matching mode
    // - else nothing
    //
    // Always put the (?:$|/) on negated tails, though, because that has to be
    // there to bind the end of the negated pattern portion, and it's easier to
    // just stick it in now rather than try to inject it later in the middle of
    // the pattern.
    //
    // We can just always return the same end, and leave it up to the caller
    // to know whether it's going to be used joined or in parts.
    // And, if the start is adjusted slightly, can do the same there:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
    // - if dots allowed or not possible: (?:/|^)
    // - if dots possible and not allowed: (?:/|^)(?!\.)
    //
    // But it's better to have a simpler binding without a conditional, for
    // performance, so probably better to return both start options.
    //
    // Then the caller just ignores the end if it's not the first pattern,
    // and the start always gets applied.
    //
    // But that's always going to be $ if it's the ending pattern, or nothing,
    // so the caller can just attach $ at the end of the pattern when building.
    //
    // So the todo is:
    // - better detect what kind of start is needed
    // - return both flavors of starting pattern
    // - attach $ at the end of the pattern when creating the actual RegExp
    //
    // Ah, but wait, no, that all only applies to the root when the first pattern
    // is not an extglob. If the first pattern IS an extglob, then we need all
    // that dot prevention biz to live in the extglob portions, because eg
    // +(*|.x*) can match .xy but not .yx.
    //
    // So, return the two flavors if it's #root and the first child is not an
    // AST, otherwise leave it to the child AST to handle it, and there,
    // use the (?:^|/) style of start binding.
    //
    // Even simplified further:
    // - Since the start for a join is eg /(?!\.) and the start for a part
    // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
    // or start or whatever) and prepend ^ or / at the Regexp construction.
    toRegExpSource(allowDot) {
        const dot = allowDot ?? !!this.#options.dot;
        if (this.#root === this)
            this.#fillNegs();
        if (!this.type) {
            const noEmpty = this.isStart() && this.isEnd();
            const src = this.#parts
                .map(p => {
                const [re, _, hasMagic, uflag] = typeof p === 'string'
                    ? AST.#parseGlob(p, this.#hasMagic, noEmpty)
                    : p.toRegExpSource(allowDot);
                this.#hasMagic = this.#hasMagic || hasMagic;
                this.#uflag = this.#uflag || uflag;
                return re;
            })
                .join('');
            let start = '';
            if (this.isStart()) {
                if (typeof this.#parts[0] === 'string') {
                    // this is the string that will match the start of the pattern,
                    // so we need to protect against dots and such.
                    // '.' and '..' cannot match unless the pattern is that exactly,
                    // even if it starts with . or dot:true is set.
                    const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
                    if (!dotTravAllowed) {
                        const aps = addPatternStart;
                        // check if we have a possibility of matching . or ..,
                        // and prevent that.
                        const needNoTrav = 
                        // dots are allowed, and the pattern starts with [ or .
                        (dot && aps.has(src.charAt(0))) ||
                            // the pattern starts with \., and then [ or .
                            (src.startsWith('\\.') && aps.has(src.charAt(2))) ||
                            // the pattern starts with \.\., and then [ or .
                            (src.startsWith('\\.\\.') && aps.has(src.charAt(4)));
                        // no need to prevent dots if it can't match a dot, or if a
                        // sub-pattern will be preventing it anyway.
                        const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
                        start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : '';
                    }
                }
            }
            // append the "end of path portion" pattern to negation tails
            let end = '';
            if (this.isEnd() &&
                this.#root.#filledNegs &&
                this.#parent?.type === '!') {
                end = '(?:$|\\/)';
            }
            const final = start + src + end;
            return [
                final,
                (0, unescape_js_1.unescape)(src),
                (this.#hasMagic = !!this.#hasMagic),
                this.#uflag,
            ];
        }
        // We need to calculate the body *twice* if it's a repeat pattern
        // at the start, once in nodot mode, then again in dot mode, so a
        // pattern like *(?) can match 'x.y'
        const repeated = this.type === '*' || this.type === '+';
        // some kind of extglob
        const start = this.type === '!' ? '(?:(?!(?:' : '(?:';
        let body = this.#partsToRegExp(dot);
        if (this.isStart() && this.isEnd() && !body && this.type !== '!') {
            // invalid extglob, has to at least be *something* present, if it's
            // the entire path portion.
            const s = this.toString();
            this.#parts = [s];
            this.type = null;
            this.#hasMagic = undefined;
            return [s, (0, unescape_js_1.unescape)(this.toString()), false, false];
        }
        // XXX abstract out this map method
        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot
            ? ''
            : this.#partsToRegExp(true);
        if (bodyDotAllowed === body) {
            bodyDotAllowed = '';
        }
        if (bodyDotAllowed) {
            body = `(?:${body})(?:${bodyDotAllowed})*?`;
        }
        // an empty !() is exactly equivalent to a starNoEmpty
        let final = '';
        if (this.type === '!' && this.#emptyExt) {
            final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty;
        }
        else {
            const close = this.type === '!'
                ? // !() must match something,but !(x) can match ''
                    '))' +
                        (this.isStart() && !dot && !allowDot ? startNoDot : '') +
                        star +
                        ')'
                : this.type === '@'
                    ? ')'
                    : this.type === '?'
                        ? ')?'
                        : this.type === '+' && bodyDotAllowed
                            ? ')'
                            : this.type === '*' && bodyDotAllowed
                                ? `)?`
                                : `)${this.type}`;
            final = start + body + close;
        }
        return [
            final,
            (0, unescape_js_1.unescape)(body),
            (this.#hasMagic = !!this.#hasMagic),
            this.#uflag,
        ];
    }
    #partsToRegExp(dot) {
        return this.#parts
            .map(p => {
            // extglob ASTs should only contain parent ASTs
            /* c8 ignore start */
            if (typeof p === 'string') {
                throw new Error('string type in extglob ast??');
            }
            /* c8 ignore stop */
            // can ignore hasMagic, because extglobs are already always magic
            const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);
            this.#uflag = this.#uflag || uflag;
            return re;
        })
            .filter(p => !(this.isStart() && this.isEnd()) || !!p)
            .join('|');
    }
    static #parseGlob(glob, hasMagic, noEmpty = false) {
        let escaping = false;
        let re = '';
        let uflag = false;
        for (let i = 0; i < glob.length; i++) {
            const c = glob.charAt(i);
            if (escaping) {
                escaping = false;
                re += (reSpecials.has(c) ? '\\' : '') + c;
                continue;
            }
            if (c === '\\') {
                if (i === glob.length - 1) {
                    re += '\\\\';
                }
                else {
                    escaping = true;
                }
                continue;
            }
            if (c === '[') {
                const [src, needUflag, consumed, magic] = (0, brace_expressions_js_1.parseClass)(glob, i);
                if (consumed) {
                    re += src;
                    uflag = uflag || needUflag;
                    i += consumed - 1;
                    hasMagic = hasMagic || magic;
                    continue;
                }
            }
            if (c === '*') {
                if (noEmpty && glob === '*')
                    re += starNoEmpty;
                else
                    re += star;
                hasMagic = true;
                continue;
            }
            if (c === '?') {
                re += qmark;
                hasMagic = true;
                continue;
            }
            re += regExpEscape(c);
        }
        return [re, (0, unescape_js_1.unescape)(glob), !!hasMagic, uflag];
    }
}
ast.AST = AST;

var _escape = {};

Object.defineProperty(_escape, "__esModule", { value: true });
_escape.escape = void 0;
/**
 * Escape all magic characters in a glob pattern.
 *
 * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}
 * option is used, then characters are escaped by wrapping in `[]`, because
 * a magic character wrapped in a character class can only be satisfied by
 * that exact character.  In this mode, `\` is _not_ escaped, because it is
 * not interpreted as a magic character, but instead as a path separator.
 */
const escape$1 = (s, { windowsPathsNoEscape = false, } = {}) => {
    // don't need to escape +@! because we escape the parens
    // that make those magic, and escaping ! as [!] isn't valid,
    // because [!]] is a valid glob class meaning not ']'.
    return windowsPathsNoEscape
        ? s.replace(/[?*()[\]]/g, '[$&]')
        : s.replace(/[?*()[\]\\]/g, '\\$&');
};
_escape.escape = escape$1;

(function (exports) {
var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.unescape = exports.escape = exports.AST = exports.Minimatch = exports.match = exports.makeRe = exports.braceExpand = exports.defaults = exports.filter = exports.GLOBSTAR = exports.sep = exports.minimatch = void 0;
const brace_expansion_1 = __importDefault(braceExpansion);
const assert_valid_pattern_js_1 = assertValidPattern$1;
const ast_js_1 = ast;
const escape_js_1 = _escape;
const unescape_js_1 = _unescape;
const minimatch = (p, pattern, options = {}) => {
    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
    // shortcut: comments match nothing.
    if (!options.nocomment && pattern.charAt(0) === '#') {
        return false;
    }
    return new Minimatch(pattern, options).match(p);
};
exports.minimatch = minimatch;
// Optimized checking for the most common glob patterns.
const starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
const starDotExtTest = (ext) => (f) => !f.startsWith('.') && f.endsWith(ext);
const starDotExtTestDot = (ext) => (f) => f.endsWith(ext);
const starDotExtTestNocase = (ext) => {
    ext = ext.toLowerCase();
    return (f) => !f.startsWith('.') && f.toLowerCase().endsWith(ext);
};
const starDotExtTestNocaseDot = (ext) => {
    ext = ext.toLowerCase();
    return (f) => f.toLowerCase().endsWith(ext);
};
const starDotStarRE = /^\*+\.\*+$/;
const starDotStarTest = (f) => !f.startsWith('.') && f.includes('.');
const starDotStarTestDot = (f) => f !== '.' && f !== '..' && f.includes('.');
const dotStarRE = /^\.\*+$/;
const dotStarTest = (f) => f !== '.' && f !== '..' && f.startsWith('.');
const starRE = /^\*+$/;
const starTest = (f) => f.length !== 0 && !f.startsWith('.');
const starTestDot = (f) => f.length !== 0 && f !== '.' && f !== '..';
const qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
const qmarksTestNocase = ([$0, ext = '']) => {
    const noext = qmarksTestNoExt([$0]);
    if (!ext)
        return noext;
    ext = ext.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext);
};
const qmarksTestNocaseDot = ([$0, ext = '']) => {
    const noext = qmarksTestNoExtDot([$0]);
    if (!ext)
        return noext;
    ext = ext.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext);
};
const qmarksTestDot = ([$0, ext = '']) => {
    const noext = qmarksTestNoExtDot([$0]);
    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
};
const qmarksTest = ([$0, ext = '']) => {
    const noext = qmarksTestNoExt([$0]);
    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
};
const qmarksTestNoExt = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && !f.startsWith('.');
};
const qmarksTestNoExtDot = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && f !== '.' && f !== '..';
};
/* c8 ignore start */
const defaultPlatform = (typeof process === 'object' && process
    ? (typeof process.env === 'object' &&
        process.env &&
        process.env.__MINIMATCH_TESTING_PLATFORM__) ||
        process.platform
    : 'posix');
const path = {
    win32: { sep: '\\' },
    posix: { sep: '/' },
};
/* c8 ignore stop */
exports.sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep;
exports.minimatch.sep = exports.sep;
exports.GLOBSTAR = Symbol('globstar **');
exports.minimatch.GLOBSTAR = exports.GLOBSTAR;
// any single thing other than /
// don't need to escape / when using new RegExp()
const qmark = '[^/]';
// * => any number of characters
const star = qmark + '*?';
// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
const twoStarDot = '(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?';
// not a ^ or / followed by a dot,
// followed by anything, any number of times.
const twoStarNoDot = '(?:(?!(?:\\/|^)\\.).)*?';
const filter = (pattern, options = {}) => (p) => (0, exports.minimatch)(p, pattern, options);
exports.filter = filter;
exports.minimatch.filter = exports.filter;
const ext = (a, b = {}) => Object.assign({}, a, b);
const defaults = (def) => {
    if (!def || typeof def !== 'object' || !Object.keys(def).length) {
        return exports.minimatch;
    }
    const orig = exports.minimatch;
    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
    return Object.assign(m, {
        Minimatch: class Minimatch extends orig.Minimatch {
            constructor(pattern, options = {}) {
                super(pattern, ext(def, options));
            }
            static defaults(options) {
                return orig.defaults(ext(def, options)).Minimatch;
            }
        },
        AST: class AST extends orig.AST {
            /* c8 ignore start */
            constructor(type, parent, options = {}) {
                super(type, parent, ext(def, options));
            }
            /* c8 ignore stop */
            static fromGlob(pattern, options = {}) {
                return orig.AST.fromGlob(pattern, ext(def, options));
            }
        },
        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
        escape: (s, options = {}) => orig.escape(s, ext(def, options)),
        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
        defaults: (options) => orig.defaults(ext(def, options)),
        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
        sep: orig.sep,
        GLOBSTAR: exports.GLOBSTAR,
    });
};
exports.defaults = defaults;
exports.minimatch.defaults = exports.defaults;
// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
const braceExpand = (pattern, options = {}) => {
    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
    // Thanks to Yeting Li <https://github.com/yetingli> for
    // improving this regexp to avoid a ReDOS vulnerability.
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        // shortcut. no need to expand.
        return [pattern];
    }
    return (0, brace_expansion_1.default)(pattern);
};
exports.braceExpand = braceExpand;
exports.minimatch.braceExpand = exports.braceExpand;
// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
const makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
exports.makeRe = makeRe;
exports.minimatch.makeRe = exports.makeRe;
const match = (list, pattern, options = {}) => {
    const mm = new Minimatch(pattern, options);
    list = list.filter(f => mm.match(f));
    if (mm.options.nonull && !list.length) {
        list.push(pattern);
    }
    return list;
};
exports.match = match;
exports.minimatch.match = exports.match;
// replace stuff like \* with *
const globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
class Minimatch {
    options;
    set;
    pattern;
    windowsPathsNoEscape;
    nonegate;
    negate;
    comment;
    empty;
    preserveMultipleSlashes;
    partial;
    globSet;
    globParts;
    nocase;
    isWindows;
    platform;
    windowsNoMagicRoot;
    regexp;
    constructor(pattern, options = {}) {
        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
        options = options || {};
        this.options = options;
        this.pattern = pattern;
        this.platform = options.platform || defaultPlatform;
        this.isWindows = this.platform === 'win32';
        this.windowsPathsNoEscape =
            !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
            this.pattern = this.pattern.replace(/\\/g, '/');
        }
        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
        this.regexp = null;
        this.negate = false;
        this.nonegate = !!options.nonegate;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.nocase = !!this.options.nocase;
        this.windowsNoMagicRoot =
            options.windowsNoMagicRoot !== undefined
                ? options.windowsNoMagicRoot
                : !!(this.isWindows && this.nocase);
        this.globSet = [];
        this.globParts = [];
        this.set = [];
        // make the set of regexps etc.
        this.make();
    }
    hasMagic() {
        if (this.options.magicalBraces && this.set.length > 1) {
            return true;
        }
        for (const pattern of this.set) {
            for (const part of pattern) {
                if (typeof part !== 'string')
                    return true;
            }
        }
        return false;
    }
    debug(..._) { }
    make() {
        const pattern = this.pattern;
        const options = this.options;
        // empty patterns and comments match nothing.
        if (!options.nocomment && pattern.charAt(0) === '#') {
            this.comment = true;
            return;
        }
        if (!pattern) {
            this.empty = true;
            return;
        }
        // step 1: figure out negation, etc.
        this.parseNegate();
        // step 2: expand braces
        this.globSet = [...new Set(this.braceExpand())];
        if (options.debug) {
            this.debug = (...args) => console.error(...args);
        }
        this.debug(this.pattern, this.globSet);
        // step 3: now we have a set, so turn each one into a series of
        // path-portion matching patterns.
        // These will be regexps, except in the case of "**", which is
        // set to the GLOBSTAR object for globstar behavior,
        // and will not contain any / characters
        //
        // First, we preprocess to make the glob pattern sets a bit simpler
        // and deduped.  There are some perf-killing patterns that can cause
        // problems with a glob walk, but we can simplify them down a bit.
        const rawGlobParts = this.globSet.map(s => this.slashSplit(s));
        this.globParts = this.preprocess(rawGlobParts);
        this.debug(this.pattern, this.globParts);
        // glob --> regexps
        let set = this.globParts.map((s, _, __) => {
            if (this.isWindows && this.windowsNoMagicRoot) {
                // check if it's a drive or unc path.
                const isUNC = s[0] === '' &&
                    s[1] === '' &&
                    (s[2] === '?' || !globMagic.test(s[2])) &&
                    !globMagic.test(s[3]);
                const isDrive = /^[a-z]:/i.test(s[0]);
                if (isUNC) {
                    return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];
                }
                else if (isDrive) {
                    return [s[0], ...s.slice(1).map(ss => this.parse(ss))];
                }
            }
            return s.map(ss => this.parse(ss));
        });
        this.debug(this.pattern, set);
        // filter out everything that didn't compile properly.
        this.set = set.filter(s => s.indexOf(false) === -1);
        // do not treat the ? in UNC paths as magic
        if (this.isWindows) {
            for (let i = 0; i < this.set.length; i++) {
                const p = this.set[i];
                if (p[0] === '' &&
                    p[1] === '' &&
                    this.globParts[i][2] === '?' &&
                    typeof p[3] === 'string' &&
                    /^[a-z]:$/i.test(p[3])) {
                    p[2] = '?';
                }
            }
        }
        this.debug(this.pattern, this.set);
    }
    // various transforms to equivalent pattern sets that are
    // faster to process in a filesystem walk.  The goal is to
    // eliminate what we can, and push all ** patterns as far
    // to the right as possible, even if it increases the number
    // of patterns that we have to process.
    preprocess(globParts) {
        // if we're not in globstar mode, then turn all ** into *
        if (this.options.noglobstar) {
            for (let i = 0; i < globParts.length; i++) {
                for (let j = 0; j < globParts[i].length; j++) {
                    if (globParts[i][j] === '**') {
                        globParts[i][j] = '*';
                    }
                }
            }
        }
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
            // aggressive optimization for the purpose of fs walking
            globParts = this.firstPhasePreProcess(globParts);
            globParts = this.secondPhasePreProcess(globParts);
        }
        else if (optimizationLevel >= 1) {
            // just basic optimizations to remove some .. parts
            globParts = this.levelOneOptimize(globParts);
        }
        else {
            globParts = this.adjascentGlobstarOptimize(globParts);
        }
        return globParts;
    }
    // just get rid of adjascent ** portions
    adjascentGlobstarOptimize(globParts) {
        return globParts.map(parts => {
            let gs = -1;
            while (-1 !== (gs = parts.indexOf('**', gs + 1))) {
                let i = gs;
                while (parts[i + 1] === '**') {
                    i++;
                }
                if (i !== gs) {
                    parts.splice(gs, i - gs);
                }
            }
            return parts;
        });
    }
    // get rid of adjascent ** and resolve .. portions
    levelOneOptimize(globParts) {
        return globParts.map(parts => {
            parts = parts.reduce((set, part) => {
                const prev = set[set.length - 1];
                if (part === '**' && prev === '**') {
                    return set;
                }
                if (part === '..') {
                    if (prev && prev !== '..' && prev !== '.' && prev !== '**') {
                        set.pop();
                        return set;
                    }
                }
                set.push(part);
                return set;
            }, []);
            return parts.length === 0 ? [''] : parts;
        });
    }
    levelTwoFileOptimize(parts) {
        if (!Array.isArray(parts)) {
            parts = this.slashSplit(parts);
        }
        let didSomething = false;
        do {
            didSomething = false;
            // <pre>/<e>/<rest> -> <pre>/<rest>
            if (!this.preserveMultipleSlashes) {
                for (let i = 1; i < parts.length - 1; i++) {
                    const p = parts[i];
                    // don't squeeze out UNC patterns
                    if (i === 1 && p === '' && parts[0] === '')
                        continue;
                    if (p === '.' || p === '') {
                        didSomething = true;
                        parts.splice(i, 1);
                        i--;
                    }
                }
                if (parts[0] === '.' &&
                    parts.length === 2 &&
                    (parts[1] === '.' || parts[1] === '')) {
                    didSomething = true;
                    parts.pop();
                }
            }
            // <pre>/<p>/../<rest> -> <pre>/<rest>
            let dd = 0;
            while (-1 !== (dd = parts.indexOf('..', dd + 1))) {
                const p = parts[dd - 1];
                if (p && p !== '.' && p !== '..' && p !== '**') {
                    didSomething = true;
                    parts.splice(dd - 1, 2);
                    dd -= 2;
                }
            }
        } while (didSomething);
        return parts.length === 0 ? [''] : parts;
    }
    // First phase: single-pattern processing
    // <pre> is 1 or more portions
    // <rest> is 1 or more portions
    // <p> is any portion other than ., .., '', or **
    // <e> is . or ''
    //
    // **/.. is *brutal* for filesystem walking performance, because
    // it effectively resets the recursive walk each time it occurs,
    // and ** cannot be reduced out by a .. pattern part like a regexp
    // or most strings (other than .., ., and '') can be.
    //
    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
    // <pre>/<e>/<rest> -> <pre>/<rest>
    // <pre>/<p>/../<rest> -> <pre>/<rest>
    // **/**/<rest> -> **/<rest>
    //
    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
    // this WOULD be allowed if ** did follow symlinks, or * didn't
    firstPhasePreProcess(globParts) {
        let didSomething = false;
        do {
            didSomething = false;
            // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
            for (let parts of globParts) {
                let gs = -1;
                while (-1 !== (gs = parts.indexOf('**', gs + 1))) {
                    let gss = gs;
                    while (parts[gss + 1] === '**') {
                        // <pre>/**/**/<rest> -> <pre>/**/<rest>
                        gss++;
                    }
                    // eg, if gs is 2 and gss is 4, that means we have 3 **
                    // parts, and can remove 2 of them.
                    if (gss > gs) {
                        parts.splice(gs + 1, gss - gs);
                    }
                    let next = parts[gs + 1];
                    const p = parts[gs + 2];
                    const p2 = parts[gs + 3];
                    if (next !== '..')
                        continue;
                    if (!p ||
                        p === '.' ||
                        p === '..' ||
                        !p2 ||
                        p2 === '.' ||
                        p2 === '..') {
                        continue;
                    }
                    didSomething = true;
                    // edit parts in place, and push the new one
                    parts.splice(gs, 1);
                    const other = parts.slice(0);
                    other[gs] = '**';
                    globParts.push(other);
                    gs--;
                }
                // <pre>/<e>/<rest> -> <pre>/<rest>
                if (!this.preserveMultipleSlashes) {
                    for (let i = 1; i < parts.length - 1; i++) {
                        const p = parts[i];
                        // don't squeeze out UNC patterns
                        if (i === 1 && p === '' && parts[0] === '')
                            continue;
                        if (p === '.' || p === '') {
                            didSomething = true;
                            parts.splice(i, 1);
                            i--;
                        }
                    }
                    if (parts[0] === '.' &&
                        parts.length === 2 &&
                        (parts[1] === '.' || parts[1] === '')) {
                        didSomething = true;
                        parts.pop();
                    }
                }
                // <pre>/<p>/../<rest> -> <pre>/<rest>
                let dd = 0;
                while (-1 !== (dd = parts.indexOf('..', dd + 1))) {
                    const p = parts[dd - 1];
                    if (p && p !== '.' && p !== '..' && p !== '**') {
                        didSomething = true;
                        const needDot = dd === 1 && parts[dd + 1] === '**';
                        const splin = needDot ? ['.'] : [];
                        parts.splice(dd - 1, 2, ...splin);
                        if (parts.length === 0)
                            parts.push('');
                        dd -= 2;
                    }
                }
            }
        } while (didSomething);
        return globParts;
    }
    // second phase: multi-pattern dedupes
    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
    //
    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
    // ^-- not valid because ** doens't follow symlinks
    secondPhasePreProcess(globParts) {
        for (let i = 0; i < globParts.length - 1; i++) {
            for (let j = i + 1; j < globParts.length; j++) {
                const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
                if (!matched)
                    continue;
                globParts[i] = matched;
                globParts[j] = [];
            }
        }
        return globParts.filter(gs => gs.length);
    }
    partsMatch(a, b, emptyGSMatch = false) {
        let ai = 0;
        let bi = 0;
        let result = [];
        let which = '';
        while (ai < a.length && bi < b.length) {
            if (a[ai] === b[bi]) {
                result.push(which === 'b' ? b[bi] : a[ai]);
                ai++;
                bi++;
            }
            else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {
                result.push(a[ai]);
                ai++;
            }
            else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {
                result.push(b[bi]);
                bi++;
            }
            else if (a[ai] === '*' &&
                b[bi] &&
                (this.options.dot || !b[bi].startsWith('.')) &&
                b[bi] !== '**') {
                if (which === 'b')
                    return false;
                which = 'a';
                result.push(a[ai]);
                ai++;
                bi++;
            }
            else if (b[bi] === '*' &&
                a[ai] &&
                (this.options.dot || !a[ai].startsWith('.')) &&
                a[ai] !== '**') {
                if (which === 'a')
                    return false;
                which = 'b';
                result.push(b[bi]);
                ai++;
                bi++;
            }
            else {
                return false;
            }
        }
        // if we fall out of the loop, it means they two are identical
        // as long as their lengths match
        return a.length === b.length && result;
    }
    parseNegate() {
        if (this.nonegate)
            return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {
            negate = !negate;
            negateOffset++;
        }
        if (negateOffset)
            this.pattern = pattern.slice(negateOffset);
        this.negate = negate;
    }
    // set partial to true to test if, for example,
    // "/a/b" matches the start of "/*/b/*/d"
    // Partial means, if you run out of file before you run
    // out of pattern, then that's fine, as long as all
    // the parts match.
    matchOne(file, pattern, partial = false) {
        const options = this.options;
        // UNC paths like //?/X:/... can match X:/... and vice versa
        // Drive letters in absolute drive or unc paths are always compared
        // case-insensitively.
        if (this.isWindows) {
            const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);
            const fileUNC = !fileDrive &&
                file[0] === '' &&
                file[1] === '' &&
                file[2] === '?' &&
                /^[a-z]:$/i.test(file[3]);
            const patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);
            const patternUNC = !patternDrive &&
                pattern[0] === '' &&
                pattern[1] === '' &&
                pattern[2] === '?' &&
                typeof pattern[3] === 'string' &&
                /^[a-z]:$/i.test(pattern[3]);
            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;
            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;
            if (typeof fdi === 'number' && typeof pdi === 'number') {
                const [fd, pd] = [file[fdi], pattern[pdi]];
                if (fd.toLowerCase() === pd.toLowerCase()) {
                    pattern[pdi] = fd;
                    if (pdi > fdi) {
                        pattern = pattern.slice(pdi);
                    }
                    else if (fdi > pdi) {
                        file = file.slice(fdi);
                    }
                }
            }
        }
        // resolve and reduce . and .. portions in the file as well.
        // dont' need to do the second phase, because it's only one string[]
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
            file = this.levelTwoFileOptimize(file);
        }
        this.debug('matchOne', this, { file, pattern });
        this.debug('matchOne', file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
            this.debug('matchOne loop');
            var p = pattern[pi];
            var f = file[fi];
            this.debug(pattern, p, f);
            // should be impossible.
            // some invalid regexp stuff in the set.
            /* c8 ignore start */
            if (p === false) {
                return false;
            }
            /* c8 ignore stop */
            if (p === exports.GLOBSTAR) {
                this.debug('GLOBSTAR', [pattern, p, f]);
                // "**"
                // a/**/b/**/c would match the following:
                // a/b/x/y/z/c
                // a/x/y/z/b/c
                // a/b/x/b/x/c
                // a/b/c
                // To do this, take the rest of the pattern after
                // the **, and see if it would match the file remainder.
                // If so, return success.
                // If not, the ** "swallows" a segment, and try again.
                // This is recursively awful.
                //
                // a/**/b/**/c matching a/b/x/y/z/c
                // - a matches a
                // - doublestar
                //   - matchOne(b/x/y/z/c, b/**/c)
                //     - b matches b
                //     - doublestar
                //       - matchOne(x/y/z/c, c) -> no
                //       - matchOne(y/z/c, c) -> no
                //       - matchOne(z/c, c) -> no
                //       - matchOne(c, c) yes, hit
                var fr = fi;
                var pr = pi + 1;
                if (pr === pl) {
                    this.debug('** at the end');
                    // a ** at the end will just swallow the rest.
                    // We have found a match.
                    // however, it will not swallow /.x, unless
                    // options.dot is set.
                    // . and .. are *never* matched by **, for explosively
                    // exponential reasons.
                    for (; fi < fl; fi++) {
                        if (file[fi] === '.' ||
                            file[fi] === '..' ||
                            (!options.dot && file[fi].charAt(0) === '.'))
                            return false;
                    }
                    return true;
                }
                // ok, let's see if we can swallow whatever we can.
                while (fr < fl) {
                    var swallowee = file[fr];
                    this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);
                    // XXX remove this slice.  Just pass the start index.
                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                        this.debug('globstar found match!', fr, fl, swallowee);
                        // found a match.
                        return true;
                    }
                    else {
                        // can't swallow "." or ".." ever.
                        // can only swallow ".foo" when explicitly asked.
                        if (swallowee === '.' ||
                            swallowee === '..' ||
                            (!options.dot && swallowee.charAt(0) === '.')) {
                            this.debug('dot detected!', file, fr, pattern, pr);
                            break;
                        }
                        // ** swallows a segment, and continue.
                        this.debug('globstar swallow a segment, and continue');
                        fr++;
                    }
                }
                // no match was found.
                // However, in partial mode, we can't say this is necessarily over.
                /* c8 ignore start */
                if (partial) {
                    // ran out of file
                    this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
                    if (fr === fl) {
                        return true;
                    }
                }
                /* c8 ignore stop */
                return false;
            }
            // something other than **
            // non-magic patterns just have to match exactly
            // patterns with magic have been turned into regexps.
            let hit;
            if (typeof p === 'string') {
                hit = f === p;
                this.debug('string match', p, f, hit);
            }
            else {
                hit = p.test(f);
                this.debug('pattern match', p, f, hit);
            }
            if (!hit)
                return false;
        }
        // Note: ending in / means that we'll get a final ""
        // at the end of the pattern.  This can only match a
        // corresponding "" at the end of the file.
        // If the file ends in /, then it can only match a
        // a pattern that ends in /, unless the pattern just
        // doesn't have any more for it. But, a/b/ should *not*
        // match "a/b/*", even though "" matches against the
        // [^/]*? pattern, except in partial mode, where it might
        // simply not be reached yet.
        // However, a/b/ should still satisfy a/*
        // now either we fell off the end of the pattern, or we're done.
        if (fi === fl && pi === pl) {
            // ran out of pattern and filename at the same time.
            // an exact hit!
            return true;
        }
        else if (fi === fl) {
            // ran out of file, but still had pattern left.
            // this is ok if we're doing the match as part of
            // a glob fs traversal.
            return partial;
        }
        else if (pi === pl) {
            // ran out of pattern, still have file left.
            // this is only acceptable if we're on the very last
            // empty segment of a file with a trailing slash.
            // a/* should match a/b/
            return fi === fl - 1 && file[fi] === '';
            /* c8 ignore start */
        }
        else {
            // should be unreachable.
            throw new Error('wtf?');
        }
        /* c8 ignore stop */
    }
    braceExpand() {
        return (0, exports.braceExpand)(this.pattern, this.options);
    }
    parse(pattern) {
        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
        const options = this.options;
        // shortcuts
        if (pattern === '**')
            return exports.GLOBSTAR;
        if (pattern === '')
            return '';
        // far and away, the most common glob pattern parts are
        // *, *.*, and *.<ext>  Add a fast check method for those.
        let m;
        let fastTest = null;
        if ((m = pattern.match(starRE))) {
            fastTest = options.dot ? starTestDot : starTest;
        }
        else if ((m = pattern.match(starDotExtRE))) {
            fastTest = (options.nocase
                ? options.dot
                    ? starDotExtTestNocaseDot
                    : starDotExtTestNocase
                : options.dot
                    ? starDotExtTestDot
                    : starDotExtTest)(m[1]);
        }
        else if ((m = pattern.match(qmarksRE))) {
            fastTest = (options.nocase
                ? options.dot
                    ? qmarksTestNocaseDot
                    : qmarksTestNocase
                : options.dot
                    ? qmarksTestDot
                    : qmarksTest)(m);
        }
        else if ((m = pattern.match(starDotStarRE))) {
            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
        }
        else if ((m = pattern.match(dotStarRE))) {
            fastTest = dotStarTest;
        }
        const re = ast_js_1.AST.fromGlob(pattern, this.options).toMMPattern();
        return fastTest ? Object.assign(re, { test: fastTest }) : re;
    }
    makeRe() {
        if (this.regexp || this.regexp === false)
            return this.regexp;
        // at this point, this.set is a 2d array of partial
        // pattern strings, or "**".
        //
        // It's better to use .match().  This function shouldn't
        // be used, really, but it's pretty convenient sometimes,
        // when you just want to work with a regex.
        const set = this.set;
        if (!set.length) {
            this.regexp = false;
            return this.regexp;
        }
        const options = this.options;
        const twoStar = options.noglobstar
            ? star
            : options.dot
                ? twoStarDot
                : twoStarNoDot;
        const flags = new Set(options.nocase ? ['i'] : []);
        // regexpify non-globstar patterns
        // if ** is only item, then we just do one twoStar
        // if ** is first, and there are more, prepend (\/|twoStar\/)? to next
        // if ** is last, append (\/twoStar|) to previous
        // if ** is in the middle, append (\/|\/twoStar\/) to previous
        // then filter out GLOBSTAR symbols
        let re = set
            .map(pattern => {
            const pp = pattern.map(p => {
                if (p instanceof RegExp) {
                    for (const f of p.flags.split(''))
                        flags.add(f);
                }
                return typeof p === 'string'
                    ? regExpEscape(p)
                    : p === exports.GLOBSTAR
                        ? exports.GLOBSTAR
                        : p._src;
            });
            pp.forEach((p, i) => {
                const next = pp[i + 1];
                const prev = pp[i - 1];
                if (p !== exports.GLOBSTAR || prev === exports.GLOBSTAR) {
                    return;
                }
                if (prev === undefined) {
                    if (next !== undefined && next !== exports.GLOBSTAR) {
                        pp[i + 1] = '(?:\\/|' + twoStar + '\\/)?' + next;
                    }
                    else {
                        pp[i] = twoStar;
                    }
                }
                else if (next === undefined) {
                    pp[i - 1] = prev + '(?:\\/|' + twoStar + ')?';
                }
                else if (next !== exports.GLOBSTAR) {
                    pp[i - 1] = prev + '(?:\\/|\\/' + twoStar + '\\/)' + next;
                    pp[i + 1] = exports.GLOBSTAR;
                }
            });
            return pp.filter(p => p !== exports.GLOBSTAR).join('/');
        })
            .join('|');
        // need to wrap in parens if we had more than one thing with |,
        // otherwise only the first will be anchored to ^ and the last to $
        const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];
        // must match entire pattern
        // ending in a * or ** will make it less strict.
        re = '^' + open + re + close + '$';
        // can match anything, as long as it's not this.
        if (this.negate)
            re = '^(?!' + re + ').+$';
        try {
            this.regexp = new RegExp(re, [...flags].join(''));
            /* c8 ignore start */
        }
        catch (ex) {
            // should be impossible
            this.regexp = false;
        }
        /* c8 ignore stop */
        return this.regexp;
    }
    slashSplit(p) {
        // if p starts with // on windows, we preserve that
        // so that UNC paths aren't broken.  Otherwise, any number of
        // / characters are coalesced into one, unless
        // preserveMultipleSlashes is set to true.
        if (this.preserveMultipleSlashes) {
            return p.split('/');
        }
        else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
            // add an extra '' for the one we lose
            return ['', ...p.split(/\/+/)];
        }
        else {
            return p.split(/\/+/);
        }
    }
    match(f, partial = this.partial) {
        this.debug('match', f, this.pattern);
        // short-circuit in the case of busted things.
        // comments, etc.
        if (this.comment) {
            return false;
        }
        if (this.empty) {
            return f === '';
        }
        if (f === '/' && partial) {
            return true;
        }
        const options = this.options;
        // windows: need to use /, not \
        if (this.isWindows) {
            f = f.split('\\').join('/');
        }
        // treat the test path as a set of pathparts.
        const ff = this.slashSplit(f);
        this.debug(this.pattern, 'split', ff);
        // just ONE of the pattern sets in this.set needs to match
        // in order for it to be valid.  If negating, then just one
        // match means that we have failed.
        // Either way, return on the first hit.
        const set = this.set;
        this.debug(this.pattern, 'set', set);
        // Find the basename of the path by looking for the last non-empty segment
        let filename = ff[ff.length - 1];
        if (!filename) {
            for (let i = ff.length - 2; !filename && i >= 0; i--) {
                filename = ff[i];
            }
        }
        for (let i = 0; i < set.length; i++) {
            const pattern = set[i];
            let file = ff;
            if (options.matchBase && pattern.length === 1) {
                file = [filename];
            }
            const hit = this.matchOne(file, pattern, partial);
            if (hit) {
                if (options.flipNegate) {
                    return true;
                }
                return !this.negate;
            }
        }
        // didn't get any hits.  this is success if it's a negative
        // pattern, failure otherwise.
        if (options.flipNegate) {
            return false;
        }
        return this.negate;
    }
    static defaults(def) {
        return exports.minimatch.defaults(def).Minimatch;
    }
}
exports.Minimatch = Minimatch;
/* c8 ignore start */
var ast_js_2 = ast;
Object.defineProperty(exports, "AST", { enumerable: true, get: function () { return ast_js_2.AST; } });
var escape_js_2 = _escape;
Object.defineProperty(exports, "escape", { enumerable: true, get: function () { return escape_js_2.escape; } });
var unescape_js_2 = _unescape;
Object.defineProperty(exports, "unescape", { enumerable: true, get: function () { return unescape_js_2.unescape; } });
/* c8 ignore stop */
exports.minimatch.AST = ast_js_1.AST;
exports.minimatch.Minimatch = Minimatch;
exports.minimatch.escape = escape_js_1.escape;
exports.minimatch.unescape = unescape_js_1.unescape;

}(cjs$2));

var glob$1 = {};

var cjs$1 = {};

var cjs = {};

/**
 * @module LRUCache
 */
Object.defineProperty(cjs, "__esModule", { value: true });
cjs.LRUCache = void 0;
const perf = typeof performance === 'object' &&
    performance &&
    typeof performance.now === 'function'
    ? performance
    : Date;
const warned = new Set();
/* c8 ignore start */
const PROCESS = (typeof process === 'object' && !!process ? process : {});
/* c8 ignore start */
const emitWarning = (msg, type, code, fn) => {
    typeof PROCESS.emitWarning === 'function'
        ? PROCESS.emitWarning(msg, type, code, fn)
        : console.error(`[${code}] ${type}: ${msg}`);
};
let AC = globalThis.AbortController;
let AS = globalThis.AbortSignal;
/* c8 ignore start */
if (typeof AC === 'undefined') {
    //@ts-ignore
    AS = class AbortSignal {
        onabort;
        _onabort = [];
        reason;
        aborted = false;
        addEventListener(_, fn) {
            this._onabort.push(fn);
        }
    };
    //@ts-ignore
    AC = class AbortController {
        constructor() {
            warnACPolyfill();
        }
        signal = new AS();
        abort(reason) {
            if (this.signal.aborted)
                return;
            //@ts-ignore
            this.signal.reason = reason;
            //@ts-ignore
            this.signal.aborted = true;
            //@ts-ignore
            for (const fn of this.signal._onabort) {
                fn(reason);
            }
            this.signal.onabort?.(reason);
        }
    };
    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';
    const warnACPolyfill = () => {
        if (!printACPolyfillWarning)
            return;
        printACPolyfillWarning = false;
        emitWarning('AbortController is not defined. If using lru-cache in ' +
            'node 14, load an AbortController polyfill from the ' +
            '`node-abort-controller` package. A minimal polyfill is ' +
            'provided for use by LRUCache.fetch(), but it should not be ' +
            'relied upon in other contexts (eg, passing it to other APIs that ' +
            'use AbortController/AbortSignal might have undesirable effects). ' +
            'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);
    };
}
/* c8 ignore stop */
const shouldWarn = (code) => !warned.has(code);
const isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
/* c8 ignore start */
// This is a little bit ridiculous, tbh.
// The maximum array length is 2^32-1 or thereabouts on most JS impls.
// And well before that point, you're caching the entire world, I mean,
// that's ~32GB of just integers for the next/prev links, plus whatever
// else to hold that many keys and values.  Just filling the memory with
// zeroes at init time is brutal when you get that big.
// But why not be complete?
// Maybe in the future, these limits will have expanded.
const getUintArray = (max) => !isPosInt(max)
    ? null
    : max <= Math.pow(2, 8)
        ? Uint8Array
        : max <= Math.pow(2, 16)
            ? Uint16Array
            : max <= Math.pow(2, 32)
                ? Uint32Array
                : max <= Number.MAX_SAFE_INTEGER
                    ? ZeroArray
                    : null;
/* c8 ignore stop */
class ZeroArray extends Array {
    constructor(size) {
        super(size);
        this.fill(0);
    }
}
class Stack$1 {
    heap;
    length;
    // private constructor
    static #constructing = false;
    static create(max) {
        const HeapCls = getUintArray(max);
        if (!HeapCls)
            return [];
        Stack$1.#constructing = true;
        const s = new Stack$1(max, HeapCls);
        Stack$1.#constructing = false;
        return s;
    }
    constructor(max, HeapCls) {
        /* c8 ignore start */
        if (!Stack$1.#constructing) {
            throw new TypeError('instantiate Stack using Stack.create(n)');
        }
        /* c8 ignore stop */
        this.heap = new HeapCls(max);
        this.length = 0;
    }
    push(n) {
        this.heap[this.length++] = n;
    }
    pop() {
        return this.heap[--this.length];
    }
}
/**
 * Default export, the thing you're using this module to get.
 *
 * All properties from the options object (with the exception of
 * {@link OptionsBase.max} and {@link OptionsBase.maxSize}) are added as
 * normal public members. (`max` and `maxBase` are read-only getters.)
 * Changing any of these will alter the defaults for subsequent method calls,
 * but is otherwise safe.
 */
class LRUCache$1 {
    // properties coming in from the options of these, only max and maxSize
    // really *need* to be protected. The rest can be modified, as they just
    // set defaults for various methods.
    #max;
    #maxSize;
    #dispose;
    #disposeAfter;
    #fetchMethod;
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    ttl;
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    ttlResolution;
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    ttlAutopurge;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    updateAgeOnGet;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    updateAgeOnHas;
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    allowStale;
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    noDisposeOnSet;
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    noUpdateTTL;
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    maxEntrySize;
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    sizeCalculation;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    noDeleteOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    noDeleteOnStaleGet;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    allowStaleOnFetchAbort;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    allowStaleOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    ignoreFetchAbort;
    // computed properties
    #size;
    #calculatedSize;
    #keyMap;
    #keyList;
    #valList;
    #next;
    #prev;
    #head;
    #tail;
    #free;
    #disposed;
    #sizes;
    #starts;
    #ttls;
    #hasDispose;
    #hasFetchMethod;
    #hasDisposeAfter;
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */
    static unsafeExposeInternals(c) {
        return {
            // properties
            starts: c.#starts,
            ttls: c.#ttls,
            sizes: c.#sizes,
            keyMap: c.#keyMap,
            keyList: c.#keyList,
            valList: c.#valList,
            next: c.#next,
            prev: c.#prev,
            get head() {
                return c.#head;
            },
            get tail() {
                return c.#tail;
            },
            free: c.#free,
            // methods
            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
            backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
            moveToTail: (index) => c.#moveToTail(index),
            indexes: (options) => c.#indexes(options),
            rindexes: (options) => c.#rindexes(options),
            isStale: (index) => c.#isStale(index),
        };
    }
    // Protected read-only members
    /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */
    get max() {
        return this.#max;
    }
    /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */
    get maxSize() {
        return this.#maxSize;
    }
    /**
     * The total computed size of items in the cache (read-only)
     */
    get calculatedSize() {
        return this.#calculatedSize;
    }
    /**
     * The number of items stored in the cache (read-only)
     */
    get size() {
        return this.#size;
    }
    /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */
    get fetchMethod() {
        return this.#fetchMethod;
    }
    /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */
    get dispose() {
        return this.#dispose;
    }
    /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */
    get disposeAfter() {
        return this.#disposeAfter;
    }
    constructor(options) {
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, } = options;
        if (max !== 0 && !isPosInt(max)) {
            throw new TypeError('max option must be a nonnegative integer');
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
            throw new Error('invalid max value: ' + max);
        }
        this.#max = max;
        this.#maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.#maxSize;
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
            if (!this.#maxSize && !this.maxEntrySize) {
                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');
            }
            if (typeof this.sizeCalculation !== 'function') {
                throw new TypeError('sizeCalculation set to non-function');
            }
        }
        if (fetchMethod !== undefined &&
            typeof fetchMethod !== 'function') {
            throw new TypeError('fetchMethod must be a function if specified');
        }
        this.#fetchMethod = fetchMethod;
        this.#hasFetchMethod = !!fetchMethod;
        this.#keyMap = new Map();
        this.#keyList = new Array(max).fill(undefined);
        this.#valList = new Array(max).fill(undefined);
        this.#next = new UintArray(max);
        this.#prev = new UintArray(max);
        this.#head = 0;
        this.#tail = 0;
        this.#free = Stack$1.create(max);
        this.#size = 0;
        this.#calculatedSize = 0;
        if (typeof dispose === 'function') {
            this.#dispose = dispose;
        }
        if (typeof disposeAfter === 'function') {
            this.#disposeAfter = disposeAfter;
            this.#disposed = [];
        }
        else {
            this.#disposeAfter = undefined;
            this.#disposed = undefined;
        }
        this.#hasDispose = !!this.#dispose;
        this.#hasDisposeAfter = !!this.#disposeAfter;
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        // NB: maxEntrySize is set to maxSize if it's set
        if (this.maxEntrySize !== 0) {
            if (this.#maxSize !== 0) {
                if (!isPosInt(this.#maxSize)) {
                    throw new TypeError('maxSize must be a positive integer if specified');
                }
            }
            if (!isPosInt(this.maxEntrySize)) {
                throw new TypeError('maxEntrySize must be a positive integer if specified');
            }
            this.#initializeSizeTracking();
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution =
            isPosInt(ttlResolution) || ttlResolution === 0
                ? ttlResolution
                : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
            if (!isPosInt(this.ttl)) {
                throw new TypeError('ttl must be a positive integer if specified');
            }
            this.#initializeTTLTracking();
        }
        // do not allow completely unbounded caches
        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
            throw new TypeError('At least one of max, maxSize, or ttl is required');
        }
        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
            const code = 'LRU_CACHE_UNBOUNDED';
            if (shouldWarn(code)) {
                warned.add(code);
                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +
                    'result in unbounded memory consumption.';
                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache$1);
            }
        }
    }
    /**
     * Return the remaining TTL time for a given entry key
     */
    getRemainingTTL(key) {
        return this.#keyMap.has(key) ? Infinity : 0;
    }
    #initializeTTLTracking() {
        const ttls = new ZeroArray(this.#max);
        const starts = new ZeroArray(this.#max);
        this.#ttls = ttls;
        this.#starts = starts;
        this.#setItemTTL = (index, ttl, start = perf.now()) => {
            starts[index] = ttl !== 0 ? start : 0;
            ttls[index] = ttl;
            if (ttl !== 0 && this.ttlAutopurge) {
                const t = setTimeout(() => {
                    if (this.#isStale(index)) {
                        this.delete(this.#keyList[index]);
                    }
                }, ttl + 1);
                // unref() not supported on all platforms
                /* c8 ignore start */
                if (t.unref) {
                    t.unref();
                }
                /* c8 ignore stop */
            }
        };
        this.#updateItemAge = index => {
            starts[index] = ttls[index] !== 0 ? perf.now() : 0;
        };
        this.#statusTTL = (status, index) => {
            if (ttls[index]) {
                const ttl = ttls[index];
                const start = starts[index];
                status.ttl = ttl;
                status.start = start;
                status.now = cachedNow || getNow();
                const age = status.now - start;
                status.remainingTTL = ttl - age;
            }
        };
        // debounce calls to perf.now() to 1s so we're not hitting
        // that costly call repeatedly.
        let cachedNow = 0;
        const getNow = () => {
            const n = perf.now();
            if (this.ttlResolution > 0) {
                cachedNow = n;
                const t = setTimeout(() => (cachedNow = 0), this.ttlResolution);
                // not available on all platforms
                /* c8 ignore start */
                if (t.unref) {
                    t.unref();
                }
                /* c8 ignore stop */
            }
            return n;
        };
        this.getRemainingTTL = key => {
            const index = this.#keyMap.get(key);
            if (index === undefined) {
                return 0;
            }
            const ttl = ttls[index];
            const start = starts[index];
            if (ttl === 0 || start === 0) {
                return Infinity;
            }
            const age = (cachedNow || getNow()) - start;
            return ttl - age;
        };
        this.#isStale = index => {
            return (ttls[index] !== 0 &&
                starts[index] !== 0 &&
                (cachedNow || getNow()) - starts[index] > ttls[index]);
        };
    }
    // conditionally set private methods related to TTL
    #updateItemAge = () => { };
    #statusTTL = () => { };
    #setItemTTL = () => { };
    /* c8 ignore stop */
    #isStale = () => false;
    #initializeSizeTracking() {
        const sizes = new ZeroArray(this.#max);
        this.#calculatedSize = 0;
        this.#sizes = sizes;
        this.#removeItemSize = index => {
            this.#calculatedSize -= sizes[index];
            sizes[index] = 0;
        };
        this.#requireSize = (k, v, size, sizeCalculation) => {
            // provisionally accept background fetches.
            // actual value size will be checked when they return.
            if (this.#isBackgroundFetch(v)) {
                return 0;
            }
            if (!isPosInt(size)) {
                if (sizeCalculation) {
                    if (typeof sizeCalculation !== 'function') {
                        throw new TypeError('sizeCalculation must be a function');
                    }
                    size = sizeCalculation(v, k);
                    if (!isPosInt(size)) {
                        throw new TypeError('sizeCalculation return invalid (expect positive integer)');
                    }
                }
                else {
                    throw new TypeError('invalid size value (must be positive integer). ' +
                        'When maxSize or maxEntrySize is used, sizeCalculation ' +
                        'or size must be set.');
                }
            }
            return size;
        };
        this.#addItemSize = (index, size, status) => {
            sizes[index] = size;
            if (this.#maxSize) {
                const maxSize = this.#maxSize - sizes[index];
                while (this.#calculatedSize > maxSize) {
                    this.#evict(true);
                }
            }
            this.#calculatedSize += sizes[index];
            if (status) {
                status.entrySize = size;
                status.totalCalculatedSize = this.#calculatedSize;
            }
        };
    }
    #removeItemSize = _i => { };
    #addItemSize = (_i, _s, _st) => { };
    #requireSize = (_k, _v, size, sizeCalculation) => {
        if (size || sizeCalculation) {
            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');
        }
        return 0;
    };
    *#indexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
            for (let i = this.#tail; true;) {
                if (!this.#isValidIndex(i)) {
                    break;
                }
                if (allowStale || !this.#isStale(i)) {
                    yield i;
                }
                if (i === this.#head) {
                    break;
                }
                else {
                    i = this.#prev[i];
                }
            }
        }
    }
    *#rindexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
            for (let i = this.#head; true;) {
                if (!this.#isValidIndex(i)) {
                    break;
                }
                if (allowStale || !this.#isStale(i)) {
                    yield i;
                }
                if (i === this.#tail) {
                    break;
                }
                else {
                    i = this.#next[i];
                }
            }
        }
    }
    #isValidIndex(index) {
        return (index !== undefined &&
            this.#keyMap.get(this.#keyList[index]) === index);
    }
    /**
     * Return a generator yielding `[key, value]` pairs,
     * in order from most recently used to least recently used.
     */
    *entries() {
        for (const i of this.#indexes()) {
            if (this.#valList[i] !== undefined &&
                this.#keyList[i] !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield [this.#keyList[i], this.#valList[i]];
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.entries}
     *
     * Return a generator yielding `[key, value]` pairs,
     * in order from least recently used to most recently used.
     */
    *rentries() {
        for (const i of this.#rindexes()) {
            if (this.#valList[i] !== undefined &&
                this.#keyList[i] !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield [this.#keyList[i], this.#valList[i]];
            }
        }
    }
    /**
     * Return a generator yielding the keys in the cache,
     * in order from most recently used to least recently used.
     */
    *keys() {
        for (const i of this.#indexes()) {
            const k = this.#keyList[i];
            if (k !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield k;
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.keys}
     *
     * Return a generator yielding the keys in the cache,
     * in order from least recently used to most recently used.
     */
    *rkeys() {
        for (const i of this.#rindexes()) {
            const k = this.#keyList[i];
            if (k !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield k;
            }
        }
    }
    /**
     * Return a generator yielding the values in the cache,
     * in order from most recently used to least recently used.
     */
    *values() {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            if (v !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield this.#valList[i];
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.values}
     *
     * Return a generator yielding the values in the cache,
     * in order from least recently used to most recently used.
     */
    *rvalues() {
        for (const i of this.#rindexes()) {
            const v = this.#valList[i];
            if (v !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield this.#valList[i];
            }
        }
    }
    /**
     * Iterating over the cache itself yields the same results as
     * {@link LRUCache.entries}
     */
    [Symbol.iterator]() {
        return this.entries();
    }
    /**
     * Find a value for which the supplied fn method returns a truthy value,
     * similar to Array.find().  fn is called as fn(value, key, cache).
     */
    find(fn, getOptions = {}) {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined)
                continue;
            if (fn(value, this.#keyList[i], this)) {
                return this.get(this.#keyList[i], getOptions);
            }
        }
    }
    /**
     * Call the supplied function on each item in the cache, in order from
     * most recently used to least recently used.  fn is called as
     * fn(value, key, cache).  Does not update age or recenty of use.
     * Does not iterate over stale values.
     */
    forEach(fn, thisp = this) {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined)
                continue;
            fn.call(thisp, value, this.#keyList[i], this);
        }
    }
    /**
     * The same as {@link LRUCache.forEach} but items are iterated over in
     * reverse order.  (ie, less recently used items are iterated over first.)
     */
    rforEach(fn, thisp = this) {
        for (const i of this.#rindexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined)
                continue;
            fn.call(thisp, value, this.#keyList[i], this);
        }
    }
    /**
     * Delete any stale entries. Returns true if anything was removed,
     * false otherwise.
     */
    purgeStale() {
        let deleted = false;
        for (const i of this.#rindexes({ allowStale: true })) {
            if (this.#isStale(i)) {
                this.delete(this.#keyList[i]);
                deleted = true;
            }
        }
        return deleted;
    }
    /**
     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
     * passed to cache.load()
     */
    dump() {
        const arr = [];
        for (const i of this.#indexes({ allowStale: true })) {
            const key = this.#keyList[i];
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined || key === undefined)
                continue;
            const entry = { value };
            if (this.#ttls && this.#starts) {
                entry.ttl = this.#ttls[i];
                // always dump the start relative to a portable timestamp
                // it's ok for this to be a bit slow, it's a rare operation.
                const age = perf.now() - this.#starts[i];
                entry.start = Math.floor(Date.now() - age);
            }
            if (this.#sizes) {
                entry.size = this.#sizes[i];
            }
            arr.unshift([key, entry]);
        }
        return arr;
    }
    /**
     * Reset the cache and load in the items in entries in the order listed.
     * Note that the shape of the resulting cache may be different if the
     * same options are not used in both caches.
     */
    load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
            if (entry.start) {
                // entry.start is a portable timestamp, but we may be using
                // node's performance.now(), so calculate the offset, so that
                // we get the intended remaining TTL, no matter how long it's
                // been on ice.
                //
                // it's ok for this to be a bit slow, it's a rare operation.
                const age = Date.now() - entry.start;
                entry.start = perf.now() - age;
            }
            this.set(key, entry.value, entry);
        }
    }
    /**
     * Add a value to the cache.
     *
     * Note: if `undefined` is specified as a value, this is an alias for
     * {@link LRUCache#delete}
     */
    set(k, v, setOptions = {}) {
        if (v === undefined) {
            this.delete(k);
            return this;
        }
        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status, } = setOptions;
        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
        // if the item doesn't fit, don't do anything
        // NB: maxEntrySize set to maxSize by default
        if (this.maxEntrySize && size > this.maxEntrySize) {
            if (status) {
                status.set = 'miss';
                status.maxEntrySizeExceeded = true;
            }
            // have to delete, in case something is there already.
            this.delete(k);
            return this;
        }
        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);
        if (index === undefined) {
            // addition
            index = (this.#size === 0
                ? this.#tail
                : this.#free.length !== 0
                    ? this.#free.pop()
                    : this.#size === this.#max
                        ? this.#evict(false)
                        : this.#size);
            this.#keyList[index] = k;
            this.#valList[index] = v;
            this.#keyMap.set(k, index);
            this.#next[this.#tail] = index;
            this.#prev[index] = this.#tail;
            this.#tail = index;
            this.#size++;
            this.#addItemSize(index, size, status);
            if (status)
                status.set = 'add';
            noUpdateTTL = false;
        }
        else {
            // update
            this.#moveToTail(index);
            const oldVal = this.#valList[index];
            if (v !== oldVal) {
                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
                    oldVal.__abortController.abort(new Error('replaced'));
                }
                else if (!noDisposeOnSet) {
                    if (this.#hasDispose) {
                        this.#dispose?.(oldVal, k, 'set');
                    }
                    if (this.#hasDisposeAfter) {
                        this.#disposed?.push([oldVal, k, 'set']);
                    }
                }
                this.#removeItemSize(index);
                this.#addItemSize(index, size, status);
                this.#valList[index] = v;
                if (status) {
                    status.set = 'replace';
                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal)
                        ? oldVal.__staleWhileFetching
                        : oldVal;
                    if (oldValue !== undefined)
                        status.oldValue = oldValue;
                }
            }
            else if (status) {
                status.set = 'update';
            }
        }
        if (ttl !== 0 && !this.#ttls) {
            this.#initializeTTLTracking();
        }
        if (this.#ttls) {
            if (!noUpdateTTL) {
                this.#setItemTTL(index, ttl, start);
            }
            if (status)
                this.#statusTTL(status, index);
        }
        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
        return this;
    }
    /**
     * Evict the least recently used item, returning its value or
     * `undefined` if cache is empty.
     */
    pop() {
        try {
            while (this.#size) {
                const val = this.#valList[this.#head];
                this.#evict(true);
                if (this.#isBackgroundFetch(val)) {
                    if (val.__staleWhileFetching) {
                        return val.__staleWhileFetching;
                    }
                }
                else if (val !== undefined) {
                    return val;
                }
            }
        }
        finally {
            if (this.#hasDisposeAfter && this.#disposed) {
                const dt = this.#disposed;
                let task;
                while ((task = dt?.shift())) {
                    this.#disposeAfter?.(...task);
                }
            }
        }
    }
    #evict(free) {
        const head = this.#head;
        const k = this.#keyList[head];
        const v = this.#valList[head];
        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error('evicted'));
        }
        else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
                this.#dispose?.(v, k, 'evict');
            }
            if (this.#hasDisposeAfter) {
                this.#disposed?.push([v, k, 'evict']);
            }
        }
        this.#removeItemSize(head);
        // if we aren't about to use the index, then null these out
        if (free) {
            this.#keyList[head] = undefined;
            this.#valList[head] = undefined;
            this.#free.push(head);
        }
        if (this.#size === 1) {
            this.#head = this.#tail = 0;
            this.#free.length = 0;
        }
        else {
            this.#head = this.#next[head];
        }
        this.#keyMap.delete(k);
        this.#size--;
        return head;
    }
    /**
     * Check if a key is in the cache, without updating the recency of use.
     * Will return false if the item is stale, even though it is technically
     * in the cache.
     *
     * Will not update item age unless
     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
     */
    has(k, hasOptions = {}) {
        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v) &&
                v.__staleWhileFetching === undefined) {
                return false;
            }
            if (!this.#isStale(index)) {
                if (updateAgeOnHas) {
                    this.#updateItemAge(index);
                }
                if (status) {
                    status.has = 'hit';
                    this.#statusTTL(status, index);
                }
                return true;
            }
            else if (status) {
                status.has = 'stale';
                this.#statusTTL(status, index);
            }
        }
        else if (status) {
            status.has = 'miss';
        }
        return false;
    }
    /**
     * Like {@link LRUCache#get} but doesn't update recency or delete stale
     * items.
     *
     * Returns `undefined` if the item is stale, unless
     * {@link LRUCache.OptionsBase.allowStale} is set.
     */
    peek(k, peekOptions = {}) {
        const { allowStale = this.allowStale } = peekOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined &&
            (allowStale || !this.#isStale(index))) {
            const v = this.#valList[index];
            // either stale and allowed, or forcing a refresh of non-stale value
            return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        }
    }
    #backgroundFetch(k, index, options, context) {
        const v = index === undefined ? undefined : this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
            return v;
        }
        const ac = new AC();
        const { signal } = options;
        // when/if our AC signals, then stop listening to theirs.
        signal?.addEventListener('abort', () => ac.abort(signal.reason), {
            signal: ac.signal,
        });
        const fetchOpts = {
            signal: ac.signal,
            options,
            context,
        };
        const cb = (v, updateCache = false) => {
            const { aborted } = ac.signal;
            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;
            if (options.status) {
                if (aborted && !updateCache) {
                    options.status.fetchAborted = true;
                    options.status.fetchError = ac.signal.reason;
                    if (ignoreAbort)
                        options.status.fetchAbortIgnored = true;
                }
                else {
                    options.status.fetchResolved = true;
                }
            }
            if (aborted && !ignoreAbort && !updateCache) {
                return fetchFail(ac.signal.reason);
            }
            // either we didn't abort, and are still here, or we did, and ignored
            const bf = p;
            if (this.#valList[index] === p) {
                if (v === undefined) {
                    if (bf.__staleWhileFetching) {
                        this.#valList[index] = bf.__staleWhileFetching;
                    }
                    else {
                        this.delete(k);
                    }
                }
                else {
                    if (options.status)
                        options.status.fetchUpdated = true;
                    this.set(k, v, fetchOpts.options);
                }
            }
            return v;
        };
        const eb = (er) => {
            if (options.status) {
                options.status.fetchRejected = true;
                options.status.fetchError = er;
            }
            return fetchFail(er);
        };
        const fetchFail = (er) => {
            const { aborted } = ac.signal;
            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
            const noDelete = allowStale || options.noDeleteOnFetchRejection;
            const bf = p;
            if (this.#valList[index] === p) {
                // if we allow stale on fetch rejections, then we need to ensure that
                // the stale value is not removed from the cache when the fetch fails.
                const del = !noDelete || bf.__staleWhileFetching === undefined;
                if (del) {
                    this.delete(k);
                }
                else if (!allowStaleAborted) {
                    // still replace the *promise* with the stale value,
                    // since we are done with the promise at this point.
                    // leave it untouched if we're still waiting for an
                    // aborted background fetch that hasn't yet returned.
                    this.#valList[index] = bf.__staleWhileFetching;
                }
            }
            if (allowStale) {
                if (options.status && bf.__staleWhileFetching !== undefined) {
                    options.status.returnedStale = true;
                }
                return bf.__staleWhileFetching;
            }
            else if (bf.__returned === bf) {
                throw er;
            }
        };
        const pcall = (res, rej) => {
            const fmp = this.#fetchMethod?.(k, v, fetchOpts);
            if (fmp && fmp instanceof Promise) {
                fmp.then(v => res(v === undefined ? undefined : v), rej);
            }
            // ignored, we go until we finish, regardless.
            // defer check until we are actually aborting,
            // so fetchMethod can override.
            ac.signal.addEventListener('abort', () => {
                if (!options.ignoreFetchAbort ||
                    options.allowStaleOnFetchAbort) {
                    res(undefined);
                    // when it eventually resolves, update the cache.
                    if (options.allowStaleOnFetchAbort) {
                        res = v => cb(v, true);
                    }
                }
            });
        };
        if (options.status)
            options.status.fetchDispatched = true;
        const p = new Promise(pcall).then(cb, eb);
        const bf = Object.assign(p, {
            __abortController: ac,
            __staleWhileFetching: v,
            __returned: undefined,
        });
        if (index === undefined) {
            // internal, don't expose status.
            this.set(k, bf, { ...fetchOpts.options, status: undefined });
            index = this.#keyMap.get(k);
        }
        else {
            this.#valList[index] = bf;
        }
        return bf;
    }
    #isBackgroundFetch(p) {
        if (!this.#hasFetchMethod)
            return false;
        const b = p;
        return (!!b &&
            b instanceof Promise &&
            b.hasOwnProperty('__staleWhileFetching') &&
            b.__abortController instanceof AC);
    }
    async fetch(k, fetchOptions = {}) {
        const { 
        // get options
        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, 
        // set options
        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, 
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal, } = fetchOptions;
        if (!this.#hasFetchMethod) {
            if (status)
                status.fetch = 'get';
            return this.get(k, {
                allowStale,
                updateAgeOnGet,
                noDeleteOnStaleGet,
                status,
            });
        }
        const options = {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            ttl,
            noDisposeOnSet,
            size,
            sizeCalculation,
            noUpdateTTL,
            noDeleteOnFetchRejection,
            allowStaleOnFetchRejection,
            allowStaleOnFetchAbort,
            ignoreFetchAbort,
            status,
            signal,
        };
        let index = this.#keyMap.get(k);
        if (index === undefined) {
            if (status)
                status.fetch = 'miss';
            const p = this.#backgroundFetch(k, index, options, context);
            return (p.__returned = p);
        }
        else {
            // in cache, maybe already fetching
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
                const stale = allowStale && v.__staleWhileFetching !== undefined;
                if (status) {
                    status.fetch = 'inflight';
                    if (stale)
                        status.returnedStale = true;
                }
                return stale ? v.__staleWhileFetching : (v.__returned = v);
            }
            // if we force a refresh, that means do NOT serve the cached value,
            // unless we are already in the process of refreshing the cache.
            const isStale = this.#isStale(index);
            if (!forceRefresh && !isStale) {
                if (status)
                    status.fetch = 'hit';
                this.#moveToTail(index);
                if (updateAgeOnGet) {
                    this.#updateItemAge(index);
                }
                if (status)
                    this.#statusTTL(status, index);
                return v;
            }
            // ok, it is stale or a forced refresh, and not already fetching.
            // refresh the cache.
            const p = this.#backgroundFetch(k, index, options, context);
            const hasStale = p.__staleWhileFetching !== undefined;
            const staleVal = hasStale && allowStale;
            if (status) {
                status.fetch = isStale ? 'stale' : 'refresh';
                if (staleVal && isStale)
                    status.returnedStale = true;
            }
            return staleVal ? p.__staleWhileFetching : (p.__returned = p);
        }
    }
    /**
     * Return a value from the cache. Will update the recency of the cache
     * entry found.
     *
     * If the key is not found, get() will return `undefined`.
     */
    get(k, getOptions = {}) {
        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status, } = getOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
            const value = this.#valList[index];
            const fetching = this.#isBackgroundFetch(value);
            if (status)
                this.#statusTTL(status, index);
            if (this.#isStale(index)) {
                if (status)
                    status.get = 'stale';
                // delete only if not an in-flight background fetch
                if (!fetching) {
                    if (!noDeleteOnStaleGet) {
                        this.delete(k);
                    }
                    if (status && allowStale)
                        status.returnedStale = true;
                    return allowStale ? value : undefined;
                }
                else {
                    if (status &&
                        allowStale &&
                        value.__staleWhileFetching !== undefined) {
                        status.returnedStale = true;
                    }
                    return allowStale ? value.__staleWhileFetching : undefined;
                }
            }
            else {
                if (status)
                    status.get = 'hit';
                // if we're currently fetching it, we don't actually have it yet
                // it's not stale, which means this isn't a staleWhileRefetching.
                // If it's not stale, and fetching, AND has a __staleWhileFetching
                // value, then that means the user fetched with {forceRefresh:true},
                // so it's safe to return that value.
                if (fetching) {
                    return value.__staleWhileFetching;
                }
                this.#moveToTail(index);
                if (updateAgeOnGet) {
                    this.#updateItemAge(index);
                }
                return value;
            }
        }
        else if (status) {
            status.get = 'miss';
        }
    }
    #connect(p, n) {
        this.#prev[n] = p;
        this.#next[p] = n;
    }
    #moveToTail(index) {
        // if tail already, nothing to do
        // if head, move head to next[index]
        // else
        //   move next[prev[index]] to next[index] (head has no prev)
        //   move prev[next[index]] to prev[index]
        // prev[index] = tail
        // next[tail] = index
        // tail = index
        if (index !== this.#tail) {
            if (index === this.#head) {
                this.#head = this.#next[index];
            }
            else {
                this.#connect(this.#prev[index], this.#next[index]);
            }
            this.#connect(this.#tail, index);
            this.#tail = index;
        }
    }
    /**
     * Deletes a key out of the cache.
     * Returns true if the key was deleted, false otherwise.
     */
    delete(k) {
        let deleted = false;
        if (this.#size !== 0) {
            const index = this.#keyMap.get(k);
            if (index !== undefined) {
                deleted = true;
                if (this.#size === 1) {
                    this.clear();
                }
                else {
                    this.#removeItemSize(index);
                    const v = this.#valList[index];
                    if (this.#isBackgroundFetch(v)) {
                        v.__abortController.abort(new Error('deleted'));
                    }
                    else if (this.#hasDispose || this.#hasDisposeAfter) {
                        if (this.#hasDispose) {
                            this.#dispose?.(v, k, 'delete');
                        }
                        if (this.#hasDisposeAfter) {
                            this.#disposed?.push([v, k, 'delete']);
                        }
                    }
                    this.#keyMap.delete(k);
                    this.#keyList[index] = undefined;
                    this.#valList[index] = undefined;
                    if (index === this.#tail) {
                        this.#tail = this.#prev[index];
                    }
                    else if (index === this.#head) {
                        this.#head = this.#next[index];
                    }
                    else {
                        this.#next[this.#prev[index]] = this.#next[index];
                        this.#prev[this.#next[index]] = this.#prev[index];
                    }
                    this.#size--;
                    this.#free.push(index);
                }
            }
        }
        if (this.#hasDisposeAfter && this.#disposed?.length) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
        return deleted;
    }
    /**
     * Clear the cache entirely, throwing away all values.
     */
    clear() {
        for (const index of this.#rindexes({ allowStale: true })) {
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
                v.__abortController.abort(new Error('deleted'));
            }
            else {
                const k = this.#keyList[index];
                if (this.#hasDispose) {
                    this.#dispose?.(v, k, 'delete');
                }
                if (this.#hasDisposeAfter) {
                    this.#disposed?.push([v, k, 'delete']);
                }
            }
        }
        this.#keyMap.clear();
        this.#valList.fill(undefined);
        this.#keyList.fill(undefined);
        if (this.#ttls && this.#starts) {
            this.#ttls.fill(0);
            this.#starts.fill(0);
        }
        if (this.#sizes) {
            this.#sizes.fill(0);
        }
        this.#head = 0;
        this.#tail = 0;
        this.#free.length = 0;
        this.#calculatedSize = 0;
        this.#size = 0;
        if (this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
    }
}
cjs.LRUCache = LRUCache$1;

var minipass$1 = {};

const proc$1 =
  typeof process === 'object' && process
    ? process
    : {
        stdout: null,
        stderr: null,
      };
const EE$1 = require$$0__default$5["default"];
const Stream$1 = Stream__default["default"];
const stringdecoder$1 = require$$2__default["default"];
const SD$1 = stringdecoder$1.StringDecoder;

const EOF$1 = Symbol('EOF');
const MAYBE_EMIT_END$1 = Symbol('maybeEmitEnd');
const EMITTED_END$1 = Symbol('emittedEnd');
const EMITTING_END$1 = Symbol('emittingEnd');
const EMITTED_ERROR$1 = Symbol('emittedError');
const CLOSED$1 = Symbol('closed');
const READ$1 = Symbol('read');
const FLUSH$1 = Symbol('flush');
const FLUSHCHUNK$1 = Symbol('flushChunk');
const ENCODING$1 = Symbol('encoding');
const DECODER$1 = Symbol('decoder');
const FLOWING$1 = Symbol('flowing');
const PAUSED$1 = Symbol('paused');
const RESUME$1 = Symbol('resume');
const BUFFER$1 = Symbol('buffer');
const PIPES$1 = Symbol('pipes');
const BUFFERLENGTH$1 = Symbol('bufferLength');
const BUFFERPUSH$1 = Symbol('bufferPush');
const BUFFERSHIFT$1 = Symbol('bufferShift');
const OBJECTMODE$1 = Symbol('objectMode');
// internal event when stream is destroyed
const DESTROYED$1 = Symbol('destroyed');
// internal event when stream has an error
const ERROR$1 = Symbol('error');
const EMITDATA$1 = Symbol('emitData');
const EMITEND$1 = Symbol('emitEnd');
const EMITEND2$1 = Symbol('emitEnd2');
const ASYNC$1 = Symbol('async');
const ABORT$1 = Symbol('abort');
const ABORTED$1 = Symbol('aborted');
const SIGNAL$1 = Symbol('signal');

const defer$1 = fn => Promise.resolve().then(fn);

// TODO remove when Node v8 support drops
const doIter$1 = commonjsGlobal._MP_NO_ITERATOR_SYMBOLS_ !== '1';
const ASYNCITERATOR$1 =
  (doIter$1 && Symbol.asyncIterator) || Symbol('asyncIterator not implemented');
const ITERATOR$1 =
  (doIter$1 && Symbol.iterator) || Symbol('iterator not implemented');

// events that mean 'the stream is over'
// these are treated specially, and re-emitted
// if they are listened for after emitting.
const isEndish$1 = ev => ev === 'end' || ev === 'finish' || ev === 'prefinish';

const isArrayBuffer$1 = b =>
  b instanceof ArrayBuffer ||
  (typeof b === 'object' &&
    b.constructor &&
    b.constructor.name === 'ArrayBuffer' &&
    b.byteLength >= 0);

const isArrayBufferView$1 = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);

class Pipe$1 {
  constructor(src, dest, opts) {
    this.src = src;
    this.dest = dest;
    this.opts = opts;
    this.ondrain = () => src[RESUME$1]();
    dest.on('drain', this.ondrain);
  }
  unpipe() {
    this.dest.removeListener('drain', this.ondrain);
  }
  // istanbul ignore next - only here for the prototype
  proxyErrors() {}
  end() {
    this.unpipe();
    if (this.opts.end) this.dest.end();
  }
}

class PipeProxyErrors$1 extends Pipe$1 {
  unpipe() {
    this.src.removeListener('error', this.proxyErrors);
    super.unpipe();
  }
  constructor(src, dest, opts) {
    super(src, dest, opts);
    this.proxyErrors = er => dest.emit('error', er);
    src.on('error', this.proxyErrors);
  }
}

class Minipass$1 extends Stream$1 {
  constructor(options) {
    super();
    this[FLOWING$1] = false;
    // whether we're explicitly paused
    this[PAUSED$1] = false;
    this[PIPES$1] = [];
    this[BUFFER$1] = [];
    this[OBJECTMODE$1] = (options && options.objectMode) || false;
    if (this[OBJECTMODE$1]) this[ENCODING$1] = null;
    else this[ENCODING$1] = (options && options.encoding) || null;
    if (this[ENCODING$1] === 'buffer') this[ENCODING$1] = null;
    this[ASYNC$1] = (options && !!options.async) || false;
    this[DECODER$1] = this[ENCODING$1] ? new SD$1(this[ENCODING$1]) : null;
    this[EOF$1] = false;
    this[EMITTED_END$1] = false;
    this[EMITTING_END$1] = false;
    this[CLOSED$1] = false;
    this[EMITTED_ERROR$1] = null;
    this.writable = true;
    this.readable = true;
    this[BUFFERLENGTH$1] = 0;
    this[DESTROYED$1] = false;
    if (options && options.debugExposeBuffer === true) {
      Object.defineProperty(this, 'buffer', { get: () => this[BUFFER$1] });
    }
    if (options && options.debugExposePipes === true) {
      Object.defineProperty(this, 'pipes', { get: () => this[PIPES$1] });
    }
    this[SIGNAL$1] = options && options.signal;
    this[ABORTED$1] = false;
    if (this[SIGNAL$1]) {
      this[SIGNAL$1].addEventListener('abort', () => this[ABORT$1]());
      if (this[SIGNAL$1].aborted) {
        this[ABORT$1]();
      }
    }
  }

  get bufferLength() {
    return this[BUFFERLENGTH$1]
  }

  get encoding() {
    return this[ENCODING$1]
  }
  set encoding(enc) {
    if (this[OBJECTMODE$1]) throw new Error('cannot set encoding in objectMode')

    if (
      this[ENCODING$1] &&
      enc !== this[ENCODING$1] &&
      ((this[DECODER$1] && this[DECODER$1].lastNeed) || this[BUFFERLENGTH$1])
    )
      throw new Error('cannot change encoding')

    if (this[ENCODING$1] !== enc) {
      this[DECODER$1] = enc ? new SD$1(enc) : null;
      if (this[BUFFER$1].length)
        this[BUFFER$1] = this[BUFFER$1].map(chunk => this[DECODER$1].write(chunk));
    }

    this[ENCODING$1] = enc;
  }

  setEncoding(enc) {
    this.encoding = enc;
  }

  get objectMode() {
    return this[OBJECTMODE$1]
  }
  set objectMode(om) {
    this[OBJECTMODE$1] = this[OBJECTMODE$1] || !!om;
  }

  get ['async']() {
    return this[ASYNC$1]
  }
  set ['async'](a) {
    this[ASYNC$1] = this[ASYNC$1] || !!a;
  }

  // drop everything and get out of the flow completely
  [ABORT$1]() {
    this[ABORTED$1] = true;
    this.emit('abort', this[SIGNAL$1].reason);
    this.destroy(this[SIGNAL$1].reason);
  }

  get aborted() {
    return this[ABORTED$1]
  }
  set aborted(_) {}

  write(chunk, encoding, cb) {
    if (this[ABORTED$1]) return false
    if (this[EOF$1]) throw new Error('write after end')

    if (this[DESTROYED$1]) {
      this.emit(
        'error',
        Object.assign(
          new Error('Cannot call write after a stream was destroyed'),
          { code: 'ERR_STREAM_DESTROYED' }
        )
      );
      return true
    }

    if (typeof encoding === 'function') (cb = encoding), (encoding = 'utf8');

    if (!encoding) encoding = 'utf8';

    const fn = this[ASYNC$1] ? defer$1 : f => f();

    // convert array buffers and typed array views into buffers
    // at some point in the future, we may want to do the opposite!
    // leave strings and buffers as-is
    // anything else switches us into object mode
    if (!this[OBJECTMODE$1] && !Buffer.isBuffer(chunk)) {
      if (isArrayBufferView$1(chunk))
        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
      else if (isArrayBuffer$1(chunk)) chunk = Buffer.from(chunk);
      else if (typeof chunk !== 'string')
        // use the setter so we throw if we have encoding set
        this.objectMode = true;
    }

    // handle object mode up front, since it's simpler
    // this yields better performance, fewer checks later.
    if (this[OBJECTMODE$1]) {
      /* istanbul ignore if - maybe impossible? */
      if (this.flowing && this[BUFFERLENGTH$1] !== 0) this[FLUSH$1](true);

      if (this.flowing) this.emit('data', chunk);
      else this[BUFFERPUSH$1](chunk);

      if (this[BUFFERLENGTH$1] !== 0) this.emit('readable');

      if (cb) fn(cb);

      return this.flowing
    }

    // at this point the chunk is a buffer or string
    // don't buffer it up or send it to the decoder
    if (!chunk.length) {
      if (this[BUFFERLENGTH$1] !== 0) this.emit('readable');
      if (cb) fn(cb);
      return this.flowing
    }

    // fast-path writing strings of same encoding to a stream with
    // an empty buffer, skipping the buffer/decoder dance
    if (
      typeof chunk === 'string' &&
      // unless it is a string already ready for us to use
      !(encoding === this[ENCODING$1] && !this[DECODER$1].lastNeed)
    ) {
      chunk = Buffer.from(chunk, encoding);
    }

    if (Buffer.isBuffer(chunk) && this[ENCODING$1])
      chunk = this[DECODER$1].write(chunk);

    // Note: flushing CAN potentially switch us into not-flowing mode
    if (this.flowing && this[BUFFERLENGTH$1] !== 0) this[FLUSH$1](true);

    if (this.flowing) this.emit('data', chunk);
    else this[BUFFERPUSH$1](chunk);

    if (this[BUFFERLENGTH$1] !== 0) this.emit('readable');

    if (cb) fn(cb);

    return this.flowing
  }

  read(n) {
    if (this[DESTROYED$1]) return null

    if (this[BUFFERLENGTH$1] === 0 || n === 0 || n > this[BUFFERLENGTH$1]) {
      this[MAYBE_EMIT_END$1]();
      return null
    }

    if (this[OBJECTMODE$1]) n = null;

    if (this[BUFFER$1].length > 1 && !this[OBJECTMODE$1]) {
      if (this.encoding) this[BUFFER$1] = [this[BUFFER$1].join('')];
      else this[BUFFER$1] = [Buffer.concat(this[BUFFER$1], this[BUFFERLENGTH$1])];
    }

    const ret = this[READ$1](n || null, this[BUFFER$1][0]);
    this[MAYBE_EMIT_END$1]();
    return ret
  }

  [READ$1](n, chunk) {
    if (n === chunk.length || n === null) this[BUFFERSHIFT$1]();
    else {
      this[BUFFER$1][0] = chunk.slice(n);
      chunk = chunk.slice(0, n);
      this[BUFFERLENGTH$1] -= n;
    }

    this.emit('data', chunk);

    if (!this[BUFFER$1].length && !this[EOF$1]) this.emit('drain');

    return chunk
  }

  end(chunk, encoding, cb) {
    if (typeof chunk === 'function') (cb = chunk), (chunk = null);
    if (typeof encoding === 'function') (cb = encoding), (encoding = 'utf8');
    if (chunk) this.write(chunk, encoding);
    if (cb) this.once('end', cb);
    this[EOF$1] = true;
    this.writable = false;

    // if we haven't written anything, then go ahead and emit,
    // even if we're not reading.
    // we'll re-emit if a new 'end' listener is added anyway.
    // This makes MP more suitable to write-only use cases.
    if (this.flowing || !this[PAUSED$1]) this[MAYBE_EMIT_END$1]();
    return this
  }

  // don't let the internal resume be overwritten
  [RESUME$1]() {
    if (this[DESTROYED$1]) return

    this[PAUSED$1] = false;
    this[FLOWING$1] = true;
    this.emit('resume');
    if (this[BUFFER$1].length) this[FLUSH$1]();
    else if (this[EOF$1]) this[MAYBE_EMIT_END$1]();
    else this.emit('drain');
  }

  resume() {
    return this[RESUME$1]()
  }

  pause() {
    this[FLOWING$1] = false;
    this[PAUSED$1] = true;
  }

  get destroyed() {
    return this[DESTROYED$1]
  }

  get flowing() {
    return this[FLOWING$1]
  }

  get paused() {
    return this[PAUSED$1]
  }

  [BUFFERPUSH$1](chunk) {
    if (this[OBJECTMODE$1]) this[BUFFERLENGTH$1] += 1;
    else this[BUFFERLENGTH$1] += chunk.length;
    this[BUFFER$1].push(chunk);
  }

  [BUFFERSHIFT$1]() {
    if (this[OBJECTMODE$1]) this[BUFFERLENGTH$1] -= 1;
    else this[BUFFERLENGTH$1] -= this[BUFFER$1][0].length;
    return this[BUFFER$1].shift()
  }

  [FLUSH$1](noDrain) {
    do {} while (this[FLUSHCHUNK$1](this[BUFFERSHIFT$1]()) && this[BUFFER$1].length)

    if (!noDrain && !this[BUFFER$1].length && !this[EOF$1]) this.emit('drain');
  }

  [FLUSHCHUNK$1](chunk) {
    this.emit('data', chunk);
    return this.flowing
  }

  pipe(dest, opts) {
    if (this[DESTROYED$1]) return

    const ended = this[EMITTED_END$1];
    opts = opts || {};
    if (dest === proc$1.stdout || dest === proc$1.stderr) opts.end = false;
    else opts.end = opts.end !== false;
    opts.proxyErrors = !!opts.proxyErrors;

    // piping an ended stream ends immediately
    if (ended) {
      if (opts.end) dest.end();
    } else {
      this[PIPES$1].push(
        !opts.proxyErrors
          ? new Pipe$1(this, dest, opts)
          : new PipeProxyErrors$1(this, dest, opts)
      );
      if (this[ASYNC$1]) defer$1(() => this[RESUME$1]());
      else this[RESUME$1]();
    }

    return dest
  }

  unpipe(dest) {
    const p = this[PIPES$1].find(p => p.dest === dest);
    if (p) {
      this[PIPES$1].splice(this[PIPES$1].indexOf(p), 1);
      p.unpipe();
    }
  }

  addListener(ev, fn) {
    return this.on(ev, fn)
  }

  on(ev, fn) {
    const ret = super.on(ev, fn);
    if (ev === 'data' && !this[PIPES$1].length && !this.flowing) this[RESUME$1]();
    else if (ev === 'readable' && this[BUFFERLENGTH$1] !== 0)
      super.emit('readable');
    else if (isEndish$1(ev) && this[EMITTED_END$1]) {
      super.emit(ev);
      this.removeAllListeners(ev);
    } else if (ev === 'error' && this[EMITTED_ERROR$1]) {
      if (this[ASYNC$1]) defer$1(() => fn.call(this, this[EMITTED_ERROR$1]));
      else fn.call(this, this[EMITTED_ERROR$1]);
    }
    return ret
  }

  get emittedEnd() {
    return this[EMITTED_END$1]
  }

  [MAYBE_EMIT_END$1]() {
    if (
      !this[EMITTING_END$1] &&
      !this[EMITTED_END$1] &&
      !this[DESTROYED$1] &&
      this[BUFFER$1].length === 0 &&
      this[EOF$1]
    ) {
      this[EMITTING_END$1] = true;
      this.emit('end');
      this.emit('prefinish');
      this.emit('finish');
      if (this[CLOSED$1]) this.emit('close');
      this[EMITTING_END$1] = false;
    }
  }

  emit(ev, data, ...extra) {
    // error and close are only events allowed after calling destroy()
    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED$1 && this[DESTROYED$1])
      return
    else if (ev === 'data') {
      return !this[OBJECTMODE$1] && !data
        ? false
        : this[ASYNC$1]
        ? defer$1(() => this[EMITDATA$1](data))
        : this[EMITDATA$1](data)
    } else if (ev === 'end') {
      return this[EMITEND$1]()
    } else if (ev === 'close') {
      this[CLOSED$1] = true;
      // don't emit close before 'end' and 'finish'
      if (!this[EMITTED_END$1] && !this[DESTROYED$1]) return
      const ret = super.emit('close');
      this.removeAllListeners('close');
      return ret
    } else if (ev === 'error') {
      this[EMITTED_ERROR$1] = data;
      super.emit(ERROR$1, data);
      const ret =
        !this[SIGNAL$1] || this.listeners('error').length
          ? super.emit('error', data)
          : false;
      this[MAYBE_EMIT_END$1]();
      return ret
    } else if (ev === 'resume') {
      const ret = super.emit('resume');
      this[MAYBE_EMIT_END$1]();
      return ret
    } else if (ev === 'finish' || ev === 'prefinish') {
      const ret = super.emit(ev);
      this.removeAllListeners(ev);
      return ret
    }

    // Some other unknown event
    const ret = super.emit(ev, data, ...extra);
    this[MAYBE_EMIT_END$1]();
    return ret
  }

  [EMITDATA$1](data) {
    for (const p of this[PIPES$1]) {
      if (p.dest.write(data) === false) this.pause();
    }
    const ret = super.emit('data', data);
    this[MAYBE_EMIT_END$1]();
    return ret
  }

  [EMITEND$1]() {
    if (this[EMITTED_END$1]) return

    this[EMITTED_END$1] = true;
    this.readable = false;
    if (this[ASYNC$1]) defer$1(() => this[EMITEND2$1]());
    else this[EMITEND2$1]();
  }

  [EMITEND2$1]() {
    if (this[DECODER$1]) {
      const data = this[DECODER$1].end();
      if (data) {
        for (const p of this[PIPES$1]) {
          p.dest.write(data);
        }
        super.emit('data', data);
      }
    }

    for (const p of this[PIPES$1]) {
      p.end();
    }
    const ret = super.emit('end');
    this.removeAllListeners('end');
    return ret
  }

  // const all = await stream.collect()
  collect() {
    const buf = [];
    if (!this[OBJECTMODE$1]) buf.dataLength = 0;
    // set the promise first, in case an error is raised
    // by triggering the flow here.
    const p = this.promise();
    this.on('data', c => {
      buf.push(c);
      if (!this[OBJECTMODE$1]) buf.dataLength += c.length;
    });
    return p.then(() => buf)
  }

  // const data = await stream.concat()
  concat() {
    return this[OBJECTMODE$1]
      ? Promise.reject(new Error('cannot concat in objectMode'))
      : this.collect().then(buf =>
          this[OBJECTMODE$1]
            ? Promise.reject(new Error('cannot concat in objectMode'))
            : this[ENCODING$1]
            ? buf.join('')
            : Buffer.concat(buf, buf.dataLength)
        )
  }

  // stream.promise().then(() => done, er => emitted error)
  promise() {
    return new Promise((resolve, reject) => {
      this.on(DESTROYED$1, () => reject(new Error('stream destroyed')));
      this.on('error', er => reject(er));
      this.on('end', () => resolve());
    })
  }

  // for await (let chunk of stream)
  [ASYNCITERATOR$1]() {
    let stopped = false;
    const stop = () => {
      this.pause();
      stopped = true;
      return Promise.resolve({ done: true })
    };
    const next = () => {
      if (stopped) return stop()
      const res = this.read();
      if (res !== null) return Promise.resolve({ done: false, value: res })

      if (this[EOF$1]) return stop()

      let resolve = null;
      let reject = null;
      const onerr = er => {
        this.removeListener('data', ondata);
        this.removeListener('end', onend);
        this.removeListener(DESTROYED$1, ondestroy);
        stop();
        reject(er);
      };
      const ondata = value => {
        this.removeListener('error', onerr);
        this.removeListener('end', onend);
        this.removeListener(DESTROYED$1, ondestroy);
        this.pause();
        resolve({ value: value, done: !!this[EOF$1] });
      };
      const onend = () => {
        this.removeListener('error', onerr);
        this.removeListener('data', ondata);
        this.removeListener(DESTROYED$1, ondestroy);
        stop();
        resolve({ done: true });
      };
      const ondestroy = () => onerr(new Error('stream destroyed'));
      return new Promise((res, rej) => {
        reject = rej;
        resolve = res;
        this.once(DESTROYED$1, ondestroy);
        this.once('error', onerr);
        this.once('end', onend);
        this.once('data', ondata);
      })
    };

    return {
      next,
      throw: stop,
      return: stop,
      [ASYNCITERATOR$1]() {
        return this
      },
    }
  }

  // for (let chunk of stream)
  [ITERATOR$1]() {
    let stopped = false;
    const stop = () => {
      this.pause();
      this.removeListener(ERROR$1, stop);
      this.removeListener(DESTROYED$1, stop);
      this.removeListener('end', stop);
      stopped = true;
      return { done: true }
    };

    const next = () => {
      if (stopped) return stop()
      const value = this.read();
      return value === null ? stop() : { value }
    };
    this.once('end', stop);
    this.once(ERROR$1, stop);
    this.once(DESTROYED$1, stop);

    return {
      next,
      throw: stop,
      return: stop,
      [ITERATOR$1]() {
        return this
      },
    }
  }

  destroy(er) {
    if (this[DESTROYED$1]) {
      if (er) this.emit('error', er);
      else this.emit(DESTROYED$1);
      return this
    }

    this[DESTROYED$1] = true;

    // throw away all buffered data, it's never coming out
    this[BUFFER$1].length = 0;
    this[BUFFERLENGTH$1] = 0;

    if (typeof this.close === 'function' && !this[CLOSED$1]) this.close();

    if (er) this.emit('error', er);
    // if no error to emit, still reject pending promises
    else this.emit(DESTROYED$1);

    return this
  }

  static isStream(s) {
    return (
      !!s &&
      (s instanceof Minipass$1 ||
        s instanceof Stream$1 ||
        (s instanceof EE$1 &&
          // readable
          (typeof s.pipe === 'function' ||
            // writable
            (typeof s.write === 'function' && typeof s.end === 'function'))))
    )
  }
}

minipass$1.Minipass = Minipass$1;

var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(cjs$1, "__esModule", { value: true });
cjs$1.PathScurry = cjs$1.Path = cjs$1.PathScurryDarwin = cjs$1.PathScurryPosix = cjs$1.PathScurryWin32 = cjs$1.PathScurryBase = cjs$1.PathPosix = cjs$1.PathWin32 = cjs$1.PathBase = cjs$1.ChildrenCache = cjs$1.ResolveCache = void 0;
const lru_cache_1 = cjs;
const path_1 = require$$1__default["default"];
const url_1$1 = require$$2__default$1["default"];
const actualFS = __importStar(require$$0__default$1["default"]);
const fs_1 = require$$0__default$1["default"];
const realpathSync = fs_1.realpathSync.native;
// TODO: test perf of fs/promises realpath vs realpathCB,
// since the promises one uses realpath.native
const promises_1 = require$$4__default$1["default"];
const minipass_1$1 = minipass$1;
const defaultFS = {
    lstatSync: fs_1.lstatSync,
    readdir: fs_1.readdir,
    readdirSync: fs_1.readdirSync,
    readlinkSync: fs_1.readlinkSync,
    realpathSync,
    promises: {
        lstat: promises_1.lstat,
        readdir: promises_1.readdir,
        readlink: promises_1.readlink,
        realpath: promises_1.realpath,
    },
};
// if they just gave us require('fs') then use our default
const fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === actualFS
    ? defaultFS
    : {
        ...defaultFS,
        ...fsOption,
        promises: {
            ...defaultFS.promises,
            ...(fsOption.promises || {}),
        },
    };
// turn something like //?/c:/ into c:\
const uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i;
const uncToDrive = (rootPath) => rootPath.replace(/\//g, '\\').replace(uncDriveRegexp, '$1\\');
// windows paths are separated by either / or \
const eitherSep = /[\\\/]/;
const UNKNOWN = 0; // may not even exist, for all we know
const IFIFO = 0b0001;
const IFCHR = 0b0010;
const IFDIR = 0b0100;
const IFBLK = 0b0110;
const IFREG = 0b1000;
const IFLNK = 0b1010;
const IFSOCK = 0b1100;
const IFMT = 0b1111;
// mask to unset low 4 bits
const IFMT_UNKNOWN = ~IFMT;
// set after successfully calling readdir() and getting entries.
const READDIR_CALLED = 16;
// set after a successful lstat()
const LSTAT_CALLED = 32;
// set if an entry (or one of its parents) is definitely not a dir
const ENOTDIR = 64;
// set if an entry (or one of its parents) does not exist
// (can also be set on lstat errors like EACCES or ENAMETOOLONG)
const ENOENT = 128;
// cannot have child entries -- also verify &IFMT is either IFDIR or IFLNK
// set if we fail to readlink
const ENOREADLINK = 256;
// set if we know realpath() will fail
const ENOREALPATH = 512;
const ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;
const TYPEMASK = 1023;
const entToType = (s) => s.isFile()
    ? IFREG
    : s.isDirectory()
        ? IFDIR
        : s.isSymbolicLink()
            ? IFLNK
            : s.isCharacterDevice()
                ? IFCHR
                : s.isBlockDevice()
                    ? IFBLK
                    : s.isSocket()
                        ? IFSOCK
                        : s.isFIFO()
                            ? IFIFO
                            : UNKNOWN;
// normalize unicode path names
const normalizeCache = new Map();
const normalize = (s) => {
    const c = normalizeCache.get(s);
    if (c)
        return c;
    const n = s.normalize('NFKD');
    normalizeCache.set(s, n);
    return n;
};
const normalizeNocaseCache = new Map();
const normalizeNocase = (s) => {
    const c = normalizeNocaseCache.get(s);
    if (c)
        return c;
    const n = normalize(s.toLowerCase());
    normalizeNocaseCache.set(s, n);
    return n;
};
/**
 * An LRUCache for storing resolved path strings or Path objects.
 * @internal
 */
class ResolveCache extends lru_cache_1.LRUCache {
    constructor() {
        super({ max: 256 });
    }
}
cjs$1.ResolveCache = ResolveCache;
// In order to prevent blowing out the js heap by allocating hundreds of
// thousands of Path entries when walking extremely large trees, the "children"
// in this tree are represented by storing an array of Path entries in an
// LRUCache, indexed by the parent.  At any time, Path.children() may return an
// empty array, indicating that it doesn't know about any of its children, and
// thus has to rebuild that cache.  This is fine, it just means that we don't
// benefit as much from having the cached entries, but huge directory walks
// don't blow out the stack, and smaller ones are still as fast as possible.
//
//It does impose some complexity when building up the readdir data, because we
//need to pass a reference to the children array that we started with.
/**
 * an LRUCache for storing child entries.
 * @internal
 */
class ChildrenCache extends lru_cache_1.LRUCache {
    constructor(maxSize = 16 * 1024) {
        super({
            maxSize,
            // parent + children
            sizeCalculation: a => a.length + 1,
        });
    }
}
cjs$1.ChildrenCache = ChildrenCache;
const setAsCwd = Symbol('PathScurry setAsCwd');
/**
 * Path objects are sort of like a super-powered
 * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}
 *
 * Each one represents a single filesystem entry on disk, which may or may not
 * exist. It includes methods for reading various types of information via
 * lstat, readlink, and readdir, and caches all information to the greatest
 * degree possible.
 *
 * Note that fs operations that would normally throw will instead return an
 * "empty" value. This is in order to prevent excessive overhead from error
 * stack traces.
 */
class PathBase {
    /**
     * the basename of this path
     *
     * **Important**: *always* test the path name against any test string
     * usingthe {@link isNamed} method, and not by directly comparing this
     * string. Otherwise, unicode path strings that the system sees as identical
     * will not be properly treated as the same path, leading to incorrect
     * behavior and possible security issues.
     */
    name;
    /**
     * the Path entry corresponding to the path root.
     *
     * @internal
     */
    root;
    /**
     * All roots found within the current PathScurry family
     *
     * @internal
     */
    roots;
    /**
     * a reference to the parent path, or undefined in the case of root entries
     *
     * @internal
     */
    parent;
    /**
     * boolean indicating whether paths are compared case-insensitively
     * @internal
     */
    nocase;
    // potential default fs override
    #fs;
    // Stats fields
    #dev;
    get dev() {
        return this.#dev;
    }
    #mode;
    get mode() {
        return this.#mode;
    }
    #nlink;
    get nlink() {
        return this.#nlink;
    }
    #uid;
    get uid() {
        return this.#uid;
    }
    #gid;
    get gid() {
        return this.#gid;
    }
    #rdev;
    get rdev() {
        return this.#rdev;
    }
    #blksize;
    get blksize() {
        return this.#blksize;
    }
    #ino;
    get ino() {
        return this.#ino;
    }
    #size;
    get size() {
        return this.#size;
    }
    #blocks;
    get blocks() {
        return this.#blocks;
    }
    #atimeMs;
    get atimeMs() {
        return this.#atimeMs;
    }
    #mtimeMs;
    get mtimeMs() {
        return this.#mtimeMs;
    }
    #ctimeMs;
    get ctimeMs() {
        return this.#ctimeMs;
    }
    #birthtimeMs;
    get birthtimeMs() {
        return this.#birthtimeMs;
    }
    #atime;
    get atime() {
        return this.#atime;
    }
    #mtime;
    get mtime() {
        return this.#mtime;
    }
    #ctime;
    get ctime() {
        return this.#ctime;
    }
    #birthtime;
    get birthtime() {
        return this.#birthtime;
    }
    #matchName;
    #depth;
    #fullpath;
    #fullpathPosix;
    #relative;
    #relativePosix;
    #type;
    #children;
    #linkTarget;
    #realpath;
    /**
     * This property is for compatibility with the Dirent class as of
     * Node v20, where Dirent['path'] refers to the path of the directory
     * that was passed to readdir.  So, somewhat counterintuitively, this
     * property refers to the *parent* path, not the path object itself.
     * For root entries, it's the path to the entry itself.
     */
    get path() {
        return (this.parent || this).fullpath();
    }
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
        this.name = name;
        this.#matchName = nocase ? normalizeNocase(name) : normalize(name);
        this.#type = type & TYPEMASK;
        this.nocase = nocase;
        this.roots = roots;
        this.root = root || this;
        this.#children = children;
        this.#fullpath = opts.fullpath;
        this.#relative = opts.relative;
        this.#relativePosix = opts.relativePosix;
        this.parent = opts.parent;
        if (this.parent) {
            this.#fs = this.parent.#fs;
        }
        else {
            this.#fs = fsFromOption(opts.fs);
        }
    }
    /**
     * Returns the depth of the Path object from its root.
     *
     * For example, a path at `/foo/bar` would have a depth of 2.
     */
    depth() {
        if (this.#depth !== undefined)
            return this.#depth;
        if (!this.parent)
            return (this.#depth = 0);
        return (this.#depth = this.parent.depth() + 1);
    }
    /**
     * @internal
     */
    childrenCache() {
        return this.#children;
    }
    /**
     * Get the Path object referenced by the string path, resolved from this Path
     */
    resolve(path) {
        if (!path) {
            return this;
        }
        const rootPath = this.getRootString(path);
        const dir = path.substring(rootPath.length);
        const dirParts = dir.split(this.splitSep);
        const result = rootPath
            ? this.getRoot(rootPath).#resolveParts(dirParts)
            : this.#resolveParts(dirParts);
        return result;
    }
    #resolveParts(dirParts) {
        let p = this;
        for (const part of dirParts) {
            p = p.child(part);
        }
        return p;
    }
    /**
     * Returns the cached children Path objects, if still available.  If they
     * have fallen out of the cache, then returns an empty array, and resets the
     * READDIR_CALLED bit, so that future calls to readdir() will require an fs
     * lookup.
     *
     * @internal
     */
    children() {
        const cached = this.#children.get(this);
        if (cached) {
            return cached;
        }
        const children = Object.assign([], { provisional: 0 });
        this.#children.set(this, children);
        this.#type &= ~READDIR_CALLED;
        return children;
    }
    /**
     * Resolves a path portion and returns or creates the child Path.
     *
     * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
     * `'..'`.
     *
     * This should not be called directly.  If `pathPart` contains any path
     * separators, it will lead to unsafe undefined behavior.
     *
     * Use `Path.resolve()` instead.
     *
     * @internal
     */
    child(pathPart, opts) {
        if (pathPart === '' || pathPart === '.') {
            return this;
        }
        if (pathPart === '..') {
            return this.parent || this;
        }
        // find the child
        const children = this.children();
        const name = this.nocase
            ? normalizeNocase(pathPart)
            : normalize(pathPart);
        for (const p of children) {
            if (p.#matchName === name) {
                return p;
            }
        }
        // didn't find it, create provisional child, since it might not
        // actually exist.  If we know the parent isn't a dir, then
        // in fact it CAN'T exist.
        const s = this.parent ? this.sep : '';
        const fullpath = this.#fullpath
            ? this.#fullpath + s + pathPart
            : undefined;
        const pchild = this.newChild(pathPart, UNKNOWN, {
            ...opts,
            parent: this,
            fullpath,
        });
        if (!this.canReaddir()) {
            pchild.#type |= ENOENT;
        }
        // don't have to update provisional, because if we have real children,
        // then provisional is set to children.length, otherwise a lower number
        children.push(pchild);
        return pchild;
    }
    /**
     * The relative path from the cwd. If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpath()
     */
    relative() {
        if (this.#relative !== undefined) {
            return this.#relative;
        }
        const name = this.name;
        const p = this.parent;
        if (!p) {
            return (this.#relative = this.name);
        }
        const pv = p.relative();
        return pv + (!pv || !p.parent ? '' : this.sep) + name;
    }
    /**
     * The relative path from the cwd, using / as the path separator.
     * If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpathPosix()
     * On posix systems, this is identical to relative().
     */
    relativePosix() {
        if (this.sep === '/')
            return this.relative();
        if (this.#relativePosix !== undefined)
            return this.#relativePosix;
        const name = this.name;
        const p = this.parent;
        if (!p) {
            return (this.#relativePosix = this.fullpathPosix());
        }
        const pv = p.relativePosix();
        return pv + (!pv || !p.parent ? '' : '/') + name;
    }
    /**
     * The fully resolved path string for this Path entry
     */
    fullpath() {
        if (this.#fullpath !== undefined) {
            return this.#fullpath;
        }
        const name = this.name;
        const p = this.parent;
        if (!p) {
            return (this.#fullpath = this.name);
        }
        const pv = p.fullpath();
        const fp = pv + (!p.parent ? '' : this.sep) + name;
        return (this.#fullpath = fp);
    }
    /**
     * On platforms other than windows, this is identical to fullpath.
     *
     * On windows, this is overridden to return the forward-slash form of the
     * full UNC path.
     */
    fullpathPosix() {
        if (this.#fullpathPosix !== undefined)
            return this.#fullpathPosix;
        if (this.sep === '/')
            return (this.#fullpathPosix = this.fullpath());
        if (!this.parent) {
            const p = this.fullpath().replace(/\\/g, '/');
            if (/^[a-z]:\//i.test(p)) {
                return (this.#fullpathPosix = `//?/${p}`);
            }
            else {
                return (this.#fullpathPosix = p);
            }
        }
        const p = this.parent;
        const pfpp = p.fullpathPosix();
        const fpp = pfpp + (!pfpp || !p.parent ? '' : '/') + this.name;
        return (this.#fullpathPosix = fpp);
    }
    /**
     * Is the Path of an unknown type?
     *
     * Note that we might know *something* about it if there has been a previous
     * filesystem operation, for example that it does not exist, or is not a
     * link, or whether it has child entries.
     */
    isUnknown() {
        return (this.#type & IFMT) === UNKNOWN;
    }
    isType(type) {
        return this[`is${type}`]();
    }
    getType() {
        return this.isUnknown()
            ? 'Unknown'
            : this.isDirectory()
                ? 'Directory'
                : this.isFile()
                    ? 'File'
                    : this.isSymbolicLink()
                        ? 'SymbolicLink'
                        : this.isFIFO()
                            ? 'FIFO'
                            : this.isCharacterDevice()
                                ? 'CharacterDevice'
                                : this.isBlockDevice()
                                    ? 'BlockDevice'
                                    : /* c8 ignore start */ this.isSocket()
                                        ? 'Socket'
                                        : 'Unknown';
        /* c8 ignore stop */
    }
    /**
     * Is the Path a regular file?
     */
    isFile() {
        return (this.#type & IFMT) === IFREG;
    }
    /**
     * Is the Path a directory?
     */
    isDirectory() {
        return (this.#type & IFMT) === IFDIR;
    }
    /**
     * Is the path a character device?
     */
    isCharacterDevice() {
        return (this.#type & IFMT) === IFCHR;
    }
    /**
     * Is the path a block device?
     */
    isBlockDevice() {
        return (this.#type & IFMT) === IFBLK;
    }
    /**
     * Is the path a FIFO pipe?
     */
    isFIFO() {
        return (this.#type & IFMT) === IFIFO;
    }
    /**
     * Is the path a socket?
     */
    isSocket() {
        return (this.#type & IFMT) === IFSOCK;
    }
    /**
     * Is the path a symbolic link?
     */
    isSymbolicLink() {
        return (this.#type & IFLNK) === IFLNK;
    }
    /**
     * Return the entry if it has been subject of a successful lstat, or
     * undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* simply
     * mean that we haven't called lstat on it.
     */
    lstatCached() {
        return this.#type & LSTAT_CALLED ? this : undefined;
    }
    /**
     * Return the cached link target if the entry has been the subject of a
     * successful readlink, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readlink() has been called at some point.
     */
    readlinkCached() {
        return this.#linkTarget;
    }
    /**
     * Returns the cached realpath target if the entry has been the subject
     * of a successful realpath, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * realpath() has been called at some point.
     */
    realpathCached() {
        return this.#realpath;
    }
    /**
     * Returns the cached child Path entries array if the entry has been the
     * subject of a successful readdir(), or [] otherwise.
     *
     * Does not read the filesystem, so an empty array *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readdir() has been called recently enough to still be valid.
     */
    readdirCached() {
        const children = this.children();
        return children.slice(0, children.provisional);
    }
    /**
     * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
     * any indication that readlink will definitely fail.
     *
     * Returns false if the path is known to not be a symlink, if a previous
     * readlink failed, or if the entry does not exist.
     */
    canReadlink() {
        if (this.#linkTarget)
            return true;
        if (!this.parent)
            return false;
        // cases where it cannot possibly succeed
        const ifmt = this.#type & IFMT;
        return !((ifmt !== UNKNOWN && ifmt !== IFLNK) ||
            this.#type & ENOREADLINK ||
            this.#type & ENOENT);
    }
    /**
     * Return true if readdir has previously been successfully called on this
     * path, indicating that cachedReaddir() is likely valid.
     */
    calledReaddir() {
        return !!(this.#type & READDIR_CALLED);
    }
    /**
     * Returns true if the path is known to not exist. That is, a previous lstat
     * or readdir failed to verify its existence when that would have been
     * expected, or a parent entry was marked either enoent or enotdir.
     */
    isENOENT() {
        return !!(this.#type & ENOENT);
    }
    /**
     * Return true if the path is a match for the given path name.  This handles
     * case sensitivity and unicode normalization.
     *
     * Note: even on case-sensitive systems, it is **not** safe to test the
     * equality of the `.name` property to determine whether a given pathname
     * matches, due to unicode normalization mismatches.
     *
     * Always use this method instead of testing the `path.name` property
     * directly.
     */
    isNamed(n) {
        return !this.nocase
            ? this.#matchName === normalize(n)
            : this.#matchName === normalizeNocase(n);
    }
    /**
     * Return the Path object corresponding to the target of a symbolic link.
     *
     * If the Path is not a symbolic link, or if the readlink call fails for any
     * reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     */
    async readlink() {
        const target = this.#linkTarget;
        if (target) {
            return target;
        }
        if (!this.canReadlink()) {
            return undefined;
        }
        /* c8 ignore start */
        // already covered by the canReadlink test, here for ts grumples
        if (!this.parent) {
            return undefined;
        }
        /* c8 ignore stop */
        try {
            const read = await this.#fs.promises.readlink(this.fullpath());
            const linkTarget = this.parent.resolve(read);
            if (linkTarget) {
                return (this.#linkTarget = linkTarget);
            }
        }
        catch (er) {
            this.#readlinkFail(er.code);
            return undefined;
        }
    }
    /**
     * Synchronous {@link PathBase.readlink}
     */
    readlinkSync() {
        const target = this.#linkTarget;
        if (target) {
            return target;
        }
        if (!this.canReadlink()) {
            return undefined;
        }
        /* c8 ignore start */
        // already covered by the canReadlink test, here for ts grumples
        if (!this.parent) {
            return undefined;
        }
        /* c8 ignore stop */
        try {
            const read = this.#fs.readlinkSync(this.fullpath());
            const linkTarget = this.parent.resolve(read);
            if (linkTarget) {
                return (this.#linkTarget = linkTarget);
            }
        }
        catch (er) {
            this.#readlinkFail(er.code);
            return undefined;
        }
    }
    #readdirSuccess(children) {
        // succeeded, mark readdir called bit
        this.#type |= READDIR_CALLED;
        // mark all remaining provisional children as ENOENT
        for (let p = children.provisional; p < children.length; p++) {
            children[p].#markENOENT();
        }
    }
    #markENOENT() {
        // mark as UNKNOWN and ENOENT
        if (this.#type & ENOENT)
            return;
        this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;
        this.#markChildrenENOENT();
    }
    #markChildrenENOENT() {
        // all children are provisional and do not exist
        const children = this.children();
        children.provisional = 0;
        for (const p of children) {
            p.#markENOENT();
        }
    }
    #markENOREALPATH() {
        this.#type |= ENOREALPATH;
        this.#markENOTDIR();
    }
    // save the information when we know the entry is not a dir
    #markENOTDIR() {
        // entry is not a directory, so any children can't exist.
        // this *should* be impossible, since any children created
        // after it's been marked ENOTDIR should be marked ENOENT,
        // so it won't even get to this point.
        /* c8 ignore start */
        if (this.#type & ENOTDIR)
            return;
        /* c8 ignore stop */
        let t = this.#type;
        // this could happen if we stat a dir, then delete it,
        // then try to read it or one of its children.
        if ((t & IFMT) === IFDIR)
            t &= IFMT_UNKNOWN;
        this.#type = t | ENOTDIR;
        this.#markChildrenENOENT();
    }
    #readdirFail(code = '') {
        // markENOTDIR and markENOENT also set provisional=0
        if (code === 'ENOTDIR' || code === 'EPERM') {
            this.#markENOTDIR();
        }
        else if (code === 'ENOENT') {
            this.#markENOENT();
        }
        else {
            this.children().provisional = 0;
        }
    }
    #lstatFail(code = '') {
        // Windows just raises ENOENT in this case, disable for win CI
        /* c8 ignore start */
        if (code === 'ENOTDIR') {
            // already know it has a parent by this point
            const p = this.parent;
            p.#markENOTDIR();
        }
        else if (code === 'ENOENT') {
            /* c8 ignore stop */
            this.#markENOENT();
        }
    }
    #readlinkFail(code = '') {
        let ter = this.#type;
        ter |= ENOREADLINK;
        if (code === 'ENOENT')
            ter |= ENOENT;
        // windows gets a weird error when you try to readlink a file
        if (code === 'EINVAL' || code === 'UNKNOWN') {
            // exists, but not a symlink, we don't know WHAT it is, so remove
            // all IFMT bits.
            ter &= IFMT_UNKNOWN;
        }
        this.#type = ter;
        // windows just gets ENOENT in this case.  We do cover the case,
        // just disabled because it's impossible on Windows CI
        /* c8 ignore start */
        if (code === 'ENOTDIR' && this.parent) {
            this.parent.#markENOTDIR();
        }
        /* c8 ignore stop */
    }
    #readdirAddChild(e, c) {
        return (this.#readdirMaybePromoteChild(e, c) ||
            this.#readdirAddNewChild(e, c));
    }
    #readdirAddNewChild(e, c) {
        // alloc new entry at head, so it's never provisional
        const type = entToType(e);
        const child = this.newChild(e.name, type, { parent: this });
        const ifmt = child.#type & IFMT;
        if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {
            child.#type |= ENOTDIR;
        }
        c.unshift(child);
        c.provisional++;
        return child;
    }
    #readdirMaybePromoteChild(e, c) {
        for (let p = c.provisional; p < c.length; p++) {
            const pchild = c[p];
            const name = this.nocase
                ? normalizeNocase(e.name)
                : normalize(e.name);
            if (name !== pchild.#matchName) {
                continue;
            }
            return this.#readdirPromoteChild(e, pchild, p, c);
        }
    }
    #readdirPromoteChild(e, p, index, c) {
        const v = p.name;
        // retain any other flags, but set ifmt from dirent
        p.#type = (p.#type & IFMT_UNKNOWN) | entToType(e);
        // case sensitivity fixing when we learn the true name.
        if (v !== e.name)
            p.name = e.name;
        // just advance provisional index (potentially off the list),
        // otherwise we have to splice/pop it out and re-insert at head
        if (index !== c.provisional) {
            if (index === c.length - 1)
                c.pop();
            else
                c.splice(index, 1);
            c.unshift(p);
        }
        c.provisional++;
        return p;
    }
    /**
     * Call lstat() on this Path, and update all known information that can be
     * determined.
     *
     * Note that unlike `fs.lstat()`, the returned value does not contain some
     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
     * information is required, you will need to call `fs.lstat` yourself.
     *
     * If the Path refers to a nonexistent file, or if the lstat call fails for
     * any reason, `undefined` is returned.  Otherwise the updated Path object is
     * returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    async lstat() {
        if ((this.#type & ENOENT) === 0) {
            try {
                this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));
                return this;
            }
            catch (er) {
                this.#lstatFail(er.code);
            }
        }
    }
    /**
     * synchronous {@link PathBase.lstat}
     */
    lstatSync() {
        if ((this.#type & ENOENT) === 0) {
            try {
                this.#applyStat(this.#fs.lstatSync(this.fullpath()));
                return this;
            }
            catch (er) {
                this.#lstatFail(er.code);
            }
        }
    }
    #applyStat(st) {
        const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid, } = st;
        this.#atime = atime;
        this.#atimeMs = atimeMs;
        this.#birthtime = birthtime;
        this.#birthtimeMs = birthtimeMs;
        this.#blksize = blksize;
        this.#blocks = blocks;
        this.#ctime = ctime;
        this.#ctimeMs = ctimeMs;
        this.#dev = dev;
        this.#gid = gid;
        this.#ino = ino;
        this.#mode = mode;
        this.#mtime = mtime;
        this.#mtimeMs = mtimeMs;
        this.#nlink = nlink;
        this.#rdev = rdev;
        this.#size = size;
        this.#uid = uid;
        const ifmt = entToType(st);
        // retain any other flags, but set the ifmt
        this.#type = (this.#type & IFMT_UNKNOWN) | ifmt | LSTAT_CALLED;
        if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {
            this.#type |= ENOTDIR;
        }
    }
    #onReaddirCB = [];
    #readdirCBInFlight = false;
    #callOnReaddirCB(children) {
        this.#readdirCBInFlight = false;
        const cbs = this.#onReaddirCB.slice();
        this.#onReaddirCB.length = 0;
        cbs.forEach(cb => cb(null, children));
    }
    /**
     * Standard node-style callback interface to get list of directory entries.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     *
     * @param cb The callback called with (er, entries).  Note that the `er`
     * param is somewhat extraneous, as all readdir() errors are handled and
     * simply result in an empty set of entries being returned.
     * @param allowZalgo Boolean indicating that immediately known results should
     * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
     * zalgo at your peril, the dark pony lord is devious and unforgiving.
     */
    readdirCB(cb, allowZalgo = false) {
        if (!this.canReaddir()) {
            if (allowZalgo)
                cb(null, []);
            else
                queueMicrotask(() => cb(null, []));
            return;
        }
        const children = this.children();
        if (this.calledReaddir()) {
            const c = children.slice(0, children.provisional);
            if (allowZalgo)
                cb(null, c);
            else
                queueMicrotask(() => cb(null, c));
            return;
        }
        // don't have to worry about zalgo at this point.
        this.#onReaddirCB.push(cb);
        if (this.#readdirCBInFlight) {
            return;
        }
        this.#readdirCBInFlight = true;
        // else read the directory, fill up children
        // de-provisionalize any provisional children.
        const fullpath = this.fullpath();
        this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {
            if (er) {
                this.#readdirFail(er.code);
                children.provisional = 0;
            }
            else {
                // if we didn't get an error, we always get entries.
                //@ts-ignore
                for (const e of entries) {
                    this.#readdirAddChild(e, children);
                }
                this.#readdirSuccess(children);
            }
            this.#callOnReaddirCB(children.slice(0, children.provisional));
            return;
        });
    }
    #asyncReaddirInFlight;
    /**
     * Return an array of known child entries.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    async readdir() {
        if (!this.canReaddir()) {
            return [];
        }
        const children = this.children();
        if (this.calledReaddir()) {
            return children.slice(0, children.provisional);
        }
        // else read the directory, fill up children
        // de-provisionalize any provisional children.
        const fullpath = this.fullpath();
        if (this.#asyncReaddirInFlight) {
            await this.#asyncReaddirInFlight;
        }
        else {
            /* c8 ignore start */
            let resolve = () => { };
            /* c8 ignore stop */
            this.#asyncReaddirInFlight = new Promise(res => (resolve = res));
            try {
                for (const e of await this.#fs.promises.readdir(fullpath, {
                    withFileTypes: true,
                })) {
                    this.#readdirAddChild(e, children);
                }
                this.#readdirSuccess(children);
            }
            catch (er) {
                this.#readdirFail(er.code);
                children.provisional = 0;
            }
            this.#asyncReaddirInFlight = undefined;
            resolve();
        }
        return children.slice(0, children.provisional);
    }
    /**
     * synchronous {@link PathBase.readdir}
     */
    readdirSync() {
        if (!this.canReaddir()) {
            return [];
        }
        const children = this.children();
        if (this.calledReaddir()) {
            return children.slice(0, children.provisional);
        }
        // else read the directory, fill up children
        // de-provisionalize any provisional children.
        const fullpath = this.fullpath();
        try {
            for (const e of this.#fs.readdirSync(fullpath, {
                withFileTypes: true,
            })) {
                this.#readdirAddChild(e, children);
            }
            this.#readdirSuccess(children);
        }
        catch (er) {
            this.#readdirFail(er.code);
            children.provisional = 0;
        }
        return children.slice(0, children.provisional);
    }
    canReaddir() {
        if (this.#type & ENOCHILD)
            return false;
        const ifmt = IFMT & this.#type;
        // we always set ENOTDIR when setting IFMT, so should be impossible
        /* c8 ignore start */
        if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {
            return false;
        }
        /* c8 ignore stop */
        return true;
    }
    shouldWalk(dirs, walkFilter) {
        return ((this.#type & IFDIR) === IFDIR &&
            !(this.#type & ENOCHILD) &&
            !dirs.has(this) &&
            (!walkFilter || walkFilter(this)));
    }
    /**
     * Return the Path object corresponding to path as resolved
     * by realpath(3).
     *
     * If the realpath call fails for any reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     * On success, returns a Path object.
     */
    async realpath() {
        if (this.#realpath)
            return this.#realpath;
        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
            return undefined;
        try {
            const rp = await this.#fs.promises.realpath(this.fullpath());
            return (this.#realpath = this.resolve(rp));
        }
        catch (_) {
            this.#markENOREALPATH();
        }
    }
    /**
     * Synchronous {@link realpath}
     */
    realpathSync() {
        if (this.#realpath)
            return this.#realpath;
        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
            return undefined;
        try {
            const rp = this.#fs.realpathSync(this.fullpath());
            return (this.#realpath = this.resolve(rp));
        }
        catch (_) {
            this.#markENOREALPATH();
        }
    }
    /**
     * Internal method to mark this Path object as the scurry cwd,
     * called by {@link PathScurry#chdir}
     *
     * @internal
     */
    [setAsCwd](oldCwd) {
        if (oldCwd === this)
            return;
        const changed = new Set([]);
        let rp = [];
        let p = this;
        while (p && p.parent) {
            changed.add(p);
            p.#relative = rp.join(this.sep);
            p.#relativePosix = rp.join('/');
            p = p.parent;
            rp.push('..');
        }
        // now un-memoize parents of old cwd
        p = oldCwd;
        while (p && p.parent && !changed.has(p)) {
            p.#relative = undefined;
            p.#relativePosix = undefined;
            p = p.parent;
        }
    }
}
cjs$1.PathBase = PathBase;
/**
 * Path class used on win32 systems
 *
 * Uses `'\\'` as the path separator for returned paths, either `'\\'` or `'/'`
 * as the path separator for parsing paths.
 */
class PathWin32 extends PathBase {
    /**
     * Separator for generating path strings.
     */
    sep = '\\';
    /**
     * Separator for parsing path strings.
     */
    splitSep = eitherSep;
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
        super(name, type, root, roots, nocase, children, opts);
    }
    /**
     * @internal
     */
    newChild(name, type = UNKNOWN, opts = {}) {
        return new PathWin32(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
    }
    /**
     * @internal
     */
    getRootString(path) {
        return path_1.win32.parse(path).root;
    }
    /**
     * @internal
     */
    getRoot(rootPath) {
        rootPath = uncToDrive(rootPath.toUpperCase());
        if (rootPath === this.root.name) {
            return this.root;
        }
        // ok, not that one, check if it matches another we know about
        for (const [compare, root] of Object.entries(this.roots)) {
            if (this.sameRoot(rootPath, compare)) {
                return (this.roots[rootPath] = root);
            }
        }
        // otherwise, have to create a new one.
        return (this.roots[rootPath] = new PathScurryWin32(rootPath, this).root);
    }
    /**
     * @internal
     */
    sameRoot(rootPath, compare = this.root.name) {
        // windows can (rarely) have case-sensitive filesystem, but
        // UNC and drive letters are always case-insensitive, and canonically
        // represented uppercase.
        rootPath = rootPath
            .toUpperCase()
            .replace(/\//g, '\\')
            .replace(uncDriveRegexp, '$1\\');
        return rootPath === compare;
    }
}
cjs$1.PathWin32 = PathWin32;
/**
 * Path class used on all posix systems.
 *
 * Uses `'/'` as the path separator.
 */
class PathPosix extends PathBase {
    /**
     * separator for parsing path strings
     */
    splitSep = '/';
    /**
     * separator for generating path strings
     */
    sep = '/';
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
        super(name, type, root, roots, nocase, children, opts);
    }
    /**
     * @internal
     */
    getRootString(path) {
        return path.startsWith('/') ? '/' : '';
    }
    /**
     * @internal
     */
    getRoot(_rootPath) {
        return this.root;
    }
    /**
     * @internal
     */
    newChild(name, type = UNKNOWN, opts = {}) {
        return new PathPosix(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
    }
}
cjs$1.PathPosix = PathPosix;
/**
 * The base class for all PathScurry classes, providing the interface for path
 * resolution and filesystem operations.
 *
 * Typically, you should *not* instantiate this class directly, but rather one
 * of the platform-specific classes, or the exported {@link PathScurry} which
 * defaults to the current platform.
 */
class PathScurryBase {
    /**
     * The root Path entry for the current working directory of this Scurry
     */
    root;
    /**
     * The string path for the root of this Scurry's current working directory
     */
    rootPath;
    /**
     * A collection of all roots encountered, referenced by rootPath
     */
    roots;
    /**
     * The Path entry corresponding to this PathScurry's current working directory.
     */
    cwd;
    #resolveCache;
    #resolvePosixCache;
    #children;
    /**
     * Perform path comparisons case-insensitively.
     *
     * Defaults true on Darwin and Windows systems, false elsewhere.
     */
    nocase;
    #fs;
    /**
     * This class should not be instantiated directly.
     *
     * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
     *
     * @internal
     */
    constructor(cwd = process.cwd(), pathImpl, sep, { nocase, childrenCacheSize = 16 * 1024, fs = defaultFS, } = {}) {
        this.#fs = fsFromOption(fs);
        if (cwd instanceof URL || cwd.startsWith('file://')) {
            cwd = (0, url_1$1.fileURLToPath)(cwd);
        }
        // resolve and split root, and then add to the store.
        // this is the only time we call path.resolve()
        const cwdPath = pathImpl.resolve(cwd);
        this.roots = Object.create(null);
        this.rootPath = this.parseRootPath(cwdPath);
        this.#resolveCache = new ResolveCache();
        this.#resolvePosixCache = new ResolveCache();
        this.#children = new ChildrenCache(childrenCacheSize);
        const split = cwdPath.substring(this.rootPath.length).split(sep);
        // resolve('/') leaves '', splits to [''], we don't want that.
        if (split.length === 1 && !split[0]) {
            split.pop();
        }
        /* c8 ignore start */
        if (nocase === undefined) {
            throw new TypeError('must provide nocase setting to PathScurryBase ctor');
        }
        /* c8 ignore stop */
        this.nocase = nocase;
        this.root = this.newRoot(this.#fs);
        this.roots[this.rootPath] = this.root;
        let prev = this.root;
        let len = split.length - 1;
        const joinSep = pathImpl.sep;
        let abs = this.rootPath;
        let sawFirst = false;
        for (const part of split) {
            const l = len--;
            prev = prev.child(part, {
                relative: new Array(l).fill('..').join(joinSep),
                relativePosix: new Array(l).fill('..').join('/'),
                fullpath: (abs += (sawFirst ? '' : joinSep) + part),
            });
            sawFirst = true;
        }
        this.cwd = prev;
    }
    /**
     * Get the depth of a provided path, string, or the cwd
     */
    depth(path = this.cwd) {
        if (typeof path === 'string') {
            path = this.cwd.resolve(path);
        }
        return path.depth();
    }
    /**
     * Return the cache of child entries.  Exposed so subclasses can create
     * child Path objects in a platform-specific way.
     *
     * @internal
     */
    childrenCache() {
        return this.#children;
    }
    /**
     * Resolve one or more path strings to a resolved string
     *
     * Same interface as require('path').resolve.
     *
     * Much faster than path.resolve() when called multiple times for the same
     * path, because the resolved Path objects are cached.  Much slower
     * otherwise.
     */
    resolve(...paths) {
        // first figure out the minimum number of paths we have to test
        // we always start at cwd, but any absolutes will bump the start
        let r = '';
        for (let i = paths.length - 1; i >= 0; i--) {
            const p = paths[i];
            if (!p || p === '.')
                continue;
            r = r ? `${p}/${r}` : p;
            if (this.isAbsolute(p)) {
                break;
            }
        }
        const cached = this.#resolveCache.get(r);
        if (cached !== undefined) {
            return cached;
        }
        const result = this.cwd.resolve(r).fullpath();
        this.#resolveCache.set(r, result);
        return result;
    }
    /**
     * Resolve one or more path strings to a resolved string, returning
     * the posix path.  Identical to .resolve() on posix systems, but on
     * windows will return a forward-slash separated UNC path.
     *
     * Same interface as require('path').resolve.
     *
     * Much faster than path.resolve() when called multiple times for the same
     * path, because the resolved Path objects are cached.  Much slower
     * otherwise.
     */
    resolvePosix(...paths) {
        // first figure out the minimum number of paths we have to test
        // we always start at cwd, but any absolutes will bump the start
        let r = '';
        for (let i = paths.length - 1; i >= 0; i--) {
            const p = paths[i];
            if (!p || p === '.')
                continue;
            r = r ? `${p}/${r}` : p;
            if (this.isAbsolute(p)) {
                break;
            }
        }
        const cached = this.#resolvePosixCache.get(r);
        if (cached !== undefined) {
            return cached;
        }
        const result = this.cwd.resolve(r).fullpathPosix();
        this.#resolvePosixCache.set(r, result);
        return result;
    }
    /**
     * find the relative path from the cwd to the supplied path string or entry
     */
    relative(entry = this.cwd) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        return entry.relative();
    }
    /**
     * find the relative path from the cwd to the supplied path string or
     * entry, using / as the path delimiter, even on Windows.
     */
    relativePosix(entry = this.cwd) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        return entry.relativePosix();
    }
    /**
     * Return the basename for the provided string or Path object
     */
    basename(entry = this.cwd) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        return entry.name;
    }
    /**
     * Return the dirname for the provided string or Path object
     */
    dirname(entry = this.cwd) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        return (entry.parent || entry).fullpath();
    }
    async readdir(entry = this.cwd, opts = {
        withFileTypes: true,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes } = opts;
        if (!entry.canReaddir()) {
            return [];
        }
        else {
            const p = await entry.readdir();
            return withFileTypes ? p : p.map(e => e.name);
        }
    }
    readdirSync(entry = this.cwd, opts = {
        withFileTypes: true,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true } = opts;
        if (!entry.canReaddir()) {
            return [];
        }
        else if (withFileTypes) {
            return entry.readdirSync();
        }
        else {
            return entry.readdirSync().map(e => e.name);
        }
    }
    /**
     * Call lstat() on the string or Path object, and update all known
     * information that can be determined.
     *
     * Note that unlike `fs.lstat()`, the returned value does not contain some
     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
     * information is required, you will need to call `fs.lstat` yourself.
     *
     * If the Path refers to a nonexistent file, or if the lstat call fails for
     * any reason, `undefined` is returned.  Otherwise the updated Path object is
     * returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    async lstat(entry = this.cwd) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        return entry.lstat();
    }
    /**
     * synchronous {@link PathScurryBase.lstat}
     */
    lstatSync(entry = this.cwd) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        return entry.lstatSync();
    }
    async readlink(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            withFileTypes = entry.withFileTypes;
            entry = this.cwd;
        }
        const e = await entry.readlink();
        return withFileTypes ? e : e?.fullpath();
    }
    readlinkSync(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            withFileTypes = entry.withFileTypes;
            entry = this.cwd;
        }
        const e = entry.readlinkSync();
        return withFileTypes ? e : e?.fullpath();
    }
    async realpath(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            withFileTypes = entry.withFileTypes;
            entry = this.cwd;
        }
        const e = await entry.realpath();
        return withFileTypes ? e : e?.fullpath();
    }
    realpathSync(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            withFileTypes = entry.withFileTypes;
            entry = this.cwd;
        }
        const e = entry.realpathSync();
        return withFileTypes ? e : e?.fullpath();
    }
    async walk(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        const results = [];
        if (!filter || filter(entry)) {
            results.push(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = new Set();
        const walk = (dir, cb) => {
            dirs.add(dir);
            dir.readdirCB((er, entries) => {
                /* c8 ignore start */
                if (er) {
                    return cb(er);
                }
                /* c8 ignore stop */
                let len = entries.length;
                if (!len)
                    return cb();
                const next = () => {
                    if (--len === 0) {
                        cb();
                    }
                };
                for (const e of entries) {
                    if (!filter || filter(e)) {
                        results.push(withFileTypes ? e : e.fullpath());
                    }
                    if (follow && e.isSymbolicLink()) {
                        e.realpath()
                            .then(r => (r?.isUnknown() ? r.lstat() : r))
                            .then(r => r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());
                    }
                    else {
                        if (e.shouldWalk(dirs, walkFilter)) {
                            walk(e, next);
                        }
                        else {
                            next();
                        }
                    }
                }
            }, true); // zalgooooooo
        };
        const start = entry;
        return new Promise((res, rej) => {
            walk(start, er => {
                /* c8 ignore start */
                if (er)
                    return rej(er);
                /* c8 ignore stop */
                res(results);
            });
        });
    }
    walkSync(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        const results = [];
        if (!filter || filter(entry)) {
            results.push(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = new Set([entry]);
        for (const dir of dirs) {
            const entries = dir.readdirSync();
            for (const e of entries) {
                if (!filter || filter(e)) {
                    results.push(withFileTypes ? e : e.fullpath());
                }
                let r = e;
                if (e.isSymbolicLink()) {
                    if (!(follow && (r = e.realpathSync())))
                        continue;
                    if (r.isUnknown())
                        r.lstatSync();
                }
                if (r.shouldWalk(dirs, walkFilter)) {
                    dirs.add(r);
                }
            }
        }
        return results;
    }
    /**
     * Support for `for await`
     *
     * Alias for {@link PathScurryBase.iterate}
     *
     * Note: As of Node 19, this is very slow, compared to other methods of
     * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
     * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
     */
    [Symbol.asyncIterator]() {
        return this.iterate();
    }
    iterate(entry = this.cwd, options = {}) {
        // iterating async over the stream is significantly more performant,
        // especially in the warm-cache scenario, because it buffers up directory
        // entries in the background instead of waiting for a yield for each one.
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            options = entry;
            entry = this.cwd;
        }
        return this.stream(entry, options)[Symbol.asyncIterator]();
    }
    /**
     * Iterating over a PathScurry performs a synchronous walk.
     *
     * Alias for {@link PathScurryBase.iterateSync}
     */
    [Symbol.iterator]() {
        return this.iterateSync();
    }
    *iterateSync(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        if (!filter || filter(entry)) {
            yield withFileTypes ? entry : entry.fullpath();
        }
        const dirs = new Set([entry]);
        for (const dir of dirs) {
            const entries = dir.readdirSync();
            for (const e of entries) {
                if (!filter || filter(e)) {
                    yield withFileTypes ? e : e.fullpath();
                }
                let r = e;
                if (e.isSymbolicLink()) {
                    if (!(follow && (r = e.realpathSync())))
                        continue;
                    if (r.isUnknown())
                        r.lstatSync();
                }
                if (r.shouldWalk(dirs, walkFilter)) {
                    dirs.add(r);
                }
            }
        }
    }
    stream(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        const results = new minipass_1$1.Minipass({ objectMode: true });
        if (!filter || filter(entry)) {
            results.write(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = new Set();
        const queue = [entry];
        let processing = 0;
        const process = () => {
            let paused = false;
            while (!paused) {
                const dir = queue.shift();
                if (!dir) {
                    if (processing === 0)
                        results.end();
                    return;
                }
                processing++;
                dirs.add(dir);
                const onReaddir = (er, entries, didRealpaths = false) => {
                    /* c8 ignore start */
                    if (er)
                        return results.emit('error', er);
                    /* c8 ignore stop */
                    if (follow && !didRealpaths) {
                        const promises = [];
                        for (const e of entries) {
                            if (e.isSymbolicLink()) {
                                promises.push(e
                                    .realpath()
                                    .then((r) => r?.isUnknown() ? r.lstat() : r));
                            }
                        }
                        if (promises.length) {
                            Promise.all(promises).then(() => onReaddir(null, entries, true));
                            return;
                        }
                    }
                    for (const e of entries) {
                        if (e && (!filter || filter(e))) {
                            if (!results.write(withFileTypes ? e : e.fullpath())) {
                                paused = true;
                            }
                        }
                    }
                    processing--;
                    for (const e of entries) {
                        const r = e.realpathCached() || e;
                        if (r.shouldWalk(dirs, walkFilter)) {
                            queue.push(r);
                        }
                    }
                    if (paused && !results.flowing) {
                        results.once('drain', process);
                    }
                    else if (!sync) {
                        process();
                    }
                };
                // zalgo containment
                let sync = true;
                dir.readdirCB(onReaddir, true);
                sync = false;
            }
        };
        process();
        return results;
    }
    streamSync(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        const results = new minipass_1$1.Minipass({ objectMode: true });
        const dirs = new Set();
        if (!filter || filter(entry)) {
            results.write(withFileTypes ? entry : entry.fullpath());
        }
        const queue = [entry];
        let processing = 0;
        const process = () => {
            let paused = false;
            while (!paused) {
                const dir = queue.shift();
                if (!dir) {
                    if (processing === 0)
                        results.end();
                    return;
                }
                processing++;
                dirs.add(dir);
                const entries = dir.readdirSync();
                for (const e of entries) {
                    if (!filter || filter(e)) {
                        if (!results.write(withFileTypes ? e : e.fullpath())) {
                            paused = true;
                        }
                    }
                }
                processing--;
                for (const e of entries) {
                    let r = e;
                    if (e.isSymbolicLink()) {
                        if (!(follow && (r = e.realpathSync())))
                            continue;
                        if (r.isUnknown())
                            r.lstatSync();
                    }
                    if (r.shouldWalk(dirs, walkFilter)) {
                        queue.push(r);
                    }
                }
            }
            if (paused && !results.flowing)
                results.once('drain', process);
        };
        process();
        return results;
    }
    chdir(path = this.cwd) {
        const oldCwd = this.cwd;
        this.cwd = typeof path === 'string' ? this.cwd.resolve(path) : path;
        this.cwd[setAsCwd](oldCwd);
    }
}
cjs$1.PathScurryBase = PathScurryBase;
/**
 * Windows implementation of {@link PathScurryBase}
 *
 * Defaults to case insensitve, uses `'\\'` to generate path strings.  Uses
 * {@link PathWin32} for Path objects.
 */
class PathScurryWin32 extends PathScurryBase {
    /**
     * separator for generating path strings
     */
    sep = '\\';
    constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = true } = opts;
        super(cwd, path_1.win32, '\\', { ...opts, nocase });
        this.nocase = nocase;
        for (let p = this.cwd; p; p = p.parent) {
            p.nocase = this.nocase;
        }
    }
    /**
     * @internal
     */
    parseRootPath(dir) {
        // if the path starts with a single separator, it's not a UNC, and we'll
        // just get separator as the root, and driveFromUNC will return \
        // In that case, mount \ on the root from the cwd.
        return path_1.win32.parse(dir).root.toUpperCase();
    }
    /**
     * @internal
     */
    newRoot(fs) {
        return new PathWin32(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), { fs });
    }
    /**
     * Return true if the provided path string is an absolute path
     */
    isAbsolute(p) {
        return (p.startsWith('/') || p.startsWith('\\') || /^[a-z]:(\/|\\)/i.test(p));
    }
}
cjs$1.PathScurryWin32 = PathScurryWin32;
/**
 * {@link PathScurryBase} implementation for all posix systems other than Darwin.
 *
 * Defaults to case-sensitive matching, uses `'/'` to generate path strings.
 *
 * Uses {@link PathPosix} for Path objects.
 */
class PathScurryPosix extends PathScurryBase {
    /**
     * separator for generating path strings
     */
    sep = '/';
    constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = false } = opts;
        super(cwd, path_1.posix, '/', { ...opts, nocase });
        this.nocase = nocase;
    }
    /**
     * @internal
     */
    parseRootPath(_dir) {
        return '/';
    }
    /**
     * @internal
     */
    newRoot(fs) {
        return new PathPosix(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), { fs });
    }
    /**
     * Return true if the provided path string is an absolute path
     */
    isAbsolute(p) {
        return p.startsWith('/');
    }
}
cjs$1.PathScurryPosix = PathScurryPosix;
/**
 * {@link PathScurryBase} implementation for Darwin (macOS) systems.
 *
 * Defaults to case-insensitive matching, uses `'/'` for generating path
 * strings.
 *
 * Uses {@link PathPosix} for Path objects.
 */
class PathScurryDarwin extends PathScurryPosix {
    constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = true } = opts;
        super(cwd, { ...opts, nocase });
    }
}
cjs$1.PathScurryDarwin = PathScurryDarwin;
/**
 * Default {@link PathBase} implementation for the current platform.
 *
 * {@link PathWin32} on Windows systems, {@link PathPosix} on all others.
 */
cjs$1.Path = process.platform === 'win32' ? PathWin32 : PathPosix;
/**
 * Default {@link PathScurryBase} implementation for the current platform.
 *
 * {@link PathScurryWin32} on Windows systems, {@link PathScurryDarwin} on
 * Darwin (macOS) systems, {@link PathScurryPosix} on all others.
 */
cjs$1.PathScurry = process.platform === 'win32'
    ? PathScurryWin32
    : process.platform === 'darwin'
        ? PathScurryDarwin
        : PathScurryPosix;

var pattern$1 = {};

// this is just a very light wrapper around 2 arrays with an offset index
Object.defineProperty(pattern$1, "__esModule", { value: true });
pattern$1.Pattern = void 0;
const minimatch_1$4 = cjs$2;
const isPatternList = (pl) => pl.length >= 1;
const isGlobList = (gl) => gl.length >= 1;
/**
 * An immutable-ish view on an array of glob parts and their parsed
 * results
 */
class Pattern {
    #patternList;
    #globList;
    #index;
    length;
    #platform;
    #rest;
    #globString;
    #isDrive;
    #isUNC;
    #isAbsolute;
    #followGlobstar = true;
    constructor(patternList, globList, index, platform) {
        if (!isPatternList(patternList)) {
            throw new TypeError('empty pattern list');
        }
        if (!isGlobList(globList)) {
            throw new TypeError('empty glob list');
        }
        if (globList.length !== patternList.length) {
            throw new TypeError('mismatched pattern list and glob list lengths');
        }
        this.length = patternList.length;
        if (index < 0 || index >= this.length) {
            throw new TypeError('index out of range');
        }
        this.#patternList = patternList;
        this.#globList = globList;
        this.#index = index;
        this.#platform = platform;
        // normalize root entries of absolute patterns on initial creation.
        if (this.#index === 0) {
            // c: => ['c:/']
            // C:/ => ['C:/']
            // C:/x => ['C:/', 'x']
            // //host/share => ['//host/share/']
            // //host/share/ => ['//host/share/']
            // //host/share/x => ['//host/share/', 'x']
            // /etc => ['/', 'etc']
            // / => ['/']
            if (this.isUNC()) {
                // '' / '' / 'host' / 'share'
                const [p0, p1, p2, p3, ...prest] = this.#patternList;
                const [g0, g1, g2, g3, ...grest] = this.#globList;
                if (prest[0] === '') {
                    // ends in /
                    prest.shift();
                    grest.shift();
                }
                const p = [p0, p1, p2, p3, ''].join('/');
                const g = [g0, g1, g2, g3, ''].join('/');
                this.#patternList = [p, ...prest];
                this.#globList = [g, ...grest];
                this.length = this.#patternList.length;
            }
            else if (this.isDrive() || this.isAbsolute()) {
                const [p1, ...prest] = this.#patternList;
                const [g1, ...grest] = this.#globList;
                if (prest[0] === '') {
                    // ends in /
                    prest.shift();
                    grest.shift();
                }
                const p = p1 + '/';
                const g = g1 + '/';
                this.#patternList = [p, ...prest];
                this.#globList = [g, ...grest];
                this.length = this.#patternList.length;
            }
        }
    }
    /**
     * The first entry in the parsed list of patterns
     */
    pattern() {
        return this.#patternList[this.#index];
    }
    /**
     * true of if pattern() returns a string
     */
    isString() {
        return typeof this.#patternList[this.#index] === 'string';
    }
    /**
     * true of if pattern() returns GLOBSTAR
     */
    isGlobstar() {
        return this.#patternList[this.#index] === minimatch_1$4.GLOBSTAR;
    }
    /**
     * true if pattern() returns a regexp
     */
    isRegExp() {
        return this.#patternList[this.#index] instanceof RegExp;
    }
    /**
     * The /-joined set of glob parts that make up this pattern
     */
    globString() {
        return (this.#globString =
            this.#globString ||
                (this.#index === 0
                    ? this.isAbsolute()
                        ? this.#globList[0] + this.#globList.slice(1).join('/')
                        : this.#globList.join('/')
                    : this.#globList.slice(this.#index).join('/')));
    }
    /**
     * true if there are more pattern parts after this one
     */
    hasMore() {
        return this.length > this.#index + 1;
    }
    /**
     * The rest of the pattern after this part, or null if this is the end
     */
    rest() {
        if (this.#rest !== undefined)
            return this.#rest;
        if (!this.hasMore())
            return (this.#rest = null);
        this.#rest = new Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);
        this.#rest.#isAbsolute = this.#isAbsolute;
        this.#rest.#isUNC = this.#isUNC;
        this.#rest.#isDrive = this.#isDrive;
        return this.#rest;
    }
    /**
     * true if the pattern represents a //unc/path/ on windows
     */
    isUNC() {
        const pl = this.#patternList;
        return this.#isUNC !== undefined
            ? this.#isUNC
            : (this.#isUNC =
                this.#platform === 'win32' &&
                    this.#index === 0 &&
                    pl[0] === '' &&
                    pl[1] === '' &&
                    typeof pl[2] === 'string' &&
                    !!pl[2] &&
                    typeof pl[3] === 'string' &&
                    !!pl[3]);
    }
    // pattern like C:/...
    // split = ['C:', ...]
    // XXX: would be nice to handle patterns like `c:*` to test the cwd
    // in c: for *, but I don't know of a way to even figure out what that
    // cwd is without actually chdir'ing into it?
    /**
     * True if the pattern starts with a drive letter on Windows
     */
    isDrive() {
        const pl = this.#patternList;
        return this.#isDrive !== undefined
            ? this.#isDrive
            : (this.#isDrive =
                this.#platform === 'win32' &&
                    this.#index === 0 &&
                    this.length > 1 &&
                    typeof pl[0] === 'string' &&
                    /^[a-z]:$/i.test(pl[0]));
    }
    // pattern = '/' or '/...' or '/x/...'
    // split = ['', ''] or ['', ...] or ['', 'x', ...]
    // Drive and UNC both considered absolute on windows
    /**
     * True if the pattern is rooted on an absolute path
     */
    isAbsolute() {
        const pl = this.#patternList;
        return this.#isAbsolute !== undefined
            ? this.#isAbsolute
            : (this.#isAbsolute =
                (pl[0] === '' && pl.length > 1) ||
                    this.isDrive() ||
                    this.isUNC());
    }
    /**
     * consume the root of the pattern, and return it
     */
    root() {
        const p = this.#patternList[0];
        return typeof p === 'string' && this.isAbsolute() && this.#index === 0
            ? p
            : '';
    }
    /**
     * Check to see if the current globstar pattern is allowed to follow
     * a symbolic link.
     */
    checkFollowGlobstar() {
        return !(this.#index === 0 ||
            !this.isGlobstar() ||
            !this.#followGlobstar);
    }
    /**
     * Mark that the current globstar pattern is following a symbolic link
     */
    markFollowGlobstar() {
        if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)
            return false;
        this.#followGlobstar = false;
        return true;
    }
}
pattern$1.Pattern = Pattern;

var walker = {};

var minipass = {};

const proc =
  typeof process === 'object' && process
    ? process
    : {
        stdout: null,
        stderr: null,
      };
const EE = require$$0__default$5["default"];
const Stream = Stream__default["default"];
const stringdecoder = require$$2__default["default"];
const SD = stringdecoder.StringDecoder;

const EOF = Symbol('EOF');
const MAYBE_EMIT_END = Symbol('maybeEmitEnd');
const EMITTED_END = Symbol('emittedEnd');
const EMITTING_END = Symbol('emittingEnd');
const EMITTED_ERROR = Symbol('emittedError');
const CLOSED = Symbol('closed');
const READ = Symbol('read');
const FLUSH = Symbol('flush');
const FLUSHCHUNK = Symbol('flushChunk');
const ENCODING = Symbol('encoding');
const DECODER = Symbol('decoder');
const FLOWING = Symbol('flowing');
const PAUSED = Symbol('paused');
const RESUME = Symbol('resume');
const BUFFER = Symbol('buffer');
const PIPES = Symbol('pipes');
const BUFFERLENGTH = Symbol('bufferLength');
const BUFFERPUSH = Symbol('bufferPush');
const BUFFERSHIFT = Symbol('bufferShift');
const OBJECTMODE = Symbol('objectMode');
// internal event when stream is destroyed
const DESTROYED = Symbol('destroyed');
// internal event when stream has an error
const ERROR = Symbol('error');
const EMITDATA = Symbol('emitData');
const EMITEND = Symbol('emitEnd');
const EMITEND2 = Symbol('emitEnd2');
const ASYNC = Symbol('async');
const ABORT = Symbol('abort');
const ABORTED = Symbol('aborted');
const SIGNAL = Symbol('signal');

const defer = fn => Promise.resolve().then(fn);

// TODO remove when Node v8 support drops
const doIter = commonjsGlobal._MP_NO_ITERATOR_SYMBOLS_ !== '1';
const ASYNCITERATOR =
  (doIter && Symbol.asyncIterator) || Symbol('asyncIterator not implemented');
const ITERATOR =
  (doIter && Symbol.iterator) || Symbol('iterator not implemented');

// events that mean 'the stream is over'
// these are treated specially, and re-emitted
// if they are listened for after emitting.
const isEndish = ev => ev === 'end' || ev === 'finish' || ev === 'prefinish';

const isArrayBuffer = b =>
  b instanceof ArrayBuffer ||
  (typeof b === 'object' &&
    b.constructor &&
    b.constructor.name === 'ArrayBuffer' &&
    b.byteLength >= 0);

const isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);

class Pipe {
  constructor(src, dest, opts) {
    this.src = src;
    this.dest = dest;
    this.opts = opts;
    this.ondrain = () => src[RESUME]();
    dest.on('drain', this.ondrain);
  }
  unpipe() {
    this.dest.removeListener('drain', this.ondrain);
  }
  // istanbul ignore next - only here for the prototype
  proxyErrors() {}
  end() {
    this.unpipe();
    if (this.opts.end) this.dest.end();
  }
}

class PipeProxyErrors extends Pipe {
  unpipe() {
    this.src.removeListener('error', this.proxyErrors);
    super.unpipe();
  }
  constructor(src, dest, opts) {
    super(src, dest, opts);
    this.proxyErrors = er => dest.emit('error', er);
    src.on('error', this.proxyErrors);
  }
}

class Minipass extends Stream {
  constructor(options) {
    super();
    this[FLOWING] = false;
    // whether we're explicitly paused
    this[PAUSED] = false;
    this[PIPES] = [];
    this[BUFFER] = [];
    this[OBJECTMODE] = (options && options.objectMode) || false;
    if (this[OBJECTMODE]) this[ENCODING] = null;
    else this[ENCODING] = (options && options.encoding) || null;
    if (this[ENCODING] === 'buffer') this[ENCODING] = null;
    this[ASYNC] = (options && !!options.async) || false;
    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
    this[EOF] = false;
    this[EMITTED_END] = false;
    this[EMITTING_END] = false;
    this[CLOSED] = false;
    this[EMITTED_ERROR] = null;
    this.writable = true;
    this.readable = true;
    this[BUFFERLENGTH] = 0;
    this[DESTROYED] = false;
    if (options && options.debugExposeBuffer === true) {
      Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] });
    }
    if (options && options.debugExposePipes === true) {
      Object.defineProperty(this, 'pipes', { get: () => this[PIPES] });
    }
    this[SIGNAL] = options && options.signal;
    this[ABORTED] = false;
    if (this[SIGNAL]) {
      this[SIGNAL].addEventListener('abort', () => this[ABORT]());
      if (this[SIGNAL].aborted) {
        this[ABORT]();
      }
    }
  }

  get bufferLength() {
    return this[BUFFERLENGTH]
  }

  get encoding() {
    return this[ENCODING]
  }
  set encoding(enc) {
    if (this[OBJECTMODE]) throw new Error('cannot set encoding in objectMode')

    if (
      this[ENCODING] &&
      enc !== this[ENCODING] &&
      ((this[DECODER] && this[DECODER].lastNeed) || this[BUFFERLENGTH])
    )
      throw new Error('cannot change encoding')

    if (this[ENCODING] !== enc) {
      this[DECODER] = enc ? new SD(enc) : null;
      if (this[BUFFER].length)
        this[BUFFER] = this[BUFFER].map(chunk => this[DECODER].write(chunk));
    }

    this[ENCODING] = enc;
  }

  setEncoding(enc) {
    this.encoding = enc;
  }

  get objectMode() {
    return this[OBJECTMODE]
  }
  set objectMode(om) {
    this[OBJECTMODE] = this[OBJECTMODE] || !!om;
  }

  get ['async']() {
    return this[ASYNC]
  }
  set ['async'](a) {
    this[ASYNC] = this[ASYNC] || !!a;
  }

  // drop everything and get out of the flow completely
  [ABORT]() {
    this[ABORTED] = true;
    this.emit('abort', this[SIGNAL].reason);
    this.destroy(this[SIGNAL].reason);
  }

  get aborted() {
    return this[ABORTED]
  }
  set aborted(_) {}

  write(chunk, encoding, cb) {
    if (this[ABORTED]) return false
    if (this[EOF]) throw new Error('write after end')

    if (this[DESTROYED]) {
      this.emit(
        'error',
        Object.assign(
          new Error('Cannot call write after a stream was destroyed'),
          { code: 'ERR_STREAM_DESTROYED' }
        )
      );
      return true
    }

    if (typeof encoding === 'function') (cb = encoding), (encoding = 'utf8');

    if (!encoding) encoding = 'utf8';

    const fn = this[ASYNC] ? defer : f => f();

    // convert array buffers and typed array views into buffers
    // at some point in the future, we may want to do the opposite!
    // leave strings and buffers as-is
    // anything else switches us into object mode
    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
      if (isArrayBufferView(chunk))
        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
      else if (isArrayBuffer(chunk)) chunk = Buffer.from(chunk);
      else if (typeof chunk !== 'string')
        // use the setter so we throw if we have encoding set
        this.objectMode = true;
    }

    // handle object mode up front, since it's simpler
    // this yields better performance, fewer checks later.
    if (this[OBJECTMODE]) {
      /* istanbul ignore if - maybe impossible? */
      if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);

      if (this.flowing) this.emit('data', chunk);
      else this[BUFFERPUSH](chunk);

      if (this[BUFFERLENGTH] !== 0) this.emit('readable');

      if (cb) fn(cb);

      return this.flowing
    }

    // at this point the chunk is a buffer or string
    // don't buffer it up or send it to the decoder
    if (!chunk.length) {
      if (this[BUFFERLENGTH] !== 0) this.emit('readable');
      if (cb) fn(cb);
      return this.flowing
    }

    // fast-path writing strings of same encoding to a stream with
    // an empty buffer, skipping the buffer/decoder dance
    if (
      typeof chunk === 'string' &&
      // unless it is a string already ready for us to use
      !(encoding === this[ENCODING] && !this[DECODER].lastNeed)
    ) {
      chunk = Buffer.from(chunk, encoding);
    }

    if (Buffer.isBuffer(chunk) && this[ENCODING])
      chunk = this[DECODER].write(chunk);

    // Note: flushing CAN potentially switch us into not-flowing mode
    if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);

    if (this.flowing) this.emit('data', chunk);
    else this[BUFFERPUSH](chunk);

    if (this[BUFFERLENGTH] !== 0) this.emit('readable');

    if (cb) fn(cb);

    return this.flowing
  }

  read(n) {
    if (this[DESTROYED]) return null

    if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
      this[MAYBE_EMIT_END]();
      return null
    }

    if (this[OBJECTMODE]) n = null;

    if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
      if (this.encoding) this[BUFFER] = [this[BUFFER].join('')];
      else this[BUFFER] = [Buffer.concat(this[BUFFER], this[BUFFERLENGTH])];
    }

    const ret = this[READ](n || null, this[BUFFER][0]);
    this[MAYBE_EMIT_END]();
    return ret
  }

  [READ](n, chunk) {
    if (n === chunk.length || n === null) this[BUFFERSHIFT]();
    else {
      this[BUFFER][0] = chunk.slice(n);
      chunk = chunk.slice(0, n);
      this[BUFFERLENGTH] -= n;
    }

    this.emit('data', chunk);

    if (!this[BUFFER].length && !this[EOF]) this.emit('drain');

    return chunk
  }

  end(chunk, encoding, cb) {
    if (typeof chunk === 'function') (cb = chunk), (chunk = null);
    if (typeof encoding === 'function') (cb = encoding), (encoding = 'utf8');
    if (chunk) this.write(chunk, encoding);
    if (cb) this.once('end', cb);
    this[EOF] = true;
    this.writable = false;

    // if we haven't written anything, then go ahead and emit,
    // even if we're not reading.
    // we'll re-emit if a new 'end' listener is added anyway.
    // This makes MP more suitable to write-only use cases.
    if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]();
    return this
  }

  // don't let the internal resume be overwritten
  [RESUME]() {
    if (this[DESTROYED]) return

    this[PAUSED] = false;
    this[FLOWING] = true;
    this.emit('resume');
    if (this[BUFFER].length) this[FLUSH]();
    else if (this[EOF]) this[MAYBE_EMIT_END]();
    else this.emit('drain');
  }

  resume() {
    return this[RESUME]()
  }

  pause() {
    this[FLOWING] = false;
    this[PAUSED] = true;
  }

  get destroyed() {
    return this[DESTROYED]
  }

  get flowing() {
    return this[FLOWING]
  }

  get paused() {
    return this[PAUSED]
  }

  [BUFFERPUSH](chunk) {
    if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;
    else this[BUFFERLENGTH] += chunk.length;
    this[BUFFER].push(chunk);
  }

  [BUFFERSHIFT]() {
    if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;
    else this[BUFFERLENGTH] -= this[BUFFER][0].length;
    return this[BUFFER].shift()
  }

  [FLUSH](noDrain) {
    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length)

    if (!noDrain && !this[BUFFER].length && !this[EOF]) this.emit('drain');
  }

  [FLUSHCHUNK](chunk) {
    this.emit('data', chunk);
    return this.flowing
  }

  pipe(dest, opts) {
    if (this[DESTROYED]) return

    const ended = this[EMITTED_END];
    opts = opts || {};
    if (dest === proc.stdout || dest === proc.stderr) opts.end = false;
    else opts.end = opts.end !== false;
    opts.proxyErrors = !!opts.proxyErrors;

    // piping an ended stream ends immediately
    if (ended) {
      if (opts.end) dest.end();
    } else {
      this[PIPES].push(
        !opts.proxyErrors
          ? new Pipe(this, dest, opts)
          : new PipeProxyErrors(this, dest, opts)
      );
      if (this[ASYNC]) defer(() => this[RESUME]());
      else this[RESUME]();
    }

    return dest
  }

  unpipe(dest) {
    const p = this[PIPES].find(p => p.dest === dest);
    if (p) {
      this[PIPES].splice(this[PIPES].indexOf(p), 1);
      p.unpipe();
    }
  }

  addListener(ev, fn) {
    return this.on(ev, fn)
  }

  on(ev, fn) {
    const ret = super.on(ev, fn);
    if (ev === 'data' && !this[PIPES].length && !this.flowing) this[RESUME]();
    else if (ev === 'readable' && this[BUFFERLENGTH] !== 0)
      super.emit('readable');
    else if (isEndish(ev) && this[EMITTED_END]) {
      super.emit(ev);
      this.removeAllListeners(ev);
    } else if (ev === 'error' && this[EMITTED_ERROR]) {
      if (this[ASYNC]) defer(() => fn.call(this, this[EMITTED_ERROR]));
      else fn.call(this, this[EMITTED_ERROR]);
    }
    return ret
  }

  get emittedEnd() {
    return this[EMITTED_END]
  }

  [MAYBE_EMIT_END]() {
    if (
      !this[EMITTING_END] &&
      !this[EMITTED_END] &&
      !this[DESTROYED] &&
      this[BUFFER].length === 0 &&
      this[EOF]
    ) {
      this[EMITTING_END] = true;
      this.emit('end');
      this.emit('prefinish');
      this.emit('finish');
      if (this[CLOSED]) this.emit('close');
      this[EMITTING_END] = false;
    }
  }

  emit(ev, data, ...extra) {
    // error and close are only events allowed after calling destroy()
    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED])
      return
    else if (ev === 'data') {
      return !this[OBJECTMODE] && !data
        ? false
        : this[ASYNC]
        ? defer(() => this[EMITDATA](data))
        : this[EMITDATA](data)
    } else if (ev === 'end') {
      return this[EMITEND]()
    } else if (ev === 'close') {
      this[CLOSED] = true;
      // don't emit close before 'end' and 'finish'
      if (!this[EMITTED_END] && !this[DESTROYED]) return
      const ret = super.emit('close');
      this.removeAllListeners('close');
      return ret
    } else if (ev === 'error') {
      this[EMITTED_ERROR] = data;
      super.emit(ERROR, data);
      const ret =
        !this[SIGNAL] || this.listeners('error').length
          ? super.emit('error', data)
          : false;
      this[MAYBE_EMIT_END]();
      return ret
    } else if (ev === 'resume') {
      const ret = super.emit('resume');
      this[MAYBE_EMIT_END]();
      return ret
    } else if (ev === 'finish' || ev === 'prefinish') {
      const ret = super.emit(ev);
      this.removeAllListeners(ev);
      return ret
    }

    // Some other unknown event
    const ret = super.emit(ev, data, ...extra);
    this[MAYBE_EMIT_END]();
    return ret
  }

  [EMITDATA](data) {
    for (const p of this[PIPES]) {
      if (p.dest.write(data) === false) this.pause();
    }
    const ret = super.emit('data', data);
    this[MAYBE_EMIT_END]();
    return ret
  }

  [EMITEND]() {
    if (this[EMITTED_END]) return

    this[EMITTED_END] = true;
    this.readable = false;
    if (this[ASYNC]) defer(() => this[EMITEND2]());
    else this[EMITEND2]();
  }

  [EMITEND2]() {
    if (this[DECODER]) {
      const data = this[DECODER].end();
      if (data) {
        for (const p of this[PIPES]) {
          p.dest.write(data);
        }
        super.emit('data', data);
      }
    }

    for (const p of this[PIPES]) {
      p.end();
    }
    const ret = super.emit('end');
    this.removeAllListeners('end');
    return ret
  }

  // const all = await stream.collect()
  collect() {
    const buf = [];
    if (!this[OBJECTMODE]) buf.dataLength = 0;
    // set the promise first, in case an error is raised
    // by triggering the flow here.
    const p = this.promise();
    this.on('data', c => {
      buf.push(c);
      if (!this[OBJECTMODE]) buf.dataLength += c.length;
    });
    return p.then(() => buf)
  }

  // const data = await stream.concat()
  concat() {
    return this[OBJECTMODE]
      ? Promise.reject(new Error('cannot concat in objectMode'))
      : this.collect().then(buf =>
          this[OBJECTMODE]
            ? Promise.reject(new Error('cannot concat in objectMode'))
            : this[ENCODING]
            ? buf.join('')
            : Buffer.concat(buf, buf.dataLength)
        )
  }

  // stream.promise().then(() => done, er => emitted error)
  promise() {
    return new Promise((resolve, reject) => {
      this.on(DESTROYED, () => reject(new Error('stream destroyed')));
      this.on('error', er => reject(er));
      this.on('end', () => resolve());
    })
  }

  // for await (let chunk of stream)
  [ASYNCITERATOR]() {
    let stopped = false;
    const stop = () => {
      this.pause();
      stopped = true;
      return Promise.resolve({ done: true })
    };
    const next = () => {
      if (stopped) return stop()
      const res = this.read();
      if (res !== null) return Promise.resolve({ done: false, value: res })

      if (this[EOF]) return stop()

      let resolve = null;
      let reject = null;
      const onerr = er => {
        this.removeListener('data', ondata);
        this.removeListener('end', onend);
        this.removeListener(DESTROYED, ondestroy);
        stop();
        reject(er);
      };
      const ondata = value => {
        this.removeListener('error', onerr);
        this.removeListener('end', onend);
        this.removeListener(DESTROYED, ondestroy);
        this.pause();
        resolve({ value: value, done: !!this[EOF] });
      };
      const onend = () => {
        this.removeListener('error', onerr);
        this.removeListener('data', ondata);
        this.removeListener(DESTROYED, ondestroy);
        stop();
        resolve({ done: true });
      };
      const ondestroy = () => onerr(new Error('stream destroyed'));
      return new Promise((res, rej) => {
        reject = rej;
        resolve = res;
        this.once(DESTROYED, ondestroy);
        this.once('error', onerr);
        this.once('end', onend);
        this.once('data', ondata);
      })
    };

    return {
      next,
      throw: stop,
      return: stop,
      [ASYNCITERATOR]() {
        return this
      },
    }
  }

  // for (let chunk of stream)
  [ITERATOR]() {
    let stopped = false;
    const stop = () => {
      this.pause();
      this.removeListener(ERROR, stop);
      this.removeListener(DESTROYED, stop);
      this.removeListener('end', stop);
      stopped = true;
      return { done: true }
    };

    const next = () => {
      if (stopped) return stop()
      const value = this.read();
      return value === null ? stop() : { value }
    };
    this.once('end', stop);
    this.once(ERROR, stop);
    this.once(DESTROYED, stop);

    return {
      next,
      throw: stop,
      return: stop,
      [ITERATOR]() {
        return this
      },
    }
  }

  destroy(er) {
    if (this[DESTROYED]) {
      if (er) this.emit('error', er);
      else this.emit(DESTROYED);
      return this
    }

    this[DESTROYED] = true;

    // throw away all buffered data, it's never coming out
    this[BUFFER].length = 0;
    this[BUFFERLENGTH] = 0;

    if (typeof this.close === 'function' && !this[CLOSED]) this.close();

    if (er) this.emit('error', er);
    // if no error to emit, still reject pending promises
    else this.emit(DESTROYED);

    return this
  }

  static isStream(s) {
    return (
      !!s &&
      (s instanceof Minipass ||
        s instanceof Stream ||
        (s instanceof EE &&
          // readable
          (typeof s.pipe === 'function' ||
            // writable
            (typeof s.write === 'function' && typeof s.end === 'function'))))
    )
  }
}

minipass.Minipass = Minipass;

var ignore = {};

// give it a pattern, and it'll be able to tell you if
// a given path should be ignored.
// Ignoring a path ignores its children if the pattern ends in /**
// Ignores are always parsed in dot:true mode
Object.defineProperty(ignore, "__esModule", { value: true });
ignore.Ignore = void 0;
const minimatch_1$3 = cjs$2;
const pattern_js_1$1 = pattern$1;
const defaultPlatform$1 = typeof process === 'object' &&
    process &&
    typeof process.platform === 'string'
    ? process.platform
    : 'linux';
/**
 * Class used to process ignored patterns
 */
class Ignore {
    relative;
    relativeChildren;
    absolute;
    absoluteChildren;
    constructor(ignored, { nobrace, nocase, noext, noglobstar, platform = defaultPlatform$1, }) {
        this.relative = [];
        this.absolute = [];
        this.relativeChildren = [];
        this.absoluteChildren = [];
        const mmopts = {
            dot: true,
            nobrace,
            nocase,
            noext,
            noglobstar,
            optimizationLevel: 2,
            platform,
            nocomment: true,
            nonegate: true,
        };
        // this is a little weird, but it gives us a clean set of optimized
        // minimatch matchers, without getting tripped up if one of them
        // ends in /** inside a brace section, and it's only inefficient at
        // the start of the walk, not along it.
        // It'd be nice if the Pattern class just had a .test() method, but
        // handling globstars is a bit of a pita, and that code already lives
        // in minimatch anyway.
        // Another way would be if maybe Minimatch could take its set/globParts
        // as an option, and then we could at least just use Pattern to test
        // for absolute-ness.
        // Yet another way, Minimatch could take an array of glob strings, and
        // a cwd option, and do the right thing.
        for (const ign of ignored) {
            const mm = new minimatch_1$3.Minimatch(ign, mmopts);
            for (let i = 0; i < mm.set.length; i++) {
                const parsed = mm.set[i];
                const globParts = mm.globParts[i];
                const p = new pattern_js_1$1.Pattern(parsed, globParts, 0, platform);
                const m = new minimatch_1$3.Minimatch(p.globString(), mmopts);
                const children = globParts[globParts.length - 1] === '**';
                const absolute = p.isAbsolute();
                if (absolute)
                    this.absolute.push(m);
                else
                    this.relative.push(m);
                if (children) {
                    if (absolute)
                        this.absoluteChildren.push(m);
                    else
                        this.relativeChildren.push(m);
                }
            }
        }
    }
    ignored(p) {
        const fullpath = p.fullpath();
        const fullpaths = `${fullpath}/`;
        const relative = p.relative() || '.';
        const relatives = `${relative}/`;
        for (const m of this.relative) {
            if (m.match(relative) || m.match(relatives))
                return true;
        }
        for (const m of this.absolute) {
            if (m.match(fullpath) || m.match(fullpaths))
                return true;
        }
        return false;
    }
    childrenIgnored(p) {
        const fullpath = p.fullpath() + '/';
        const relative = (p.relative() || '.') + '/';
        for (const m of this.relativeChildren) {
            if (m.match(relative))
                return true;
        }
        for (const m of this.absoluteChildren) {
            if (m.match(fullpath))
                ;
        }
        return false;
    }
}
ignore.Ignore = Ignore;

var processor = {};

// synchronous utility for filtering entries and calculating subwalks
Object.defineProperty(processor, "__esModule", { value: true });
processor.Processor = processor.SubWalks = processor.MatchRecord = processor.HasWalkedCache = void 0;
const minimatch_1$2 = cjs$2;
/**
 * A cache of which patterns have been processed for a given Path
 */
class HasWalkedCache {
    store;
    constructor(store = new Map()) {
        this.store = store;
    }
    copy() {
        return new HasWalkedCache(new Map(this.store));
    }
    hasWalked(target, pattern) {
        return this.store.get(target.fullpath())?.has(pattern.globString());
    }
    storeWalked(target, pattern) {
        const fullpath = target.fullpath();
        const cached = this.store.get(fullpath);
        if (cached)
            cached.add(pattern.globString());
        else
            this.store.set(fullpath, new Set([pattern.globString()]));
    }
}
processor.HasWalkedCache = HasWalkedCache;
/**
 * A record of which paths have been matched in a given walk step,
 * and whether they only are considered a match if they are a directory,
 * and whether their absolute or relative path should be returned.
 */
class MatchRecord {
    store = new Map();
    add(target, absolute, ifDir) {
        const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);
        const current = this.store.get(target);
        this.store.set(target, current === undefined ? n : n & current);
    }
    // match, absolute, ifdir
    entries() {
        return [...this.store.entries()].map(([path, n]) => [
            path,
            !!(n & 2),
            !!(n & 1),
        ]);
    }
}
processor.MatchRecord = MatchRecord;
/**
 * A collection of patterns that must be processed in a subsequent step
 * for a given path.
 */
class SubWalks {
    store = new Map();
    add(target, pattern) {
        if (!target.canReaddir()) {
            return;
        }
        const subs = this.store.get(target);
        if (subs) {
            if (!subs.find(p => p.globString() === pattern.globString())) {
                subs.push(pattern);
            }
        }
        else
            this.store.set(target, [pattern]);
    }
    get(target) {
        const subs = this.store.get(target);
        /* c8 ignore start */
        if (!subs) {
            throw new Error('attempting to walk unknown path');
        }
        /* c8 ignore stop */
        return subs;
    }
    entries() {
        return this.keys().map(k => [k, this.store.get(k)]);
    }
    keys() {
        return [...this.store.keys()].filter(t => t.canReaddir());
    }
}
processor.SubWalks = SubWalks;
/**
 * The class that processes patterns for a given path.
 *
 * Handles child entry filtering, and determining whether a path's
 * directory contents must be read.
 */
class Processor {
    hasWalkedCache;
    matches = new MatchRecord();
    subwalks = new SubWalks();
    patterns;
    follow;
    dot;
    opts;
    constructor(opts, hasWalkedCache) {
        this.opts = opts;
        this.follow = !!opts.follow;
        this.dot = !!opts.dot;
        this.hasWalkedCache = hasWalkedCache
            ? hasWalkedCache.copy()
            : new HasWalkedCache();
    }
    processPatterns(target, patterns) {
        this.patterns = patterns;
        const processingSet = patterns.map(p => [target, p]);
        // map of paths to the magic-starting subwalks they need to walk
        // first item in patterns is the filter
        for (let [t, pattern] of processingSet) {
            this.hasWalkedCache.storeWalked(t, pattern);
            const root = pattern.root();
            const absolute = pattern.isAbsolute() && this.opts.absolute !== false;
            // start absolute patterns at root
            if (root) {
                t = t.resolve(root === '/' && this.opts.root !== undefined
                    ? this.opts.root
                    : root);
                const rest = pattern.rest();
                if (!rest) {
                    this.matches.add(t, true, false);
                    continue;
                }
                else {
                    pattern = rest;
                }
            }
            if (t.isENOENT())
                continue;
            let p;
            let rest;
            let changed = false;
            while (typeof (p = pattern.pattern()) === 'string' &&
                (rest = pattern.rest())) {
                const c = t.resolve(p);
                // we can be reasonably sure that .. is a readable dir
                if (c.isUnknown() && p !== '..')
                    break;
                t = c;
                pattern = rest;
                changed = true;
            }
            p = pattern.pattern();
            rest = pattern.rest();
            if (changed) {
                if (this.hasWalkedCache.hasWalked(t, pattern))
                    continue;
                this.hasWalkedCache.storeWalked(t, pattern);
            }
            // now we have either a final string for a known entry,
            // more strings for an unknown entry,
            // or a pattern starting with magic, mounted on t.
            if (typeof p === 'string') {
                // must be final entry
                if (!rest) {
                    const ifDir = p === '..' || p === '' || p === '.';
                    this.matches.add(t.resolve(p), absolute, ifDir);
                }
                else {
                    this.subwalks.add(t, pattern);
                }
                continue;
            }
            else if (p === minimatch_1$2.GLOBSTAR) {
                // if no rest, match and subwalk pattern
                // if rest, process rest and subwalk pattern
                // if it's a symlink, but we didn't get here by way of a
                // globstar match (meaning it's the first time THIS globstar
                // has traversed a symlink), then we follow it. Otherwise, stop.
                if (!t.isSymbolicLink() ||
                    this.follow ||
                    pattern.checkFollowGlobstar()) {
                    this.subwalks.add(t, pattern);
                }
                const rp = rest?.pattern();
                const rrest = rest?.rest();
                if (!rest || ((rp === '' || rp === '.') && !rrest)) {
                    // only HAS to be a dir if it ends in **/ or **/.
                    // but ending in ** will match files as well.
                    this.matches.add(t, absolute, rp === '' || rp === '.');
                }
                else {
                    if (rp === '..') {
                        // this would mean you're matching **/.. at the fs root,
                        // and no thanks, I'm not gonna test that specific case.
                        /* c8 ignore start */
                        const tp = t.parent || t;
                        /* c8 ignore stop */
                        if (!rrest)
                            this.matches.add(tp, absolute, true);
                        else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {
                            this.subwalks.add(tp, rrest);
                        }
                    }
                }
            }
            else if (p instanceof RegExp) {
                this.subwalks.add(t, pattern);
            }
        }
        return this;
    }
    subwalkTargets() {
        return this.subwalks.keys();
    }
    child() {
        return new Processor(this.opts, this.hasWalkedCache);
    }
    // return a new Processor containing the subwalks for each
    // child entry, and a set of matches, and
    // a hasWalkedCache that's a copy of this one
    // then we're going to call
    filterEntries(parent, entries) {
        const patterns = this.subwalks.get(parent);
        // put matches and entry walks into the results processor
        const results = this.child();
        for (const e of entries) {
            for (const pattern of patterns) {
                const absolute = pattern.isAbsolute();
                const p = pattern.pattern();
                const rest = pattern.rest();
                if (p === minimatch_1$2.GLOBSTAR) {
                    results.testGlobstar(e, pattern, rest, absolute);
                }
                else if (p instanceof RegExp) {
                    results.testRegExp(e, p, rest, absolute);
                }
                else {
                    results.testString(e, p, rest, absolute);
                }
            }
        }
        return results;
    }
    testGlobstar(e, pattern, rest, absolute) {
        if (this.dot || !e.name.startsWith('.')) {
            if (!pattern.hasMore()) {
                this.matches.add(e, absolute, false);
            }
            if (e.canReaddir()) {
                // if we're in follow mode or it's not a symlink, just keep
                // testing the same pattern. If there's more after the globstar,
                // then this symlink consumes the globstar. If not, then we can
                // follow at most ONE symlink along the way, so we mark it, which
                // also checks to ensure that it wasn't already marked.
                if (this.follow || !e.isSymbolicLink()) {
                    this.subwalks.add(e, pattern);
                }
                else if (e.isSymbolicLink()) {
                    if (rest && pattern.checkFollowGlobstar()) {
                        this.subwalks.add(e, rest);
                    }
                    else if (pattern.markFollowGlobstar()) {
                        this.subwalks.add(e, pattern);
                    }
                }
            }
        }
        // if the NEXT thing matches this entry, then also add
        // the rest.
        if (rest) {
            const rp = rest.pattern();
            if (typeof rp === 'string' &&
                // dots and empty were handled already
                rp !== '..' &&
                rp !== '' &&
                rp !== '.') {
                this.testString(e, rp, rest.rest(), absolute);
            }
            else if (rp === '..') {
                /* c8 ignore start */
                const ep = e.parent || e;
                /* c8 ignore stop */
                this.subwalks.add(ep, rest);
            }
            else if (rp instanceof RegExp) {
                this.testRegExp(e, rp, rest.rest(), absolute);
            }
        }
    }
    testRegExp(e, p, rest, absolute) {
        if (!p.test(e.name))
            return;
        if (!rest) {
            this.matches.add(e, absolute, false);
        }
        else {
            this.subwalks.add(e, rest);
        }
    }
    testString(e, p, rest, absolute) {
        // should never happen?
        if (!e.isNamed(p))
            return;
        if (!rest) {
            this.matches.add(e, absolute, false);
        }
        else {
            this.subwalks.add(e, rest);
        }
    }
}
processor.Processor = Processor;

Object.defineProperty(walker, "__esModule", { value: true });
walker.GlobStream = walker.GlobWalker = walker.GlobUtil = void 0;
/**
 * Single-use utility classes to provide functionality to the {@link Glob}
 * methods.
 *
 * @module
 */
const minipass_1 = minipass;
const ignore_js_1 = ignore;
const processor_js_1 = processor;
const makeIgnore = (ignore, opts) => typeof ignore === 'string'
    ? new ignore_js_1.Ignore([ignore], opts)
    : Array.isArray(ignore)
        ? new ignore_js_1.Ignore(ignore, opts)
        : ignore;
/**
 * basic walking utilities that all the glob walker types use
 */
class GlobUtil {
    path;
    patterns;
    opts;
    seen = new Set();
    paused = false;
    aborted = false;
    #onResume = [];
    #ignore;
    #sep;
    signal;
    maxDepth;
    constructor(patterns, path, opts) {
        this.patterns = patterns;
        this.path = path;
        this.opts = opts;
        this.#sep = !opts.posix && opts.platform === 'win32' ? '\\' : '/';
        if (opts.ignore) {
            this.#ignore = makeIgnore(opts.ignore, opts);
        }
        // ignore, always set with maxDepth, but it's optional on the
        // GlobOptions type
        /* c8 ignore start */
        this.maxDepth = opts.maxDepth || Infinity;
        /* c8 ignore stop */
        if (opts.signal) {
            this.signal = opts.signal;
            this.signal.addEventListener('abort', () => {
                this.#onResume.length = 0;
            });
        }
    }
    #ignored(path) {
        return this.seen.has(path) || !!this.#ignore?.ignored?.(path);
    }
    #childrenIgnored(path) {
        return !!this.#ignore?.childrenIgnored?.(path);
    }
    // backpressure mechanism
    pause() {
        this.paused = true;
    }
    resume() {
        /* c8 ignore start */
        if (this.signal?.aborted)
            return;
        /* c8 ignore stop */
        this.paused = false;
        let fn = undefined;
        while (!this.paused && (fn = this.#onResume.shift())) {
            fn();
        }
    }
    onResume(fn) {
        if (this.signal?.aborted)
            return;
        /* c8 ignore start */
        if (!this.paused) {
            fn();
        }
        else {
            /* c8 ignore stop */
            this.#onResume.push(fn);
        }
    }
    // do the requisite realpath/stat checking, and return the path
    // to add or undefined to filter it out.
    async matchCheck(e, ifDir) {
        if (ifDir && this.opts.nodir)
            return undefined;
        let rpc;
        if (this.opts.realpath) {
            rpc = e.realpathCached() || (await e.realpath());
            if (!rpc)
                return undefined;
            e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        return this.matchCheckTest(needStat ? await e.lstat() : e, ifDir);
    }
    matchCheckTest(e, ifDir) {
        return e &&
            (this.maxDepth === Infinity || e.depth() <= this.maxDepth) &&
            (!ifDir || e.canReaddir()) &&
            (!this.opts.nodir || !e.isDirectory()) &&
            !this.#ignored(e)
            ? e
            : undefined;
    }
    matchCheckSync(e, ifDir) {
        if (ifDir && this.opts.nodir)
            return undefined;
        let rpc;
        if (this.opts.realpath) {
            rpc = e.realpathCached() || e.realpathSync();
            if (!rpc)
                return undefined;
            e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        return this.matchCheckTest(needStat ? e.lstatSync() : e, ifDir);
    }
    matchFinish(e, absolute) {
        if (this.#ignored(e))
            return;
        const abs = this.opts.absolute === undefined ? absolute : this.opts.absolute;
        this.seen.add(e);
        const mark = this.opts.mark && e.isDirectory() ? this.#sep : '';
        // ok, we have what we need!
        if (this.opts.withFileTypes) {
            this.matchEmit(e);
        }
        else if (abs) {
            const abs = this.opts.posix ? e.fullpathPosix() : e.fullpath();
            this.matchEmit(abs + mark);
        }
        else {
            const rel = this.opts.posix ? e.relativePosix() : e.relative();
            const pre = this.opts.dotRelative && !rel.startsWith('..' + this.#sep)
                ? '.' + this.#sep
                : '';
            this.matchEmit(!rel ? '.' + mark : pre + rel + mark);
        }
    }
    async match(e, absolute, ifDir) {
        const p = await this.matchCheck(e, ifDir);
        if (p)
            this.matchFinish(p, absolute);
    }
    matchSync(e, absolute, ifDir) {
        const p = this.matchCheckSync(e, ifDir);
        if (p)
            this.matchFinish(p, absolute);
    }
    walkCB(target, patterns, cb) {
        /* c8 ignore start */
        if (this.signal?.aborted)
            cb();
        /* c8 ignore stop */
        this.walkCB2(target, patterns, new processor_js_1.Processor(this.opts), cb);
    }
    walkCB2(target, patterns, processor, cb) {
        if (this.#childrenIgnored(target))
            return cb();
        if (this.signal?.aborted)
            cb();
        if (this.paused) {
            this.onResume(() => this.walkCB2(target, patterns, processor, cb));
            return;
        }
        processor.processPatterns(target, patterns);
        // done processing.  all of the above is sync, can be abstracted out.
        // subwalks is a map of paths to the entry filters they need
        // matches is a map of paths to [absolute, ifDir] tuples.
        let tasks = 1;
        const next = () => {
            if (--tasks === 0)
                cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
            if (this.#ignored(m))
                continue;
            tasks++;
            this.match(m, absolute, ifDir).then(() => next());
        }
        for (const t of processor.subwalkTargets()) {
            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
                continue;
            }
            tasks++;
            const childrenCached = t.readdirCached();
            if (t.calledReaddir())
                this.walkCB3(t, childrenCached, processor, next);
            else {
                t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);
            }
        }
        next();
    }
    walkCB3(target, entries, processor, cb) {
        processor = processor.filterEntries(target, entries);
        let tasks = 1;
        const next = () => {
            if (--tasks === 0)
                cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
            if (this.#ignored(m))
                continue;
            tasks++;
            this.match(m, absolute, ifDir).then(() => next());
        }
        for (const [target, patterns] of processor.subwalks.entries()) {
            tasks++;
            this.walkCB2(target, patterns, processor.child(), next);
        }
        next();
    }
    walkCBSync(target, patterns, cb) {
        /* c8 ignore start */
        if (this.signal?.aborted)
            cb();
        /* c8 ignore stop */
        this.walkCB2Sync(target, patterns, new processor_js_1.Processor(this.opts), cb);
    }
    walkCB2Sync(target, patterns, processor, cb) {
        if (this.#childrenIgnored(target))
            return cb();
        if (this.signal?.aborted)
            cb();
        if (this.paused) {
            this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));
            return;
        }
        processor.processPatterns(target, patterns);
        // done processing.  all of the above is sync, can be abstracted out.
        // subwalks is a map of paths to the entry filters they need
        // matches is a map of paths to [absolute, ifDir] tuples.
        let tasks = 1;
        const next = () => {
            if (--tasks === 0)
                cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
            if (this.#ignored(m))
                continue;
            this.matchSync(m, absolute, ifDir);
        }
        for (const t of processor.subwalkTargets()) {
            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
                continue;
            }
            tasks++;
            const children = t.readdirSync();
            this.walkCB3Sync(t, children, processor, next);
        }
        next();
    }
    walkCB3Sync(target, entries, processor, cb) {
        processor = processor.filterEntries(target, entries);
        let tasks = 1;
        const next = () => {
            if (--tasks === 0)
                cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
            if (this.#ignored(m))
                continue;
            this.matchSync(m, absolute, ifDir);
        }
        for (const [target, patterns] of processor.subwalks.entries()) {
            tasks++;
            this.walkCB2Sync(target, patterns, processor.child(), next);
        }
        next();
    }
}
walker.GlobUtil = GlobUtil;
class GlobWalker extends GlobUtil {
    matches;
    constructor(patterns, path, opts) {
        super(patterns, path, opts);
        this.matches = new Set();
    }
    matchEmit(e) {
        this.matches.add(e);
    }
    async walk() {
        if (this.signal?.aborted)
            throw this.signal.reason;
        if (this.path.isUnknown()) {
            await this.path.lstat();
        }
        await new Promise((res, rej) => {
            this.walkCB(this.path, this.patterns, () => {
                if (this.signal?.aborted) {
                    rej(this.signal.reason);
                }
                else {
                    res(this.matches);
                }
            });
        });
        return this.matches;
    }
    walkSync() {
        if (this.signal?.aborted)
            throw this.signal.reason;
        if (this.path.isUnknown()) {
            this.path.lstatSync();
        }
        // nothing for the callback to do, because this never pauses
        this.walkCBSync(this.path, this.patterns, () => {
            if (this.signal?.aborted)
                throw this.signal.reason;
        });
        return this.matches;
    }
}
walker.GlobWalker = GlobWalker;
class GlobStream extends GlobUtil {
    results;
    constructor(patterns, path, opts) {
        super(patterns, path, opts);
        this.results = new minipass_1.Minipass({
            signal: this.signal,
            objectMode: true,
        });
        this.results.on('drain', () => this.resume());
        this.results.on('resume', () => this.resume());
    }
    matchEmit(e) {
        this.results.write(e);
        if (!this.results.flowing)
            this.pause();
    }
    stream() {
        const target = this.path;
        if (target.isUnknown()) {
            target.lstat().then(() => {
                this.walkCB(target, this.patterns, () => this.results.end());
            });
        }
        else {
            this.walkCB(target, this.patterns, () => this.results.end());
        }
        return this.results;
    }
    streamSync() {
        if (this.path.isUnknown()) {
            this.path.lstatSync();
        }
        this.walkCBSync(this.path, this.patterns, () => this.results.end());
        return this.results;
    }
}
walker.GlobStream = GlobStream;

Object.defineProperty(glob$1, "__esModule", { value: true });
glob$1.Glob = void 0;
const minimatch_1$1 = cjs$2;
const path_scurry_1 = cjs$1;
const url_1 = require$$2__default$1["default"];
const pattern_js_1 = pattern$1;
const walker_js_1 = walker;
// if no process global, just call it linux.
// so we default to case-sensitive, / separators
const defaultPlatform = typeof process === 'object' &&
    process &&
    typeof process.platform === 'string'
    ? process.platform
    : 'linux';
/**
 * An object that can perform glob pattern traversals.
 */
class Glob {
    absolute;
    cwd;
    root;
    dot;
    dotRelative;
    follow;
    ignore;
    magicalBraces;
    mark;
    matchBase;
    maxDepth;
    nobrace;
    nocase;
    nodir;
    noext;
    noglobstar;
    pattern;
    platform;
    realpath;
    scurry;
    stat;
    signal;
    windowsPathsNoEscape;
    withFileTypes;
    /**
     * The options provided to the constructor.
     */
    opts;
    /**
     * An array of parsed immutable {@link Pattern} objects.
     */
    patterns;
    /**
     * All options are stored as properties on the `Glob` object.
     *
     * See {@link GlobOptions} for full options descriptions.
     *
     * Note that a previous `Glob` object can be passed as the
     * `GlobOptions` to another `Glob` instantiation to re-use settings
     * and caches with a new pattern.
     *
     * Traversal functions can be called multiple times to run the walk
     * again.
     */
    constructor(pattern, opts) {
        this.withFileTypes = !!opts.withFileTypes;
        this.signal = opts.signal;
        this.follow = !!opts.follow;
        this.dot = !!opts.dot;
        this.dotRelative = !!opts.dotRelative;
        this.nodir = !!opts.nodir;
        this.mark = !!opts.mark;
        if (!opts.cwd) {
            this.cwd = '';
        }
        else if (opts.cwd instanceof URL || opts.cwd.startsWith('file://')) {
            opts.cwd = (0, url_1.fileURLToPath)(opts.cwd);
        }
        this.cwd = opts.cwd || '';
        this.root = opts.root;
        this.magicalBraces = !!opts.magicalBraces;
        this.nobrace = !!opts.nobrace;
        this.noext = !!opts.noext;
        this.realpath = !!opts.realpath;
        this.absolute = opts.absolute;
        this.noglobstar = !!opts.noglobstar;
        this.matchBase = !!opts.matchBase;
        this.maxDepth =
            typeof opts.maxDepth === 'number' ? opts.maxDepth : Infinity;
        this.stat = !!opts.stat;
        this.ignore = opts.ignore;
        if (this.withFileTypes && this.absolute !== undefined) {
            throw new Error('cannot set absolute and withFileTypes:true');
        }
        if (typeof pattern === 'string') {
            pattern = [pattern];
        }
        this.windowsPathsNoEscape =
            !!opts.windowsPathsNoEscape ||
                opts.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
            pattern = pattern.map(p => p.replace(/\\/g, '/'));
        }
        if (this.matchBase) {
            if (opts.noglobstar) {
                throw new TypeError('base matching requires globstar');
            }
            pattern = pattern.map(p => (p.includes('/') ? p : `./**/${p}`));
        }
        this.pattern = pattern;
        this.platform = opts.platform || defaultPlatform;
        this.opts = { ...opts, platform: this.platform };
        if (opts.scurry) {
            this.scurry = opts.scurry;
            if (opts.nocase !== undefined &&
                opts.nocase !== opts.scurry.nocase) {
                throw new Error('nocase option contradicts provided scurry option');
            }
        }
        else {
            const Scurry = opts.platform === 'win32'
                ? path_scurry_1.PathScurryWin32
                : opts.platform === 'darwin'
                    ? path_scurry_1.PathScurryDarwin
                    : opts.platform
                        ? path_scurry_1.PathScurryPosix
                        : path_scurry_1.PathScurry;
            this.scurry = new Scurry(this.cwd, {
                nocase: opts.nocase,
                fs: opts.fs,
            });
        }
        this.nocase = this.scurry.nocase;
        // If you do nocase:true on a case-sensitive file system, then
        // we need to use regexps instead of strings for non-magic
        // path portions, because statting `aBc` won't return results
        // for the file `AbC` for example.
        const nocaseMagicOnly = this.platform === 'darwin' || this.platform === 'win32';
        const mmo = {
            // default nocase based on platform
            ...opts,
            dot: this.dot,
            matchBase: this.matchBase,
            nobrace: this.nobrace,
            nocase: this.nocase,
            nocaseMagicOnly,
            nocomment: true,
            noext: this.noext,
            nonegate: true,
            optimizationLevel: 2,
            platform: this.platform,
            windowsPathsNoEscape: this.windowsPathsNoEscape,
            debug: !!this.opts.debug,
        };
        const mms = this.pattern.map(p => new minimatch_1$1.Minimatch(p, mmo));
        const [matchSet, globParts] = mms.reduce((set, m) => {
            set[0].push(...m.set);
            set[1].push(...m.globParts);
            return set;
        }, [[], []]);
        this.patterns = matchSet.map((set, i) => {
            return new pattern_js_1.Pattern(set, globParts[i], 0, this.platform);
        });
    }
    async walk() {
        // Walkers always return array of Path objects, so we just have to
        // coerce them into the right shape.  It will have already called
        // realpath() if the option was set to do so, so we know that's cached.
        // start out knowing the cwd, at least
        return [
            ...(await new walker_js_1.GlobWalker(this.patterns, this.scurry.cwd, {
                ...this.opts,
                maxDepth: this.maxDepth !== Infinity
                    ? this.maxDepth + this.scurry.cwd.depth()
                    : Infinity,
                platform: this.platform,
                nocase: this.nocase,
            }).walk()),
        ];
    }
    walkSync() {
        return [
            ...new walker_js_1.GlobWalker(this.patterns, this.scurry.cwd, {
                ...this.opts,
                maxDepth: this.maxDepth !== Infinity
                    ? this.maxDepth + this.scurry.cwd.depth()
                    : Infinity,
                platform: this.platform,
                nocase: this.nocase,
            }).walkSync(),
        ];
    }
    stream() {
        return new walker_js_1.GlobStream(this.patterns, this.scurry.cwd, {
            ...this.opts,
            maxDepth: this.maxDepth !== Infinity
                ? this.maxDepth + this.scurry.cwd.depth()
                : Infinity,
            platform: this.platform,
            nocase: this.nocase,
        }).stream();
    }
    streamSync() {
        return new walker_js_1.GlobStream(this.patterns, this.scurry.cwd, {
            ...this.opts,
            maxDepth: this.maxDepth !== Infinity
                ? this.maxDepth + this.scurry.cwd.depth()
                : Infinity,
            platform: this.platform,
            nocase: this.nocase,
        }).streamSync();
    }
    /**
     * Default sync iteration function. Returns a Generator that
     * iterates over the results.
     */
    iterateSync() {
        return this.streamSync()[Symbol.iterator]();
    }
    [Symbol.iterator]() {
        return this.iterateSync();
    }
    /**
     * Default async iteration function. Returns an AsyncGenerator that
     * iterates over the results.
     */
    iterate() {
        return this.stream()[Symbol.asyncIterator]();
    }
    [Symbol.asyncIterator]() {
        return this.iterate();
    }
}
glob$1.Glob = Glob;

var hasMagic$1 = {};

Object.defineProperty(hasMagic$1, "__esModule", { value: true });
hasMagic$1.hasMagic = void 0;
const minimatch_1 = cjs$2;
/**
 * Return true if the patterns provided contain any magic glob characters,
 * given the options provided.
 *
 * Brace expansion is not considered "magic" unless the `magicalBraces` option
 * is set, as brace expansion just turns one string into an array of strings.
 * So a pattern like `'x{a,b}y'` would return `false`, because `'xay'` and
 * `'xby'` both do not contain any magic glob characters, and it's treated the
 * same as if you had called it on `['xay', 'xby']`. When `magicalBraces:true`
 * is in the options, brace expansion _is_ treated as a pattern having magic.
 */
const hasMagic = (pattern, options = {}) => {
    if (!Array.isArray(pattern)) {
        pattern = [pattern];
    }
    for (const p of pattern) {
        if (new minimatch_1.Minimatch(p, options).hasMagic())
            return true;
    }
    return false;
};
hasMagic$1.hasMagic = hasMagic;

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.glob = exports.hasMagic = exports.Glob = exports.unescape = exports.escape = exports.sync = exports.iterate = exports.iterateSync = exports.stream = exports.streamSync = exports.globIterate = exports.globIterateSync = exports.globSync = exports.globStream = exports.globStreamSync = void 0;
const minimatch_1 = cjs$2;
const glob_js_1 = glob$1;
const has_magic_js_1 = hasMagic$1;
function globStreamSync(pattern, options = {}) {
    return new glob_js_1.Glob(pattern, options).streamSync();
}
exports.globStreamSync = globStreamSync;
function globStream(pattern, options = {}) {
    return new glob_js_1.Glob(pattern, options).stream();
}
exports.globStream = globStream;
function globSync(pattern, options = {}) {
    return new glob_js_1.Glob(pattern, options).walkSync();
}
exports.globSync = globSync;
async function glob_(pattern, options = {}) {
    return new glob_js_1.Glob(pattern, options).walk();
}
function globIterateSync(pattern, options = {}) {
    return new glob_js_1.Glob(pattern, options).iterateSync();
}
exports.globIterateSync = globIterateSync;
function globIterate(pattern, options = {}) {
    return new glob_js_1.Glob(pattern, options).iterate();
}
exports.globIterate = globIterate;
// aliases: glob.sync.stream() glob.stream.sync() glob.sync() etc
exports.streamSync = globStreamSync;
exports.stream = Object.assign(globStream, { sync: globStreamSync });
exports.iterateSync = globIterateSync;
exports.iterate = Object.assign(globIterate, {
    sync: globIterateSync,
});
exports.sync = Object.assign(globSync, {
    stream: globStreamSync,
    iterate: globIterateSync,
});
/* c8 ignore start */
var minimatch_2 = cjs$2;
Object.defineProperty(exports, "escape", { enumerable: true, get: function () { return minimatch_2.escape; } });
Object.defineProperty(exports, "unescape", { enumerable: true, get: function () { return minimatch_2.unescape; } });
var glob_js_2 = glob$1;
Object.defineProperty(exports, "Glob", { enumerable: true, get: function () { return glob_js_2.Glob; } });
var has_magic_js_2 = hasMagic$1;
Object.defineProperty(exports, "hasMagic", { enumerable: true, get: function () { return has_magic_js_2.hasMagic; } });
/* c8 ignore stop */
exports.glob = Object.assign(glob_, {
    glob: glob_,
    globSync,
    sync: exports.sync,
    globStream,
    stream: exports.stream,
    globStreamSync,
    streamSync: exports.streamSync,
    globIterate,
    iterate: exports.iterate,
    globIterateSync,
    iterateSync: exports.iterateSync,
    Glob: glob_js_1.Glob,
    hasMagic: has_magic_js_1.hasMagic,
    escape: minimatch_1.escape,
    unescape: minimatch_1.unescape,
});
exports.glob.glob = exports.glob;

}(src));

const fs$8 = lib$1;
const path$6 = require$$1__default["default"];
const fetch$2 = require$$1$1.default;
const { BrowserWindow: BrowserWindow$1, app: app$5 } = require$$0__default$4["default"];
const crypto$1 = require$$4__default$2["default"];
const unhandled = electronUnhandled.exports;
const util$a = require$$4__default["default"];
const { glob } = src;
const readdir$1 = util$a.promisify(fs$8.readdir);
const isDev$2 = !app$5.isPackaged;
const appRoot = isDev$2 ? path$6.resolve(__dirname, "..", "..") : path$6.resolve(app$5.getAppPath(), "..", "..");
const userDataPath$2 = path$6.resolve(appRoot, "userData");
const userPath$1 = app$5.getPath("userData");
let win$1 = null;
const initWindow$1 = () => {
  const win2 = new BrowserWindow$1({
    width: 800,
    height: 600,
    frame: false,
    backgroundColor: "#1f1f1f",
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false,
      webSecurity: false
    }
  });
  return win2;
};
const getWin = () => win$1;
const log = [];
const sendMsg$2 = (text, type = "LOAD_DATA_STATUS") => {
  if (type !== "LOAD_DATA_STATUS") {
    log.push([Date.now(), type, text]);
    saveLog();
  }
};
const saveLog = () => {
  const text = log.map((item) => {
    const time = new Date(item[0]).toLocaleString();
    const type = item[1] === "LOAD_DATA_STATUS" ? "INFO" : item[1];
    const text2 = item[2];
    return `[${type}][${time}]${text2}`;
  }).join("\r\n");
  fs$8.outputFileSync(path$6.join(userDataPath$2, "log.txt"), text);
};
const authkeyMask = (text = "") => {
  return text.replace(/authkey=[^&]+&/g, "authkey=***&");
};
unhandled({
  showDialog: false,
  logger: function(err) {
    log.push([Date.now(), "ERROR", authkeyMask(err.stack)]);
    saveLog();
  }
});
const request$1 = async (url) => {
  const res = await fetch$2(url, {
    timeout: 15 * 1e3
  });
  return await res.json();
};
const sleep$1 = (sec = 1) => {
  return new Promise((rev) => {
    setTimeout(rev, sec * 1e3);
  });
};
const langMap$1 = new Map([
  ["zh-cn", "\u7B80\u4F53\u4E2D\u6587"],
  ["zh-tw", "\u7E41\u9AD4\u4E2D\u6587"],
  ["de-de", "Deutsch"],
  ["en-us", "English"],
  ["es-es", "Espa\xF1ol"],
  ["fr-fr", "Fran\xE7ais"],
  ["id-id", "Indonesia"],
  ["ja-jp", "\u65E5\u672C\u8A9E"],
  ["ko-kr", "\uD55C\uAD6D\uC5B4"],
  ["pt-pt", "Portugu\xEAs"],
  ["ru-ru", "P\u0443\u0441\u0441\u043A\u0438\u0439"],
  ["th-th", "\u0E20\u0E32\u0E29\u0E32\u0E44\u0E17\u0E22"],
  ["vi-vn", "Ti\u1EBFng Vi\u1EC7t"]
]);
const localeMap = new Map([
  ["zh-cn", ["zh", "zh-CN"]],
  ["zh-tw", ["zh-TW"]],
  ["de-de", ["de-AT", "de-CH", "de-DE", "de"]],
  ["en-us", ["en-AU", "en-CA", "en-GB", "en-NZ", "en-US", "en-ZA", "en"]],
  ["es-es", ["es", "es-419"]],
  ["fr-fr", ["fr-CA", "fr-CH", "fr-FR", "fr"]],
  ["id-id", ["id"]],
  ["ja-jp", ["ja"]],
  ["ko-kr", ["ko"]],
  ["pt-pt", ["pt-BR", "pt-PT", "pt"]],
  ["ru-ru", ["ru"]],
  ["th-th", ["th"]],
  ["vi-vn", ["vi"]]
]);
const fixLocalMap$1 = new Map([
  ["en", "en-us"],
  ["fr", "fr-fr"],
  ["de", "de-de"],
  ["es", "es-es"],
  ["pt", "pt-pt"],
  ["ru", "ru-ru"],
  ["ja", "ja-jp"],
  ["ko", "ko-kr"],
  ["th", "th-th"],
  ["vi", "vi-vn"],
  ["id", "id-id"],
  ["zh-cn", "zh-cn"],
  ["zh-tw", "zh-tw"],
  ["tr", "tr-tr"],
  ["it", "it-it"]
]);
const detectLocale$1 = () => {
  const locale = app$5.getLocale();
  let result = "zh-cn";
  for (let [key, list] of localeMap) {
    if (list.includes(locale)) {
      result = key;
      break;
    }
  }
  return result;
};
function existsFile$1(name) {
  return fs$8.existsSync(path$6.join(userDataPath$2, name));
}
const saveJSON$3 = async (name, data) => {
  try {
    await fs$8.outputJSON(path$6.join(userDataPath$2, name), data, {
      spaces: 2
    });
  } catch (e) {
    sendMsg$2(e, "ERROR");
    await sleep$1(3);
  }
};
const readJSON$3 = async (name) => {
  let data = null;
  try {
    data = await fs$8.readJSON(path$6.join(userDataPath$2, name));
  } catch (e) {
  }
  return data;
};
const hash$1 = (data, type = "sha256") => {
  const hmac = crypto$1.createHmac(type, "hk4e");
  hmac.update(data);
  return hmac.digest("hex");
};
const scryptKey = crypto$1.scryptSync(userPath$1, "hk4e", 24);
const cipherAes$1 = (data) => {
  const algorithm = "aes-192-cbc";
  const iv = Buffer.alloc(16, 0);
  const cipher = crypto$1.createCipheriv(algorithm, scryptKey, iv);
  let encrypted = cipher.update(data, "utf8", "hex");
  encrypted += cipher.final("hex");
  return encrypted;
};
const decipherAes$1 = (encrypted) => {
  const algorithm = "aes-192-cbc";
  const iv = Buffer.alloc(16, 0);
  const decipher = crypto$1.createDecipheriv(algorithm, scryptKey, iv);
  let decrypted = decipher.update(encrypted, "hex", "utf8");
  decrypted += decipher.final("utf8");
  return decrypted;
};
const interfaces = require$$0__default$3["default"].networkInterfaces();
const localIp$1 = () => {
  for (var devName in interfaces) {
    var iface = interfaces[devName];
    for (var i = 0; i < iface.length; i++) {
      var alias = iface[i];
      if (alias.family === "IPv4" && alias.address !== "127.0.0.1" && !alias.internal)
        return alias.address;
    }
  }
  return "127.0.0.1";
};
async function getCacheText$1(gamePath) {
  const results = await glob(path$6.join(gamePath, "/webCaches{/,/*/}Cache/Cache_Data/data_2"), {
    stat: true,
    withFileTypes: true,
    nodir: true,
    windowsPathsNoEscape: true
  });
  const timeSortedFiles = results.sort((a, b) => b.mtimeMs - a.mtimeMs).map((path2) => path2.fullpath());
  const cacheText = await fs$8.readFile(path$6.join(timeSortedFiles[0]), "utf8");
  return [cacheText, timeSortedFiles[0]];
}
var utils = {
  readdir: readdir$1,
  sleep: sleep$1,
  request: request$1,
  hash: hash$1,
  cipherAes: cipherAes$1,
  decipherAes: decipherAes$1,
  saveLog,
  sendMsg: sendMsg$2,
  existsFile: existsFile$1,
  readJSON: readJSON$3,
  saveJSON: saveJSON$3,
  initWindow: initWindow$1,
  getWin,
  localIp: localIp$1,
  userPath: userPath$1,
  detectLocale: detectLocale$1,
  langMap: langMap$1,
  fixLocalMap: fixLocalMap$1,
  getCacheText: getCacheText$1,
  appRoot,
  userDataPath: userDataPath$2
};

/************************************************************************************************************
 * registry.js - contains a wrapper for the REG command under Windows, which provides access to the registry
 *
 * @author Paul Bottin a/k/a FrEsC
 *
 */

/* imports */
var util$9          = require$$4__default["default"]
,   path$5          = require$$1__default["default"]
,   spawn         = require$$2__default$2["default"].spawn

/* set to console.log for debugging */
,   HKLM          = 'HKLM'
,   HKCU          = 'HKCU'
,   HKCR          = 'HKCR'
,   HKU           = 'HKU'
,   HKCC          = 'HKCC'
,   HIVES         = [ HKLM, HKCU, HKCR, HKU, HKCC ]

/* registry value type ids */
,   REG_SZ        = 'REG_SZ'
,   REG_MULTI_SZ  = 'REG_MULTI_SZ'
,   REG_EXPAND_SZ = 'REG_EXPAND_SZ'
,   REG_DWORD     = 'REG_DWORD'
,   REG_QWORD     = 'REG_QWORD'
,   REG_BINARY    = 'REG_BINARY'
,   REG_NONE      = 'REG_NONE'
,   REG_TYPES     = [ REG_SZ, REG_MULTI_SZ, REG_EXPAND_SZ, REG_DWORD, REG_QWORD, REG_BINARY, REG_NONE ]

/* default registry value name */
,   DEFAULT_VALUE = ''

/* general key pattern */
,   KEY_PATTERN   = /(\\[a-zA-Z0-9_\s]+)*/

/* key path pattern (as returned by REG-cli) */
,   PATH_PATTERN  = /^(HKEY_LOCAL_MACHINE|HKEY_CURRENT_USER|HKEY_CLASSES_ROOT|HKEY_USERS|HKEY_CURRENT_CONFIG)(.*)$/

/* registry item pattern */
,   ITEM_PATTERN  = /^(.*)\s(REG_SZ|REG_MULTI_SZ|REG_EXPAND_SZ|REG_DWORD|REG_QWORD|REG_BINARY|REG_NONE)\s+([^\s].*)$/;

/**
 * Creates an Error object that contains the exit code of the REG.EXE process.
 * This contructor is private. Objects of this type are created internally and returned in the <code>err</code> parameters in case the REG.EXE process doesn't exit cleanly.
 *
 * @private
 * @class
 *
 * @param {string} message - the error message
 * @param {number} code - the process exit code
 *
 */
function ProcessUncleanExitError(message, code) {
  if (!(this instanceof ProcessUncleanExitError))
    return new ProcessUncleanExitError(message, code);

  Error.captureStackTrace(this, ProcessUncleanExitError);

  /**
   * The error name.
   * @readonly
   * @member {string} ProcessUncleanExitError#name
   */
  this.__defineGetter__('name', function () { return ProcessUncleanExitError.name; });

  /**
   * The error message.
   * @readonly
   * @member {string} ProcessUncleanExitError#message
   */
  this.__defineGetter__('message', function () { return message; });

  /**
   * The process exit code.
   * @readonly
   * @member {number} ProcessUncleanExitError#code
   */
  this.__defineGetter__('code', function () { return code; });

}

util$9.inherits(ProcessUncleanExitError, Error);

/*
 * Captures stdout/stderr for a child process
 */
function captureOutput(child) {
  // Use a mutable data structure so we can append as we get new data and have
  // the calling context see the new data
  var output = {'stdout': '', 'stderr': ''};

  child.stdout.on('data', function(data) { output["stdout"] += data.toString(); });
  child.stderr.on('data', function(data) { output["stderr"] += data.toString(); });

  return output;
}


/*
 * Returns an error message containing the stdout/stderr of the child process
 */
function mkErrorMsg(registryCommand, code, output) {
    var stdout = output['stdout'].trim();
    var stderr = output['stderr'].trim();

    var msg = util$9.format("%s command exited with code %d:\n%s\n%s", registryCommand, code, stdout, stderr);
    return new ProcessUncleanExitError(msg, code);
}


/*
 * Converts x86/x64 to 32/64
 */
function convertArchString(archString) {
  if (archString == 'x64') {
    return '64';
  } else if (archString == 'x86') {
    return '32';
  } else {
    throw new Error('illegal architecture: ' + archString + ' (use x86 or x64)');
  }
}


/*
 * Adds correct architecture to reg args
 */
function pushArch(args, arch) {
  if (arch) {
    args.push('/reg:' + convertArchString(arch));
  }
}

/*
 * Get the path to system's reg.exe. Useful when another reg.exe is added to the PATH
 * Implemented only for Windows
 */
function getRegExePath() {
    if (process.platform === 'win32') {
        return path$5.join(process.env.windir, 'system32', 'reg.exe');
    } else {
        return "REG";
    }
}


/**
 * Creates a single registry value record.
 * This contructor is private. Objects of this type are created internally and returned by methods of {@link Registry} objects.
 *
 * @private
 * @class
 *
 * @param {string} host - the hostname
 * @param {string} hive - the hive id
 * @param {string} key - the registry key
 * @param {string} name - the value name
 * @param {string} type - the value type
 * @param {string} value - the value
 * @param {string} arch - the hive architecture ('x86' or 'x64')
 *
 */
function RegistryItem (host, hive, key, name, type, value, arch) {

  if (!(this instanceof RegistryItem))
    return new RegistryItem(host, hive, key, name, type, value, arch);

  /* private members */
  var _host = host    // hostname
  ,   _hive = hive    // registry hive
  ,   _key = key      // registry key
  ,   _name = name    // property name
  ,   _type = type    // property type
  ,   _value = value  // property value
  ,   _arch = arch;    // hive architecture

  /* getters/setters */

  /**
   * The hostname.
   * @readonly
   * @member {string} RegistryItem#host
   */
  this.__defineGetter__('host', function () { return _host; });

  /**
   * The hive id.
   * @readonly
   * @member {string} RegistryItem#hive
   */
  this.__defineGetter__('hive', function () { return _hive; });

  /**
   * The registry key.
   * @readonly
   * @member {string} RegistryItem#key
   */
  this.__defineGetter__('key', function () { return _key; });

  /**
   * The value name.
   * @readonly
   * @member {string} RegistryItem#name
   */
  this.__defineGetter__('name', function () { return _name; });

  /**
   * The value type.
   * @readonly
   * @member {string} RegistryItem#type
   */
  this.__defineGetter__('type', function () { return _type; });

  /**
   * The value.
   * @readonly
   * @member {string} RegistryItem#value
   */
  this.__defineGetter__('value', function () { return _value; });

  /**
   * The hive architecture.
   * @readonly
   * @member {string} RegistryItem#arch
   */
  this.__defineGetter__('arch', function () { return _arch; });

}

util$9.inherits(RegistryItem, Object);

/**
 * Creates a registry object, which provides access to a single registry key.
 * Note: This class is returned by a call to ```require('winreg')```.
 *
 * @public
 * @class
 *
 * @param {object} options - the options
 * @param {string=} options.host - the hostname
 * @param {string=} options.hive - the hive id
 * @param {string=} options.key - the registry key
 * @param {string=} options.arch - the optional registry hive architecture ('x86' or 'x64'; only valid on Windows 64 Bit Operating Systems)
 *
 * @example
 * var Registry = require('winreg')
 * ,   autoStartCurrentUser = new Registry({
 *       hive: Registry.HKCU,
 *       key:  '\\Software\\Microsoft\\Windows\\CurrentVersion\\Run'
 *     });
 *
 */
function Registry$1 (options) {

  if (!(this instanceof Registry$1))
    return new Registry$1(options);

  /* private members */
  var _options = options || {}
  ,   _host = '' + (_options.host || '')    // hostname
  ,   _hive = '' + (_options.hive || HKLM)  // registry hive
  ,   _key  = '' + (_options.key  || '')    // registry key
  ,   _arch = _options.arch || null;         // hive architecture

  /* getters/setters */

  /**
   * The hostname.
   * @readonly
   * @member {string} Registry#host
   */
  this.__defineGetter__('host', function () { return _host; });

  /**
   * The hive id.
   * @readonly
   * @member {string} Registry#hive
   */
  this.__defineGetter__('hive', function () { return _hive; });

  /**
   * The registry key name.
   * @readonly
   * @member {string} Registry#key
   */
  this.__defineGetter__('key', function () { return _key; });

  /**
   * The full path to the registry key.
   * @readonly
   * @member {string} Registry#path
   */
  this.__defineGetter__('path', function () { return (_host.length == 0 ? '' : '\\\\' + _host + '\\') + _hive + _key; });

  /**
   * The registry hive architecture ('x86' or 'x64').
   * @readonly
   * @member {string} Registry#arch
   */
  this.__defineGetter__('arch', function () { return _arch; });

  /**
   * Creates a new {@link Registry} instance that points to the parent registry key.
   * @readonly
   * @member {Registry} Registry#parent
   */
  this.__defineGetter__('parent', function () {
    var i = _key.lastIndexOf('\\');
    return new Registry$1({
      host: this.host,
      hive: this.hive,
      key:  (i == -1)?'':_key.substring(0, i),
      arch: this.arch
    });
  });

  // validate options...
  if (HIVES.indexOf(_hive) == -1)
    throw new Error('illegal hive specified.');

  if (!KEY_PATTERN.test(_key))
    throw new Error('illegal key specified.');

  if (_arch && _arch != 'x64' && _arch != 'x86')
    throw new Error('illegal architecture specified (use x86 or x64)');

}

/**
 * Registry hive key HKEY_LOCAL_MACHINE.
 * Note: For writing to this hive your program has to run with admin privileges.
 * @type {string}
 */
Registry$1.HKLM = HKLM;

/**
 * Registry hive key HKEY_CURRENT_USER.
 * @type {string}
 */
Registry$1.HKCU = HKCU;

/**
 * Registry hive key HKEY_CLASSES_ROOT.
 * Note: For writing to this hive your program has to run with admin privileges.
 * @type {string}
 */
Registry$1.HKCR = HKCR;

/**
 * Registry hive key HKEY_USERS.
 * Note: For writing to this hive your program has to run with admin privileges.
 * @type {string}
 */
Registry$1.HKU = HKU;

/**
 * Registry hive key HKEY_CURRENT_CONFIG.
 * Note: For writing to this hive your program has to run with admin privileges.
 * @type {string}
 */
Registry$1.HKCC = HKCC;

/**
 * Collection of available registry hive keys.
 * @type {array}
 */
Registry$1.HIVES = HIVES;

/**
 * Registry value type STRING.
 * @type {string}
 */
Registry$1.REG_SZ = REG_SZ;

/**
 * Registry value type MULTILINE_STRING.
 * @type {string}
 */
Registry$1.REG_MULTI_SZ = REG_MULTI_SZ;

/**
 * Registry value type EXPANDABLE_STRING.
 * @type {string}
 */
Registry$1.REG_EXPAND_SZ = REG_EXPAND_SZ;

/**
 * Registry value type DOUBLE_WORD.
 * @type {string}
 */
Registry$1.REG_DWORD = REG_DWORD;

/**
 * Registry value type QUAD_WORD.
 * @type {string}
 */
Registry$1.REG_QWORD = REG_QWORD;

/**
 * Registry value type BINARY.
 * @type {string}
 */
Registry$1.REG_BINARY = REG_BINARY;

/**
 * Registry value type UNKNOWN.
 * @type {string}
 */
Registry$1.REG_NONE = REG_NONE;

/**
 * Collection of available registry value types.
 * @type {array}
 */
Registry$1.REG_TYPES = REG_TYPES;

/**
 * The name of the default value. May be used instead of the empty string literal for better readability.
 * @type {string}
 */
Registry$1.DEFAULT_VALUE = DEFAULT_VALUE;

/**
 * Retrieve all values from this registry key.
 * @param {valuesCallback} cb - callback function
 * @param {ProcessUncleanExitError=} cb.err - error object or null if successful
 * @param {array=} cb.items - an array of {@link RegistryItem} objects
 * @returns {Registry} this registry key object
 */
Registry$1.prototype.values = function values (cb) {

  if (typeof cb !== 'function')
    throw new TypeError('must specify a callback');

  var args = [ 'QUERY', this.path ];

  pushArch(args, this.arch);

  var proc = spawn(getRegExePath(), args, {
        cwd: undefined,
        env: process.env,
        stdio: [ 'ignore', 'pipe', 'pipe' ]
      })
  ,   buffer = ''
  ,   self = this
  ,   error = null; // null means no error previously reported.

  var output = captureOutput(proc);

  proc.on('close', function (code) {
    if (error) {
      return;
    } else if (code !== 0) {
      cb(mkErrorMsg('QUERY', code, output), null);
    } else {
      var items = []
      ,   result = []
      ,   lines = buffer.split('\n')
      ,   lineNumber = 0;

      for (var i = 0, l = lines.length; i < l; i++) {
        var line = lines[i].trim();
        if (line.length > 0) {
          if (lineNumber != 0) {
            items.push(line);
          }
          ++lineNumber;
        }
      }

      for (var i = 0, l = items.length; i < l; i++) {

        var match = ITEM_PATTERN.exec(items[i])
        ,   name
        ,   type
        ,   value;

        if (match) {
          name = match[1].trim();
          type = match[2].trim();
          value = match[3];
          result.push(new RegistryItem(self.host, self.hive, self.key, name, type, value, self.arch));
        }
      }

      cb(null, result);

    }
  });

  proc.stdout.on('data', function (data) {
    buffer += data.toString();
  });

  proc.on('error', function(err) {
    error = err;
    cb(err);
  });

  return this;
};

/**
 * Retrieve all subkeys from this registry key.
 * @param {function (err, items)} cb - callback function
 * @param {ProcessUncleanExitError=} cb.err - error object or null if successful
 * @param {array=} cb.items - an array of {@link Registry} objects
 * @returns {Registry} this registry key object
 */
Registry$1.prototype.keys = function keys (cb) {

  if (typeof cb !== 'function')
    throw new TypeError('must specify a callback');

  var args = [ 'QUERY', this.path ];

  pushArch(args, this.arch);

  var proc = spawn(getRegExePath(), args, {
        cwd: undefined,
        env: process.env,
        stdio: [ 'ignore', 'pipe', 'pipe' ]
      })
  ,   buffer = ''
  ,   self = this
  ,   error = null; // null means no error previously reported.

  var output = captureOutput(proc);

  proc.on('close', function (code) {
    if (error) {
      return;
    } else if (code !== 0) {
      cb(mkErrorMsg('QUERY', code, output), null);
    }
  });

  proc.stdout.on('data', function (data) {
    buffer += data.toString();
  });

  proc.stdout.on('end', function () {

    var items = []
    ,   result = []
    ,   lines = buffer.split('\n');

    for (var i = 0, l = lines.length; i < l; i++) {
      var line = lines[i].trim();
      if (line.length > 0) {
        items.push(line);
      }
    }

    for (var i = 0, l = items.length; i < l; i++) {

      var match = PATH_PATTERN.exec(items[i])
      ,   key;

      if (match) {
        key  = match[2];
        if (key && (key !== self.key)) {
          result.push(new Registry$1({
            host: self.host,
            hive: self.hive,
            key:  key,
            arch: self.arch
          }));
        }
      }
    }

    cb(null, result);

  });

  proc.on('error', function(err) {
    error = err;
    cb(err);
  });

  return this;
};

/**
 * Gets a named value from this registry key.
 * @param {string} name - the value name, use {@link Registry.DEFAULT_VALUE} or an empty string for the default value
 * @param {function (err, item)} cb - callback function
 * @param {ProcessUncleanExitError=} cb.err - error object or null if successful
 * @param {RegistryItem=} cb.item - the retrieved registry item
 * @returns {Registry} this registry key object
 */
Registry$1.prototype.get = function get (name, cb) {

  if (typeof cb !== 'function')
    throw new TypeError('must specify a callback');

  var args = ['QUERY', this.path];
  if (name == '')
    args.push('/ve');
  else
    args = args.concat(['/v', name]);

  pushArch(args, this.arch);

  var proc = spawn(getRegExePath(), args, {
        cwd: undefined,
        env: process.env,
        stdio: [ 'ignore', 'pipe', 'pipe' ]
      })
  ,   buffer = ''
  ,   self = this
  ,   error = null; // null means no error previously reported.

  var output = captureOutput(proc);

  proc.on('close', function (code) {
    if (error) {
      return;
    } else if (code !== 0) {
      cb(mkErrorMsg('QUERY', code, output), null);
    } else {
      var items = []
      ,   result = null
      ,   lines = buffer.split('\n')
      ,   lineNumber = 0;

      for (var i = 0, l = lines.length; i < l; i++) {
        var line = lines[i].trim();
        if (line.length > 0) {
          if (lineNumber != 0) {
             items.push(line);
          }
          ++lineNumber;
        }
      }

      //Get last item - so it works in XP where REG QUERY returns with a header
      var item = items[items.length-1] || ''
      ,   match = ITEM_PATTERN.exec(item)
      ,   name
      ,   type
      ,   value;

      if (match) {
        name = match[1].trim();
        type = match[2].trim();
        value = match[3];
        result = new RegistryItem(self.host, self.hive, self.key, name, type, value, self.arch);
      }

      cb(null, result);
    }
  });

  proc.stdout.on('data', function (data) {
    buffer += data.toString();
  });

  proc.on('error', function(err) {
    error = err;
    cb(err);
  });

  return this;
};

/**
 * Sets a named value in this registry key, overwriting an already existing value.
 * @param {string} name - the value name, use {@link Registry.DEFAULT_VALUE} or an empty string for the default value
 * @param {string} type - the value type
 * @param {string} value - the value
 * @param {function (err)} cb - callback function
 * @param {ProcessUncleanExitError=} cb.err - error object or null if successful
 * @returns {Registry} this registry key object
 */
Registry$1.prototype.set = function set (name, type, value, cb) {

  if (typeof cb !== 'function')
    throw new TypeError('must specify a callback');

  if (REG_TYPES.indexOf(type) == -1)
    throw Error('illegal type specified.');

  var args = ['ADD', this.path];
  if (name == '')
    args.push('/ve');
  else
    args = args.concat(['/v', name]);

  args = args.concat(['/t', type, '/d', value, '/f']);

  pushArch(args, this.arch);

  var proc = spawn(getRegExePath(), args, {
        cwd: undefined,
        env: process.env,
        stdio: [ 'ignore', 'pipe', 'pipe' ]
      })
  ,   error = null; // null means no error previously reported.

  var output = captureOutput(proc);

  proc.on('close', function (code) {
    if(error) {
      return;
    } else if (code !== 0) {
      cb(mkErrorMsg('ADD', code, output));
    } else {
      cb(null);
    }
  });

  proc.stdout.on('data', function (data) {
  });

  proc.on('error', function(err) {
    error = err;
    cb(err);
  });

  return this;
};

/**
 * Remove a named value from this registry key. If name is empty, sets the default value of this key.
 * Note: This key must be already existing.
 * @param {string} name - the value name, use {@link Registry.DEFAULT_VALUE} or an empty string for the default value
 * @param {function (err)} cb - callback function
 * @param {ProcessUncleanExitError=} cb.err - error object or null if successful
 * @returns {Registry} this registry key object
 */
Registry$1.prototype.remove = function remove (name, cb) {

  if (typeof cb !== 'function')
    throw new TypeError('must specify a callback');

  var args = name ? ['DELETE', this.path, '/f', '/v', name] : ['DELETE', this.path, '/f', '/ve'];

  pushArch(args, this.arch);

  var proc = spawn(getRegExePath(), args, {
        cwd: undefined,
        env: process.env,
        stdio: [ 'ignore', 'pipe', 'pipe' ]
      })
  ,   error = null; // null means no error previously reported.

  var output = captureOutput(proc);

  proc.on('close', function (code) {
    if(error) {
      return;
    } else if (code !== 0) {
      cb(mkErrorMsg('DELETE', code, output), null);
    } else {
      cb(null);
    }
  });

  proc.stdout.on('data', function (data) {
  });

  proc.on('error', function(err) {
    error = err;
    cb(err);
  });

  return this;
};

/**
 * Remove all subkeys and values (including the default value) from this registry key.
 * @param {function (err)} cb - callback function
 * @param {ProcessUncleanExitError=} cb.err - error object or null if successful
 * @returns {Registry} this registry key object
 */
Registry$1.prototype.clear = function clear (cb) {

  if (typeof cb !== 'function')
    throw new TypeError('must specify a callback');

  var args = ['DELETE', this.path, '/f', '/va'];

  pushArch(args, this.arch);

  var proc = spawn(getRegExePath(), args, {
        cwd: undefined,
        env: process.env,
        stdio: [ 'ignore', 'pipe', 'pipe' ]
      })
  ,   error = null; // null means no error previously reported.

  var output = captureOutput(proc);

  proc.on('close', function (code) {
    if(error) {
      return;
    } else if (code !== 0) {
      cb(mkErrorMsg("DELETE", code, output), null);
    } else {
      cb(null);
    }
  });

  proc.stdout.on('data', function (data) {
  });

  proc.on('error', function(err) {
    error = err;
    cb(err);
  });

  return this;
};

/**
 * Alias for the clear method to keep it backward compatible.
 * @method
 * @deprecated Use {@link Registry#clear} or {@link Registry#destroy} in favour of this method.
 * @param {function (err)} cb - callback function
 * @param {ProcessUncleanExitError=} cb.err - error object or null if successful
 * @returns {Registry} this registry key object
 */
Registry$1.prototype.erase = Registry$1.prototype.clear;

/**
 * Delete this key and all subkeys from the registry.
 * @param {function (err)} cb - callback function
 * @param {ProcessUncleanExitError=} cb.err - error object or null if successful
 * @returns {Registry} this registry key object
 */
Registry$1.prototype.destroy = function destroy (cb) {

  if (typeof cb !== 'function')
    throw new TypeError('must specify a callback');

  var args = ['DELETE', this.path, '/f'];

  pushArch(args, this.arch);

  var proc = spawn(getRegExePath(), args, {
        cwd: undefined,
        env: process.env,
        stdio: [ 'ignore', 'pipe', 'pipe' ]
      })
  ,   error = null; // null means no error previously reported.

  var output = captureOutput(proc);

  proc.on('close', function (code) {
    if (error) {
      return;
    } else if (code !== 0) {
      cb(mkErrorMsg('DELETE', code, output), null);
    } else {
      cb(null);
    }
  });

  proc.stdout.on('data', function (data) {
  });

  proc.on('error', function(err) {
    error = err;
    cb(err);
  });

  return this;
};

/**
 * Create this registry key. Note that this is a no-op if the key already exists.
 * @param {function (err)} cb - callback function
 * @param {ProcessUncleanExitError=} cb.err - error object or null if successful
 * @returns {Registry} this registry key object
 */
Registry$1.prototype.create = function create (cb) {

  if (typeof cb !== 'function')
    throw new TypeError('must specify a callback');

  var args = ['ADD', this.path, '/f'];

  pushArch(args, this.arch);

  var proc = spawn(getRegExePath(), args, {
        cwd: undefined,
        env: process.env,
        stdio: [ 'ignore', 'pipe', 'pipe' ]
      })
  ,   error = null; // null means no error previously reported.

  var output = captureOutput(proc);

  proc.on('close', function (code) {
    if (error) {
      return;
    } else if (code !== 0) {
      cb(mkErrorMsg('ADD', code, output), null);
    } else {
      cb(null);
    }
  });

  proc.stdout.on('data', function (data) {
  });

  proc.on('error', function(err) {
    error = err;
    cb(err);
  });

  return this;
};

/**
 * Checks if this key already exists.
 * @param {function (err, exists)} cb - callback function
 * @param {ProcessUncleanExitError=} cb.err - error object or null if successful
 * @param {boolean=} cb.exists - true if a registry key with this name already exists
 * @returns {Registry} this registry key object
 */
Registry$1.prototype.keyExists = function keyExists (cb) {

  this.values(function (err, items) {
    if (err) {
      // process should return with code 1 if key not found
      if (err.code == 1) {
        return cb(null, false);
      }
      // other error
      return cb(err);
    }
    cb(null, true);
  });

  return this;
};

/**
 * Checks if a value with the given name already exists within this key.
 * @param {string} name - the value name, use {@link Registry.DEFAULT_VALUE} or an empty string for the default value
 * @param {function (err, exists)} cb - callback function
 * @param {ProcessUncleanExitError=} cb.err - error object or null if successful
 * @param {boolean=} cb.exists - true if a value with the given name was found in this key
 * @returns {Registry} this registry key object
 */
Registry$1.prototype.valueExists = function valueExists (name, cb) {

  this.get(name, function (err, item) {
    if (err) {
      // process should return with code 1 if value not found
      if (err.code == 1) {
        return cb(null, false);
      }
      // other error
      return cb(err);
    }
    cb(null, true);
  });

  return this;
};

var registry = Registry$1;

const Registry = registry;
const proxyStatus$1 = {
  started: false
};
const setProxy = async (enable, proxyIp = "", ignoreIp = "") => {
  const regKey = new Registry({
    hive: Registry.HKCU,
    key: "\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"
  });
  const regSet = function(key, type, value) {
    return new Promise((rev, rej) => {
      regKey.set(key, type, value, function(err) {
        if (err)
          rej(err);
        rev();
      });
    });
  };
  await regSet("ProxyEnable", Registry.REG_DWORD, enable);
  await regSet("ProxyServer", Registry.REG_SZ, proxyIp);
  await regSet("ProxyOverride", Registry.REG_SZ, ignoreIp);
};
const enableProxy$1 = async (ip, port) => {
  const proxyIp = `${ip}:${port}`;
  const ignoreIp = "localhost;127.*;10.*;172.16.*;172.17.*;172.18.*;172.19.*;172.20.*;172.21.*;172.22.*;172.23.*;172.24.*;172.25.*;172.26.*;172.27.*;172.28.*;172.29.*;172.30.*;172.31.*;192.168.*;<local>";
  await setProxy("1", proxyIp, ignoreIp);
  proxyStatus$1.started = true;
};
const disableProxy$2 = async () => {
  await setProxy("0");
  proxyStatus$1.started = false;
};
var systemProxy = {
  enableProxy: enableProxy$1,
  disableProxy: disableProxy$2,
  proxyStatus: proxyStatus$1
};

var getData$3 = {};

const { readJSON: readJSON$2, saveJSON: saveJSON$2, decipherAes, cipherAes, detectLocale } = utils;
const config$4 = {
  urls: [],
  logType: 0,
  lang: detectLocale(),
  current: 0,
  proxyPort: 8325,
  proxyMode: false,
  autoUpdate: true,
  fetchFullHistory: false,
  hideNovice: true,
  gistsToken: "",
  gistsId: "",
  readableJSON: false
};
const getLocalConfig = async () => {
  const localConfig = await readJSON$2("config.json");
  if (!localConfig)
    return;
  const configTemp = {};
  for (let key in localConfig) {
    if (typeof config$4[key] !== "undefined") {
      configTemp[key] = localConfig[key];
    }
  }
  configTemp.urls.forEach((item) => {
    try {
      item[1] = decipherAes(item[1]);
    } catch (e) {
      item[1] = "";
    }
  });
  Object.assign(config$4, configTemp);
};
getLocalConfig();
let urlsMap = null;
const setConfig = (key, value) => {
  Reflect.set(config$4, key, value);
};
const saveConfig = async () => {
  let configTemp = config$4;
  if (urlsMap) {
    const urls = [...urlsMap];
    urls.forEach((item) => {
      try {
        item[1] = cipherAes(item[1]);
      } catch (e) {
        item[1] = "";
      }
    });
    configTemp = Object.assign({}, config$4, { urls });
  }
  await saveJSON$2("config.json", configTemp);
};
const getPlainConfig = () => config$4;
const configProxy = new Proxy(config$4, {
  get: function(obj, prop) {
    if (prop === "urls") {
      if (!urlsMap) {
        urlsMap = new Map(obj[prop]);
      }
      return urlsMap;
    } else if (prop === "set") {
      return setConfig;
    } else if (prop === "save") {
      return saveConfig;
    } else if (prop === "value") {
      return getPlainConfig;
    }
    return obj[prop];
  }
});
var config_1 = configProxy;

var gachaTypeMap = {};

var require$$0$1 = {
	"en-us": [
	{
		key: "200",
		name: "Permanent Wish"
	},
	{
		key: "100",
		name: "Novice Wishes"
	},
	{
		key: "301",
		name: "Character Event Wish"
	},
	{
		key: "302",
		name: "Weapon Event Wish"
	},
	{
		key: "400",
		name: "Character Event Wish-2"
	},
	{
		key: "500",
		name: "Chronicled Wish"
	}
],
	"fr-fr": [
	{
		key: "200",
		name: "Vux permanents"
	},
	{
		key: "100",
		name: "Vux des dbutants"
	},
	{
		key: "301",
		name: "Vux vnements de personnage"
	},
	{
		key: "302",
		name: "Vux vnements d'arme"
	},
	{
		key: "400",
		name: "Vux vnements de personnage - 2"
	},
	{
		key: "500",
		name: "Vux nostalgie"
	}
],
	"de-de": [
	{
		key: "200",
		name: "Standardgebet"
	},
	{
		key: "100",
		name: "Neulingsgebete"
	},
	{
		key: "301",
		name: "Figurenaktionsgebet"
	},
	{
		key: "302",
		name: "Waffenaktionsgebet"
	},
	{
		key: "400",
		name: "Figurenaktionsgebet 2"
	},
	{
		key: "500",
		name: "Kollektionsgebet"
	}
],
	"es-es": [
	{
		key: "200",
		name: "Gachapn permanente"
	},
	{
		key: "100",
		name: "Gachapn de principiante"
	},
	{
		key: "301",
		name: "Gachapn promocional de personaje"
	},
	{
		key: "302",
		name: "Gachapn promocional de arma"
	},
	{
		key: "400",
		name: "Gachapn promocional de personaje 2"
	},
	{
		key: "500",
		name: "Gachapn recopilatorio"
	}
],
	"pt-pt": [
	{
		key: "200",
		name: "Orao Comum"
	},
	{
		key: "100",
		name: "Desejos de Novato"
	},
	{
		key: "301",
		name: "Orao do Evento do Personagem"
	},
	{
		key: "302",
		name: "Orao do Evento de Arma"
	},
	{
		key: "400",
		name: "Orao de Evento de Personagem - 2"
	},
	{
		key: "500",
		name: "Registro de Orao"
	}
],
	"ru-ru": [
	{
		key: "200",
		name: " "
	},
	{
		key: "100",
		name: " "
	},
	{
		key: "301",
		name: "  "
	},
	{
		key: "302",
		name: "  "
	},
	{
		key: "400",
		name: "   II"
	},
	{
		key: "500",
		name: " "
	}
],
	"ja-jp": [
	{
		key: "200",
		name: ""
	},
	{
		key: "100",
		name: ""
	},
	{
		key: "301",
		name: ""
	},
	{
		key: "302",
		name: ""
	},
	{
		key: "400",
		name: " 2"
	},
	{
		key: "500",
		name: ""
	}
],
	"ko-kr": [
	{
		key: "200",
		name: " "
	},
	{
		key: "100",
		name: " "
	},
	{
		key: "301",
		name: "  "
	},
	{
		key: "302",
		name: "  "
	},
	{
		key: "400",
		name: "  -2"
	},
	{
		key: "500",
		name: " "
	}
],
	"th-th": [
	{
		key: "200",
		name: ""
	},
	{
		key: "100",
		name: ""
	},
	{
		key: "301",
		name: ""
	},
	{
		key: "302",
		name: ""
	},
	{
		key: "400",
		name: " - 2"
	},
	{
		key: "500",
		name: ""
	}
],
	"vi-vn": [
	{
		key: "200",
		name: "Cu Nguyn Thng"
	},
	{
		key: "100",
		name: "Cu Nguyn Tn Th"
	},
	{
		key: "301",
		name: "Cu Nguyn Nhn Vt"
	},
	{
		key: "302",
		name: "Cu Nguyn V Kh"
	},
	{
		key: "400",
		name: "Cu Nguyn Nhn Vt-2"
	},
	{
		key: "500",
		name: "S K Cu Nguyn"
	}
],
	"id-id": [
	{
		key: "200",
		name: "Permohonan Standar"
	},
	{
		key: "100",
		name: "Permohonan Pemula"
	},
	{
		key: "301",
		name: "Event Permohonan Karakter"
	},
	{
		key: "302",
		name: "Event Permohonan Senjata"
	},
	{
		key: "400",
		name: "Event Permohonan Karakter - 2"
	},
	{
		key: "500",
		name: "Chronicled Wish"
	}
],
	"zh-cn": [
	{
		key: "200",
		name: ""
	},
	{
		key: "100",
		name: ""
	},
	{
		key: "301",
		name: ""
	},
	{
		key: "302",
		name: ""
	},
	{
		key: "400",
		name: "-2"
	},
	{
		key: "500",
		name: ""
	}
],
	"zh-tw": [
	{
		key: "200",
		name: ""
	},
	{
		key: "100",
		name: ""
	},
	{
		key: "301",
		name: ""
	},
	{
		key: "302",
		name: ""
	},
	{
		key: "400",
		name: "-2"
	},
	{
		key: "500",
		name: ""
	}
],
	"tr-tr": [
	{
		key: "200",
		name: "Kalc Dilek"
	},
	{
		key: "100",
		name: "Acemi Dilekleri"
	},
	{
		key: "301",
		name: "Karakter Etkinlii Dilei"
	},
	{
		key: "302",
		name: "Silah Etkinlii Dilei"
	},
	{
		key: "400",
		name: "Karakter Etkinlii Dilei-2"
	},
	{
		key: "500",
		name: "Nostaljik Dilek"
	}
],
	"it-it": [
	{
		key: "200",
		name: "Desiderio standard"
	},
	{
		key: "100",
		name: "Desideri per viaggiatori novizi"
	},
	{
		key: "301",
		name: "Desiderio evento personaggio"
	},
	{
		key: "302",
		name: "Desiderio evento arma"
	},
	{
		key: "400",
		name: "Desiderio evento personaggio 2"
	},
	{
		key: "500",
		name: "Desiderio delle cronache"
	}
]
};

const itemTypeNameMap = require$$0$1;
const order = ["301", "302", "200", "500", "100"];
function convertItemTypeMap(mapObject) {
  const convertedItemTypeMap = new Map();
  order.forEach((id) => {
    const itemType = mapObject.find((item) => {
      return item.key === id;
    });
    convertedItemTypeMap.set(itemType.key, itemType.name);
  });
  return convertedItemTypeMap;
}
gachaTypeMap.getItemTypeNameMap = function(language) {
  const lang = language.startsWith("zh-") || language.includes("-") ? language : Object.keys(itemTypeNameMap).find((key) => key.startsWith(language + "-"));
  return convertItemTypeMap(itemTypeNameMap[lang]);
};

var require$$0 = {
	"symbol.colon": "",
	"ui.button.load": "",
	"ui.button.update": "",
	"ui.button.directUpdate": "",
	"ui.button.excel": "Excel",
	"ui.button.url": "URL",
	"ui.button.setting": "",
	"ui.button.option": "",
	"ui.button.startProxy": "",
	"ui.button.solution": "",
	"ui.button.cacheFolder": "",
	"ui.button.copyUrl": "URL",
	"ui.select.newAccount": "",
	"ui.hint.newAccount": "",
	"ui.hint.init": "",
	"ui.hint.lastUpdate": "",
	"ui.hint.relaunchHint": "",
	"ui.hint.failed": "",
	"ui.win.title": "",
	"ui.data.total": "",
	"ui.data.times": "",
	"ui.data.sum": "",
	"ui.data.no5star": "5",
	"ui.data.character": "",
	"ui.data.weapon": "",
	"ui.data.star5": "5",
	"ui.data.star4": "4",
	"ui.data.star3": "3",
	"ui.data.history": "5",
	"ui.data.average": "5",
	"ui.data.chara5": "5",
	"ui.data.chara4": "4",
	"ui.data.weapon5": "5",
	"ui.data.weapon4": "4",
	"ui.data.weapon3": "3",
	"ui.setting.title": "",
	"ui.setting.language": "",
	"ui.setting.languageHint": "",
	"ui.setting.logType": "",
	"ui.setting.auto": "",
	"ui.setting.cnServer": "",
	"ui.setting.seaServer": "",
	"ui.setting.logTypeHint": "URL",
	"ui.setting.autoUpdate": "",
	"ui.setting.hideNovice": "",
	"ui.setting.proxyMode": "",
	"ui.setting.proxyModeHint": "URLURL",
	"ui.setting.fetchFullHistory": "",
	"ui.setting.fetchFullHistoryHint": "66",
	"ui.setting.closeProxy": "",
	"ui.setting.closeProxyHint": "",
	"ui.setting.UIGFHint": "/",
	"ui.setting.UIGFImportButton": "",
	"ui.setting.UIGFImportSuccessed": "",
	"ui.setting.UIGFLink": "",
	"ui.setting.UIGFLable": "/",
	"ui.setting.UIGFButton": "",
	"ui.setting.UIGFReadable": "",
	"ui.about.title": "",
	"ui.about.license": " MIT ",
	"ui.urlDialog.title": "URL",
	"ui.urlDialog.hint": "URL",
	"ui.urlDialog.placeholder": "URL",
	"ui.common.cancel": "",
	"ui.common.ok": "",
	"log.save.failed": "",
	"log.file.notFound": "",
	"log.url.notFound": "URL",
	"log.file.readFailed": "",
	"log.fetch.retry": "${name}${page}5${count}",
	"log.fetch.retryFailed": "${name}${page}",
	"log.fetch.interval": "${name}${page}101",
	"log.fetch.current": "${name}${page}",
	"log.fetch.authTimeout": "",
	"log.fetch.gachaType": "",
	"log.fetch.gachaTypeOk": "",
	"log.url.lackAuth": "URLauthkey",
	"log.proxy.hint": "[${ip}:${port}]URL",
	"log.url.notFound2": "URL",
	"log.url.incorrect": "URL",
	"log.autoUpdate.success": "",
	"excel.header.time": "",
	"excel.header.name": "",
	"excel.header.type": "",
	"excel.header.rank": "",
	"excel.header.total": "",
	"excel.header.pity": "",
	"excel.header.remark": "",
	"excel.wish2": "2",
	"excel.customFont": "",
	"excel.filePrefix": "",
	"excel.fileType": "Excel",
	"ui.extra.cacheClean": "1. \n2. \n3. Cache\n4. Cache_Data\n5. \n6. ",
	"ui.extra.findCacheFolder": "/Genshin Impact Game/YuanShen_Data/webCaches/Cache/",
	"ui.extra.urlCopied": "URL"
};

var require$$1 = {
	"symbol.colon": "",
	"ui.button.load": "",
	"ui.button.update": "",
	"ui.button.directUpdate": "",
	"ui.button.excel": " Excel",
	"ui.button.url": " URL",
	"ui.button.setting": "",
	"ui.button.option": "",
	"ui.button.startProxy": "Proxy ",
	"ui.button.solution": "",
	"ui.button.cacheFolder": "",
	"ui.select.newAccount": "",
	"ui.hint.newAccount": "",
	"ui.hint.init": "",
	"ui.hint.lastUpdate": "",
	"ui.hint.relaunchHint": "",
	"ui.hint.failed": "",
	"ui.win.title": "",
	"ui.data.total": "",
	"ui.data.times": "",
	"ui.data.sum": "",
	"ui.data.no5star": "5",
	"ui.data.character": "",
	"ui.data.weapon": "",
	"ui.data.star5": "5",
	"ui.data.star4": "4",
	"ui.data.star3": "3",
	"ui.data.history": "5",
	"ui.data.average": "5",
	"ui.data.chara5": "5",
	"ui.data.chara4": "4",
	"ui.data.weapon5": "5",
	"ui.data.weapon4": "4",
	"ui.data.weapon3": "3",
	"ui.setting.title": "",
	"ui.setting.language": "",
	"ui.setting.languageHint": "",
	"ui.setting.logType": "",
	"ui.setting.auto": "",
	"ui.setting.cnServer": "",
	"ui.setting.seaServer": "",
	"ui.setting.logTypeHint": " URL ",
	"ui.setting.autoUpdate": "",
	"ui.setting.hideNovice": "",
	"ui.setting.proxyMode": "Proxy ",
	"ui.setting.proxyModeHint": " Proxy  URL URL ",
	"ui.setting.fetchFullHistory": "",
	"ui.setting.fetchFullHistoryHint": " 6  6 ",
	"ui.setting.closeProxy": " Proxy",
	"ui.setting.closeProxyHint": " Proxy  Proxy ",
	"ui.about.title": "",
	"ui.about.license": " MIT ",
	"ui.urlDialog.title": " URL",
	"ui.urlDialog.hint": " URL ",
	"ui.urlDialog.placeholder": " URL",
	"ui.common.cancel": "",
	"ui.common.ok": "",
	"log.save.failed": "",
	"log.file.notFound": "",
	"log.url.notFound": " URL",
	"log.file.readFailed": "",
	"log.fetch.retry": "${name} ${page} 5  ${count} ",
	"log.fetch.retryFailed": "${name} ${page} ",
	"log.fetch.interval": "${name} ${page}  10  1 ",
	"log.fetch.current": "${name} ${page} ",
	"log.fetch.authTimeout": "",
	"log.fetch.gachaType": "",
	"log.fetch.gachaTypeOk": "",
	"log.url.lackAuth": "URL ",
	"log.proxy.hint": " Proxy  [${ip}:${port}]  URL",
	"log.url.notFound2": " URL",
	"log.url.incorrect": " URL ",
	"log.autoUpdate.success": "",
	"excel.header.time": "",
	"excel.header.name": "",
	"excel.header.type": "",
	"excel.header.rank": "",
	"excel.header.total": "",
	"excel.header.pity": "",
	"excel.header.remark": "",
	"excel.wish2": "-2",
	"excel.customFont": "",
	"excel.filePrefix": "",
	"excel.fileType": "Excel ",
	"ui.extra.cacheClean": "1. \n2. \n3. Cache\n4. Cache_Data\n5. \n6. ",
	"ui.extra.findCacheFolder": "/Genshin Impact Game/GenshinImpact_Data/webCaches/Cache/"
};

var require$$2 = {
	"symbol.colon": ": ",
	"ui.button.load": "Lade Daten",
	"ui.button.update": "Aktualisieren",
	"ui.button.excel": "In Excel exportieren",
	"ui.button.url": "Eingabe URL",
	"ui.button.setting": "Einstellungen",
	"ui.button.option": "Optionen",
	"ui.button.startProxy": "Proxy modus",
	"ui.select.newAccount": "Neuer Nutzer",
	"ui.hint.newAccount": "Daten von anderen Nutzern exportieren",
	"ui.hint.init": "Bitte ffne deinen Wunschlverlauf im Spiel bevor du versuchst deine Wunschdaten zu laden",
	"ui.hint.lastUpdate": "Letzte Aktualisierung",
	"ui.hint.failed": "Oops, irgendetwas ist schief gelaufen",
	"ui.win.title": "Genshin Wunsch Verlauf Exporter",
	"ui.data.total": "Total",
	"ui.data.times": "Wnsche",
	"ui.data.sum": "Angehuft",
	"ui.data.no5star": "Wnsche ohne 5 Sterne",
	"ui.data.character": "Character",
	"ui.data.weapon": "Waffe",
	"ui.data.star5": "5 Sterne",
	"ui.data.star4": "4 Sterne",
	"ui.data.star3": "3 Sterne",
	"ui.data.history": "5 Sterne verlauf",
	"ui.data.average": "Durschnittlicher 5 Sterne",
	"ui.data.chara5": "5 Sterne Character",
	"ui.data.chara4": "4 Sterne Character",
	"ui.data.weapon5": "5 Sterne Waffe",
	"ui.data.weapon4": "4 Sterne Waffe",
	"ui.data.weapon3": "3 Sterne Waffe",
	"ui.setting.title": "Einstellungen",
	"ui.setting.language": "Sprache",
	"ui.setting.languageHint": "Wenn eine bersetzung fehlt, wird Englisch als Standardsparche ausgewhlt.",
	"ui.setting.logType": "Aufzeichnungstyp",
	"ui.setting.auto": "Automatisch",
	"ui.setting.cnServer": "CN Server",
	"ui.setting.seaServer": "Globaler Server",
	"ui.setting.logTypeHint": "Whle aus, welche von dem Server generierten Aufzeichnungen benutzt werden sollen, wenn zum ersten mal die URL von den Spielaufzeichnungen erworben wird",
	"ui.setting.autoUpdate": "Automatische Aktualisierung",
	"ui.setting.proxyMode": "Proxy modus",
	"ui.setting.proxyModeHint": "Wenn das Erwerben der URL von den Systemaufzeichnungen scheitert, nutz den Systemproxy",
	"ui.setting.closeProxy": "Deaktiviere den Systemproxy",
	"ui.setting.closeProxyHint": "Wenn der Proxymodus aktiviert ist und das Programm abstrzt kann es zu unerwnschten Folgen fr dein System fhren. Du kannst diesen Knopf drcken, um die Systemproxy Einstellungen zurckzusetzen.",
	"ui.about.title": "ber uns",
	"ui.about.license": "Diese Software ist Open-Source und nutzt die MIT Lizenz.",
	"ui.urlDialog.title": "Gebe die URL manuell ein",
	"ui.urlDialog.hint": "Diese Funktion sollte nur benutzt werden, falls Sie wissen, welche URL hier bentigt wird",
	"ui.urlDialog.placeholder": "Bitte gebe die URL mit den Authentifizierungsinformationen ein",
	"ui.common.cancel": "Abbrechen",
	"ui.common.ok": "Weiter",
	"log.save.failed": "Lokale Daten konnten nicht gespeichert werden",
	"log.file.notFound": "Die Wunschaufzeichnungen konnten nicht gefunden werden, stelle sicher, dass du im Spiel deinen Wunschverlauf schon geffnet hast",
	"log.url.notFound": "Konnte die URL nicht finden",
	"log.file.readFailed": "Konnte die Aufzeichnungen nicht lesen",
	"log.fetch.retry": "Das Verarbeiten von ${name} auf Seite ${page} ist gescheitertversuche in 5 Sekunden erneut, zum ${count}. mal",
	"log.fetch.retryFailed": "Das Verarbeiten von ${name} auf Seite ${page} ist gescheitert, maximale Versuche wurden erreicht",
	"log.fetch.interval": "Verarbeite ${name} auf Seite ${page}1 Sekunde Timeout fr 10 Seiten",
	"log.fetch.current": "Verarbeite ${name} auf Seite ${page}",
	"log.fetch.authTimeout": "Die Nutzer Authentifizierung ist abgelaufen, bitte ffne im Spiel die Wunschaufzeichnungen erneut.",
	"log.fetch.gachaType": "Wunschtyp wird erworben, bitte warten",
	"log.fetch.gachaTypeOk": "Wunschtyp erworben",
	"log.url.lackAuth": "Der Authentifizierungsschlssel konnte in der URL nicht aufgefunden werden",
	"log.proxy.hint": "Nutze den Proxymodus [${ip}:${port}] um die URL zu erwerben, bitte ffne im Spiel die Wunschaufzeichnungen erneut.",
	"log.url.notFound2": "URL konnte nicht gefunden werden, bitte stelle sicher, dass du deinen Wunschverlauf schon einmal im Spiel geffnet hast",
	"log.url.incorrect": "URL Parameter konnten nicht erworben werden",
	"log.autoUpdate.success": "Die automatische aktualisierung war erfolgreich, bitte starten sie das Programm neu",
	"excel.header.time": "zeit",
	"excel.header.name": "name",
	"excel.header.type": "typ",
	"excel.header.rank": "seltenheit",
	"excel.header.total": "ingesammt",
	"excel.header.pity": "innerhalb von pity",
	"excel.header.remark": "bemerkung",
	"excel.wish2": "Wunsch 2",
	"excel.customFont": "Arial",
	"excel.filePrefix": "Genshin Wunsch Aufzeichner",
	"excel.fileType": "Excel Datei"
};

var require$$3 = {
	"symbol.colon": ": ",
	"ui.button.load": "Load data",
	"ui.button.update": "Update",
	"ui.button.directUpdate": "Direct update",
	"ui.button.excel": "Export Excel",
	"ui.button.url": "Input URL",
	"ui.button.setting": "Settings",
	"ui.button.option": "Option",
	"ui.button.startProxy": "Proxy mode",
	"ui.button.solution": "Solution",
	"ui.button.cacheFolder": "Open cache folder",
	"ui.button.copyUrl": "Copy URL",
	"ui.select.newAccount": "New account",
	"ui.hint.newAccount": "Export data from other accounts",
	"ui.hint.init": "Please open your wish history inside the game client before clicking on the 'Load data' button",
	"ui.hint.lastUpdate": "Last update",
	"ui.hint.failed": "Oops, something failed",
	"ui.hint.relaunchHint": "The update has been completed, it will take effect after clicking the button to restart the tool",
	"ui.win.title": "Genshin Wish History Exporter",
	"ui.data.total": "Total",
	"ui.data.times": "Pulls",
	"ui.data.sum": "Accumulated",
	"ui.data.no5star": "pulls without a 5 star",
	"ui.data.character": "Character",
	"ui.data.weapon": "Weapon",
	"ui.data.star5": "5 star",
	"ui.data.star4": "4 star",
	"ui.data.star3": "3 star",
	"ui.data.history": "5 star history",
	"ui.data.average": "5 star on average",
	"ui.data.chara5": "5 star character",
	"ui.data.chara4": "4 star character",
	"ui.data.weapon5": "5 star weapon",
	"ui.data.weapon4": "4 star weapon",
	"ui.data.weapon3": "3 star weapon",
	"ui.setting.title": "Settings",
	"ui.setting.language": "Language",
	"ui.setting.languageHint": "When the translation is missing, English will be displayed by default.",
	"ui.setting.logType": "Log type",
	"ui.setting.auto": "Auto",
	"ui.setting.cnServer": "CN server",
	"ui.setting.seaServer": "Global server",
	"ui.setting.logTypeHint": "Choose which server generated logs to be used first when acquiring URL from game logs",
	"ui.setting.autoUpdate": "Auto update",
	"ui.setting.hideNovice": "Hide novice wishes",
	"ui.setting.proxyMode": "Proxy mode",
	"ui.setting.proxyModeHint": "When we fail to get the URL from system logs, use the system proxy",
	"ui.setting.fetchFullHistory": "Get complete data",
	"ui.setting.fetchFullHistoryHint": "When this option is enabled, click the \"Update Data\" button to get all the card draw records within 6 months. When there are incorrect data within 6 months, this function can be used to repair.",
	"ui.setting.closeProxy": "Disable system proxy",
	"ui.setting.closeProxyHint": "When you choose proxy mode, if the program crashes it can cause unwanted results that may affect your system. You can click this button to clear the system proxy settings.",
	"ui.setting.UIGFHint": "This feature is used for importing/exporting data (the first export may take some time). Refer to this link for supported tools:",
	"ui.setting.UIGFImportButton": "Import data",
	"ui.setting.UIGFImportSuccessed": "Data has been imported",
	"ui.setting.UIGFLink": "Uniformed Interchangeable GachaLog Format Standard",
	"ui.setting.UIGFLable": "Import / Export",
	"ui.setting.UIGFButton": "Export data",
	"ui.setting.UIGFReadable": "Readable",
	"ui.about.title": "About",
	"ui.about.license": "This software is opensource using MIT license.",
	"ui.urlDialog.title": "Input URL manually",
	"ui.urlDialog.hint": "This function should only be used when you understand what URL is needed here",
	"ui.urlDialog.placeholder": "Please enter the URL with authentication information",
	"ui.common.cancel": "Cancel",
	"ui.common.ok": "OK",
	"log.save.failed": "Failed to save local data",
	"log.file.notFound": "Unable to find game logs, please make sure you already opened wish history inside the game client",
	"log.url.notFound": "Unable to find URL",
	"log.file.readFailed": "Failed to read logs",
	"log.fetch.retry": "Processing ${name} of page ${page} failedretrying in 5 seconds for the ${count} time",
	"log.fetch.retryFailed": "Processing ${name} of page ${page} failedretry times maxed out",
	"log.fetch.interval": "Processing ${name} of page ${page}1 second timeout every 10 pages",
	"log.fetch.current": "Processing ${name} of page ${page}",
	"log.fetch.authTimeout": "User authentication expired, please reopen wish history inside the game client.",
	"log.fetch.gachaType": "Getting wish type, please wait",
	"log.fetch.gachaTypeOk": "Wish type acquired",
	"log.url.lackAuth": "Authkey not found in URL",
	"log.proxy.hint": "Using proxy mode [${ip}:${port}] to get URLplease reopen wish history inside the game client.",
	"log.url.notFound2": "Unable to find URL, please make sure you already opened wish history inside the game client",
	"log.url.incorrect": "Unable to get URL parameters",
	"log.autoUpdate.success": "Auto update successfulplease restart the program",
	"excel.header.time": "time",
	"excel.header.name": "name",
	"excel.header.type": "type",
	"excel.header.rank": "rarity",
	"excel.header.total": "total",
	"excel.header.pity": "within pity",
	"excel.header.remark": "remark",
	"excel.wish2": "Wish 2",
	"excel.customFont": "Arial",
	"excel.filePrefix": "Genshin wish logger",
	"excel.fileType": "Excel file",
	"ui.extra.cacheClean": "1. Confirm whether the wish history in the game has been opened, and if the error \"User authentication expired\" still appears, try the following steps \n2. Close the game window of Genshin Impact \n3. Click the \"Open Web Cache Folder\" button above to open the \"Cache\" folder \n4. Delete the \"Cache_ Data\" folder \n5. Start the Genshin Impact game and open the wish history page in the game \n6. Close this dialog and click the \"Update Data\" button",
	"ui.extra.findCacheFolder": "If the \"Open cache folder\" button does not respond, you can manually find the game's web cache folder. The directory is \"Your game installation path/Genshin Impact Game/GenshinImpact_Data/webCaches/Cache/\"",
	"ui.extra.urlCopied": "URL Copied"
};

var require$$4 = {
	"symbol.colon": ": ",
	"ui.button.load": "Obtener datos",
	"ui.button.update": "Actualizar",
	"ui.button.excel": "Exportar a Excel",
	"ui.button.url": "Introducir URL",
	"ui.button.setting": "Ajustes",
	"ui.button.option": "Opciones",
	"ui.button.startProxy": "Modo proxy",
	"ui.select.newAccount": "Nueva cuenta",
	"ui.hint.newAccount": "Exportar datos de otras cuentas",
	"ui.hint.init": "Por favor, abre el historial de deseos en el juego antes de pulsar en el botn 'Obtener datos'.",
	"ui.hint.lastUpdate": "ltima actualizacin",
	"ui.hint.failed": "Ups, algo ha fallado",
	"ui.win.title": "Genshin Wish History Exporter",
	"ui.data.total": "Total",
	"ui.data.times": "tiradas",
	"ui.data.sum": "acumuladas.",
	"ui.data.no5star": "tiradas sin un 5 estrellas",
	"ui.data.character": "Personaje",
	"ui.data.weapon": "Arma",
	"ui.data.star5": "5 estrellas",
	"ui.data.star4": "4 estrellas",
	"ui.data.star3": "3 estrellas",
	"ui.data.history": "Historial de 5 estrellas",
	"ui.data.average": "Promedio de tiradas para un 5 estrellas",
	"ui.data.chara5": "Personaje 5 estrellas",
	"ui.data.chara4": "Personaje 4 estrellas",
	"ui.data.weapon5": "Arma 5 estrellas",
	"ui.data.weapon4": "Arma 4 estrellas",
	"ui.data.weapon3": "Arma 3 estrellas",
	"ui.setting.title": "Ajustes",
	"ui.setting.language": "Idiomas",
	"ui.setting.languageHint": "Si no se encuentra una traduccin se mostrar en ingls por defecto.",
	"ui.setting.logType": "Tipo de log",
	"ui.setting.auto": "Auto",
	"ui.setting.cnServer": "Servidor CN",
	"ui.setting.seaServer": "Servidor global",
	"ui.setting.logTypeHint": "Elige qu logs generados por el servidor se utilizarn primero al obtener la URL de los logs del juego.",
	"ui.setting.autoUpdate": "Actualizacin automtica",
	"ui.setting.proxyMode": "Modo proxy",
	"ui.setting.proxyModeHint": "Cuando no se pueda obtener la URL de los logs del sistema utiliza el modo proxy.",
	"ui.setting.closeProxy": "Desactivar proxy del sistema",
	"ui.setting.closeProxyHint": "Al seleccionar el modo proxy si el programa falla puede causar resultados no deseados que pueden afectar a tu sistema. Puede hacer click en este botn para borrar la configuracin del proxy del sistema.",
	"ui.about.title": "Acerca de Genshin Wish History Exporter",
	"ui.about.license": "Este software es opensource con licencia MIT.",
	"ui.urlDialog.title": "Introducir URL manualmente",
	"ui.urlDialog.hint": "Utiliza esta funcin solo si sabes qu URL se necesita introducir",
	"ui.urlDialog.placeholder": "Introduce la URL con la informacin de autenticacin",
	"ui.common.cancel": "Cancelar",
	"ui.common.ok": "OK",
	"log.save.failed": "Error al guardar datos locales",
	"log.file.notFound": "No se han podido encontrar los logs del juego, asegurate de que has abierto el historial de deseos dentro del juego.",
	"log.url.notFound": "No se ha podido encontrar la URL",
	"log.file.readFailed": "Error al leer los logs",
	"log.fetch.retry": "Error al procesar ${name} en la pgina ${page}. Reintentando en 5 segudos por ${count} vez",
	"log.fetch.retryFailed": "Error al procesar ${name} en la pgina ${page}alcanzado el nmero mximo de intentos",
	"log.fetch.interval": "Procesando ${name} en la pgina ${page}1 segundo de tiempo de espera cada 10 pginas",
	"log.fetch.current": "Procesando ${name} en la pgina ${page}",
	"log.fetch.authTimeout": "La autenticacin ha expirado, Abre de nuevo el historial de deseos en el juego.",
	"log.fetch.gachaType": "Obteniendo el tipo de deseo",
	"log.fetch.gachaTypeOk": "Tipo de deseo obtenido",
	"log.url.lackAuth": "No se encuentra la Authkey en la URL",
	"log.proxy.hint": "Usando modo proxy [${ip}:${port}] para obtener la URL, Abre de nuevo el historial de deseos en el juego.",
	"log.url.notFound2": "Error al obtener la URL, asegurate de que has abierto el historial de deseos dentro del juego.",
	"log.url.incorrect": "Error al obtener los parmetros de la URL",
	"log.autoUpdate.success": "Actualizado correctamente, reinicia el programa",
	"excel.header.time": "tiempo",
	"excel.header.name": "nombre",
	"excel.header.type": "tipo",
	"excel.header.rank": "rareza",
	"excel.header.total": "total",
	"excel.header.pity": "pity",
	"excel.customFont": "Arial",
	"excel.filePrefix": "Genshin wish logger",
	"excel.fileType": "Excel file"
};

var require$$5 = {
	"symbol.colon": " : ",
	"ui.button.load": "Charger les donnes",
	"ui.button.update": "Mettre  jour",
	"ui.button.directUpdate": "Mise  jour directe",
	"ui.button.excel": "Exporter vers Excel",
	"ui.button.url": "URL d'import",
	"ui.button.setting": "Paramtres",
	"ui.button.option": "Options",
	"ui.button.startProxy": "Mode Proxy",
	"ui.button.solution": "Solution",
	"ui.button.cacheFolder": "Ouvrir le dossier de cache",
	"ui.select.newAccount": "Nouveau compte",
	"ui.hint.newAccount": "Charger les donnes d'autres comptes",
	"ui.hint.init": "Veuillez ouvrir votre historique de vux depuis le client du jeu avant de cliquer sur le bouton 'Charger les donnes'.",
	"ui.hint.lastUpdate": "Dernire mise  jour",
	"ui.hint.failed": "Oups, une erreur est survenue...",
	"ui.hint.relaunchHint": "La mise  jour est termine, elle prendra effet aprs avoir cliqu sur le bouton permettant le redmarrage de l'outil",
	"ui.win.title": "Outil d'export de l'historique de vux de Genshin Impact",
	"ui.data.total": "Total de",
	"ui.data.times": "tirages.",
	"ui.data.sum": "Vous avez effectu",
	"ui.data.no5star": "tirages sans objet 5.",
	"ui.data.character": "Personnage",
	"ui.data.weapon": "Arme",
	"ui.data.star5": "5",
	"ui.data.star4": "4",
	"ui.data.star3": "3",
	"ui.data.history": "Historique de 5",
	"ui.data.average": "Moyenne de tirages d'objet 5",
	"ui.data.chara5": "Personnage 5",
	"ui.data.chara4": "Personnage 4",
	"ui.data.weapon5": "Arme 5",
	"ui.data.weapon4": "Arme 4",
	"ui.data.weapon3": "Arme 3",
	"ui.setting.title": "Paramtres",
	"ui.setting.language": "Langue",
	"ui.setting.languageHint": "L'anglais sera utilis par dfaut si la traduction slectionne n'est pas disponible.",
	"ui.setting.logType": "Type de journalisation",
	"ui.setting.auto": "Automatique",
	"ui.setting.cnServer": "Serveur Chinois",
	"ui.setting.seaServer": "Serveur Global",
	"ui.setting.logTypeHint": "Choisissez les journaux gnrs par le serveur  utiliser en priorit lors de la rcupration de l'URL  partir des journaux du jeu.",
	"ui.setting.autoUpdate": "Mise  jour automatique",
	"ui.setting.hideNovice": "Masquer les vux du dbutant",
	"ui.setting.proxyMode": "Mode Proxy",
	"ui.setting.proxyModeHint": "Si la rcupration de l'URL depuis les journaux systme choue, utilisez le proxy systme.",
	"ui.setting.fetchFullHistory": "Rcuprer l'intgralit des donnes",
	"ui.setting.fetchFullHistoryHint": "Lorsque cette option est active, cliquez sur le bouton \"Mettre  jour les donnes\" pour rcuprer tous les enregistrements des tirages des 6 derniers mois. Cette fonction peut tre utilise si des erreurs figurent dans les donnes des 6 derniers mois.",
	"ui.setting.closeProxy": "Dsactiver le proxy systme",
	"ui.setting.closeProxyHint": "Si le programme se bloque lorsque vous choisissez le mode proxy, des rsultats indsirables susceptibles d'affecter votre systme peuvent survenir. Vous pouvez cliquer sur ce bouton pour rinitialiser les paramtres du proxy systme.",
	"ui.about.title": " propos",
	"ui.about.license": "Ce logiciel est open source et sous licence MIT.",
	"ui.urlDialog.title": "Saisir l'URL d'import manuellement",
	"ui.urlDialog.hint": "Cette fonctionnalit ne doit tre utilise que lorsque vous savez quel type d'URL est ncessaire ici.",
	"ui.urlDialog.placeholder": "Veuillez saisir l'URL avec les informations d'authentification.",
	"ui.common.cancel": "Annuler",
	"ui.common.ok": "OK",
	"log.save.failed": "chec de la sauvegarde des donnes locales.",
	"log.file.notFound": "Les journaux du jeu sont introuvables, veuillez vous assurer que vous avez dj ouvert l'historique de vux dans le client du jeu.",
	"log.url.notFound": "URL introuvable.",
	"log.file.readFailed": "chec de la lecture des journaux.",
	"log.fetch.retry": "chec de la rcupration des ${name} - page ${page}, nouvelle tentative dans 5 secondes pour la ${count}e fois",
	"log.fetch.retryFailed": "chec de la rcupration des ${name} - page ${page}, nombre de tentatives maximum atteint.",
	"log.fetch.interval": "Rcupration des ${name} - page ${page}, dlai de 1 seconde toutes les 10 pages",
	"log.fetch.current": "Rcupration des ${name} - page ${page}.",
	"log.fetch.authTimeout": "L'authentification de l'utilisateur a expir, veuillez rouvrir l'historique des vux dans le client du jeu.",
	"log.fetch.gachaType": "Rcupration du type de vux, veuillez patienter.",
	"log.fetch.gachaTypeOk": "Le type de vux a t rcupr.",
	"log.url.lackAuth": "Cl d'authentification introuvable dans l'URL.",
	"log.proxy.hint": "Utilisation du mode proxy [${ip}:${port}] pour obtenir l'URL, veuillez rouvrir l'historique des vux dans le client du jeu.",
	"log.url.notFound2": "URL introuvable, veuillez vous assurer que vous avez dj ouvert l'historique de vux dans le client du jeu.",
	"log.url.incorrect": "Impossible d'obtenir les paramtres d'URL.",
	"log.autoUpdate.success": "Mise  jour automatique russie, veuillez redmarrer le programme.",
	"excel.header.time": "Date",
	"excel.header.name": "Nom",
	"excel.header.type": "Type",
	"excel.header.rank": "Raret",
	"excel.header.total": "Tirages",
	"excel.header.pity": "Pity 5",
	"excel.header.remark": "Commentaire",
	"excel.wish2": "Vux 2",
	"excel.customFont": "Arial",
	"excel.filePrefix": "GenshinImpact_historique_voeux",
	"excel.fileType": "Classeur Excel",
	"ui.extra.cacheClean": "1. Confirmez si l'historique des vux dans le jeu a t ouvert et si l'erreur \"Authentification utilisateur expire\" apparat toujours, essayez les tapes suivantes \n2. Fermez la fentre de jeu de Genshin Impact \n3. Cliquez sur le bouton \"Ouvrir le dossier de cache Web\" ci-dessus pour ouvrir le dossier \"Cache\" \n4. Supprimez le dossier \"Cache_Data\" \n5. Dmarrez le jeu Genshin Impact et ouvrez la page d'historique des vux dans le jeu \n6. Fermez cette bote de dialogue et cliquez sur le bouton \"Mettre  jour les donnes\"",
	"ui.extra.findCacheFolder": "Si le bouton \"Ouvrir le dossier de cache\" ne rpond pas, vous pouvez rechercher manuellement le dossier cache web du jeu. Le rpertoire est \"Chemin d'installation de votre jeu/Genshin Impact Game/GenshinImpact_Data/webCaches/Cache/\""
};

var require$$6$1 = {
	"symbol.colon": ": ",
	"ui.button.load": "Muat data",
	"ui.button.update": "Perbarui",
	"ui.button.excel": "Ekspor Excel",
	"ui.button.url": "Masukkan URL",
	"ui.button.setting": "Pengaturan",
	"ui.button.option": "Pilihan",
	"ui.button.startProxy": "Mode proksi",
	"ui.select.newAccount": "Akun baru",
	"ui.hint.newAccount": "Ekspor data dari akun lain",
	"ui.hint.init": "Silakan buka riwayat permohonan anda di dalam klien permainan sebelum klik pada tombol 'Muat data' ",
	"ui.hint.lastUpdate": "Terakhir diperbarui",
	"ui.hint.failed": "Aduhh, tampaknya gagal",
	"ui.win.title": "Genshin Expor Catatan Permohonan",
	"ui.data.total": "Total",
	"ui.data.times": "Pulls",
	"ui.data.sum": "Akumulasi",
	"ui.data.no5star": "pulls tanpa  5",
	"ui.data.character": "Karakter",
	"ui.data.weapon": " 5",
	"ui.data.star4": " 4",
	"ui.data.star3": " 3",
	"ui.data.history": "Riwayat  5",
	"ui.data.average": " 5 dalam rata - rata",
	"ui.data.chara5": " 5 karakter",
	"ui.data.chara4": " 4 karakter",
	"ui.data.weapon5": " 5 senjata",
	"ui.data.weapon4": " 4 senjata",
	"ui.data.weapon3": " 3 senjata",
	"ui.setting.title": "Pengatuan",
	"ui.setting.language": "Bahasa",
	"ui.setting.languageHint": "Jika terjemahan hilang, Bahasa Inggris akan ditampilkan secara default.",
	"ui.setting.logType": "Tipe catatan",
	"ui.setting.auto": "Auto",
	"ui.setting.cnServer": "Server China",
	"ui.setting.seaServer": "Server Global",
	"ui.setting.logTypeHint": "Pilih catatan yang dihasilkan dari server mana yang akan digunakan pertama kali saat memperoleh URL di dalam catatan permainan",
	"ui.setting.autoUpdate": "Automatis perbarui",
	"ui.setting.proxyMode": "Mode proksi",
	"ui.setting.proxyModeHint": "Ketika kita gagal mengambil URL dari catatan sistem, gunakan proksi sistem",
	"ui.setting.closeProxy": "Matikan sistem proksi",
	"ui.setting.closeProxyHint": "Ketika anda memilih mode proksi, jika program macet dapat menyebabkan hasil yang tidak diinginkan yang dapat mempengaruhi sistem anda. Anda dapat klik tombol ini untuk menghapus pengaturan sistem proksi.",
	"ui.about.title": "Tentang",
	"ui.about.license": "Perangkat lunak ini opensource menggunakan lisensi MIT.",
	"ui.urlDialog.title": "Masukkan URL secara manual",
	"ui.urlDialog.hint": "Fungsi ini hanya boleh digunakan jika anda memahami URL apa yang dibutuhkan di sini",
	"ui.urlDialog.placeholder": "Silakan masukkan URL dengan informasi autentikasi",
	"ui.common.cancel": "Batalkan",
	"ui.common.ok": "OK",
	"log.save.failed": "Gagal untuk menyimpan data lokal",
	"log.file.notFound": "Tidak bisa menemukan catatan permainan, pastikan anda telah membuka riwayat permohonan di dalam klien permainan",
	"log.url.notFound": "Tidak dapat menemukan URL",
	"log.file.readFailed": "Gagal membaca catatan",
	"log.fetch.retry": "Proses ${name} dari halaman $ {page} gagal, mencoba lagi dalam 5 detik untuk waktu ${count} ",
	"log.fetch.retryFailed": "Proses ${name} dari halaman $ {page} gagal, waktu coba lagi telah mencapai batas maksimum",
	"log.fetch.interval": "Proses ${name} dari halaman ${page} waktu tunggu 1 detik setiap 10 halaman ",
	"log.fetch.current": "Proses ${name} dari halaman $ {page}",
	"log.fetch.authTimeout": "Autentikasi pengguna kedaluwarsa, buka kembali riwayat permohonan di dalam klien permainan.",
	"log.fetch.gachaType": "Sedang mengambil tipe permohonan, silahkan tunggu",
	"log.fetch.gachaTypeOk": "Jenis permohonan diperoleh",
	"log.url.lackAuth": "Authkey tidak ditemukan di URL",
	"log.proxy.hint": "Menggunakan mode proksi [${ip}:${port}] untuk mendapatkan URL, buka kembali riwayat permohonan di dalam klien permainan.",
	"log.url.notFound2": "Tidak dapat menemukan URL, pastikan Anda telah membuka riwayat permohonan di dalam klien permainan",
	"log.url.incorrect": "Tidak bisa mendapatkan parameter URL",
	"log.autoUpdate.success": "Pembaruan otomatis berhasil, mulai ulang program",
	"excel.header.time": "waktu",
	"excel.header.name": "nama",
	"excel.header.type": "tipe",
	"excel.header.rank": "rarity",
	"excel.header.total": "total",
	"excel.header.pity": "dengan pity",
	"excel.customFont": "Arial",
	"excel.filePrefix": "GenshinImpact_catatan_permohonan",
	"excel.fileType": "Excel file"
};

var require$$7$1 = {
	"symbol.colon": "",
	"ui.button.load": "",
	"ui.button.update": "",
	"ui.button.excel": "Excel",
	"ui.button.url": "URL",
	"ui.button.setting": "",
	"ui.button.option": "",
	"ui.button.startProxy": "",
	"ui.select.newAccount": "",
	"ui.hint.newAccount": " ",
	"ui.hint.init": " ",
	"ui.hint.lastUpdate": "",
	"ui.hint.failed": "",
	"ui.win.title": "",
	"ui.data.total": "",
	"ui.data.times": "",
	"ui.data.sum": "",
	"ui.data.no5star": "5",
	"ui.data.character": "",
	"ui.data.weapon": "",
	"ui.data.star5": "5",
	"ui.data.star4": "4",
	"ui.data.star3": "3",
	"ui.data.history": "5",
	"ui.data.average": "5",
	"ui.data.chara5": "5",
	"ui.data.chara4": "4",
	"ui.data.weapon5": "5",
	"ui.data.weapon4": "4",
	"ui.data.weapon3": "3",
	"ui.setting.title": "",
	"ui.setting.language": "",
	"ui.setting.languageHint": "",
	"ui.setting.logType": "",
	"ui.setting.auto": "",
	"ui.setting.cnServer": "",
	"ui.setting.seaServer": "",
	"ui.setting.logTypeHint": "URL",
	"ui.setting.autoUpdate": "",
	"ui.setting.proxyMode": "",
	"ui.setting.proxyModeHint": "URLURL",
	"ui.setting.closeProxy": "",
	"ui.setting.closeProxyHint": "",
	"ui.about.title": "About",
	"ui.about.license": "MIT",
	"ui.urlDialog.title": "URL",
	"ui.urlDialog.hint": "URL",
	"ui.urlDialog.placeholder": "authkeyURL",
	"ui.common.cancel": "",
	"ui.common.ok": "",
	"log.save.failed": "",
	"log.file.notFound": "",
	"log.url.notFound": "URL",
	"log.file.readFailed": "",
	"log.fetch.retry": "${name}${page}5${count}...",
	"log.fetch.retryFailed": "${name}${page}",
	"log.fetch.interval": "${name}${page}101...",
	"log.fetch.current": "${name}${page}",
	"log.fetch.authTimeout": "authkey",
	"log.fetch.gachaType": "",
	"log.fetch.gachaTypeOk": "",
	"log.url.lackAuth": "URLauthkey",
	"log.proxy.hint": "URL[${ip}:${port}]",
	"log.url.notFound2": "URL",
	"log.url.incorrect": "URL",
	"log.autoUpdate.success": "",
	"excel.header.time": "",
	"excel.header.name": "",
	"excel.header.type": "",
	"excel.header.rank": "",
	"excel.header.total": "",
	"excel.header.pity": "",
	"excel.customFont": "",
	"excel.filePrefix": "",
	"excel.fileType": "Excel"
};

var require$$8 = {
	"symbol.colon": ": ",
	"ui.button.load": " ",
	"ui.button.update": "",
	"ui.button.excel": " ",
	"ui.button.url": "URL ",
	"ui.button.setting": "",
	"ui.button.option": "",
	"ui.button.startProxy": " ",
	"ui.select.newAccount": " ",
	"ui.hint.newAccount": "   ",
	"ui.hint.init": "' '         .",
	"ui.hint.lastUpdate": " ",
	"ui.hint.failed": ",  ",
	"ui.win.title": "Genshin Wish History Exporter",
	"ui.data.total": "",
	"ui.data.times": "",
	"ui.data.sum": "",
	"ui.data.no5star": "(: 90)",
	"ui.data.character": "",
	"ui.data.weapon": "",
	"ui.data.star5": "5",
	"ui.data.star4": "4",
	"ui.data.star3": "3",
	"ui.data.history": "5 ",
	"ui.data.average": "5  ",
	"ui.data.chara5": "5 ",
	"ui.data.chara4": "4 ",
	"ui.data.weapon5": "5 ",
	"ui.data.weapon4": "4 ",
	"ui.data.weapon3": "3 ",
	"ui.setting.title": "",
	"ui.setting.language": "",
	"ui.setting.languageHint": "    ..",
	"ui.setting.logType": " ",
	"ui.setting.auto": "",
	"ui.setting.cnServer": " ",
	"ui.setting.seaServer": " ",
	"ui.setting.logTypeHint": "  URL        ",
	"ui.setting.autoUpdate": " ",
	"ui.setting.proxyMode": " ",
	"ui.setting.proxyModeHint": "  URL      .",
	"ui.setting.closeProxy": "    ",
	"ui.setting.closeProxyHint": "                .         .",
	"ui.about.title": "About",
	"ui.about.license": "This software is opensource using MIT license.",
	"ui.urlDialog.title": " URL ",
	"ui.urlDialog.hint": "    URL     .",
	"ui.urlDialog.placeholder": "   URL .",
	"ui.common.cancel": "Cancel",
	"ui.common.ok": "OK",
	"log.save.failed": "   ",
	"log.file.notFound": "    .       .",
	"log.url.notFound": "URL   .",
	"log.file.readFailed": "  ",
	"log.fetch.retry": "${name} ${page}   5  ${count} ",
	"log.fetch.retryFailed": "${name} ${page}      ",
	"log.fetch.interval": "${name} ${page}  10  1  ",
	"log.fetch.current": "${name} ${page}  ",
	"log.fetch.authTimeout": "  .       .",
	"log.fetch.gachaType": "   .   .",
	"log.fetch.gachaTypeOk": "   ",
	"log.url.lackAuth": "URL     .",
	"log.proxy.hint": "   [${ip}:${port}] URL       .",
	"log.url.notFound2": "URL   .       .",
	"log.url.incorrect": "URL     .",
	"log.autoUpdate.success": "    .",
	"excel.header.time": "",
	"excel.header.name": "",
	"excel.header.type": "",
	"excel.header.rank": "",
	"excel.header.total": "  ",
	"excel.header.pity": "(: 90)",
	"excel.customFont": "Arial",
	"excel.filePrefix": "Genshin wish logger",
	"excel.fileType": "Excel file"
};

var require$$9 = {
	"symbol.colon": ": ",
	"ui.button.load": "Carregar dados",
	"ui.button.update": "Atualizar",
	"ui.button.excel": "Exportar Planilha",
	"ui.button.setting": "Configuraes",
	"ui.select.newAccount": "Nova conta",
	"ui.hint.newAccount": "Exportar dados de outras contas",
	"ui.hint.init": "Abra o Histrico de Desejos dentro do jogo antes de clicar no boto 'Carregar dados'",
	"ui.hint.lastUpdate": "ltima atualizao",
	"ui.hint.failed": "Ops falha inesperada!",
	"ui.win.title": "Genshin Wish History Exporter",
	"ui.data.total": "Total",
	"ui.data.times": "Desejos",
	"ui.data.sum": "Acumulados",
	"ui.data.no5star": "Desejos sem 5 estrelas",
	"ui.data.character": "Personagem",
	"ui.data.weapon": "Arma",
	"ui.data.star5": "5 estrelas",
	"ui.data.star4": "4 estrelas",
	"ui.data.star3": "3 estrelas",
	"ui.data.history": "Histrico 5 estrelas",
	"ui.data.average": "Mdia 5 estrelas",
	"ui.data.chara5": "Personagem 5 estrelas",
	"ui.data.chara4": "Personagem 4 estrelas",
	"ui.data.weapon5": "Arma 5 estrelas",
	"ui.data.weapon4": "Arma 4 estrelas",
	"ui.data.weapon3": "Arma 3 estrelas",
	"ui.setting.title": "Configuraes",
	"ui.setting.language": "Idioma",
	"ui.setting.languageHint": "Caso uma traduo esteja faltando, por padro  exibido o idioma Ingls.",
	"ui.setting.logType": "Tipo de registro",
	"ui.setting.auto": "Auto",
	"ui.setting.cnServer": "Servidor CN",
	"ui.setting.seaServer": "Servidor Global",
	"ui.setting.logTypeHint": "Selecione o servidor em que sero gerados os registros ao adquirir a URL dos registros dentro do jogo.",
	"ui.setting.autoUpdate": "Atualizar automticamente",
	"ui.setting.proxyMode": "Modo Proxy",
	"ui.setting.proxyModeHint": "Caso no seja possvel obter a URL registros do sistema, use o proxy do sistema.",
	"ui.setting.closeProxy": "Desativar proxy do sistema",
	"ui.setting.closeProxyHint": "Ao escolher o modo proxy, caso o programa pare de funcionar possa ser que ocorra resultados indesejados que afetem o seu sistema. Caso isso acontea, clique neste boto para limpar as configuraes de proxy do sistema.",
	"ui.about.title": "Sobre",
	"ui.about.license": "Este  um software de cdigo aberto usando licena MIT.",
	"log.save.failed": "Falha ao salvar dados",
	"log.file.notFound": "No foi possvel encontrar registros do jogo, tenha certeza de ter aberto o Histrico de Desejos dentro do jogo",
	"log.url.notFound": "No foi possvel encontrar a URL",
	"log.file.readFailed": "Falha ao ler registros",
	"log.fetch.retry": "Processando ${name} da pgina ${page} falhoutentando novamente em 5 segundos pela ${count} vez",
	"log.fetch.retryFailed": "Processando ${name} da pgina ${page} falhou, nmero de tentativas atingiu o limite",
	"log.fetch.interval": "Processando ${name} da pgina ${page}intervalo de 1 segundo a cada 10 pginas",
	"log.fetch.current": "Processando ${name} da pgina ${page}",
	"log.fetch.authTimeout": "Autenticao do usurio expirou, reabra novamente o Histrico de Desejos em seu jogo.",
	"log.fetch.gachaType": "Carregando tipo de Desejo, aguarde.",
	"log.fetch.gachaTypeOk": "Tipo de Desejo adquirido",
	"log.url.lackAuth": "Chave-acesso no encontrada na URL",
	"log.proxy.hint": "Usando modo proxy [${ip}:${port}] para conseguir a URL, reabra novamente o Histrico de Desejos em seu jogo.",
	"log.url.notFound2": "No foi possvel encontrar a URL, tenha certeza de ter aberto o Histrico de Desejos dentro do jogo",
	"log.url.incorrect": "No foi possvel conseguir os parametros de URL",
	"log.autoUpdate.success": "Atualizao automtica bem-sucedida, por gentiliza reabra o programa",
	"excel.header.time": "DATA/HORRIO",
	"excel.header.name": "NOME",
	"excel.header.type": "TIPO",
	"excel.header.rank": "RARIDADE",
	"excel.header.total": "TOTAL",
	"excel.header.pity": "DENTRO DO PITY",
	"excel.customFont": "Arial",
	"excel.filePrefix": "Genshin historico desejos",
	"excel.fileType": "Excel file"
};

var require$$10$1 = {
	"symbol.colon": ": ",
	"ui.button.load": " ",
	"ui.button.update": " ",
	"ui.button.directUpdate": " ",
	"ui.button.excel": "  Excel",
	"ui.button.url": " URL",
	"ui.button.setting": "",
	"ui.button.option": "",
	"ui.button.startProxy": " ",
	"ui.button.solution": "",
	"ui.button.cacheFolder": "  ",
	"ui.button.copyUrl": " URL",
	"ui.select.newAccount": " ",
	"ui.hint.newAccount": "     ",
	"ui.hint.init": ",       ,     ' '",
	"ui.hint.lastUpdate": " ",
	"ui.hint.failed": ", -   ..",
	"ui.hint.relaunchHint": " ,       ",
	"ui.win.title": "  ",
	"ui.data.total": "",
	"ui.data.times": "",
	"ui.data.sum": "",
	"ui.data.no5star": "   5*",
	"ui.data.character": "",
	"ui.data.weapon": "",
	"ui.data.star5": "5 ",
	"ui.data.star4": "4 ",
	"ui.data.star3": "3 ",
	"ui.data.history": " 5* ",
	"ui.data.average": "   5*",
	"ui.data.chara5": "5* ",
	"ui.data.chara4": "4* ",
	"ui.data.weapon5": "5* ",
	"ui.data.weapon4": "4* ",
	"ui.data.weapon3": "3* ",
	"ui.setting.title": "",
	"ui.setting.language": "",
	"ui.setting.languageHint": "  ,       .",
	"ui.setting.logType": " ",
	"ui.setting.auto": "",
	"ui.setting.cnServer": "CN ",
	"ui.setting.seaServer": " ",
	"ui.setting.logTypeHint": ",     ,        URL   .",
	"ui.setting.autoUpdate": " ",
	"ui.setting.hideNovice": "  ",
	"ui.setting.proxyMode": "-",
	"ui.setting.proxyModeHint": "     URL   ,   .",
	"ui.setting.UIGFHint": "           , (      ).",
	"ui.setting.UIGFLink": "Uniformed Interchangeable GachaLog Format Standard",
	"ui.setting.UIGFLable": "  ",
	"ui.setting.UIGFButton": " JSON ",
	"ui.setting.UIGFReadable": "",
	"ui.setting.closeProxy": "  ",
	"ui.setting.closeProxyHint": "      -,    ,   .",
	"ui.setting.fetchFullHistory": "  ",
	"ui.setting.fetchFullHistoryHint": "   ,   \" \"         6 .",
	"ui.about.title": " ",
	"ui.about.license": "      ,  MIT-.",
	"ui.urlDialog.title": " URL ",
	"ui.urlDialog.hint": "         URL  ",
	"ui.urlDialog.placeholder": ",  URL   ",
	"ui.common.cancel": "",
	"ui.common.ok": "",
	"log.save.failed": "    .",
	"log.file.notFound": "  - .  ,        .",
	"log.url.notFound": "  URL",
	"log.file.readFailed": "   ",
	"log.fetch.retry": " ${name}  ${page} ,   5   ${count} ...",
	"log.fetch.retryFailed": " ${name}  ${page} ,     .",
	"log.fetch.interval": " ${name}  ${page},1  -   10 ...",
	"log.fetch.current": " ${name}  ${page}",
	"log.fetch.authTimeout": "  . ,      .",
	"log.fetch.gachaType": "  . , ...",
	"log.fetch.gachaTypeOk": "  ",
	"log.url.lackAuth": "     URL",
	"log.proxy.hint": " - [${ip}:${port}]   URL,      .",
	"log.url.notFound2": "  URL.  ,        .",
	"log.url.incorrect": "   URL-",
	"log.autoUpdate.success": "   .   .",
	"excel.header.time": "",
	"excel.header.name": "",
	"excel.header.type": "",
	"excel.header.rank": "",
	"excel.header.total": "",
	"excel.header.pity": "   5*",
	"excel.header.remark": "",
	"excel.wish2": " 2",
	"excel.customFont": "Times New Roman",
	"excel.filePrefix": "  ",
	"excel.fileType": "Excel file",
	"ui.extra.cacheClean": "1. ,      ,    \"    \"   ,   . \n2.  Genshin Impact.  \n3.   \"  -\" ,    \"\". \n4.    \"Cache_Data\". \n5.  Genshin Impact       . \n6.       \" \".",
	"ui.extra.findCacheFolder": "  \"  \"  ,      - . : \" /Genshin Impact Game/GenshinImpact_Data/webCaches/Cache/\",",
	"ui.extra.urlCopied": "URL "
};

var require$$11$1 = {
	"symbol.colon": ": ",
	"ui.button.load": "",
	"ui.button.update": "",
	"ui.button.directUpdate": "",
	"ui.button.excel": " Excel",
	"ui.button.url": " URL",
	"ui.button.setting": "",
	"ui.button.option": "",
	"ui.button.startProxy": " Proxy",
	"ui.select.newAccount": "",
	"ui.hint.newAccount": "",
	"ui.hint.init": " ''",
	"ui.hint.lastUpdate": "",
	"ui.hint.failed": "? ",
	"ui.win.title": "Genshin Wish History Exporter",
	"ui.data.total": "",
	"ui.data.times": "",
	"ui.data.sum": "",
	"ui.data.no5star": " 5 ",
	"ui.data.character": "",
	"ui.data.weapon": "",
	"ui.data.star5": "5 ",
	"ui.data.star4": "4 ",
	"ui.data.star3": "3 ",
	"ui.data.history": " 5 ",
	"ui.data.average": " 5 ",
	"ui.data.chara5": " 5 ",
	"ui.data.chara4": " 4 ",
	"ui.data.weapon5": " 5 ",
	"ui.data.weapon4": " 4 ",
	"ui.data.weapon3": " 3 ",
	"ui.setting.title": "",
	"ui.setting.language": "",
	"ui.setting.languageHint": " ",
	"ui.setting.logType": " Log",
	"ui.setting.auto": "",
	"ui.setting.cnServer": " (CN)",
	"ui.setting.seaServer": " (Global)",
	"ui.setting.logTypeHint": " Log ",
	"ui.setting.autoUpdate": "",
	"ui.setting.proxyMode": "",
	"ui.setting.proxyModeHint": " URL  ",
	"ui.setting.closeProxy": "",
	"ui.setting.closeProxyHint": "   ",
	"ui.setting.fetchFullHistory": "",
	"ui.setting.fetchFullHistoryHint": "  \"\"  6   6  ",
	"ui.about.title": "",
	"ui.about.license": " Open Source  MIT",
	"ui.urlDialog.title": " URL ",
	"ui.urlDialog.hint": " URL ",
	"ui.urlDialog.placeholder": " URL ",
	"ui.common.cancel": "",
	"ui.common.ok": "",
	"log.save.failed": "",
	"log.file.notFound": " Log , ",
	"log.url.notFound": " URL",
	"log.file.readFailed": "",
	"log.fetch.retry": " ${name}  ${page}   5  ${count}",
	"log.fetch.retryFailed": " ${name}  ${page}  ",
	"log.fetch.interval": " ${name}  ${page}   1  10 ",
	"log.fetch.current": " ${name}  ${page}",
	"log.fetch.authTimeout": " ",
	"log.fetch.gachaType": "",
	"log.fetch.gachaTypeOk": "",
	"log.url.lackAuth": "",
	"log.proxy.hint": " [${ip}:${port}]  ",
	"log.url.notFound2": " URL  ",
	"log.url.incorrect": "",
	"log.autoUpdate.success": "",
	"excel.header.time": "",
	"excel.header.name": "",
	"excel.header.type": "",
	"excel.header.rank": "",
	"excel.header.total": "",
	"excel.header.pity": "",
	"excel.customFont": "Arial",
	"excel.filePrefix": "Genshin wish logger",
	"excel.fileType": " Excel"
};

var require$$12$1 = {
	"symbol.colon": ": ",
	"ui.button.load": "Ti d liu",
	"ui.button.update": "Cp nht",
	"ui.button.excel": "Xut tp tin Excel",
	"ui.button.url": "Nhp URL",
	"ui.button.setting": "Ci t",
	"ui.button.option": "Ty chn",
	"ui.button.startProxy": "Ch  Proxy",
	"ui.select.newAccount": "Chn ti khon",
	"ui.hint.newAccount": "Xut d liu t ti khon khc",
	"ui.hint.init": "Vui lng m lch s cu nguyn ca bn bn trong tr chi trc khi nhp vo nt 'Ti d liu'",
	"ui.hint.lastUpdate": "Ln cp nht cui",
	"ui.hint.failed": "Rt tic,  xy ra li",
	"ui.win.title": "Genshin Gacha Export",
	"ui.data.total": "Tng cng",
	"ui.data.times": "ln.",
	"ui.data.sum": " tch lu",
	"ui.data.no5star": "ln cha ra 5 sao",
	"ui.data.character": "Nhn vt",
	"ui.data.weapon": "V kh",
	"ui.data.star5": "5 sao",
	"ui.data.star4": "4 sao",
	"ui.data.star3": "3 sao",
	"ui.data.history": "Lch s 5 sao",
	"ui.data.average": "T l 5 sao trung bnh",
	"ui.data.chara5": "Nhn vt 5 sao",
	"ui.data.chara4": "Nhn vt 4 sao",
	"ui.data.weapon5": "V kh 5 sao",
	"ui.data.weapon4": "V kh 4 sao",
	"ui.data.weapon3": "V kh 3 sao",
	"ui.setting.title": "Ci t",
	"ui.setting.language": "Ngn ng",
	"ui.setting.languageHint": "Khi bn dch b thiu, ting Anh s c hin th theo mc nh.",
	"ui.setting.logType": "Loi nht k",
	"ui.setting.auto": "T ng",
	"ui.setting.cnServer": "My ch Trung Quc",
	"ui.setting.seaServer": "My ch ton cu",
	"ui.setting.logTypeHint": "Chn nht k do my ch to s c s dng u tin khi ly URL t nht k tr chi",
	"ui.setting.autoUpdate": "T ng cp nht",
	"ui.setting.proxyMode": "Ch  Proxy",
	"ui.setting.proxyModeHint": "Khi chng ti khng ly c URL t nht k h thng, hy s dng proxy h thng",
	"ui.setting.closeProxy": "Tt proxy h thng",
	"ui.setting.closeProxyHint": "Khi bn chn ch  proxy, nu chng trnh b treo, n c th gy ra cc kt qu khng mong mun c th nh hng n h thng ca bn. Bn c th nhp vo nt ny  tt ci t proxy h thng.",
	"ui.about.title": "V tc gi",
	"ui.about.license": "Phn mm ny l m ngun m s dng giy php MIT.",
	"ui.urlDialog.title": "Nhp URL th cng",
	"ui.urlDialog.hint": "Chc nng ny ch nn c s dng khi bn hiu URL no l cn thit  y",
	"ui.urlDialog.placeholder": "Vui lng nhp URL vi thng tin xc thc",
	"ui.common.cancel": "Hy b",
	"ui.common.ok": "ng ",
	"log.save.failed": "Khng lu c d liu cc b",
	"log.file.notFound": "Khng th tm thy nht k tr chi, vui lng m bo rng bn  m lch s cu nguyn bn trong tr chi",
	"log.url.notFound": "Khng th tm thy URL",
	"log.file.readFailed": "Khng c c nht k",
	"log.fetch.retry": "X l ${name} trang ${page} khng thnh cng, s th li sau 5 giy vi thi gian ${count}...",
	"log.fetch.retryFailed": "X l ${name} trang ${page} khng thnh cng, s ln th li  ht",
	"log.fetch.interval": "ang x l ${name} trang ${page}, gian ch 1 giy sau mi 10 trang...",
	"log.fetch.current": "ang x l ${name} trang ${page}",
	"log.fetch.authTimeout": "Xc thc ngi dng  ht hn, vui lng m li lch s cu nguyn bn trong tr chi.",
	"log.fetch.gachaType": "ang nhn loi cu nguyn, vui lng i",
	"log.fetch.gachaTypeOk": "Nhn loi cu nguyn thnh cng",
	"log.url.lackAuth": "Khng tm thy m xc thc trong URL",
	"log.proxy.hint": "S dng ch  proxy [${ip}:${port}]  nhn URL, vui lng m li lch s cu nguyn bn trong tr chi.",
	"log.url.notFound2": "Khng th tm thy URL, vui lng m bo rng bn  m lch s cu nguyn bn trong tr chi",
	"log.url.incorrect": "Khng th nhn thng s URL",
	"log.autoUpdate.success": "T ng cp nht thnh cng, vui lng khi ng li chng trnh",
	"excel.header.time": "Thi gian",
	"excel.header.name": "Tn",
	"excel.header.type": "Loi",
	"excel.header.rank": "Sao",
	"excel.header.total": "S ln",
	"excel.header.pity": "Bo him",
	"excel.customFont": "Arial",
	"excel.filePrefix": "Nht k lch s cu nguyn Genshin",
	"excel.fileType": "Tp tin Excel"
};

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */

function overArg$2(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

var _overArg = overArg$2;

var overArg$1 = _overArg;

/** Built-in value references. */
var getPrototype$3 = overArg$1(Object.getPrototypeOf, Object);

var _getPrototype = getPrototype$3;

var baseGetTag$1 = _baseGetTag,
    getPrototype$2 = _getPrototype,
    isObjectLike$1 = isObjectLike_1;

/** `Object#toString` result references. */
var objectTag$3 = '[object Object]';

/** Used for built-in method references. */
var funcProto$2 = Function.prototype,
    objectProto$d = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$2 = funcProto$2.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$a = objectProto$d.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString$2.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject$1(value) {
  if (!isObjectLike$1(value) || baseGetTag$1(value) != objectTag$3) {
    return false;
  }
  var proto = getPrototype$2(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$a.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString$2.call(Ctor) == objectCtorString;
}

var isPlainObject_1 = isPlainObject$1;

const raw = {
  "zh-cn": require$$0,
  "zh-tw": require$$1,
  "de-de": require$$2,
  "en-us": require$$3,
  "es-es": require$$4,
  "fr-fr": require$$5,
  "id-id": require$$6$1,
  "ja-jp": require$$7$1,
  "ko-kr": require$$8,
  "pt-pt": require$$9,
  "ru-ru": require$$10$1,
  "th-th": require$$11$1,
  "vi-vn": require$$12$1
};
const config$3 = config_1;
const isPlainObject = isPlainObject_1;
const addProp = (obj, key) => {
  if (isPlainObject(obj[key])) {
    return obj[key];
  } else if (typeof obj[key] === "undefined") {
    let temp = {};
    obj[key] = temp;
    return temp;
  }
};
const parseData = (data) => {
  const result = {};
  for (let key in data) {
    let temp = result;
    const arr = key.split(".");
    arr.forEach((prop, index) => {
      if (index === arr.length - 1) {
        temp[prop] = data[key];
      } else {
        temp = addProp(temp, prop);
      }
    });
  }
  return result;
};
const i18nMap = new Map();
const prepareData = () => {
  for (let key in raw) {
    let temp = {};
    if (key === "zh-tw") {
      Object.assign(temp, raw["zh-cn"], raw[key]);
    } else {
      Object.assign(temp, raw["zh-cn"], raw["en-us"], raw[key]);
    }
    i18nMap.set(key, parseData(temp));
  }
};
prepareData();
const parseText = (text, data) => {
  return text.replace(/(\${.+?})/g, function(...args) {
    const key = args[0].slice(2, args[0].length - 1);
    if (data[key])
      return data[key];
    return args[0];
  });
};
const mainProps = [
  "symbol",
  "ui",
  "log",
  "excel"
];
const i18n$3 = new Proxy(raw, {
  get(obj, prop) {
    if (prop === "data") {
      return i18nMap.get(config$3.lang);
    } else if (mainProps.includes(prop)) {
      return i18nMap.get(config$3.lang)[prop];
    } else if (prop === "parse") {
      return parseText;
    }
    return obj[prop];
  }
});
var i18n_1 = i18n$3;

var t$5 = require$$0__default$1["default"], e = require$$1__default["default"], r = require$$4__default$2["default"], n = http__default["default"], i = require$$4__default["default"], a = require$$0__default$3["default"], o = https__default["default"], s = require$$2__default$1["default"], u = require$$8__default["default"], c = require$$0__default$5["default"], f = require$$10__default["default"], l = require$$5__default["default"];
function h(t7) {
  return t7 && typeof t7 == "object" && "default" in t7 ? t7 : { default: t7 };
}
var p = h(t$5), d = h(e), y = h(r), g = h(n), v = h(i), m = h(a), C = h(o), E = h(s), S = h(u), b = h(c), T = h(f), I = h(l), A = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : {};
function w(t7) {
  var e2 = { exports: {} };
  return t7(e2, e2.exports), e2.exports;
}
var _ = w(function(t7) {
  var e2 = t7.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
  typeof __g == "number" && (__g = e2);
}), B = {}.hasOwnProperty, N = function(t7, e2) {
  return B.call(t7, e2);
}, k = function(t7) {
  try {
    return !!t7();
  } catch (t8) {
    return true;
  }
}, R = !k(function() {
  return Object.defineProperty({}, "a", { get: function() {
    return 7;
  } }).a != 7;
}), O = w(function(t7) {
  var e2 = t7.exports = { version: "2.6.12" };
  typeof __e == "number" && (__e = e2);
}), L = function(t7) {
  return typeof t7 == "object" ? t7 !== null : typeof t7 == "function";
}, P = function(t7) {
  if (!L(t7))
    throw TypeError(t7 + " is not an object!");
  return t7;
}, U = _.document, x = L(U) && L(U.createElement), D = function(t7) {
  return x ? U.createElement(t7) : {};
}, V = !R && !k(function() {
  return Object.defineProperty(D("div"), "a", { get: function() {
    return 7;
  } }).a != 7;
}), M = function(t7, e2) {
  if (!L(t7))
    return t7;
  var r2, n2;
  if (e2 && typeof (r2 = t7.toString) == "function" && !L(n2 = r2.call(t7)))
    return n2;
  if (typeof (r2 = t7.valueOf) == "function" && !L(n2 = r2.call(t7)))
    return n2;
  if (!e2 && typeof (r2 = t7.toString) == "function" && !L(n2 = r2.call(t7)))
    return n2;
  throw TypeError("Can't convert object to primitive value");
}, j = Object.defineProperty, F = { f: R ? Object.defineProperty : function(t7, e2, r2) {
  if (P(t7), e2 = M(e2, true), P(r2), V)
    try {
      return j(t7, e2, r2);
    } catch (t8) {
    }
  if ("get" in r2 || "set" in r2)
    throw TypeError("Accessors not supported!");
  return "value" in r2 && (t7[e2] = r2.value), t7;
} }, K = function(t7, e2) {
  return { enumerable: !(1 & t7), configurable: !(2 & t7), writable: !(4 & t7), value: e2 };
}, q = R ? function(t7, e2, r2) {
  return F.f(t7, e2, K(1, r2));
} : function(t7, e2, r2) {
  return t7[e2] = r2, t7;
}, G = 0, z = Math.random(), W = function(t7) {
  return "Symbol(".concat(t7 === void 0 ? "" : t7, ")_", (++G + z).toString(36));
}, H = w(function(t7) {
  var e2 = "__core-js_shared__", r2 = _[e2] || (_[e2] = {});
  (t7.exports = function(t8, e3) {
    return r2[t8] || (r2[t8] = e3 !== void 0 ? e3 : {});
  })("versions", []).push({ version: O.version, mode: "global", copyright: "\xA9 2020 Denis Pushkarev (zloirock.ru)" });
}), Q = H("native-function-to-string", Function.toString), Y = w(function(t7) {
  var e2 = W("src"), r2 = "toString", n2 = ("" + Q).split(r2);
  O.inspectSource = function(t8) {
    return Q.call(t8);
  }, (t7.exports = function(t8, r3, i2, a2) {
    var o2 = typeof i2 == "function";
    o2 && (N(i2, "name") || q(i2, "name", r3)), t8[r3] !== i2 && (o2 && (N(i2, e2) || q(i2, e2, t8[r3] ? "" + t8[r3] : n2.join(String(r3)))), t8 === _ ? t8[r3] = i2 : a2 ? t8[r3] ? t8[r3] = i2 : q(t8, r3, i2) : (delete t8[r3], q(t8, r3, i2)));
  })(Function.prototype, r2, function() {
    return typeof this == "function" && this[e2] || Q.call(this);
  });
}), X = function(t7) {
  if (typeof t7 != "function")
    throw TypeError(t7 + " is not a function!");
  return t7;
}, $ = function(t7, e2, r2) {
  if (X(t7), e2 === void 0)
    return t7;
  switch (r2) {
    case 1:
      return function(r3) {
        return t7.call(e2, r3);
      };
    case 2:
      return function(r3, n2) {
        return t7.call(e2, r3, n2);
      };
    case 3:
      return function(r3, n2, i2) {
        return t7.call(e2, r3, n2, i2);
      };
  }
  return function() {
    return t7.apply(e2, arguments);
  };
}, Z = function(t7, e2, r2) {
  var n2, i2, a2, o2, s2 = t7 & Z.F, u2 = t7 & Z.G, c2 = t7 & Z.S, f2 = t7 & Z.P, l2 = t7 & Z.B, h2 = u2 ? _ : c2 ? _[e2] || (_[e2] = {}) : (_[e2] || {}).prototype, p2 = u2 ? O : O[e2] || (O[e2] = {}), d2 = p2.prototype || (p2.prototype = {});
  for (n2 in u2 && (r2 = e2), r2)
    a2 = ((i2 = !s2 && h2 && h2[n2] !== void 0) ? h2 : r2)[n2], o2 = l2 && i2 ? $(a2, _) : f2 && typeof a2 == "function" ? $(Function.call, a2) : a2, h2 && Y(h2, n2, a2, t7 & Z.U), p2[n2] != a2 && q(p2, n2, o2), f2 && d2[n2] != a2 && (d2[n2] = a2);
};
_.core = O, Z.F = 1, Z.G = 2, Z.S = 4, Z.P = 8, Z.B = 16, Z.W = 32, Z.U = 64, Z.R = 128;
var J = Z, tt = w(function(t7) {
  var e2 = W("meta"), r2 = F.f, n2 = 0, i2 = Object.isExtensible || function() {
    return true;
  }, a2 = !k(function() {
    return i2(Object.preventExtensions({}));
  }), o2 = function(t8) {
    r2(t8, e2, { value: { i: "O" + ++n2, w: {} } });
  }, s2 = t7.exports = { KEY: e2, NEED: false, fastKey: function(t8, r3) {
    if (!L(t8))
      return typeof t8 == "symbol" ? t8 : (typeof t8 == "string" ? "S" : "P") + t8;
    if (!N(t8, e2)) {
      if (!i2(t8))
        return "F";
      if (!r3)
        return "E";
      o2(t8);
    }
    return t8[e2].i;
  }, getWeak: function(t8, r3) {
    if (!N(t8, e2)) {
      if (!i2(t8))
        return true;
      if (!r3)
        return false;
      o2(t8);
    }
    return t8[e2].w;
  }, onFreeze: function(t8) {
    return a2 && s2.NEED && i2(t8) && !N(t8, e2) && o2(t8), t8;
  } };
}), et = w(function(t7) {
  var e2 = H("wks"), r2 = _.Symbol, n2 = typeof r2 == "function";
  (t7.exports = function(t8) {
    return e2[t8] || (e2[t8] = n2 && r2[t8] || (n2 ? r2 : W)("Symbol." + t8));
  }).store = e2;
}), rt = F.f, nt = et("toStringTag"), it = function(t7, e2, r2) {
  t7 && !N(t7 = r2 ? t7 : t7.prototype, nt) && rt(t7, nt, { configurable: true, value: e2 });
}, at = { f: et }, ot = F.f, st = function(t7) {
  var e2 = O.Symbol || (O.Symbol = _.Symbol || {});
  t7.charAt(0) == "_" || t7 in e2 || ot(e2, t7, { value: at.f(t7) });
}, ut = {}.toString, ct = function(t7) {
  return ut.call(t7).slice(8, -1);
}, ft = Object("z").propertyIsEnumerable(0) ? Object : function(t7) {
  return ct(t7) == "String" ? t7.split("") : Object(t7);
}, lt$3 = function(t7) {
  if (t7 == null)
    throw TypeError("Can't call method on  " + t7);
  return t7;
}, ht = function(t7) {
  return ft(lt$3(t7));
}, pt = Math.ceil, dt = Math.floor, yt = function(t7) {
  return isNaN(t7 = +t7) ? 0 : (t7 > 0 ? dt : pt)(t7);
}, gt$4 = Math.min, vt = function(t7) {
  return t7 > 0 ? gt$4(yt(t7), 9007199254740991) : 0;
}, mt = Math.max, Ct = Math.min, Et = function(t7, e2) {
  return (t7 = yt(t7)) < 0 ? mt(t7 + e2, 0) : Ct(t7, e2);
}, St = function(t7) {
  return function(e2, r2, n2) {
    var i2, a2 = ht(e2), o2 = vt(a2.length), s2 = Et(n2, o2);
    if (t7 && r2 != r2) {
      for (; o2 > s2; )
        if ((i2 = a2[s2++]) != i2)
          return true;
    } else
      for (; o2 > s2; s2++)
        if ((t7 || s2 in a2) && a2[s2] === r2)
          return t7 || s2 || 0;
    return !t7 && -1;
  };
}, bt = H("keys"), Tt = function(t7) {
  return bt[t7] || (bt[t7] = W(t7));
}, It = St(false), At = Tt("IE_PROTO"), wt = function(t7, e2) {
  var r2, n2 = ht(t7), i2 = 0, a2 = [];
  for (r2 in n2)
    r2 != At && N(n2, r2) && a2.push(r2);
  for (; e2.length > i2; )
    N(n2, r2 = e2[i2++]) && (~It(a2, r2) || a2.push(r2));
  return a2;
}, _t = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(","), Bt = Object.keys || function(t7) {
  return wt(t7, _t);
}, Nt = { f: Object.getOwnPropertySymbols }, kt = { f: {}.propertyIsEnumerable }, Rt = Array.isArray || function(t7) {
  return ct(t7) == "Array";
}, Ot = function(t7) {
  return Object(lt$3(t7));
}, Lt = R ? Object.defineProperties : function(t7, e2) {
  P(t7);
  for (var r2, n2 = Bt(e2), i2 = n2.length, a2 = 0; i2 > a2; )
    F.f(t7, r2 = n2[a2++], e2[r2]);
  return t7;
}, Pt = _.document, Ut = Pt && Pt.documentElement, xt = Tt("IE_PROTO"), Dt = function() {
}, Vt = function() {
  var t7, e2 = D("iframe"), r2 = _t.length;
  for (e2.style.display = "none", Ut.appendChild(e2), e2.src = "javascript:", (t7 = e2.contentWindow.document).open(), t7.write("<script>document.F=Object<\/script>"), t7.close(), Vt = t7.F; r2--; )
    delete Vt.prototype[_t[r2]];
  return Vt();
}, Mt = Object.create || function(t7, e2) {
  var r2;
  return t7 !== null ? (Dt.prototype = P(t7), r2 = new Dt(), Dt.prototype = null, r2[xt] = t7) : r2 = Vt(), e2 === void 0 ? r2 : Lt(r2, e2);
}, jt = _t.concat("length", "prototype"), Ft = { f: Object.getOwnPropertyNames || function(t7) {
  return wt(t7, jt);
} }, Kt = Ft.f, qt = {}.toString, Gt = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [], zt = { f: function(t7) {
  return Gt && qt.call(t7) == "[object Window]" ? function(t8) {
    try {
      return Kt(t8);
    } catch (t9) {
      return Gt.slice();
    }
  }(t7) : Kt(ht(t7));
} }, Wt = Object.getOwnPropertyDescriptor, Ht = { f: R ? Wt : function(t7, e2) {
  if (t7 = ht(t7), e2 = M(e2, true), V)
    try {
      return Wt(t7, e2);
    } catch (t8) {
    }
  if (N(t7, e2))
    return K(!kt.f.call(t7, e2), t7[e2]);
} }, Qt = tt.KEY, Yt = Ht.f, Xt = F.f, $t = zt.f, Zt = _.Symbol, Jt = _.JSON, te = Jt && Jt.stringify, ee = et("_hidden"), re$6 = et("toPrimitive"), ne = {}.propertyIsEnumerable, ie = H("symbol-registry"), ae = H("symbols"), oe = H("op-symbols"), se = Object.prototype, ue = typeof Zt == "function" && !!Nt.f, ce = _.QObject, fe = !ce || !ce.prototype || !ce.prototype.findChild, le = R && k(function() {
  return Mt(Xt({}, "a", { get: function() {
    return Xt(this, "a", { value: 7 }).a;
  } })).a != 7;
}) ? function(t7, e2, r2) {
  var n2 = Yt(se, e2);
  n2 && delete se[e2], Xt(t7, e2, r2), n2 && t7 !== se && Xt(se, e2, n2);
} : Xt, he = function(t7) {
  var e2 = ae[t7] = Mt(Zt.prototype);
  return e2._k = t7, e2;
}, pe = ue && typeof Zt.iterator == "symbol" ? function(t7) {
  return typeof t7 == "symbol";
} : function(t7) {
  return t7 instanceof Zt;
}, de = function(t7, e2, r2) {
  return t7 === se && de(oe, e2, r2), P(t7), e2 = M(e2, true), P(r2), N(ae, e2) ? (r2.enumerable ? (N(t7, ee) && t7[ee][e2] && (t7[ee][e2] = false), r2 = Mt(r2, { enumerable: K(0, false) })) : (N(t7, ee) || Xt(t7, ee, K(1, {})), t7[ee][e2] = true), le(t7, e2, r2)) : Xt(t7, e2, r2);
}, ye = function(t7, e2) {
  P(t7);
  for (var r2, n2 = function(t8) {
    var e3 = Bt(t8), r3 = Nt.f;
    if (r3)
      for (var n3, i3 = r3(t8), a3 = kt.f, o2 = 0; i3.length > o2; )
        a3.call(t8, n3 = i3[o2++]) && e3.push(n3);
    return e3;
  }(e2 = ht(e2)), i2 = 0, a2 = n2.length; a2 > i2; )
    de(t7, r2 = n2[i2++], e2[r2]);
  return t7;
}, ge = function(t7) {
  var e2 = ne.call(this, t7 = M(t7, true));
  return !(this === se && N(ae, t7) && !N(oe, t7)) && (!(e2 || !N(this, t7) || !N(ae, t7) || N(this, ee) && this[ee][t7]) || e2);
}, ve = function(t7, e2) {
  if (t7 = ht(t7), e2 = M(e2, true), t7 !== se || !N(ae, e2) || N(oe, e2)) {
    var r2 = Yt(t7, e2);
    return !r2 || !N(ae, e2) || N(t7, ee) && t7[ee][e2] || (r2.enumerable = true), r2;
  }
}, me = function(t7) {
  for (var e2, r2 = $t(ht(t7)), n2 = [], i2 = 0; r2.length > i2; )
    N(ae, e2 = r2[i2++]) || e2 == ee || e2 == Qt || n2.push(e2);
  return n2;
}, Ce = function(t7) {
  for (var e2, r2 = t7 === se, n2 = $t(r2 ? oe : ht(t7)), i2 = [], a2 = 0; n2.length > a2; )
    !N(ae, e2 = n2[a2++]) || r2 && !N(se, e2) || i2.push(ae[e2]);
  return i2;
};
ue || (Y((Zt = function() {
  if (this instanceof Zt)
    throw TypeError("Symbol is not a constructor!");
  var t7 = W(arguments.length > 0 ? arguments[0] : void 0), e2 = function(r2) {
    this === se && e2.call(oe, r2), N(this, ee) && N(this[ee], t7) && (this[ee][t7] = false), le(this, t7, K(1, r2));
  };
  return R && fe && le(se, t7, { configurable: true, set: e2 }), he(t7);
}).prototype, "toString", function() {
  return this._k;
}), Ht.f = ve, F.f = de, Ft.f = zt.f = me, kt.f = ge, Nt.f = Ce, R && Y(se, "propertyIsEnumerable", ge, true), at.f = function(t7) {
  return he(et(t7));
}), J(J.G + J.W + J.F * !ue, { Symbol: Zt });
for (var Ee = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), Se = 0; Ee.length > Se; )
  et(Ee[Se++]);
for (var be = Bt(et.store), Te = 0; be.length > Te; )
  st(be[Te++]);
J(J.S + J.F * !ue, "Symbol", { for: function(t7) {
  return N(ie, t7 += "") ? ie[t7] : ie[t7] = Zt(t7);
}, keyFor: function(t7) {
  if (!pe(t7))
    throw TypeError(t7 + " is not a symbol!");
  for (var e2 in ie)
    if (ie[e2] === t7)
      return e2;
}, useSetter: function() {
  fe = true;
}, useSimple: function() {
  fe = false;
} }), J(J.S + J.F * !ue, "Object", { create: function(t7, e2) {
  return e2 === void 0 ? Mt(t7) : ye(Mt(t7), e2);
}, defineProperty: de, defineProperties: ye, getOwnPropertyDescriptor: ve, getOwnPropertyNames: me, getOwnPropertySymbols: Ce });
var Ie = k(function() {
  Nt.f(1);
});
J(J.S + J.F * Ie, "Object", { getOwnPropertySymbols: function(t7) {
  return Nt.f(Ot(t7));
} }), Jt && J(J.S + J.F * (!ue || k(function() {
  var t7 = Zt();
  return te([t7]) != "[null]" || te({ a: t7 }) != "{}" || te(Object(t7)) != "{}";
})), "JSON", { stringify: function(t7) {
  for (var e2, r2, n2 = [t7], i2 = 1; arguments.length > i2; )
    n2.push(arguments[i2++]);
  if (r2 = e2 = n2[1], (L(e2) || t7 !== void 0) && !pe(t7))
    return Rt(e2) || (e2 = function(t8, e3) {
      if (typeof r2 == "function" && (e3 = r2.call(this, t8, e3)), !pe(e3))
        return e3;
    }), n2[1] = e2, te.apply(Jt, n2);
} }), Zt.prototype[re$6] || q(Zt.prototype, re$6, Zt.prototype.valueOf), it(Zt, "Symbol"), it(Math, "Math", true), it(_.JSON, "JSON", true), J(J.S, "Object", { create: Mt }), J(J.S + J.F * !R, "Object", { defineProperty: F.f }), J(J.S + J.F * !R, "Object", { defineProperties: Lt });
var Ae = function(t7, e2) {
  var r2 = (O.Object || {})[t7] || Object[t7], n2 = {};
  n2[t7] = e2(r2), J(J.S + J.F * k(function() {
    r2(1);
  }), "Object", n2);
}, we = Ht.f;
Ae("getOwnPropertyDescriptor", function() {
  return function(t7, e2) {
    return we(ht(t7), e2);
  };
});
var _e = Tt("IE_PROTO"), Be = Object.prototype, Ne = Object.getPrototypeOf || function(t7) {
  return t7 = Ot(t7), N(t7, _e) ? t7[_e] : typeof t7.constructor == "function" && t7 instanceof t7.constructor ? t7.constructor.prototype : t7 instanceof Object ? Be : null;
};
Ae("getPrototypeOf", function() {
  return function(t7) {
    return Ne(Ot(t7));
  };
}), Ae("keys", function() {
  return function(t7) {
    return Bt(Ot(t7));
  };
}), Ae("getOwnPropertyNames", function() {
  return zt.f;
});
var ke = tt.onFreeze;
Ae("freeze", function(t7) {
  return function(e2) {
    return t7 && L(e2) ? t7(ke(e2)) : e2;
  };
});
var Re = tt.onFreeze;
Ae("seal", function(t7) {
  return function(e2) {
    return t7 && L(e2) ? t7(Re(e2)) : e2;
  };
});
var Oe = tt.onFreeze;
Ae("preventExtensions", function(t7) {
  return function(e2) {
    return t7 && L(e2) ? t7(Oe(e2)) : e2;
  };
}), Ae("isFrozen", function(t7) {
  return function(e2) {
    return !L(e2) || !!t7 && t7(e2);
  };
}), Ae("isSealed", function(t7) {
  return function(e2) {
    return !L(e2) || !!t7 && t7(e2);
  };
}), Ae("isExtensible", function(t7) {
  return function(e2) {
    return !!L(e2) && (!t7 || t7(e2));
  };
});
var Le = Object.assign, Pe = !Le || k(function() {
  var t7 = {}, e2 = {}, r2 = Symbol(), n2 = "abcdefghijklmnopqrst";
  return t7[r2] = 7, n2.split("").forEach(function(t8) {
    e2[t8] = t8;
  }), Le({}, t7)[r2] != 7 || Object.keys(Le({}, e2)).join("") != n2;
}) ? function(t7, e2) {
  for (var r2 = Ot(t7), n2 = arguments.length, i2 = 1, a2 = Nt.f, o2 = kt.f; n2 > i2; )
    for (var s2, u2 = ft(arguments[i2++]), c2 = a2 ? Bt(u2).concat(a2(u2)) : Bt(u2), f2 = c2.length, l2 = 0; f2 > l2; )
      s2 = c2[l2++], R && !o2.call(u2, s2) || (r2[s2] = u2[s2]);
  return r2;
} : Le;
J(J.S + J.F, "Object", { assign: Pe });
var Ue = Object.is || function(t7, e2) {
  return t7 === e2 ? t7 !== 0 || 1 / t7 == 1 / e2 : t7 != t7 && e2 != e2;
};
J(J.S, "Object", { is: Ue });
var xe = function(t7, e2) {
  if (P(t7), !L(e2) && e2 !== null)
    throw TypeError(e2 + ": can't set as prototype!");
}, De = { set: Object.setPrototypeOf || ("__proto__" in {} ? function(t7, e2, r2) {
  try {
    (r2 = $(Function.call, Ht.f(Object.prototype, "__proto__").set, 2))(t7, []), e2 = !(t7 instanceof Array);
  } catch (t8) {
    e2 = true;
  }
  return function(t8, n2) {
    return xe(t8, n2), e2 ? t8.__proto__ = n2 : r2(t8, n2), t8;
  };
}({}, false) : void 0), check: xe };
J(J.S, "Object", { setPrototypeOf: De.set });
var Ve = et("toStringTag"), Me = ct(function() {
  return arguments;
}()) == "Arguments", je = function(t7) {
  var e2, r2, n2;
  return t7 === void 0 ? "Undefined" : t7 === null ? "Null" : typeof (r2 = function(t8, e3) {
    try {
      return t8[e3];
    } catch (t9) {
    }
  }(e2 = Object(t7), Ve)) == "string" ? r2 : Me ? ct(e2) : (n2 = ct(e2)) == "Object" && typeof e2.callee == "function" ? "Arguments" : n2;
}, Fe = {};
Fe[et("toStringTag")] = "z", Fe + "" != "[object z]" && Y(Object.prototype, "toString", function() {
  return "[object " + je(this) + "]";
}, true);
var Ke = function(t7, e2, r2) {
  var n2 = r2 === void 0;
  switch (e2.length) {
    case 0:
      return n2 ? t7() : t7.call(r2);
    case 1:
      return n2 ? t7(e2[0]) : t7.call(r2, e2[0]);
    case 2:
      return n2 ? t7(e2[0], e2[1]) : t7.call(r2, e2[0], e2[1]);
    case 3:
      return n2 ? t7(e2[0], e2[1], e2[2]) : t7.call(r2, e2[0], e2[1], e2[2]);
    case 4:
      return n2 ? t7(e2[0], e2[1], e2[2], e2[3]) : t7.call(r2, e2[0], e2[1], e2[2], e2[3]);
  }
  return t7.apply(r2, e2);
}, qe = [].slice, Ge = {}, ze = function(t7, e2, r2) {
  if (!(e2 in Ge)) {
    for (var n2 = [], i2 = 0; i2 < e2; i2++)
      n2[i2] = "a[" + i2 + "]";
    Ge[e2] = Function("F,a", "return new F(" + n2.join(",") + ")");
  }
  return Ge[e2](t7, r2);
}, We = Function.bind || function(t7) {
  var e2 = X(this), r2 = qe.call(arguments, 1), n2 = function() {
    var i2 = r2.concat(qe.call(arguments));
    return this instanceof n2 ? ze(e2, i2.length, i2) : Ke(e2, i2, t7);
  };
  return L(e2.prototype) && (n2.prototype = e2.prototype), n2;
};
J(J.P, "Function", { bind: We });
var He = F.f, Qe = Function.prototype, Ye = /^\s*function ([^ (]*)/;
"name" in Qe || R && He(Qe, "name", { configurable: true, get: function() {
  try {
    return ("" + this).match(Ye)[1];
  } catch (t7) {
    return "";
  }
} });
var Xe = et("hasInstance"), $e = Function.prototype;
Xe in $e || F.f($e, Xe, { value: function(t7) {
  if (typeof this != "function" || !L(t7))
    return false;
  if (!L(this.prototype))
    return t7 instanceof this;
  for (; t7 = Ne(t7); )
    if (this.prototype === t7)
      return true;
  return false;
} });
var Ze = "	\n\v\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF", Je = "[" + Ze + "]", tr = RegExp("^" + Je + Je + "*"), er = RegExp(Je + Je + "*$"), rr = function(t7, e2, r2) {
  var n2 = {}, i2 = k(function() {
    return !!Ze[t7]() || "\u200B\x85"[t7]() != "\u200B\x85";
  }), a2 = n2[t7] = i2 ? e2(nr) : Ze[t7];
  r2 && (n2[r2] = a2), J(J.P + J.F * i2, "String", n2);
}, nr = rr.trim = function(t7, e2) {
  return t7 = String(lt$3(t7)), 1 & e2 && (t7 = t7.replace(tr, "")), 2 & e2 && (t7 = t7.replace(er, "")), t7;
}, ir = rr, ar = _.parseInt, or = ir.trim, sr = /^[-+]?0[xX]/, ur = ar(Ze + "08") !== 8 || ar(Ze + "0x16") !== 22 ? function(t7, e2) {
  var r2 = or(String(t7), 3);
  return ar(r2, e2 >>> 0 || (sr.test(r2) ? 16 : 10));
} : ar;
J(J.G + J.F * (parseInt != ur), { parseInt: ur });
var cr = _.parseFloat, fr = ir.trim, lr = 1 / cr(Ze + "-0") != -1 / 0 ? function(t7) {
  var e2 = fr(String(t7), 3), r2 = cr(e2);
  return r2 === 0 && e2.charAt(0) == "-" ? -0 : r2;
} : cr;
J(J.G + J.F * (parseFloat != lr), { parseFloat: lr });
var hr = De.set, pr = function(t7, e2, r2) {
  var n2, i2 = e2.constructor;
  return i2 !== r2 && typeof i2 == "function" && (n2 = i2.prototype) !== r2.prototype && L(n2) && hr && hr(t7, n2), t7;
}, dr = Ft.f, yr = Ht.f, gr = F.f, vr = ir.trim, mr = _.Number, Cr = mr, Er = mr.prototype, Sr = ct(Mt(Er)) == "Number", br = "trim" in String.prototype, Tr = function(t7) {
  var e2 = M(t7, false);
  if (typeof e2 == "string" && e2.length > 2) {
    var r2, n2, i2, a2 = (e2 = br ? e2.trim() : vr(e2, 3)).charCodeAt(0);
    if (a2 === 43 || a2 === 45) {
      if ((r2 = e2.charCodeAt(2)) === 88 || r2 === 120)
        return NaN;
    } else if (a2 === 48) {
      switch (e2.charCodeAt(1)) {
        case 66:
        case 98:
          n2 = 2, i2 = 49;
          break;
        case 79:
        case 111:
          n2 = 8, i2 = 55;
          break;
        default:
          return +e2;
      }
      for (var o2, s2 = e2.slice(2), u2 = 0, c2 = s2.length; u2 < c2; u2++)
        if ((o2 = s2.charCodeAt(u2)) < 48 || o2 > i2)
          return NaN;
      return parseInt(s2, n2);
    }
  }
  return +e2;
};
if (!mr(" 0o1") || !mr("0b1") || mr("+0x1")) {
  mr = function(t7) {
    var e2 = arguments.length < 1 ? 0 : t7, r2 = this;
    return r2 instanceof mr && (Sr ? k(function() {
      Er.valueOf.call(r2);
    }) : ct(r2) != "Number") ? pr(new Cr(Tr(e2)), r2, mr) : Tr(e2);
  };
  for (var Ir, Ar = R ? dr(Cr) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","), wr = 0; Ar.length > wr; wr++)
    N(Cr, Ir = Ar[wr]) && !N(mr, Ir) && gr(mr, Ir, yr(Cr, Ir));
  mr.prototype = Er, Er.constructor = mr, Y(_, "Number", mr);
}
var _r = function(t7, e2) {
  if (typeof t7 != "number" && ct(t7) != "Number")
    throw TypeError(e2);
  return +t7;
}, Br = function(t7) {
  var e2 = String(lt$3(this)), r2 = "", n2 = yt(t7);
  if (n2 < 0 || n2 == 1 / 0)
    throw RangeError("Count can't be negative");
  for (; n2 > 0; (n2 >>>= 1) && (e2 += e2))
    1 & n2 && (r2 += e2);
  return r2;
}, Nr = 1 .toFixed, kr = Math.floor, Rr = [0, 0, 0, 0, 0, 0], Or = "Number.toFixed: incorrect invocation!", Lr = function(t7, e2) {
  for (var r2 = -1, n2 = e2; ++r2 < 6; )
    n2 += t7 * Rr[r2], Rr[r2] = n2 % 1e7, n2 = kr(n2 / 1e7);
}, Pr = function(t7) {
  for (var e2 = 6, r2 = 0; --e2 >= 0; )
    r2 += Rr[e2], Rr[e2] = kr(r2 / t7), r2 = r2 % t7 * 1e7;
}, Ur = function() {
  for (var t7 = 6, e2 = ""; --t7 >= 0; )
    if (e2 !== "" || t7 === 0 || Rr[t7] !== 0) {
      var r2 = String(Rr[t7]);
      e2 = e2 === "" ? r2 : e2 + Br.call("0", 7 - r2.length) + r2;
    }
  return e2;
}, xr = function(t7, e2, r2) {
  return e2 === 0 ? r2 : e2 % 2 == 1 ? xr(t7, e2 - 1, r2 * t7) : xr(t7 * t7, e2 / 2, r2);
};
J(J.P + J.F * (!!Nr && (8e-5 .toFixed(3) !== "0.000" || 0.9 .toFixed(0) !== "1" || 1.255 .toFixed(2) !== "1.25" || 1000000000000000100 .toFixed(0) !== "1000000000000000128") || !k(function() {
  Nr.call({});
})), "Number", { toFixed: function(t7) {
  var e2, r2, n2, i2, a2 = _r(this, Or), o2 = yt(t7), s2 = "", u2 = "0";
  if (o2 < 0 || o2 > 20)
    throw RangeError(Or);
  if (a2 != a2)
    return "NaN";
  if (a2 <= -1e21 || a2 >= 1e21)
    return String(a2);
  if (a2 < 0 && (s2 = "-", a2 = -a2), a2 > 1e-21)
    if (r2 = (e2 = function(t8) {
      for (var e3 = 0, r3 = t8; r3 >= 4096; )
        e3 += 12, r3 /= 4096;
      for (; r3 >= 2; )
        e3 += 1, r3 /= 2;
      return e3;
    }(a2 * xr(2, 69, 1)) - 69) < 0 ? a2 * xr(2, -e2, 1) : a2 / xr(2, e2, 1), r2 *= 4503599627370496, (e2 = 52 - e2) > 0) {
      for (Lr(0, r2), n2 = o2; n2 >= 7; )
        Lr(1e7, 0), n2 -= 7;
      for (Lr(xr(10, n2, 1), 0), n2 = e2 - 1; n2 >= 23; )
        Pr(1 << 23), n2 -= 23;
      Pr(1 << n2), Lr(1, 1), Pr(2), u2 = Ur();
    } else
      Lr(0, r2), Lr(1 << -e2, 0), u2 = Ur() + Br.call("0", o2);
  return u2 = o2 > 0 ? s2 + ((i2 = u2.length) <= o2 ? "0." + Br.call("0", o2 - i2) + u2 : u2.slice(0, i2 - o2) + "." + u2.slice(i2 - o2)) : s2 + u2;
} });
var Dr = 1 .toPrecision;
J(J.P + J.F * (k(function() {
  return Dr.call(1, void 0) !== "1";
}) || !k(function() {
  Dr.call({});
})), "Number", { toPrecision: function(t7) {
  var e2 = _r(this, "Number#toPrecision: incorrect invocation!");
  return t7 === void 0 ? Dr.call(e2) : Dr.call(e2, t7);
} }), J(J.S, "Number", { EPSILON: Math.pow(2, -52) });
var Vr = _.isFinite;
J(J.S, "Number", { isFinite: function(t7) {
  return typeof t7 == "number" && Vr(t7);
} });
var Mr = Math.floor, jr = function(t7) {
  return !L(t7) && isFinite(t7) && Mr(t7) === t7;
};
J(J.S, "Number", { isInteger: jr }), J(J.S, "Number", { isNaN: function(t7) {
  return t7 != t7;
} });
var Fr = Math.abs;
J(J.S, "Number", { isSafeInteger: function(t7) {
  return jr(t7) && Fr(t7) <= 9007199254740991;
} }), J(J.S, "Number", { MAX_SAFE_INTEGER: 9007199254740991 }), J(J.S, "Number", { MIN_SAFE_INTEGER: -9007199254740991 }), J(J.S + J.F * (Number.parseFloat != lr), "Number", { parseFloat: lr }), J(J.S + J.F * (Number.parseInt != ur), "Number", { parseInt: ur });
var Kr = Math.log1p || function(t7) {
  return (t7 = +t7) > -1e-8 && t7 < 1e-8 ? t7 - t7 * t7 / 2 : Math.log(1 + t7);
}, qr = Math.sqrt, Gr = Math.acosh;
J(J.S + J.F * !(Gr && Math.floor(Gr(Number.MAX_VALUE)) == 710 && Gr(1 / 0) == 1 / 0), "Math", { acosh: function(t7) {
  return (t7 = +t7) < 1 ? NaN : t7 > 9490626562425156e-8 ? Math.log(t7) + Math.LN2 : Kr(t7 - 1 + qr(t7 - 1) * qr(t7 + 1));
} });
var zr = Math.asinh;
J(J.S + J.F * !(zr && 1 / zr(0) > 0), "Math", { asinh: function t2(e2) {
  return isFinite(e2 = +e2) && e2 != 0 ? e2 < 0 ? -t2(-e2) : Math.log(e2 + Math.sqrt(e2 * e2 + 1)) : e2;
} });
var Wr = Math.atanh;
J(J.S + J.F * !(Wr && 1 / Wr(-0) < 0), "Math", { atanh: function(t7) {
  return (t7 = +t7) == 0 ? t7 : Math.log((1 + t7) / (1 - t7)) / 2;
} });
var Hr = Math.sign || function(t7) {
  return (t7 = +t7) == 0 || t7 != t7 ? t7 : t7 < 0 ? -1 : 1;
};
J(J.S, "Math", { cbrt: function(t7) {
  return Hr(t7 = +t7) * Math.pow(Math.abs(t7), 1 / 3);
} }), J(J.S, "Math", { clz32: function(t7) {
  return (t7 >>>= 0) ? 31 - Math.floor(Math.log(t7 + 0.5) * Math.LOG2E) : 32;
} });
var Qr = Math.exp;
J(J.S, "Math", { cosh: function(t7) {
  return (Qr(t7 = +t7) + Qr(-t7)) / 2;
} });
var Yr = Math.expm1, Xr = !Yr || Yr(10) > 22025.465794806718 || Yr(10) < 22025.465794806718 || Yr(-2e-17) != -2e-17 ? function(t7) {
  return (t7 = +t7) == 0 ? t7 : t7 > -1e-6 && t7 < 1e-6 ? t7 + t7 * t7 / 2 : Math.exp(t7) - 1;
} : Yr;
J(J.S + J.F * (Xr != Math.expm1), "Math", { expm1: Xr });
var $r = Math.pow, Zr = $r(2, -52), Jr = $r(2, -23), tn = $r(2, 127) * (2 - Jr), en = $r(2, -126), rn = Math.fround || function(t7) {
  var e2, r2, n2 = Math.abs(t7), i2 = Hr(t7);
  return n2 < en ? i2 * (n2 / en / Jr + 1 / Zr - 1 / Zr) * en * Jr : (r2 = (e2 = (1 + Jr / Zr) * n2) - (e2 - n2)) > tn || r2 != r2 ? i2 * (1 / 0) : i2 * r2;
};
J(J.S, "Math", { fround: rn });
var nn = Math.abs;
J(J.S, "Math", { hypot: function(t7, e2) {
  for (var r2, n2, i2 = 0, a2 = 0, o2 = arguments.length, s2 = 0; a2 < o2; )
    s2 < (r2 = nn(arguments[a2++])) ? (i2 = i2 * (n2 = s2 / r2) * n2 + 1, s2 = r2) : i2 += r2 > 0 ? (n2 = r2 / s2) * n2 : r2;
  return s2 === 1 / 0 ? 1 / 0 : s2 * Math.sqrt(i2);
} });
var an = Math.imul;
J(J.S + J.F * k(function() {
  return an(4294967295, 5) != -5 || an.length != 2;
}), "Math", { imul: function(t7, e2) {
  var r2 = 65535, n2 = +t7, i2 = +e2, a2 = r2 & n2, o2 = r2 & i2;
  return 0 | a2 * o2 + ((r2 & n2 >>> 16) * o2 + a2 * (r2 & i2 >>> 16) << 16 >>> 0);
} }), J(J.S, "Math", { log10: function(t7) {
  return Math.log(t7) * Math.LOG10E;
} }), J(J.S, "Math", { log1p: Kr }), J(J.S, "Math", { log2: function(t7) {
  return Math.log(t7) / Math.LN2;
} }), J(J.S, "Math", { sign: Hr });
var on = Math.exp;
J(J.S + J.F * k(function() {
  return !Math.sinh(-2e-17) != -2e-17;
}), "Math", { sinh: function(t7) {
  return Math.abs(t7 = +t7) < 1 ? (Xr(t7) - Xr(-t7)) / 2 : (on(t7 - 1) - on(-t7 - 1)) * (Math.E / 2);
} });
var sn = Math.exp;
J(J.S, "Math", { tanh: function(t7) {
  var e2 = Xr(t7 = +t7), r2 = Xr(-t7);
  return e2 == 1 / 0 ? 1 : r2 == 1 / 0 ? -1 : (e2 - r2) / (sn(t7) + sn(-t7));
} }), J(J.S, "Math", { trunc: function(t7) {
  return (t7 > 0 ? Math.floor : Math.ceil)(t7);
} });
var un = String.fromCharCode, cn = String.fromCodePoint;
J(J.S + J.F * (!!cn && cn.length != 1), "String", { fromCodePoint: function(t7) {
  for (var e2, r2 = [], n2 = arguments.length, i2 = 0; n2 > i2; ) {
    if (e2 = +arguments[i2++], Et(e2, 1114111) !== e2)
      throw RangeError(e2 + " is not a valid code point");
    r2.push(e2 < 65536 ? un(e2) : un(55296 + ((e2 -= 65536) >> 10), e2 % 1024 + 56320));
  }
  return r2.join("");
} }), J(J.S, "String", { raw: function(t7) {
  for (var e2 = ht(t7.raw), r2 = vt(e2.length), n2 = arguments.length, i2 = [], a2 = 0; r2 > a2; )
    i2.push(String(e2[a2++])), a2 < n2 && i2.push(String(arguments[a2]));
  return i2.join("");
} }), ir("trim", function(t7) {
  return function() {
    return t7(this, 3);
  };
});
var fn = function(t7) {
  return function(e2, r2) {
    var n2, i2, a2 = String(lt$3(e2)), o2 = yt(r2), s2 = a2.length;
    return o2 < 0 || o2 >= s2 ? t7 ? "" : void 0 : (n2 = a2.charCodeAt(o2)) < 55296 || n2 > 56319 || o2 + 1 === s2 || (i2 = a2.charCodeAt(o2 + 1)) < 56320 || i2 > 57343 ? t7 ? a2.charAt(o2) : n2 : t7 ? a2.slice(o2, o2 + 2) : i2 - 56320 + (n2 - 55296 << 10) + 65536;
  };
}, ln = {}, hn = {};
q(hn, et("iterator"), function() {
  return this;
});
var pn = function(t7, e2, r2) {
  t7.prototype = Mt(hn, { next: K(1, r2) }), it(t7, e2 + " Iterator");
}, dn = et("iterator"), yn = !([].keys && "next" in [].keys()), gn = function() {
  return this;
}, vn = function(t7, e2, r2, n2, i2, a2, o2) {
  pn(r2, e2, n2);
  var s2, u2, c2, f2 = function(t8) {
    if (!yn && t8 in d2)
      return d2[t8];
    switch (t8) {
      case "keys":
      case "values":
        return function() {
          return new r2(this, t8);
        };
    }
    return function() {
      return new r2(this, t8);
    };
  }, l2 = e2 + " Iterator", h2 = i2 == "values", p2 = false, d2 = t7.prototype, y2 = d2[dn] || d2["@@iterator"] || i2 && d2[i2], g2 = y2 || f2(i2), v2 = i2 ? h2 ? f2("entries") : g2 : void 0, m2 = e2 == "Array" && d2.entries || y2;
  if (m2 && (c2 = Ne(m2.call(new t7()))) !== Object.prototype && c2.next && (it(c2, l2, true), typeof c2[dn] != "function" && q(c2, dn, gn)), h2 && y2 && y2.name !== "values" && (p2 = true, g2 = function() {
    return y2.call(this);
  }), (yn || p2 || !d2[dn]) && q(d2, dn, g2), ln[e2] = g2, ln[l2] = gn, i2)
    if (s2 = { values: h2 ? g2 : f2("values"), keys: a2 ? g2 : f2("keys"), entries: v2 }, o2)
      for (u2 in s2)
        u2 in d2 || Y(d2, u2, s2[u2]);
    else
      J(J.P + J.F * (yn || p2), e2, s2);
  return s2;
}, mn = fn(true);
vn(String, "String", function(t7) {
  this._t = String(t7), this._i = 0;
}, function() {
  var t7, e2 = this._t, r2 = this._i;
  return r2 >= e2.length ? { value: void 0, done: true } : (t7 = mn(e2, r2), this._i += t7.length, { value: t7, done: false });
});
var Cn = fn(false);
J(J.P, "String", { codePointAt: function(t7) {
  return Cn(this, t7);
} });
var En = et("match"), Sn = function(t7) {
  var e2;
  return L(t7) && ((e2 = t7[En]) !== void 0 ? !!e2 : ct(t7) == "RegExp");
}, bn = function(t7, e2, r2) {
  if (Sn(e2))
    throw TypeError("String#" + r2 + " doesn't accept regex!");
  return String(lt$3(t7));
}, Tn = et("match"), In = function(t7) {
  var e2 = /./;
  try {
    "/./"[t7](e2);
  } catch (r2) {
    try {
      return e2[Tn] = false, !"/./"[t7](e2);
    } catch (t8) {
    }
  }
  return true;
}, An = "".endsWith;
J(J.P + J.F * In("endsWith"), "String", { endsWith: function(t7) {
  var e2 = bn(this, t7, "endsWith"), r2 = arguments.length > 1 ? arguments[1] : void 0, n2 = vt(e2.length), i2 = r2 === void 0 ? n2 : Math.min(vt(r2), n2), a2 = String(t7);
  return An ? An.call(e2, a2, i2) : e2.slice(i2 - a2.length, i2) === a2;
} });
J(J.P + J.F * In("includes"), "String", { includes: function(t7) {
  return !!~bn(this, t7, "includes").indexOf(t7, arguments.length > 1 ? arguments[1] : void 0);
} }), J(J.P, "String", { repeat: Br });
var wn = "".startsWith;
J(J.P + J.F * In("startsWith"), "String", { startsWith: function(t7) {
  var e2 = bn(this, t7, "startsWith"), r2 = vt(Math.min(arguments.length > 1 ? arguments[1] : void 0, e2.length)), n2 = String(t7);
  return wn ? wn.call(e2, n2, r2) : e2.slice(r2, r2 + n2.length) === n2;
} });
var _n = /"/g, Bn = function(t7, e2, r2, n2) {
  var i2 = String(lt$3(t7)), a2 = "<" + e2;
  return r2 !== "" && (a2 += " " + r2 + '="' + String(n2).replace(_n, "&quot;") + '"'), a2 + ">" + i2 + "</" + e2 + ">";
}, Nn = function(t7, e2) {
  var r2 = {};
  r2[t7] = e2(Bn), J(J.P + J.F * k(function() {
    var e3 = ""[t7]('"');
    return e3 !== e3.toLowerCase() || e3.split('"').length > 3;
  }), "String", r2);
};
Nn("anchor", function(t7) {
  return function(e2) {
    return t7(this, "a", "name", e2);
  };
}), Nn("big", function(t7) {
  return function() {
    return t7(this, "big", "", "");
  };
}), Nn("blink", function(t7) {
  return function() {
    return t7(this, "blink", "", "");
  };
}), Nn("bold", function(t7) {
  return function() {
    return t7(this, "b", "", "");
  };
}), Nn("fixed", function(t7) {
  return function() {
    return t7(this, "tt", "", "");
  };
}), Nn("fontcolor", function(t7) {
  return function(e2) {
    return t7(this, "font", "color", e2);
  };
}), Nn("fontsize", function(t7) {
  return function(e2) {
    return t7(this, "font", "size", e2);
  };
}), Nn("italics", function(t7) {
  return function() {
    return t7(this, "i", "", "");
  };
}), Nn("link", function(t7) {
  return function(e2) {
    return t7(this, "a", "href", e2);
  };
}), Nn("small", function(t7) {
  return function() {
    return t7(this, "small", "", "");
  };
}), Nn("strike", function(t7) {
  return function() {
    return t7(this, "strike", "", "");
  };
}), Nn("sub", function(t7) {
  return function() {
    return t7(this, "sub", "", "");
  };
}), Nn("sup", function(t7) {
  return function() {
    return t7(this, "sup", "", "");
  };
}), J(J.S, "Date", { now: function() {
  return new Date().getTime();
} }), J(J.P + J.F * k(function() {
  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({ toISOString: function() {
    return 1;
  } }) !== 1;
}), "Date", { toJSON: function(t7) {
  var e2 = Ot(this), r2 = M(e2);
  return typeof r2 != "number" || isFinite(r2) ? e2.toISOString() : null;
} });
var kn = Date.prototype.getTime, Rn = Date.prototype.toISOString, On = function(t7) {
  return t7 > 9 ? t7 : "0" + t7;
}, Ln = k(function() {
  return Rn.call(new Date(-50000000000001)) != "0385-07-25T07:06:39.999Z";
}) || !k(function() {
  Rn.call(new Date(NaN));
}) ? function() {
  if (!isFinite(kn.call(this)))
    throw RangeError("Invalid time value");
  var t7 = this, e2 = t7.getUTCFullYear(), r2 = t7.getUTCMilliseconds(), n2 = e2 < 0 ? "-" : e2 > 9999 ? "+" : "";
  return n2 + ("00000" + Math.abs(e2)).slice(n2 ? -6 : -4) + "-" + On(t7.getUTCMonth() + 1) + "-" + On(t7.getUTCDate()) + "T" + On(t7.getUTCHours()) + ":" + On(t7.getUTCMinutes()) + ":" + On(t7.getUTCSeconds()) + "." + (r2 > 99 ? r2 : "0" + On(r2)) + "Z";
} : Rn;
J(J.P + J.F * (Date.prototype.toISOString !== Ln), "Date", { toISOString: Ln });
var Pn = Date.prototype, Un = Pn.toString, xn = Pn.getTime;
new Date(NaN) + "" != "Invalid Date" && Y(Pn, "toString", function() {
  var t7 = xn.call(this);
  return t7 == t7 ? Un.call(this) : "Invalid Date";
});
var Dn = et("toPrimitive"), Vn = Date.prototype;
Dn in Vn || q(Vn, Dn, function(t7) {
  if (t7 !== "string" && t7 !== "number" && t7 !== "default")
    throw TypeError("Incorrect hint");
  return M(P(this), t7 != "number");
}), J(J.S, "Array", { isArray: Rt });
var Mn = function(t7, e2, r2, n2) {
  try {
    return n2 ? e2(P(r2)[0], r2[1]) : e2(r2);
  } catch (e3) {
    var i2 = t7.return;
    throw i2 !== void 0 && P(i2.call(t7)), e3;
  }
}, jn = et("iterator"), Fn = Array.prototype, Kn = function(t7) {
  return t7 !== void 0 && (ln.Array === t7 || Fn[jn] === t7);
}, qn = function(t7, e2, r2) {
  e2 in t7 ? F.f(t7, e2, K(0, r2)) : t7[e2] = r2;
}, Gn = et("iterator"), zn = O.getIteratorMethod = function(t7) {
  if (t7 != null)
    return t7[Gn] || t7["@@iterator"] || ln[je(t7)];
}, Wn = et("iterator"), Hn = false;
try {
  var Qn = [7][Wn]();
  Qn.return = function() {
    Hn = true;
  }, Array.from(Qn, function() {
    throw 2;
  });
} catch (t7) {
}
var Yn = function(t7, e2) {
  if (!e2 && !Hn)
    return false;
  var r2 = false;
  try {
    var n2 = [7], i2 = n2[Wn]();
    i2.next = function() {
      return { done: r2 = true };
    }, n2[Wn] = function() {
      return i2;
    }, t7(n2);
  } catch (t8) {
  }
  return r2;
};
J(J.S + J.F * !Yn(function(t7) {
  Array.from(t7);
}), "Array", { from: function(t7) {
  var e2, r2, n2, i2, a2 = Ot(t7), o2 = typeof this == "function" ? this : Array, s2 = arguments.length, u2 = s2 > 1 ? arguments[1] : void 0, c2 = u2 !== void 0, f2 = 0, l2 = zn(a2);
  if (c2 && (u2 = $(u2, s2 > 2 ? arguments[2] : void 0, 2)), l2 == null || o2 == Array && Kn(l2))
    for (r2 = new o2(e2 = vt(a2.length)); e2 > f2; f2++)
      qn(r2, f2, c2 ? u2(a2[f2], f2) : a2[f2]);
  else
    for (i2 = l2.call(a2), r2 = new o2(); !(n2 = i2.next()).done; f2++)
      qn(r2, f2, c2 ? Mn(i2, u2, [n2.value, f2], true) : n2.value);
  return r2.length = f2, r2;
} }), J(J.S + J.F * k(function() {
  function t7() {
  }
  return !(Array.of.call(t7) instanceof t7);
}), "Array", { of: function() {
  for (var t7 = 0, e2 = arguments.length, r2 = new (typeof this == "function" ? this : Array)(e2); e2 > t7; )
    qn(r2, t7, arguments[t7++]);
  return r2.length = e2, r2;
} });
var Xn = function(t7, e2) {
  return !!t7 && k(function() {
    e2 ? t7.call(null, function() {
    }, 1) : t7.call(null);
  });
}, $n = [].join;
J(J.P + J.F * (ft != Object || !Xn($n)), "Array", { join: function(t7) {
  return $n.call(ht(this), t7 === void 0 ? "," : t7);
} });
var Zn = [].slice;
J(J.P + J.F * k(function() {
  Ut && Zn.call(Ut);
}), "Array", { slice: function(t7, e2) {
  var r2 = vt(this.length), n2 = ct(this);
  if (e2 = e2 === void 0 ? r2 : e2, n2 == "Array")
    return Zn.call(this, t7, e2);
  for (var i2 = Et(t7, r2), a2 = Et(e2, r2), o2 = vt(a2 - i2), s2 = new Array(o2), u2 = 0; u2 < o2; u2++)
    s2[u2] = n2 == "String" ? this.charAt(i2 + u2) : this[i2 + u2];
  return s2;
} });
var Jn = [].sort, ti = [1, 2, 3];
J(J.P + J.F * (k(function() {
  ti.sort(void 0);
}) || !k(function() {
  ti.sort(null);
}) || !Xn(Jn)), "Array", { sort: function(t7) {
  return t7 === void 0 ? Jn.call(Ot(this)) : Jn.call(Ot(this), X(t7));
} });
var ei = et("species"), ri = function(t7, e2) {
  return new (function(t8) {
    var e3;
    return Rt(t8) && (typeof (e3 = t8.constructor) != "function" || e3 !== Array && !Rt(e3.prototype) || (e3 = void 0), L(e3) && (e3 = e3[ei]) === null && (e3 = void 0)), e3 === void 0 ? Array : e3;
  }(t7))(e2);
}, ni = function(t7, e2) {
  var r2 = t7 == 1, n2 = t7 == 2, i2 = t7 == 3, a2 = t7 == 4, o2 = t7 == 6, s2 = t7 == 5 || o2, u2 = e2 || ri;
  return function(e3, c2, f2) {
    for (var l2, h2, p2 = Ot(e3), d2 = ft(p2), y2 = $(c2, f2, 3), g2 = vt(d2.length), v2 = 0, m2 = r2 ? u2(e3, g2) : n2 ? u2(e3, 0) : void 0; g2 > v2; v2++)
      if ((s2 || v2 in d2) && (h2 = y2(l2 = d2[v2], v2, p2), t7)) {
        if (r2)
          m2[v2] = h2;
        else if (h2)
          switch (t7) {
            case 3:
              return true;
            case 5:
              return l2;
            case 6:
              return v2;
            case 2:
              m2.push(l2);
          }
        else if (a2)
          return false;
      }
    return o2 ? -1 : i2 || a2 ? a2 : m2;
  };
}, ii = ni(0), ai = Xn([].forEach, true);
J(J.P + J.F * !ai, "Array", { forEach: function(t7) {
  return ii(this, t7, arguments[1]);
} });
var oi = ni(1);
J(J.P + J.F * !Xn([].map, true), "Array", { map: function(t7) {
  return oi(this, t7, arguments[1]);
} });
var si = ni(2);
J(J.P + J.F * !Xn([].filter, true), "Array", { filter: function(t7) {
  return si(this, t7, arguments[1]);
} });
var ui = ni(3);
J(J.P + J.F * !Xn([].some, true), "Array", { some: function(t7) {
  return ui(this, t7, arguments[1]);
} });
var ci = ni(4);
J(J.P + J.F * !Xn([].every, true), "Array", { every: function(t7) {
  return ci(this, t7, arguments[1]);
} });
var fi = function(t7, e2, r2, n2, i2) {
  X(e2);
  var a2 = Ot(t7), o2 = ft(a2), s2 = vt(a2.length), u2 = i2 ? s2 - 1 : 0, c2 = i2 ? -1 : 1;
  if (r2 < 2)
    for (; ; ) {
      if (u2 in o2) {
        n2 = o2[u2], u2 += c2;
        break;
      }
      if (u2 += c2, i2 ? u2 < 0 : s2 <= u2)
        throw TypeError("Reduce of empty array with no initial value");
    }
  for (; i2 ? u2 >= 0 : s2 > u2; u2 += c2)
    u2 in o2 && (n2 = e2(n2, o2[u2], u2, a2));
  return n2;
};
J(J.P + J.F * !Xn([].reduce, true), "Array", { reduce: function(t7) {
  return fi(this, t7, arguments.length, arguments[1], false);
} }), J(J.P + J.F * !Xn([].reduceRight, true), "Array", { reduceRight: function(t7) {
  return fi(this, t7, arguments.length, arguments[1], true);
} });
var li = St(false), hi = [].indexOf, pi = !!hi && 1 / [1].indexOf(1, -0) < 0;
J(J.P + J.F * (pi || !Xn(hi)), "Array", { indexOf: function(t7) {
  return pi ? hi.apply(this, arguments) || 0 : li(this, t7, arguments[1]);
} });
var di = [].lastIndexOf, yi = !!di && 1 / [1].lastIndexOf(1, -0) < 0;
J(J.P + J.F * (yi || !Xn(di)), "Array", { lastIndexOf: function(t7) {
  if (yi)
    return di.apply(this, arguments) || 0;
  var e2 = ht(this), r2 = vt(e2.length), n2 = r2 - 1;
  for (arguments.length > 1 && (n2 = Math.min(n2, yt(arguments[1]))), n2 < 0 && (n2 = r2 + n2); n2 >= 0; n2--)
    if (n2 in e2 && e2[n2] === t7)
      return n2 || 0;
  return -1;
} });
var gi = [].copyWithin || function(t7, e2) {
  var r2 = Ot(this), n2 = vt(r2.length), i2 = Et(t7, n2), a2 = Et(e2, n2), o2 = arguments.length > 2 ? arguments[2] : void 0, s2 = Math.min((o2 === void 0 ? n2 : Et(o2, n2)) - a2, n2 - i2), u2 = 1;
  for (a2 < i2 && i2 < a2 + s2 && (u2 = -1, a2 += s2 - 1, i2 += s2 - 1); s2-- > 0; )
    a2 in r2 ? r2[i2] = r2[a2] : delete r2[i2], i2 += u2, a2 += u2;
  return r2;
}, vi = et("unscopables"), mi = Array.prototype;
mi[vi] == null && q(mi, vi, {});
var Ci = function(t7) {
  mi[vi][t7] = true;
};
J(J.P, "Array", { copyWithin: gi }), Ci("copyWithin");
var Ei = function(t7) {
  for (var e2 = Ot(this), r2 = vt(e2.length), n2 = arguments.length, i2 = Et(n2 > 1 ? arguments[1] : void 0, r2), a2 = n2 > 2 ? arguments[2] : void 0, o2 = a2 === void 0 ? r2 : Et(a2, r2); o2 > i2; )
    e2[i2++] = t7;
  return e2;
};
J(J.P, "Array", { fill: Ei }), Ci("fill");
var Si = ni(5), bi = true;
"find" in [] && Array(1).find(function() {
  bi = false;
}), J(J.P + J.F * bi, "Array", { find: function(t7) {
  return Si(this, t7, arguments.length > 1 ? arguments[1] : void 0);
} }), Ci("find");
var Ti = ni(6), Ii = true;
"findIndex" in [] && Array(1).findIndex(function() {
  Ii = false;
}), J(J.P + J.F * Ii, "Array", { findIndex: function(t7) {
  return Ti(this, t7, arguments.length > 1 ? arguments[1] : void 0);
} }), Ci("findIndex");
var Ai = et("species"), wi = function(t7) {
  var e2 = _[t7];
  R && e2 && !e2[Ai] && F.f(e2, Ai, { configurable: true, get: function() {
    return this;
  } });
};
wi("Array");
var _i = function(t7, e2) {
  return { value: e2, done: !!t7 };
}, Bi = vn(Array, "Array", function(t7, e2) {
  this._t = ht(t7), this._i = 0, this._k = e2;
}, function() {
  var t7 = this._t, e2 = this._k, r2 = this._i++;
  return !t7 || r2 >= t7.length ? (this._t = void 0, _i(1)) : _i(0, e2 == "keys" ? r2 : e2 == "values" ? t7[r2] : [r2, t7[r2]]);
}, "values");
ln.Arguments = ln.Array, Ci("keys"), Ci("values"), Ci("entries");
var Ni = function() {
  var t7 = P(this), e2 = "";
  return t7.global && (e2 += "g"), t7.ignoreCase && (e2 += "i"), t7.multiline && (e2 += "m"), t7.unicode && (e2 += "u"), t7.sticky && (e2 += "y"), e2;
}, ki = F.f, Ri = Ft.f, Oi = _.RegExp, Li = Oi, Pi = Oi.prototype, Ui = /a/g, xi = /a/g, Di = new Oi(Ui) !== Ui;
if (R && (!Di || k(function() {
  return xi[et("match")] = false, Oi(Ui) != Ui || Oi(xi) == xi || Oi(Ui, "i") != "/a/i";
}))) {
  Oi = function(t7, e2) {
    var r2 = this instanceof Oi, n2 = Sn(t7), i2 = e2 === void 0;
    return !r2 && n2 && t7.constructor === Oi && i2 ? t7 : pr(Di ? new Li(n2 && !i2 ? t7.source : t7, e2) : Li((n2 = t7 instanceof Oi) ? t7.source : t7, n2 && i2 ? Ni.call(t7) : e2), r2 ? this : Pi, Oi);
  };
  for (var Vi = function(t7) {
    t7 in Oi || ki(Oi, t7, { configurable: true, get: function() {
      return Li[t7];
    }, set: function(e2) {
      Li[t7] = e2;
    } });
  }, Mi = Ri(Li), ji = 0; Mi.length > ji; )
    Vi(Mi[ji++]);
  Pi.constructor = Oi, Oi.prototype = Pi, Y(_, "RegExp", Oi);
}
wi("RegExp");
var Fi = RegExp.prototype.exec, Ki = String.prototype.replace, qi = Fi, Gi = function() {
  var t7 = /a/, e2 = /b*/g;
  return Fi.call(t7, "a"), Fi.call(e2, "a"), t7.lastIndex !== 0 || e2.lastIndex !== 0;
}(), zi = /()??/.exec("")[1] !== void 0;
(Gi || zi) && (qi = function(t7) {
  var e2, r2, n2, i2, a2 = this;
  return zi && (r2 = new RegExp("^" + a2.source + "$(?!\\s)", Ni.call(a2))), Gi && (e2 = a2.lastIndex), n2 = Fi.call(a2, t7), Gi && n2 && (a2.lastIndex = a2.global ? n2.index + n2[0].length : e2), zi && n2 && n2.length > 1 && Ki.call(n2[0], r2, function() {
    for (i2 = 1; i2 < arguments.length - 2; i2++)
      arguments[i2] === void 0 && (n2[i2] = void 0);
  }), n2;
});
var Wi = qi;
J({ target: "RegExp", proto: true, forced: Wi !== /./.exec }, { exec: Wi }), R && /./g.flags != "g" && F.f(RegExp.prototype, "flags", { configurable: true, get: Ni });
var Hi = /./.toString, Qi = function(t7) {
  Y(RegExp.prototype, "toString", t7, true);
};
k(function() {
  return Hi.call({ source: "a", flags: "b" }) != "/a/b";
}) ? Qi(function() {
  var t7 = P(this);
  return "/".concat(t7.source, "/", "flags" in t7 ? t7.flags : !R && t7 instanceof RegExp ? Ni.call(t7) : void 0);
}) : Hi.name != "toString" && Qi(function() {
  return Hi.call(this);
});
var Yi = fn(true), Xi = function(t7, e2, r2) {
  return e2 + (r2 ? Yi(t7, e2).length : 1);
}, $i = RegExp.prototype.exec, Zi = function(t7, e2) {
  var r2 = t7.exec;
  if (typeof r2 == "function") {
    var n2 = r2.call(t7, e2);
    if (typeof n2 != "object")
      throw new TypeError("RegExp exec method returned something other than an Object or null");
    return n2;
  }
  if (je(t7) !== "RegExp")
    throw new TypeError("RegExp#exec called on incompatible receiver");
  return $i.call(t7, e2);
}, Ji = et("species"), ta = !k(function() {
  var t7 = /./;
  return t7.exec = function() {
    var t8 = [];
    return t8.groups = { a: "7" }, t8;
  }, "".replace(t7, "$<a>") !== "7";
}), ea = function() {
  var t7 = /(?:)/, e2 = t7.exec;
  t7.exec = function() {
    return e2.apply(this, arguments);
  };
  var r2 = "ab".split(t7);
  return r2.length === 2 && r2[0] === "a" && r2[1] === "b";
}(), ra = function(t7, e2, r2) {
  var n2 = et(t7), i2 = !k(function() {
    var e3 = {};
    return e3[n2] = function() {
      return 7;
    }, ""[t7](e3) != 7;
  }), a2 = i2 ? !k(function() {
    var e3 = false, r3 = /a/;
    return r3.exec = function() {
      return e3 = true, null;
    }, t7 === "split" && (r3.constructor = {}, r3.constructor[Ji] = function() {
      return r3;
    }), r3[n2](""), !e3;
  }) : void 0;
  if (!i2 || !a2 || t7 === "replace" && !ta || t7 === "split" && !ea) {
    var o2 = /./[n2], s2 = r2(lt$3, n2, ""[t7], function(t8, e3, r3, n3, a3) {
      return e3.exec === Wi ? i2 && !a3 ? { done: true, value: o2.call(e3, r3, n3) } : { done: true, value: t8.call(r3, e3, n3) } : { done: false };
    }), u2 = s2[0], c2 = s2[1];
    Y(String.prototype, t7, u2), q(RegExp.prototype, n2, e2 == 2 ? function(t8, e3) {
      return c2.call(t8, this, e3);
    } : function(t8) {
      return c2.call(t8, this);
    });
  }
};
ra("match", 1, function(t7, e2, r2, n2) {
  return [function(r3) {
    var n3 = t7(this), i2 = r3 == null ? void 0 : r3[e2];
    return i2 !== void 0 ? i2.call(r3, n3) : new RegExp(r3)[e2](String(n3));
  }, function(t8) {
    var e3 = n2(r2, t8, this);
    if (e3.done)
      return e3.value;
    var i2 = P(t8), a2 = String(this);
    if (!i2.global)
      return Zi(i2, a2);
    var o2 = i2.unicode;
    i2.lastIndex = 0;
    for (var s2, u2 = [], c2 = 0; (s2 = Zi(i2, a2)) !== null; ) {
      var f2 = String(s2[0]);
      u2[c2] = f2, f2 === "" && (i2.lastIndex = Xi(a2, vt(i2.lastIndex), o2)), c2++;
    }
    return c2 === 0 ? null : u2;
  }];
});
var na = Math.max, ia = Math.min, aa = Math.floor, oa = /\$([$&`']|\d\d?|<[^>]*>)/g, sa = /\$([$&`']|\d\d?)/g;
ra("replace", 2, function(t7, e2, r2, n2) {
  return [function(n3, i3) {
    var a2 = t7(this), o2 = n3 == null ? void 0 : n3[e2];
    return o2 !== void 0 ? o2.call(n3, a2, i3) : r2.call(String(a2), n3, i3);
  }, function(t8, e3) {
    var a2 = n2(r2, t8, this, e3);
    if (a2.done)
      return a2.value;
    var o2 = P(t8), s2 = String(this), u2 = typeof e3 == "function";
    u2 || (e3 = String(e3));
    var c2 = o2.global;
    if (c2) {
      var f2 = o2.unicode;
      o2.lastIndex = 0;
    }
    for (var l2 = []; ; ) {
      var h2 = Zi(o2, s2);
      if (h2 === null)
        break;
      if (l2.push(h2), !c2)
        break;
      String(h2[0]) === "" && (o2.lastIndex = Xi(s2, vt(o2.lastIndex), f2));
    }
    for (var p2, d2 = "", y2 = 0, g2 = 0; g2 < l2.length; g2++) {
      h2 = l2[g2];
      for (var v2 = String(h2[0]), m2 = na(ia(yt(h2.index), s2.length), 0), C2 = [], E2 = 1; E2 < h2.length; E2++)
        C2.push((p2 = h2[E2]) === void 0 ? p2 : String(p2));
      var S2 = h2.groups;
      if (u2) {
        var b2 = [v2].concat(C2, m2, s2);
        S2 !== void 0 && b2.push(S2);
        var T2 = String(e3.apply(void 0, b2));
      } else
        T2 = i2(v2, s2, m2, C2, S2, e3);
      m2 >= y2 && (d2 += s2.slice(y2, m2) + T2, y2 = m2 + v2.length);
    }
    return d2 + s2.slice(y2);
  }];
  function i2(t8, e3, n3, i3, a2, o2) {
    var s2 = n3 + t8.length, u2 = i3.length, c2 = sa;
    return a2 !== void 0 && (a2 = Ot(a2), c2 = oa), r2.call(o2, c2, function(r3, o3) {
      var c3;
      switch (o3.charAt(0)) {
        case "$":
          return "$";
        case "&":
          return t8;
        case "`":
          return e3.slice(0, n3);
        case "'":
          return e3.slice(s2);
        case "<":
          c3 = a2[o3.slice(1, -1)];
          break;
        default:
          var f2 = +o3;
          if (f2 === 0)
            return r3;
          if (f2 > u2) {
            var l2 = aa(f2 / 10);
            return l2 === 0 ? r3 : l2 <= u2 ? i3[l2 - 1] === void 0 ? o3.charAt(1) : i3[l2 - 1] + o3.charAt(1) : r3;
          }
          c3 = i3[f2 - 1];
      }
      return c3 === void 0 ? "" : c3;
    });
  }
}), ra("search", 1, function(t7, e2, r2, n2) {
  return [function(r3) {
    var n3 = t7(this), i2 = r3 == null ? void 0 : r3[e2];
    return i2 !== void 0 ? i2.call(r3, n3) : new RegExp(r3)[e2](String(n3));
  }, function(t8) {
    var e3 = n2(r2, t8, this);
    if (e3.done)
      return e3.value;
    var i2 = P(t8), a2 = String(this), o2 = i2.lastIndex;
    Ue(o2, 0) || (i2.lastIndex = 0);
    var s2 = Zi(i2, a2);
    return Ue(i2.lastIndex, o2) || (i2.lastIndex = o2), s2 === null ? -1 : s2.index;
  }];
});
var ua = et("species"), ca = function(t7, e2) {
  var r2, n2 = P(t7).constructor;
  return n2 === void 0 || (r2 = P(n2)[ua]) == null ? e2 : X(r2);
}, fa = Math.min, la = [].push, ha = !k(function() {
  RegExp(4294967295, "y");
});
ra("split", 2, function(t7, e2, r2, n2) {
  var i2;
  return i2 = "abbc".split(/(b)*/)[1] == "c" || "test".split(/(?:)/, -1).length != 4 || "ab".split(/(?:ab)*/).length != 2 || ".".split(/(.?)(.?)/).length != 4 || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function(t8, e3) {
    var n3 = String(this);
    if (t8 === void 0 && e3 === 0)
      return [];
    if (!Sn(t8))
      return r2.call(n3, t8, e3);
    for (var i3, a2, o2, s2 = [], u2 = (t8.ignoreCase ? "i" : "") + (t8.multiline ? "m" : "") + (t8.unicode ? "u" : "") + (t8.sticky ? "y" : ""), c2 = 0, f2 = e3 === void 0 ? 4294967295 : e3 >>> 0, l2 = new RegExp(t8.source, u2 + "g"); (i3 = Wi.call(l2, n3)) && !((a2 = l2.lastIndex) > c2 && (s2.push(n3.slice(c2, i3.index)), i3.length > 1 && i3.index < n3.length && la.apply(s2, i3.slice(1)), o2 = i3[0].length, c2 = a2, s2.length >= f2)); )
      l2.lastIndex === i3.index && l2.lastIndex++;
    return c2 === n3.length ? !o2 && l2.test("") || s2.push("") : s2.push(n3.slice(c2)), s2.length > f2 ? s2.slice(0, f2) : s2;
  } : "0".split(void 0, 0).length ? function(t8, e3) {
    return t8 === void 0 && e3 === 0 ? [] : r2.call(this, t8, e3);
  } : r2, [function(r3, n3) {
    var a2 = t7(this), o2 = r3 == null ? void 0 : r3[e2];
    return o2 !== void 0 ? o2.call(r3, a2, n3) : i2.call(String(a2), r3, n3);
  }, function(t8, e3) {
    var a2 = n2(i2, t8, this, e3, i2 !== r2);
    if (a2.done)
      return a2.value;
    var o2 = P(t8), s2 = String(this), u2 = ca(o2, RegExp), c2 = o2.unicode, f2 = (o2.ignoreCase ? "i" : "") + (o2.multiline ? "m" : "") + (o2.unicode ? "u" : "") + (ha ? "y" : "g"), l2 = new u2(ha ? o2 : "^(?:" + o2.source + ")", f2), h2 = e3 === void 0 ? 4294967295 : e3 >>> 0;
    if (h2 === 0)
      return [];
    if (s2.length === 0)
      return Zi(l2, s2) === null ? [s2] : [];
    for (var p2 = 0, d2 = 0, y2 = []; d2 < s2.length; ) {
      l2.lastIndex = ha ? d2 : 0;
      var g2, v2 = Zi(l2, ha ? s2 : s2.slice(d2));
      if (v2 === null || (g2 = fa(vt(l2.lastIndex + (ha ? 0 : d2)), s2.length)) === p2)
        d2 = Xi(s2, d2, c2);
      else {
        if (y2.push(s2.slice(p2, d2)), y2.length === h2)
          return y2;
        for (var m2 = 1; m2 <= v2.length - 1; m2++)
          if (y2.push(v2[m2]), y2.length === h2)
            return y2;
        d2 = p2 = g2;
      }
    }
    return y2.push(s2.slice(p2)), y2;
  }];
});
var pa, da, ya, ga = function(t7, e2, r2, n2) {
  if (!(t7 instanceof e2) || n2 !== void 0 && n2 in t7)
    throw TypeError(r2 + ": incorrect invocation!");
  return t7;
}, va = w(function(t7) {
  var e2 = {}, r2 = {}, n2 = t7.exports = function(t8, n3, i2, a2, o2) {
    var s2, u2, c2, f2, l2 = o2 ? function() {
      return t8;
    } : zn(t8), h2 = $(i2, a2, n3 ? 2 : 1), p2 = 0;
    if (typeof l2 != "function")
      throw TypeError(t8 + " is not iterable!");
    if (Kn(l2)) {
      for (s2 = vt(t8.length); s2 > p2; p2++)
        if ((f2 = n3 ? h2(P(u2 = t8[p2])[0], u2[1]) : h2(t8[p2])) === e2 || f2 === r2)
          return f2;
    } else
      for (c2 = l2.call(t8); !(u2 = c2.next()).done; )
        if ((f2 = Mn(c2, h2, u2.value, n3)) === e2 || f2 === r2)
          return f2;
  };
  n2.BREAK = e2, n2.RETURN = r2;
}), ma = _.process, Ca = _.setImmediate, Ea = _.clearImmediate, Sa = _.MessageChannel, ba = _.Dispatch, Ta = 0, Ia = {}, Aa = function() {
  var t7 = +this;
  if (Ia.hasOwnProperty(t7)) {
    var e2 = Ia[t7];
    delete Ia[t7], e2();
  }
}, wa = function(t7) {
  Aa.call(t7.data);
};
Ca && Ea || (Ca = function(t7) {
  for (var e2 = [], r2 = 1; arguments.length > r2; )
    e2.push(arguments[r2++]);
  return Ia[++Ta] = function() {
    Ke(typeof t7 == "function" ? t7 : Function(t7), e2);
  }, pa(Ta), Ta;
}, Ea = function(t7) {
  delete Ia[t7];
}, ct(ma) == "process" ? pa = function(t7) {
  ma.nextTick($(Aa, t7, 1));
} : ba && ba.now ? pa = function(t7) {
  ba.now($(Aa, t7, 1));
} : Sa ? (ya = (da = new Sa()).port2, da.port1.onmessage = wa, pa = $(ya.postMessage, ya, 1)) : _.addEventListener && typeof postMessage == "function" && !_.importScripts ? (pa = function(t7) {
  _.postMessage(t7 + "", "*");
}, _.addEventListener("message", wa, false)) : pa = "onreadystatechange" in D("script") ? function(t7) {
  Ut.appendChild(D("script")).onreadystatechange = function() {
    Ut.removeChild(this), Aa.call(t7);
  };
} : function(t7) {
  setTimeout($(Aa, t7, 1), 0);
});
var _a = { set: Ca, clear: Ea }, Ba = _a.set, Na = _.MutationObserver || _.WebKitMutationObserver, ka = _.process, Ra = _.Promise, Oa = ct(ka) == "process", La = function() {
  var t7, e2, r2, n2 = function() {
    var n3, i3;
    for (Oa && (n3 = ka.domain) && n3.exit(); t7; ) {
      i3 = t7.fn, t7 = t7.next;
      try {
        i3();
      } catch (n4) {
        throw t7 ? r2() : e2 = void 0, n4;
      }
    }
    e2 = void 0, n3 && n3.enter();
  };
  if (Oa)
    r2 = function() {
      ka.nextTick(n2);
    };
  else if (!Na || _.navigator && _.navigator.standalone)
    if (Ra && Ra.resolve) {
      var i2 = Ra.resolve(void 0);
      r2 = function() {
        i2.then(n2);
      };
    } else
      r2 = function() {
        Ba.call(_, n2);
      };
  else {
    var a2 = true, o2 = document.createTextNode("");
    new Na(n2).observe(o2, { characterData: true }), r2 = function() {
      o2.data = a2 = !a2;
    };
  }
  return function(n3) {
    var i3 = { fn: n3, next: void 0 };
    e2 && (e2.next = i3), t7 || (t7 = i3, r2()), e2 = i3;
  };
};
function Pa(t7) {
  var e2, r2;
  this.promise = new t7(function(t8, n2) {
    if (e2 !== void 0 || r2 !== void 0)
      throw TypeError("Bad Promise constructor");
    e2 = t8, r2 = n2;
  }), this.resolve = X(e2), this.reject = X(r2);
}
var Ua, xa, Da, Va, Ma = { f: function(t7) {
  return new Pa(t7);
} }, ja = function(t7) {
  try {
    return { e: false, v: t7() };
  } catch (t8) {
    return { e: true, v: t8 };
  }
}, Fa = _.navigator, Ka = Fa && Fa.userAgent || "", qa = function(t7, e2) {
  if (P(t7), L(e2) && e2.constructor === t7)
    return e2;
  var r2 = Ma.f(t7);
  return (0, r2.resolve)(e2), r2.promise;
}, Ga = function(t7, e2, r2) {
  for (var n2 in e2)
    Y(t7, n2, e2[n2], r2);
  return t7;
}, za = _a.set, Wa = La(), Ha = _.TypeError, Qa = _.process, Ya = Qa && Qa.versions, Xa = Ya && Ya.v8 || "", $a = _.Promise, Za = je(Qa) == "process", Ja = function() {
}, to = xa = Ma.f, eo = !!function() {
  try {
    var t7 = $a.resolve(1), e2 = (t7.constructor = {})[et("species")] = function(t8) {
      t8(Ja, Ja);
    };
    return (Za || typeof PromiseRejectionEvent == "function") && t7.then(Ja) instanceof e2 && Xa.indexOf("6.6") !== 0 && Ka.indexOf("Chrome/66") === -1;
  } catch (t8) {
  }
}(), ro = function(t7) {
  var e2;
  return !(!L(t7) || typeof (e2 = t7.then) != "function") && e2;
}, no = function(t7, e2) {
  if (!t7._n) {
    t7._n = true;
    var r2 = t7._c;
    Wa(function() {
      for (var n2 = t7._v, i2 = t7._s == 1, a2 = 0, o2 = function(e3) {
        var r3, a3, o3, s2 = i2 ? e3.ok : e3.fail, u2 = e3.resolve, c2 = e3.reject, f2 = e3.domain;
        try {
          s2 ? (i2 || (t7._h == 2 && oo(t7), t7._h = 1), s2 === true ? r3 = n2 : (f2 && f2.enter(), r3 = s2(n2), f2 && (f2.exit(), o3 = true)), r3 === e3.promise ? c2(Ha("Promise-chain cycle")) : (a3 = ro(r3)) ? a3.call(r3, u2, c2) : u2(r3)) : c2(n2);
        } catch (t8) {
          f2 && !o3 && f2.exit(), c2(t8);
        }
      }; r2.length > a2; )
        o2(r2[a2++]);
      t7._c = [], t7._n = false, e2 && !t7._h && io(t7);
    });
  }
}, io = function(t7) {
  za.call(_, function() {
    var e2, r2, n2, i2 = t7._v, a2 = ao(t7);
    if (a2 && (e2 = ja(function() {
      Za ? Qa.emit("unhandledRejection", i2, t7) : (r2 = _.onunhandledrejection) ? r2({ promise: t7, reason: i2 }) : (n2 = _.console) && n2.error && n2.error("Unhandled promise rejection", i2);
    }), t7._h = Za || ao(t7) ? 2 : 1), t7._a = void 0, a2 && e2.e)
      throw e2.v;
  });
}, ao = function(t7) {
  return t7._h !== 1 && (t7._a || t7._c).length === 0;
}, oo = function(t7) {
  za.call(_, function() {
    var e2;
    Za ? Qa.emit("rejectionHandled", t7) : (e2 = _.onrejectionhandled) && e2({ promise: t7, reason: t7._v });
  });
}, so = function(t7) {
  var e2 = this;
  e2._d || (e2._d = true, (e2 = e2._w || e2)._v = t7, e2._s = 2, e2._a || (e2._a = e2._c.slice()), no(e2, true));
}, uo = function(t7) {
  var e2, r2 = this;
  if (!r2._d) {
    r2._d = true, r2 = r2._w || r2;
    try {
      if (r2 === t7)
        throw Ha("Promise can't be resolved itself");
      (e2 = ro(t7)) ? Wa(function() {
        var n2 = { _w: r2, _d: false };
        try {
          e2.call(t7, $(uo, n2, 1), $(so, n2, 1));
        } catch (t8) {
          so.call(n2, t8);
        }
      }) : (r2._v = t7, r2._s = 1, no(r2, false));
    } catch (t8) {
      so.call({ _w: r2, _d: false }, t8);
    }
  }
};
eo || ($a = function(t7) {
  ga(this, $a, "Promise", "_h"), X(t7), Ua.call(this);
  try {
    t7($(uo, this, 1), $(so, this, 1));
  } catch (t8) {
    so.call(this, t8);
  }
}, (Ua = function(t7) {
  this._c = [], this._a = void 0, this._s = 0, this._d = false, this._v = void 0, this._h = 0, this._n = false;
}).prototype = Ga($a.prototype, { then: function(t7, e2) {
  var r2 = to(ca(this, $a));
  return r2.ok = typeof t7 != "function" || t7, r2.fail = typeof e2 == "function" && e2, r2.domain = Za ? Qa.domain : void 0, this._c.push(r2), this._a && this._a.push(r2), this._s && no(this, false), r2.promise;
}, catch: function(t7) {
  return this.then(void 0, t7);
} }), Da = function() {
  var t7 = new Ua();
  this.promise = t7, this.resolve = $(uo, t7, 1), this.reject = $(so, t7, 1);
}, Ma.f = to = function(t7) {
  return t7 === $a || t7 === Va ? new Da(t7) : xa(t7);
}), J(J.G + J.W + J.F * !eo, { Promise: $a }), it($a, "Promise"), wi("Promise"), Va = O.Promise, J(J.S + J.F * !eo, "Promise", { reject: function(t7) {
  var e2 = to(this);
  return (0, e2.reject)(t7), e2.promise;
} }), J(J.S + J.F * !eo, "Promise", { resolve: function(t7) {
  return qa(this, t7);
} }), J(J.S + J.F * !(eo && Yn(function(t7) {
  $a.all(t7).catch(Ja);
})), "Promise", { all: function(t7) {
  var e2 = this, r2 = to(e2), n2 = r2.resolve, i2 = r2.reject, a2 = ja(function() {
    var r3 = [], a3 = 0, o2 = 1;
    va(t7, false, function(t8) {
      var s2 = a3++, u2 = false;
      r3.push(void 0), o2++, e2.resolve(t8).then(function(t9) {
        u2 || (u2 = true, r3[s2] = t9, --o2 || n2(r3));
      }, i2);
    }), --o2 || n2(r3);
  });
  return a2.e && i2(a2.v), r2.promise;
}, race: function(t7) {
  var e2 = this, r2 = to(e2), n2 = r2.reject, i2 = ja(function() {
    va(t7, false, function(t8) {
      e2.resolve(t8).then(r2.resolve, n2);
    });
  });
  return i2.e && n2(i2.v), r2.promise;
} });
var co = function(t7, e2) {
  if (!L(t7) || t7._t !== e2)
    throw TypeError("Incompatible receiver, " + e2 + " required!");
  return t7;
}, fo = F.f, lo = tt.fastKey, ho = R ? "_s" : "size", po = function(t7, e2) {
  var r2, n2 = lo(e2);
  if (n2 !== "F")
    return t7._i[n2];
  for (r2 = t7._f; r2; r2 = r2.n)
    if (r2.k == e2)
      return r2;
}, yo = { getConstructor: function(t7, e2, r2, n2) {
  var i2 = t7(function(t8, a2) {
    ga(t8, i2, e2, "_i"), t8._t = e2, t8._i = Mt(null), t8._f = void 0, t8._l = void 0, t8[ho] = 0, a2 != null && va(a2, r2, t8[n2], t8);
  });
  return Ga(i2.prototype, { clear: function() {
    for (var t8 = co(this, e2), r3 = t8._i, n3 = t8._f; n3; n3 = n3.n)
      n3.r = true, n3.p && (n3.p = n3.p.n = void 0), delete r3[n3.i];
    t8._f = t8._l = void 0, t8[ho] = 0;
  }, delete: function(t8) {
    var r3 = co(this, e2), n3 = po(r3, t8);
    if (n3) {
      var i3 = n3.n, a2 = n3.p;
      delete r3._i[n3.i], n3.r = true, a2 && (a2.n = i3), i3 && (i3.p = a2), r3._f == n3 && (r3._f = i3), r3._l == n3 && (r3._l = a2), r3[ho]--;
    }
    return !!n3;
  }, forEach: function(t8) {
    co(this, e2);
    for (var r3, n3 = $(t8, arguments.length > 1 ? arguments[1] : void 0, 3); r3 = r3 ? r3.n : this._f; )
      for (n3(r3.v, r3.k, this); r3 && r3.r; )
        r3 = r3.p;
  }, has: function(t8) {
    return !!po(co(this, e2), t8);
  } }), R && fo(i2.prototype, "size", { get: function() {
    return co(this, e2)[ho];
  } }), i2;
}, def: function(t7, e2, r2) {
  var n2, i2, a2 = po(t7, e2);
  return a2 ? a2.v = r2 : (t7._l = a2 = { i: i2 = lo(e2, true), k: e2, v: r2, p: n2 = t7._l, n: void 0, r: false }, t7._f || (t7._f = a2), n2 && (n2.n = a2), t7[ho]++, i2 !== "F" && (t7._i[i2] = a2)), t7;
}, getEntry: po, setStrong: function(t7, e2, r2) {
  vn(t7, e2, function(t8, r3) {
    this._t = co(t8, e2), this._k = r3, this._l = void 0;
  }, function() {
    for (var t8 = this, e3 = t8._k, r3 = t8._l; r3 && r3.r; )
      r3 = r3.p;
    return t8._t && (t8._l = r3 = r3 ? r3.n : t8._t._f) ? _i(0, e3 == "keys" ? r3.k : e3 == "values" ? r3.v : [r3.k, r3.v]) : (t8._t = void 0, _i(1));
  }, r2 ? "entries" : "values", !r2, true), wi(e2);
} }, go = function(t7, e2, r2, n2, i2, a2) {
  var o2 = _[t7], s2 = o2, u2 = i2 ? "set" : "add", c2 = s2 && s2.prototype, f2 = {}, l2 = function(t8) {
    var e3 = c2[t8];
    Y(c2, t8, t8 == "delete" || t8 == "has" ? function(t9) {
      return !(a2 && !L(t9)) && e3.call(this, t9 === 0 ? 0 : t9);
    } : t8 == "get" ? function(t9) {
      return a2 && !L(t9) ? void 0 : e3.call(this, t9 === 0 ? 0 : t9);
    } : t8 == "add" ? function(t9) {
      return e3.call(this, t9 === 0 ? 0 : t9), this;
    } : function(t9, r3) {
      return e3.call(this, t9 === 0 ? 0 : t9, r3), this;
    });
  };
  if (typeof s2 == "function" && (a2 || c2.forEach && !k(function() {
    new s2().entries().next();
  }))) {
    var h2 = new s2(), p2 = h2[u2](a2 ? {} : -0, 1) != h2, d2 = k(function() {
      h2.has(1);
    }), y2 = Yn(function(t8) {
      new s2(t8);
    }), g2 = !a2 && k(function() {
      for (var t8 = new s2(), e3 = 5; e3--; )
        t8[u2](e3, e3);
      return !t8.has(-0);
    });
    y2 || ((s2 = e2(function(e3, r3) {
      ga(e3, s2, t7);
      var n3 = pr(new o2(), e3, s2);
      return r3 != null && va(r3, i2, n3[u2], n3), n3;
    })).prototype = c2, c2.constructor = s2), (d2 || g2) && (l2("delete"), l2("has"), i2 && l2("get")), (g2 || p2) && l2(u2), a2 && c2.clear && delete c2.clear;
  } else
    s2 = n2.getConstructor(e2, t7, i2, u2), Ga(s2.prototype, r2), tt.NEED = true;
  return it(s2, t7), f2[t7] = s2, J(J.G + J.W + J.F * (s2 != o2), f2), a2 || n2.setStrong(s2, t7, i2), s2;
}, vo = go("Map", function(t7) {
  return function() {
    return t7(this, arguments.length > 0 ? arguments[0] : void 0);
  };
}, { get: function(t7) {
  var e2 = yo.getEntry(co(this, "Map"), t7);
  return e2 && e2.v;
}, set: function(t7, e2) {
  return yo.def(co(this, "Map"), t7 === 0 ? 0 : t7, e2);
} }, yo, true), mo = go("Set", function(t7) {
  return function() {
    return t7(this, arguments.length > 0 ? arguments[0] : void 0);
  };
}, { add: function(t7) {
  return yo.def(co(this, "Set"), t7 = t7 === 0 ? 0 : t7, t7);
} }, yo), Co = tt.getWeak, Eo = ni(5), So = ni(6), bo = 0, To = function(t7) {
  return t7._l || (t7._l = new Io());
}, Io = function() {
  this.a = [];
}, Ao = function(t7, e2) {
  return Eo(t7.a, function(t8) {
    return t8[0] === e2;
  });
};
Io.prototype = { get: function(t7) {
  var e2 = Ao(this, t7);
  if (e2)
    return e2[1];
}, has: function(t7) {
  return !!Ao(this, t7);
}, set: function(t7, e2) {
  var r2 = Ao(this, t7);
  r2 ? r2[1] = e2 : this.a.push([t7, e2]);
}, delete: function(t7) {
  var e2 = So(this.a, function(e3) {
    return e3[0] === t7;
  });
  return ~e2 && this.a.splice(e2, 1), !!~e2;
} };
var wo = { getConstructor: function(t7, e2, r2, n2) {
  var i2 = t7(function(t8, a2) {
    ga(t8, i2, e2, "_i"), t8._t = e2, t8._i = bo++, t8._l = void 0, a2 != null && va(a2, r2, t8[n2], t8);
  });
  return Ga(i2.prototype, { delete: function(t8) {
    if (!L(t8))
      return false;
    var r3 = Co(t8);
    return r3 === true ? To(co(this, e2)).delete(t8) : r3 && N(r3, this._i) && delete r3[this._i];
  }, has: function(t8) {
    if (!L(t8))
      return false;
    var r3 = Co(t8);
    return r3 === true ? To(co(this, e2)).has(t8) : r3 && N(r3, this._i);
  } }), i2;
}, def: function(t7, e2, r2) {
  var n2 = Co(P(e2), true);
  return n2 === true ? To(t7).set(e2, r2) : n2[t7._i] = r2, t7;
}, ufstore: To }, _o = w(function(t7) {
  var e2, r2 = ni(0), n2 = co, i2 = !_.ActiveXObject && "ActiveXObject" in _, a2 = "WeakMap", o2 = tt.getWeak, s2 = Object.isExtensible, u2 = wo.ufstore, c2 = function(t8) {
    return function() {
      return t8(this, arguments.length > 0 ? arguments[0] : void 0);
    };
  }, f2 = { get: function(t8) {
    if (L(t8)) {
      var e3 = o2(t8);
      return e3 === true ? u2(co(this, a2)).get(t8) : e3 ? e3[this._i] : void 0;
    }
  }, set: function(t8, e3) {
    return wo.def(co(this, a2), t8, e3);
  } }, l2 = t7.exports = go(a2, c2, f2, wo, true, true);
  n2 && i2 && (e2 = wo.getConstructor(c2, a2), Pe(e2.prototype, f2), tt.NEED = true, r2(["delete", "has", "get", "set"], function(t8) {
    var r3 = l2.prototype, n3 = r3[t8];
    Y(r3, t8, function(r4, i3) {
      if (L(r4) && !s2(r4)) {
        this._f || (this._f = new e2());
        var a3 = this._f[t8](r4, i3);
        return t8 == "set" ? this : a3;
      }
      return n3.call(this, r4, i3);
    });
  }));
});
go("WeakSet", function(t7) {
  return function() {
    return t7(this, arguments.length > 0 ? arguments[0] : void 0);
  };
}, { add: function(t7) {
  return wo.def(co(this, "WeakSet"), t7, true);
} }, wo, false, true);
for (var Bo, No = W("typed_array"), ko = W("view"), Ro = !(!_.ArrayBuffer || !_.DataView), Oo = Ro, Lo = 0, Po = "Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(","); Lo < 9; )
  (Bo = _[Po[Lo++]]) ? (q(Bo.prototype, No, true), q(Bo.prototype, ko, true)) : Oo = false;
var Uo = { ABV: Ro, CONSTR: Oo, TYPED: No, VIEW: ko }, xo = function(t7) {
  if (t7 === void 0)
    return 0;
  var e2 = yt(t7), r2 = vt(e2);
  if (e2 !== r2)
    throw RangeError("Wrong length!");
  return r2;
}, Do = w(function(t7, e2) {
  var r2 = Ft.f, n2 = F.f, i2 = "ArrayBuffer", a2 = "DataView", o2 = "Wrong index!", s2 = _.ArrayBuffer, u2 = _.DataView, c2 = _.Math, f2 = _.RangeError, l2 = _.Infinity, h2 = s2, p2 = c2.abs, d2 = c2.pow, y2 = c2.floor, g2 = c2.log, v2 = c2.LN2, m2 = "buffer", C2 = "byteLength", E2 = "byteOffset", S2 = R ? "_b" : m2, b2 = R ? "_l" : C2, T2 = R ? "_o" : E2;
  function I2(t8, e3, r3) {
    var n3, i3, a3, o3 = new Array(r3), s3 = 8 * r3 - e3 - 1, u3 = (1 << s3) - 1, c3 = u3 >> 1, f3 = e3 === 23 ? d2(2, -24) - d2(2, -77) : 0, h3 = 0, m3 = t8 < 0 || t8 === 0 && 1 / t8 < 0 ? 1 : 0;
    for ((t8 = p2(t8)) != t8 || t8 === l2 ? (i3 = t8 != t8 ? 1 : 0, n3 = u3) : (n3 = y2(g2(t8) / v2), t8 * (a3 = d2(2, -n3)) < 1 && (n3--, a3 *= 2), (t8 += n3 + c3 >= 1 ? f3 / a3 : f3 * d2(2, 1 - c3)) * a3 >= 2 && (n3++, a3 /= 2), n3 + c3 >= u3 ? (i3 = 0, n3 = u3) : n3 + c3 >= 1 ? (i3 = (t8 * a3 - 1) * d2(2, e3), n3 += c3) : (i3 = t8 * d2(2, c3 - 1) * d2(2, e3), n3 = 0)); e3 >= 8; o3[h3++] = 255 & i3, i3 /= 256, e3 -= 8)
      ;
    for (n3 = n3 << e3 | i3, s3 += e3; s3 > 0; o3[h3++] = 255 & n3, n3 /= 256, s3 -= 8)
      ;
    return o3[--h3] |= 128 * m3, o3;
  }
  function A2(t8, e3, r3) {
    var n3, i3 = 8 * r3 - e3 - 1, a3 = (1 << i3) - 1, o3 = a3 >> 1, s3 = i3 - 7, u3 = r3 - 1, c3 = t8[u3--], f3 = 127 & c3;
    for (c3 >>= 7; s3 > 0; f3 = 256 * f3 + t8[u3], u3--, s3 -= 8)
      ;
    for (n3 = f3 & (1 << -s3) - 1, f3 >>= -s3, s3 += e3; s3 > 0; n3 = 256 * n3 + t8[u3], u3--, s3 -= 8)
      ;
    if (f3 === 0)
      f3 = 1 - o3;
    else {
      if (f3 === a3)
        return n3 ? NaN : c3 ? -l2 : l2;
      n3 += d2(2, e3), f3 -= o3;
    }
    return (c3 ? -1 : 1) * n3 * d2(2, f3 - e3);
  }
  function w2(t8) {
    return t8[3] << 24 | t8[2] << 16 | t8[1] << 8 | t8[0];
  }
  function B2(t8) {
    return [255 & t8];
  }
  function N2(t8) {
    return [255 & t8, t8 >> 8 & 255];
  }
  function O2(t8) {
    return [255 & t8, t8 >> 8 & 255, t8 >> 16 & 255, t8 >> 24 & 255];
  }
  function L2(t8) {
    return I2(t8, 52, 8);
  }
  function P2(t8) {
    return I2(t8, 23, 4);
  }
  function U2(t8, e3, r3) {
    n2(t8.prototype, e3, { get: function() {
      return this[r3];
    } });
  }
  function x2(t8, e3, r3, n3) {
    var i3 = xo(+r3);
    if (i3 + e3 > t8[b2])
      throw f2(o2);
    var a3 = t8[S2]._b, s3 = i3 + t8[T2], u3 = a3.slice(s3, s3 + e3);
    return n3 ? u3 : u3.reverse();
  }
  function D2(t8, e3, r3, n3, i3, a3) {
    var s3 = xo(+r3);
    if (s3 + e3 > t8[b2])
      throw f2(o2);
    for (var u3 = t8[S2]._b, c3 = s3 + t8[T2], l3 = n3(+i3), h3 = 0; h3 < e3; h3++)
      u3[c3 + h3] = l3[a3 ? h3 : e3 - h3 - 1];
  }
  if (Uo.ABV) {
    if (!k(function() {
      s2(1);
    }) || !k(function() {
      new s2(-1);
    }) || k(function() {
      return new s2(), new s2(1.5), new s2(NaN), s2.name != i2;
    })) {
      for (var V2, M2 = (s2 = function(t8) {
        return ga(this, s2), new h2(xo(t8));
      }).prototype = h2.prototype, j2 = r2(h2), K2 = 0; j2.length > K2; )
        (V2 = j2[K2++]) in s2 || q(s2, V2, h2[V2]);
      M2.constructor = s2;
    }
    var G2 = new u2(new s2(2)), z2 = u2.prototype.setInt8;
    G2.setInt8(0, 2147483648), G2.setInt8(1, 2147483649), !G2.getInt8(0) && G2.getInt8(1) || Ga(u2.prototype, { setInt8: function(t8, e3) {
      z2.call(this, t8, e3 << 24 >> 24);
    }, setUint8: function(t8, e3) {
      z2.call(this, t8, e3 << 24 >> 24);
    } }, true);
  } else
    s2 = function(t8) {
      ga(this, s2, i2);
      var e3 = xo(t8);
      this._b = Ei.call(new Array(e3), 0), this[b2] = e3;
    }, u2 = function(t8, e3, r3) {
      ga(this, u2, a2), ga(t8, s2, a2);
      var n3 = t8[b2], i3 = yt(e3);
      if (i3 < 0 || i3 > n3)
        throw f2("Wrong offset!");
      if (i3 + (r3 = r3 === void 0 ? n3 - i3 : vt(r3)) > n3)
        throw f2("Wrong length!");
      this[S2] = t8, this[T2] = i3, this[b2] = r3;
    }, R && (U2(s2, C2, "_l"), U2(u2, m2, "_b"), U2(u2, C2, "_l"), U2(u2, E2, "_o")), Ga(u2.prototype, { getInt8: function(t8) {
      return x2(this, 1, t8)[0] << 24 >> 24;
    }, getUint8: function(t8) {
      return x2(this, 1, t8)[0];
    }, getInt16: function(t8) {
      var e3 = x2(this, 2, t8, arguments[1]);
      return (e3[1] << 8 | e3[0]) << 16 >> 16;
    }, getUint16: function(t8) {
      var e3 = x2(this, 2, t8, arguments[1]);
      return e3[1] << 8 | e3[0];
    }, getInt32: function(t8) {
      return w2(x2(this, 4, t8, arguments[1]));
    }, getUint32: function(t8) {
      return w2(x2(this, 4, t8, arguments[1])) >>> 0;
    }, getFloat32: function(t8) {
      return A2(x2(this, 4, t8, arguments[1]), 23, 4);
    }, getFloat64: function(t8) {
      return A2(x2(this, 8, t8, arguments[1]), 52, 8);
    }, setInt8: function(t8, e3) {
      D2(this, 1, t8, B2, e3);
    }, setUint8: function(t8, e3) {
      D2(this, 1, t8, B2, e3);
    }, setInt16: function(t8, e3) {
      D2(this, 2, t8, N2, e3, arguments[2]);
    }, setUint16: function(t8, e3) {
      D2(this, 2, t8, N2, e3, arguments[2]);
    }, setInt32: function(t8, e3) {
      D2(this, 4, t8, O2, e3, arguments[2]);
    }, setUint32: function(t8, e3) {
      D2(this, 4, t8, O2, e3, arguments[2]);
    }, setFloat32: function(t8, e3) {
      D2(this, 4, t8, P2, e3, arguments[2]);
    }, setFloat64: function(t8, e3) {
      D2(this, 8, t8, L2, e3, arguments[2]);
    } });
  it(s2, i2), it(u2, a2), q(u2.prototype, Uo.VIEW, true), e2.ArrayBuffer = s2, e2.DataView = u2;
}), Vo = _.ArrayBuffer, Mo = Do.ArrayBuffer, jo = Do.DataView, Fo = Uo.ABV && Vo.isView, Ko = Mo.prototype.slice, qo = Uo.VIEW;
J(J.G + J.W + J.F * (Vo !== Mo), { ArrayBuffer: Mo }), J(J.S + J.F * !Uo.CONSTR, "ArrayBuffer", { isView: function(t7) {
  return Fo && Fo(t7) || L(t7) && qo in t7;
} }), J(J.P + J.U + J.F * k(function() {
  return !new Mo(2).slice(1, void 0).byteLength;
}), "ArrayBuffer", { slice: function(t7, e2) {
  if (Ko !== void 0 && e2 === void 0)
    return Ko.call(P(this), t7);
  for (var r2 = P(this).byteLength, n2 = Et(t7, r2), i2 = Et(e2 === void 0 ? r2 : e2, r2), a2 = new (ca(this, Mo))(vt(i2 - n2)), o2 = new jo(this), s2 = new jo(a2), u2 = 0; n2 < i2; )
    s2.setUint8(u2++, o2.getUint8(n2++));
  return a2;
} }), wi("ArrayBuffer"), J(J.G + J.W + J.F * !Uo.ABV, { DataView: Do.DataView });
var Go = w(function(t7) {
  if (R) {
    var e2 = _, r2 = k, n2 = J, i2 = Uo, a2 = Do, o2 = $, s2 = ga, u2 = K, c2 = q, f2 = Ga, l2 = yt, h2 = vt, p2 = xo, d2 = Et, y2 = M, g2 = N, v2 = je, m2 = L, C2 = Ot, E2 = Kn, S2 = Mt, b2 = Ne, T2 = Ft.f, I2 = zn, A2 = W, w2 = et, B2 = ni, O2 = St, P2 = ca, U2 = Bi, x2 = ln, D2 = Yn, V2 = wi, j2 = Ei, G2 = gi, z2 = F, H2 = Ht, Q2 = z2.f, Y2 = H2.f, X2 = e2.RangeError, Z2 = e2.TypeError, tt2 = e2.Uint8Array, rt2 = "ArrayBuffer", nt2 = "SharedArrayBuffer", it2 = "BYTES_PER_ELEMENT", at2 = Array.prototype, ot2 = a2.ArrayBuffer, st2 = a2.DataView, ut2 = B2(0), ct2 = B2(2), ft2 = B2(3), lt2 = B2(4), ht2 = B2(5), pt2 = B2(6), dt2 = O2(true), gt2 = O2(false), mt2 = U2.values, Ct2 = U2.keys, bt2 = U2.entries, Tt2 = at2.lastIndexOf, It2 = at2.reduce, At2 = at2.reduceRight, wt2 = at2.join, _t2 = at2.sort, Bt2 = at2.slice, Nt2 = at2.toString, kt2 = at2.toLocaleString, Rt2 = w2("iterator"), Lt2 = w2("toStringTag"), Pt2 = A2("typed_constructor"), Ut2 = A2("def_constructor"), xt2 = i2.CONSTR, Dt2 = i2.TYPED, Vt2 = i2.VIEW, jt2 = "Wrong length!", Kt2 = B2(1, function(t8, e3) {
      return Qt2(P2(t8, t8[Ut2]), e3);
    }), qt2 = r2(function() {
      return new tt2(new Uint16Array([1]).buffer)[0] === 1;
    }), Gt2 = !!tt2 && !!tt2.prototype.set && r2(function() {
      new tt2(1).set({});
    }), zt2 = function(t8, e3) {
      var r3 = l2(t8);
      if (r3 < 0 || r3 % e3)
        throw X2("Wrong offset!");
      return r3;
    }, Wt2 = function(t8) {
      if (m2(t8) && Dt2 in t8)
        return t8;
      throw Z2(t8 + " is not a typed array!");
    }, Qt2 = function(t8, e3) {
      if (!m2(t8) || !(Pt2 in t8))
        throw Z2("It is not a typed array constructor!");
      return new t8(e3);
    }, Yt2 = function(t8, e3) {
      return Xt2(P2(t8, t8[Ut2]), e3);
    }, Xt2 = function(t8, e3) {
      for (var r3 = 0, n3 = e3.length, i3 = Qt2(t8, n3); n3 > r3; )
        i3[r3] = e3[r3++];
      return i3;
    }, $t2 = function(t8, e3, r3) {
      Q2(t8, e3, { get: function() {
        return this._d[r3];
      } });
    }, Zt2 = function(t8) {
      var e3, r3, n3, i3, a3, s3, u3 = C2(t8), c3 = arguments.length, f3 = c3 > 1 ? arguments[1] : void 0, l3 = f3 !== void 0, p3 = I2(u3);
      if (p3 != null && !E2(p3)) {
        for (s3 = p3.call(u3), n3 = [], e3 = 0; !(a3 = s3.next()).done; e3++)
          n3.push(a3.value);
        u3 = n3;
      }
      for (l3 && c3 > 2 && (f3 = o2(f3, arguments[2], 2)), e3 = 0, r3 = h2(u3.length), i3 = Qt2(this, r3); r3 > e3; e3++)
        i3[e3] = l3 ? f3(u3[e3], e3) : u3[e3];
      return i3;
    }, Jt2 = function() {
      for (var t8 = 0, e3 = arguments.length, r3 = Qt2(this, e3); e3 > t8; )
        r3[t8] = arguments[t8++];
      return r3;
    }, te2 = !!tt2 && r2(function() {
      kt2.call(new tt2(1));
    }), ee2 = function() {
      return kt2.apply(te2 ? Bt2.call(Wt2(this)) : Wt2(this), arguments);
    }, re2 = { copyWithin: function(t8, e3) {
      return G2.call(Wt2(this), t8, e3, arguments.length > 2 ? arguments[2] : void 0);
    }, every: function(t8) {
      return lt2(Wt2(this), t8, arguments.length > 1 ? arguments[1] : void 0);
    }, fill: function(t8) {
      return j2.apply(Wt2(this), arguments);
    }, filter: function(t8) {
      return Yt2(this, ct2(Wt2(this), t8, arguments.length > 1 ? arguments[1] : void 0));
    }, find: function(t8) {
      return ht2(Wt2(this), t8, arguments.length > 1 ? arguments[1] : void 0);
    }, findIndex: function(t8) {
      return pt2(Wt2(this), t8, arguments.length > 1 ? arguments[1] : void 0);
    }, forEach: function(t8) {
      ut2(Wt2(this), t8, arguments.length > 1 ? arguments[1] : void 0);
    }, indexOf: function(t8) {
      return gt2(Wt2(this), t8, arguments.length > 1 ? arguments[1] : void 0);
    }, includes: function(t8) {
      return dt2(Wt2(this), t8, arguments.length > 1 ? arguments[1] : void 0);
    }, join: function(t8) {
      return wt2.apply(Wt2(this), arguments);
    }, lastIndexOf: function(t8) {
      return Tt2.apply(Wt2(this), arguments);
    }, map: function(t8) {
      return Kt2(Wt2(this), t8, arguments.length > 1 ? arguments[1] : void 0);
    }, reduce: function(t8) {
      return It2.apply(Wt2(this), arguments);
    }, reduceRight: function(t8) {
      return At2.apply(Wt2(this), arguments);
    }, reverse: function() {
      for (var t8, e3 = this, r3 = Wt2(e3).length, n3 = Math.floor(r3 / 2), i3 = 0; i3 < n3; )
        t8 = e3[i3], e3[i3++] = e3[--r3], e3[r3] = t8;
      return e3;
    }, some: function(t8) {
      return ft2(Wt2(this), t8, arguments.length > 1 ? arguments[1] : void 0);
    }, sort: function(t8) {
      return _t2.call(Wt2(this), t8);
    }, subarray: function(t8, e3) {
      var r3 = Wt2(this), n3 = r3.length, i3 = d2(t8, n3);
      return new (P2(r3, r3[Ut2]))(r3.buffer, r3.byteOffset + i3 * r3.BYTES_PER_ELEMENT, h2((e3 === void 0 ? n3 : d2(e3, n3)) - i3));
    } }, ne2 = function(t8, e3) {
      return Yt2(this, Bt2.call(Wt2(this), t8, e3));
    }, ie2 = function(t8) {
      Wt2(this);
      var e3 = zt2(arguments[1], 1), r3 = this.length, n3 = C2(t8), i3 = h2(n3.length), a3 = 0;
      if (i3 + e3 > r3)
        throw X2(jt2);
      for (; a3 < i3; )
        this[e3 + a3] = n3[a3++];
    }, ae2 = { entries: function() {
      return bt2.call(Wt2(this));
    }, keys: function() {
      return Ct2.call(Wt2(this));
    }, values: function() {
      return mt2.call(Wt2(this));
    } }, oe2 = function(t8, e3) {
      return m2(t8) && t8[Dt2] && typeof e3 != "symbol" && e3 in t8 && String(+e3) == String(e3);
    }, se2 = function(t8, e3) {
      return oe2(t8, e3 = y2(e3, true)) ? u2(2, t8[e3]) : Y2(t8, e3);
    }, ue2 = function(t8, e3, r3) {
      return !(oe2(t8, e3 = y2(e3, true)) && m2(r3) && g2(r3, "value")) || g2(r3, "get") || g2(r3, "set") || r3.configurable || g2(r3, "writable") && !r3.writable || g2(r3, "enumerable") && !r3.enumerable ? Q2(t8, e3, r3) : (t8[e3] = r3.value, t8);
    };
    xt2 || (H2.f = se2, z2.f = ue2), n2(n2.S + n2.F * !xt2, "Object", { getOwnPropertyDescriptor: se2, defineProperty: ue2 }), r2(function() {
      Nt2.call({});
    }) && (Nt2 = kt2 = function() {
      return wt2.call(this);
    });
    var ce2 = f2({}, re2);
    f2(ce2, ae2), c2(ce2, Rt2, ae2.values), f2(ce2, { slice: ne2, set: ie2, constructor: function() {
    }, toString: Nt2, toLocaleString: ee2 }), $t2(ce2, "buffer", "b"), $t2(ce2, "byteOffset", "o"), $t2(ce2, "byteLength", "l"), $t2(ce2, "length", "e"), Q2(ce2, Lt2, { get: function() {
      return this[Dt2];
    } }), t7.exports = function(t8, a3, o3, u3) {
      var f3 = t8 + ((u3 = !!u3) ? "Clamped" : "") + "Array", l3 = "get" + t8, d3 = "set" + t8, y3 = e2[f3], g3 = y3 || {}, C3 = y3 && b2(y3), E3 = !y3 || !i2.ABV, I3 = {}, A3 = y3 && y3.prototype, w3 = function(t9, e3) {
        Q2(t9, e3, { get: function() {
          return function(t10, e4) {
            var r3 = t10._d;
            return r3.v[l3](e4 * a3 + r3.o, qt2);
          }(this, e3);
        }, set: function(t10) {
          return function(t11, e4, r3) {
            var n3 = t11._d;
            u3 && (r3 = (r3 = Math.round(r3)) < 0 ? 0 : r3 > 255 ? 255 : 255 & r3), n3.v[d3](e4 * a3 + n3.o, r3, qt2);
          }(this, e3, t10);
        }, enumerable: true });
      };
      E3 ? (y3 = o3(function(t9, e3, r3, n3) {
        s2(t9, y3, f3, "_d");
        var i3, o4, u4, l4, d4 = 0, g4 = 0;
        if (m2(e3)) {
          if (!(e3 instanceof ot2 || (l4 = v2(e3)) == rt2 || l4 == nt2))
            return Dt2 in e3 ? Xt2(y3, e3) : Zt2.call(y3, e3);
          i3 = e3, g4 = zt2(r3, a3);
          var C4 = e3.byteLength;
          if (n3 === void 0) {
            if (C4 % a3)
              throw X2(jt2);
            if ((o4 = C4 - g4) < 0)
              throw X2(jt2);
          } else if ((o4 = h2(n3) * a3) + g4 > C4)
            throw X2(jt2);
          u4 = o4 / a3;
        } else
          u4 = p2(e3), i3 = new ot2(o4 = u4 * a3);
        for (c2(t9, "_d", { b: i3, o: g4, l: o4, e: u4, v: new st2(i3) }); d4 < u4; )
          w3(t9, d4++);
      }), A3 = y3.prototype = S2(ce2), c2(A3, "constructor", y3)) : r2(function() {
        y3(1);
      }) && r2(function() {
        new y3(-1);
      }) && D2(function(t9) {
        new y3(), new y3(null), new y3(1.5), new y3(t9);
      }, true) || (y3 = o3(function(t9, e3, r3, n3) {
        var i3;
        return s2(t9, y3, f3), m2(e3) ? e3 instanceof ot2 || (i3 = v2(e3)) == rt2 || i3 == nt2 ? n3 !== void 0 ? new g3(e3, zt2(r3, a3), n3) : r3 !== void 0 ? new g3(e3, zt2(r3, a3)) : new g3(e3) : Dt2 in e3 ? Xt2(y3, e3) : Zt2.call(y3, e3) : new g3(p2(e3));
      }), ut2(C3 !== Function.prototype ? T2(g3).concat(T2(C3)) : T2(g3), function(t9) {
        t9 in y3 || c2(y3, t9, g3[t9]);
      }), y3.prototype = A3, A3.constructor = y3);
      var _2 = A3[Rt2], B3 = !!_2 && (_2.name == "values" || _2.name == null), N2 = ae2.values;
      c2(y3, Pt2, true), c2(A3, Dt2, f3), c2(A3, Vt2, true), c2(A3, Ut2, y3), (u3 ? new y3(1)[Lt2] == f3 : Lt2 in A3) || Q2(A3, Lt2, { get: function() {
        return f3;
      } }), I3[f3] = y3, n2(n2.G + n2.W + n2.F * (y3 != g3), I3), n2(n2.S, f3, { BYTES_PER_ELEMENT: a3 }), n2(n2.S + n2.F * r2(function() {
        g3.of.call(y3, 1);
      }), f3, { from: Zt2, of: Jt2 }), it2 in A3 || c2(A3, it2, a3), n2(n2.P, f3, re2), V2(f3), n2(n2.P + n2.F * Gt2, f3, { set: ie2 }), n2(n2.P + n2.F * !B3, f3, ae2), A3.toString != Nt2 && (A3.toString = Nt2), n2(n2.P + n2.F * r2(function() {
        new y3(1).slice();
      }), f3, { slice: ne2 }), n2(n2.P + n2.F * (r2(function() {
        return [1, 2].toLocaleString() != new y3([1, 2]).toLocaleString();
      }) || !r2(function() {
        A3.toLocaleString.call([1, 2]);
      })), f3, { toLocaleString: ee2 }), x2[f3] = B3 ? _2 : N2, B3 || c2(A3, Rt2, N2);
    };
  } else
    t7.exports = function() {
    };
});
Go("Int8", 1, function(t7) {
  return function(e2, r2, n2) {
    return t7(this, e2, r2, n2);
  };
}), Go("Uint8", 1, function(t7) {
  return function(e2, r2, n2) {
    return t7(this, e2, r2, n2);
  };
}), Go("Uint8", 1, function(t7) {
  return function(e2, r2, n2) {
    return t7(this, e2, r2, n2);
  };
}, true), Go("Int16", 2, function(t7) {
  return function(e2, r2, n2) {
    return t7(this, e2, r2, n2);
  };
}), Go("Uint16", 2, function(t7) {
  return function(e2, r2, n2) {
    return t7(this, e2, r2, n2);
  };
}), Go("Int32", 4, function(t7) {
  return function(e2, r2, n2) {
    return t7(this, e2, r2, n2);
  };
}), Go("Uint32", 4, function(t7) {
  return function(e2, r2, n2) {
    return t7(this, e2, r2, n2);
  };
}), Go("Float32", 4, function(t7) {
  return function(e2, r2, n2) {
    return t7(this, e2, r2, n2);
  };
}), Go("Float64", 8, function(t7) {
  return function(e2, r2, n2) {
    return t7(this, e2, r2, n2);
  };
});
var zo = (_.Reflect || {}).apply, Wo = Function.apply;
J(J.S + J.F * !k(function() {
  zo(function() {
  });
}), "Reflect", { apply: function(t7, e2, r2) {
  var n2 = X(t7), i2 = P(r2);
  return zo ? zo(n2, e2, i2) : Wo.call(n2, e2, i2);
} });
var Ho = (_.Reflect || {}).construct, Qo = k(function() {
  function t7() {
  }
  return !(Ho(function() {
  }, [], t7) instanceof t7);
}), Yo = !k(function() {
  Ho(function() {
  });
});
J(J.S + J.F * (Qo || Yo), "Reflect", { construct: function(t7, e2) {
  X(t7), P(e2);
  var r2 = arguments.length < 3 ? t7 : X(arguments[2]);
  if (Yo && !Qo)
    return Ho(t7, e2, r2);
  if (t7 == r2) {
    switch (e2.length) {
      case 0:
        return new t7();
      case 1:
        return new t7(e2[0]);
      case 2:
        return new t7(e2[0], e2[1]);
      case 3:
        return new t7(e2[0], e2[1], e2[2]);
      case 4:
        return new t7(e2[0], e2[1], e2[2], e2[3]);
    }
    var n2 = [null];
    return n2.push.apply(n2, e2), new (We.apply(t7, n2))();
  }
  var i2 = r2.prototype, a2 = Mt(L(i2) ? i2 : Object.prototype), o2 = Function.apply.call(t7, a2, e2);
  return L(o2) ? o2 : a2;
} }), J(J.S + J.F * k(function() {
  Reflect.defineProperty(F.f({}, 1, { value: 1 }), 1, { value: 2 });
}), "Reflect", { defineProperty: function(t7, e2, r2) {
  P(t7), e2 = M(e2, true), P(r2);
  try {
    return F.f(t7, e2, r2), true;
  } catch (t8) {
    return false;
  }
} });
var Xo = Ht.f;
J(J.S, "Reflect", { deleteProperty: function(t7, e2) {
  var r2 = Xo(P(t7), e2);
  return !(r2 && !r2.configurable) && delete t7[e2];
} });
var $o = function(t7) {
  this._t = P(t7), this._i = 0;
  var e2, r2 = this._k = [];
  for (e2 in t7)
    r2.push(e2);
};
pn($o, "Object", function() {
  var t7, e2 = this, r2 = e2._k;
  do {
    if (e2._i >= r2.length)
      return { value: void 0, done: true };
  } while (!((t7 = r2[e2._i++]) in e2._t));
  return { value: t7, done: false };
}), J(J.S, "Reflect", { enumerate: function(t7) {
  return new $o(t7);
} }), J(J.S, "Reflect", { get: function t3(e2, r2) {
  var n2, i2, a2 = arguments.length < 3 ? e2 : arguments[2];
  return P(e2) === a2 ? e2[r2] : (n2 = Ht.f(e2, r2)) ? N(n2, "value") ? n2.value : n2.get !== void 0 ? n2.get.call(a2) : void 0 : L(i2 = Ne(e2)) ? t3(i2, r2, a2) : void 0;
} }), J(J.S, "Reflect", { getOwnPropertyDescriptor: function(t7, e2) {
  return Ht.f(P(t7), e2);
} }), J(J.S, "Reflect", { getPrototypeOf: function(t7) {
  return Ne(P(t7));
} }), J(J.S, "Reflect", { has: function(t7, e2) {
  return e2 in t7;
} });
var Zo = Object.isExtensible;
J(J.S, "Reflect", { isExtensible: function(t7) {
  return P(t7), !Zo || Zo(t7);
} });
var Jo = _.Reflect, ts = Jo && Jo.ownKeys || function(t7) {
  var e2 = Ft.f(P(t7)), r2 = Nt.f;
  return r2 ? e2.concat(r2(t7)) : e2;
};
J(J.S, "Reflect", { ownKeys: ts });
var es = Object.preventExtensions;
J(J.S, "Reflect", { preventExtensions: function(t7) {
  P(t7);
  try {
    return es && es(t7), true;
  } catch (t8) {
    return false;
  }
} }), J(J.S, "Reflect", { set: function t4(e2, r2, n2) {
  var i2, a2, o2 = arguments.length < 4 ? e2 : arguments[3], s2 = Ht.f(P(e2), r2);
  if (!s2) {
    if (L(a2 = Ne(e2)))
      return t4(a2, r2, n2, o2);
    s2 = K(0);
  }
  if (N(s2, "value")) {
    if (s2.writable === false || !L(o2))
      return false;
    if (i2 = Ht.f(o2, r2)) {
      if (i2.get || i2.set || i2.writable === false)
        return false;
      i2.value = n2, F.f(o2, r2, i2);
    } else
      F.f(o2, r2, K(0, n2));
    return true;
  }
  return s2.set !== void 0 && (s2.set.call(o2, n2), true);
} }), De && J(J.S, "Reflect", { setPrototypeOf: function(t7, e2) {
  De.check(t7, e2);
  try {
    return De.set(t7, e2), true;
  } catch (t8) {
    return false;
  }
} });
var rs = St(true);
J(J.P, "Array", { includes: function(t7) {
  return rs(this, t7, arguments.length > 1 ? arguments[1] : void 0);
} }), Ci("includes");
var ns = et("isConcatSpreadable");
var is = function t5(e2, r2, n2, i2, a2, o2, s2, u2) {
  for (var c2, f2, l2 = a2, h2 = 0, p2 = !!s2 && $(s2, u2, 3); h2 < i2; ) {
    if (h2 in n2) {
      if (c2 = p2 ? p2(n2[h2], h2, r2) : n2[h2], f2 = false, L(c2) && (f2 = (f2 = c2[ns]) !== void 0 ? !!f2 : Rt(c2)), f2 && o2 > 0)
        l2 = t5(e2, r2, c2, vt(c2.length), l2, o2 - 1) - 1;
      else {
        if (l2 >= 9007199254740991)
          throw TypeError();
        e2[l2] = c2;
      }
      l2++;
    }
    h2++;
  }
  return l2;
};
J(J.P, "Array", { flatMap: function(t7) {
  var e2, r2, n2 = Ot(this);
  return X(t7), e2 = vt(n2.length), r2 = ri(n2, 0), is(r2, n2, n2, e2, 0, 1, t7, arguments[1]), r2;
} }), Ci("flatMap"), J(J.P, "Array", { flatten: function() {
  var t7 = arguments[0], e2 = Ot(this), r2 = vt(e2.length), n2 = ri(e2, 0);
  return is(n2, e2, e2, r2, 0, t7 === void 0 ? 1 : yt(t7)), n2;
} }), Ci("flatten");
var as = fn(true), os = k(function() {
  return "\u{20BB7}".at(0) !== "\u{20BB7}";
});
J(J.P + J.F * os, "String", { at: function(t7) {
  return as(this, t7);
} });
var ss = function(t7, e2, r2, n2) {
  var i2 = String(lt$3(t7)), a2 = i2.length, o2 = r2 === void 0 ? " " : String(r2), s2 = vt(e2);
  if (s2 <= a2 || o2 == "")
    return i2;
  var u2 = s2 - a2, c2 = Br.call(o2, Math.ceil(u2 / o2.length));
  return c2.length > u2 && (c2 = c2.slice(0, u2)), n2 ? c2 + i2 : i2 + c2;
}, us = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(Ka);
J(J.P + J.F * us, "String", { padStart: function(t7) {
  return ss(this, t7, arguments.length > 1 ? arguments[1] : void 0, true);
} });
var cs = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(Ka);
J(J.P + J.F * cs, "String", { padEnd: function(t7) {
  return ss(this, t7, arguments.length > 1 ? arguments[1] : void 0, false);
} }), ir("trimLeft", function(t7) {
  return function() {
    return t7(this, 1);
  };
}, "trimStart"), ir("trimRight", function(t7) {
  return function() {
    return t7(this, 2);
  };
}, "trimEnd");
var fs$7 = RegExp.prototype, ls = function(t7, e2) {
  this._r = t7, this._s = e2;
};
pn(ls, "RegExp String", function() {
  var t7 = this._r.exec(this._s);
  return { value: t7, done: t7 === null };
}), J(J.P, "String", { matchAll: function(t7) {
  if (lt$3(this), !Sn(t7))
    throw TypeError(t7 + " is not a regexp!");
  var e2 = String(this), r2 = "flags" in fs$7 ? String(t7.flags) : Ni.call(t7), n2 = new RegExp(t7.source, ~r2.indexOf("g") ? r2 : "g" + r2);
  return n2.lastIndex = vt(t7.lastIndex), new ls(n2, e2);
} }), st("asyncIterator"), st("observable"), J(J.S, "Object", { getOwnPropertyDescriptors: function(t7) {
  for (var e2, r2, n2 = ht(t7), i2 = Ht.f, a2 = ts(n2), o2 = {}, s2 = 0; a2.length > s2; )
    (r2 = i2(n2, e2 = a2[s2++])) !== void 0 && qn(o2, e2, r2);
  return o2;
} });
var hs = kt.f, ps = function(t7) {
  return function(e2) {
    for (var r2, n2 = ht(e2), i2 = Bt(n2), a2 = i2.length, o2 = 0, s2 = []; a2 > o2; )
      r2 = i2[o2++], R && !hs.call(n2, r2) || s2.push(t7 ? [r2, n2[r2]] : n2[r2]);
    return s2;
  };
}, ds = ps(false);
J(J.S, "Object", { values: function(t7) {
  return ds(t7);
} });
var ys = ps(true);
J(J.S, "Object", { entries: function(t7) {
  return ys(t7);
} });
var gs = !k(function() {
  var t7 = Math.random();
  __defineSetter__.call(null, t7, function() {
  }), delete _[t7];
});
R && J(J.P + gs, "Object", { __defineGetter__: function(t7, e2) {
  F.f(Ot(this), t7, { get: X(e2), enumerable: true, configurable: true });
} }), R && J(J.P + gs, "Object", { __defineSetter__: function(t7, e2) {
  F.f(Ot(this), t7, { set: X(e2), enumerable: true, configurable: true });
} });
var vs = Ht.f;
R && J(J.P + gs, "Object", { __lookupGetter__: function(t7) {
  var e2, r2 = Ot(this), n2 = M(t7, true);
  do {
    if (e2 = vs(r2, n2))
      return e2.get;
  } while (r2 = Ne(r2));
} });
var ms = Ht.f;
R && J(J.P + gs, "Object", { __lookupSetter__: function(t7) {
  var e2, r2 = Ot(this), n2 = M(t7, true);
  do {
    if (e2 = ms(r2, n2))
      return e2.set;
  } while (r2 = Ne(r2));
} });
var Cs = function(t7, e2) {
  var r2 = [];
  return va(t7, false, r2.push, r2, e2), r2;
}, Es = function(t7) {
  return function() {
    if (je(this) != t7)
      throw TypeError(t7 + "#toJSON isn't generic");
    return Cs(this);
  };
};
J(J.P + J.R, "Map", { toJSON: Es("Map") }), J(J.P + J.R, "Set", { toJSON: Es("Set") });
var Ss = function(t7) {
  J(J.S, t7, { of: function() {
    for (var t8 = arguments.length, e2 = new Array(t8); t8--; )
      e2[t8] = arguments[t8];
    return new this(e2);
  } });
};
Ss("Map"), Ss("Set"), Ss("WeakMap"), Ss("WeakSet");
var bs = function(t7) {
  J(J.S, t7, { from: function(t8) {
    var e2, r2, n2, i2, a2 = arguments[1];
    return X(this), (e2 = a2 !== void 0) && X(a2), t8 == null ? new this() : (r2 = [], e2 ? (n2 = 0, i2 = $(a2, arguments[2], 2), va(t8, false, function(t9) {
      r2.push(i2(t9, n2++));
    })) : va(t8, false, r2.push, r2), new this(r2));
  } });
};
bs("Map"), bs("Set"), bs("WeakMap"), bs("WeakSet"), J(J.G, { global: _ }), J(J.S, "System", { global: _ }), J(J.S, "Error", { isError: function(t7) {
  return ct(t7) === "Error";
} }), J(J.S, "Math", { clamp: function(t7, e2, r2) {
  return Math.min(r2, Math.max(e2, t7));
} }), J(J.S, "Math", { DEG_PER_RAD: Math.PI / 180 });
var Ts = 180 / Math.PI;
J(J.S, "Math", { degrees: function(t7) {
  return t7 * Ts;
} });
var Is = Math.scale || function(t7, e2, r2, n2, i2) {
  return arguments.length === 0 || t7 != t7 || e2 != e2 || r2 != r2 || n2 != n2 || i2 != i2 ? NaN : t7 === 1 / 0 || t7 === -1 / 0 ? t7 : (t7 - e2) * (i2 - n2) / (r2 - e2) + n2;
};
J(J.S, "Math", { fscale: function(t7, e2, r2, n2, i2) {
  return rn(Is(t7, e2, r2, n2, i2));
} }), J(J.S, "Math", { iaddh: function(t7, e2, r2, n2) {
  var i2 = t7 >>> 0, a2 = r2 >>> 0;
  return (e2 >>> 0) + (n2 >>> 0) + ((i2 & a2 | (i2 | a2) & ~(i2 + a2 >>> 0)) >>> 31) | 0;
} }), J(J.S, "Math", { isubh: function(t7, e2, r2, n2) {
  var i2 = t7 >>> 0, a2 = r2 >>> 0;
  return (e2 >>> 0) - (n2 >>> 0) - ((~i2 & a2 | ~(i2 ^ a2) & i2 - a2 >>> 0) >>> 31) | 0;
} }), J(J.S, "Math", { imulh: function(t7, e2) {
  var r2 = 65535, n2 = +t7, i2 = +e2, a2 = n2 & r2, o2 = i2 & r2, s2 = n2 >> 16, u2 = i2 >> 16, c2 = (s2 * o2 >>> 0) + (a2 * o2 >>> 16);
  return s2 * u2 + (c2 >> 16) + ((a2 * u2 >>> 0) + (c2 & r2) >> 16);
} }), J(J.S, "Math", { RAD_PER_DEG: 180 / Math.PI });
var As = Math.PI / 180;
J(J.S, "Math", { radians: function(t7) {
  return t7 * As;
} }), J(J.S, "Math", { scale: Is }), J(J.S, "Math", { umulh: function(t7, e2) {
  var r2 = 65535, n2 = +t7, i2 = +e2, a2 = n2 & r2, o2 = i2 & r2, s2 = n2 >>> 16, u2 = i2 >>> 16, c2 = (s2 * o2 >>> 0) + (a2 * o2 >>> 16);
  return s2 * u2 + (c2 >>> 16) + ((a2 * u2 >>> 0) + (c2 & r2) >>> 16);
} }), J(J.S, "Math", { signbit: function(t7) {
  return (t7 = +t7) != t7 ? t7 : t7 == 0 ? 1 / t7 == 1 / 0 : t7 > 0;
} }), J(J.P + J.R, "Promise", { finally: function(t7) {
  var e2 = ca(this, O.Promise || _.Promise), r2 = typeof t7 == "function";
  return this.then(r2 ? function(r3) {
    return qa(e2, t7()).then(function() {
      return r3;
    });
  } : t7, r2 ? function(r3) {
    return qa(e2, t7()).then(function() {
      throw r3;
    });
  } : t7);
} }), J(J.S, "Promise", { try: function(t7) {
  var e2 = Ma.f(this), r2 = ja(t7);
  return (r2.e ? e2.reject : e2.resolve)(r2.v), e2.promise;
} });
var ws = H("metadata"), _s = ws.store || (ws.store = new _o()), Bs = function(t7, e2, r2) {
  var n2 = _s.get(t7);
  if (!n2) {
    if (!r2)
      return;
    _s.set(t7, n2 = new vo());
  }
  var i2 = n2.get(e2);
  if (!i2) {
    if (!r2)
      return;
    n2.set(e2, i2 = new vo());
  }
  return i2;
}, Ns = { store: _s, map: Bs, has: function(t7, e2, r2) {
  var n2 = Bs(e2, r2, false);
  return n2 !== void 0 && n2.has(t7);
}, get: function(t7, e2, r2) {
  var n2 = Bs(e2, r2, false);
  return n2 === void 0 ? void 0 : n2.get(t7);
}, set: function(t7, e2, r2, n2) {
  Bs(r2, n2, true).set(t7, e2);
}, keys: function(t7, e2) {
  var r2 = Bs(t7, e2, false), n2 = [];
  return r2 && r2.forEach(function(t8, e3) {
    n2.push(e3);
  }), n2;
}, key: function(t7) {
  return t7 === void 0 || typeof t7 == "symbol" ? t7 : String(t7);
}, exp: function(t7) {
  J(J.S, "Reflect", t7);
} }, ks = Ns.key, Rs = Ns.set;
Ns.exp({ defineMetadata: function(t7, e2, r2, n2) {
  Rs(t7, e2, P(r2), ks(n2));
} });
var Os = Ns.key, Ls = Ns.map, Ps = Ns.store;
Ns.exp({ deleteMetadata: function(t7, e2) {
  var r2 = arguments.length < 3 ? void 0 : Os(arguments[2]), n2 = Ls(P(e2), r2, false);
  if (n2 === void 0 || !n2.delete(t7))
    return false;
  if (n2.size)
    return true;
  var i2 = Ps.get(e2);
  return i2.delete(r2), !!i2.size || Ps.delete(e2);
} });
var Us = Ns.has, xs = Ns.get, Ds = Ns.key, Vs = function(t7, e2, r2) {
  if (Us(t7, e2, r2))
    return xs(t7, e2, r2);
  var n2 = Ne(e2);
  return n2 !== null ? Vs(t7, n2, r2) : void 0;
};
Ns.exp({ getMetadata: function(t7, e2) {
  return Vs(t7, P(e2), arguments.length < 3 ? void 0 : Ds(arguments[2]));
} });
var Ms = Ns.keys, js = Ns.key, Fs = function(t7, e2) {
  var r2 = Ms(t7, e2), n2 = Ne(t7);
  if (n2 === null)
    return r2;
  var i2 = Fs(n2, e2);
  return i2.length ? r2.length ? Cs(new mo(r2.concat(i2))) : i2 : r2;
};
Ns.exp({ getMetadataKeys: function(t7) {
  return Fs(P(t7), arguments.length < 2 ? void 0 : js(arguments[1]));
} });
var Ks = Ns.get, qs = Ns.key;
Ns.exp({ getOwnMetadata: function(t7, e2) {
  return Ks(t7, P(e2), arguments.length < 3 ? void 0 : qs(arguments[2]));
} });
var Gs = Ns.keys, zs = Ns.key;
Ns.exp({ getOwnMetadataKeys: function(t7) {
  return Gs(P(t7), arguments.length < 2 ? void 0 : zs(arguments[1]));
} });
var Ws = Ns.has, Hs = Ns.key, Qs = function(t7, e2, r2) {
  if (Ws(t7, e2, r2))
    return true;
  var n2 = Ne(e2);
  return n2 !== null && Qs(t7, n2, r2);
};
Ns.exp({ hasMetadata: function(t7, e2) {
  return Qs(t7, P(e2), arguments.length < 3 ? void 0 : Hs(arguments[2]));
} });
var Ys = Ns.has, Xs = Ns.key;
Ns.exp({ hasOwnMetadata: function(t7, e2) {
  return Ys(t7, P(e2), arguments.length < 3 ? void 0 : Xs(arguments[2]));
} });
var $s = Ns.key, Zs = Ns.set;
Ns.exp({ metadata: function(t7, e2) {
  return function(r2, n2) {
    Zs(t7, e2, (n2 !== void 0 ? P : X)(r2), $s(n2));
  };
} });
var Js = La(), tu = _.process, eu = ct(tu) == "process";
J(J.G, { asap: function(t7) {
  var e2 = eu && tu.domain;
  Js(e2 ? e2.bind(t7) : t7);
} });
var ru = La(), nu = et("observable"), iu = va.RETURN, au = function(t7) {
  return t7 == null ? void 0 : X(t7);
}, ou = function(t7) {
  var e2 = t7._c;
  e2 && (t7._c = void 0, e2());
}, su = function(t7) {
  return t7._o === void 0;
}, uu = function(t7) {
  su(t7) || (t7._o = void 0, ou(t7));
}, cu = function(t7, e2) {
  P(t7), this._c = void 0, this._o = t7, t7 = new fu(this);
  try {
    var r2 = e2(t7), n2 = r2;
    r2 != null && (typeof r2.unsubscribe == "function" ? r2 = function() {
      n2.unsubscribe();
    } : X(r2), this._c = r2);
  } catch (e3) {
    return void t7.error(e3);
  }
  su(this) && ou(this);
};
cu.prototype = Ga({}, { unsubscribe: function() {
  uu(this);
} });
var fu = function(t7) {
  this._s = t7;
};
fu.prototype = Ga({}, { next: function(t7) {
  var e2 = this._s;
  if (!su(e2)) {
    var r2 = e2._o;
    try {
      var n2 = au(r2.next);
      if (n2)
        return n2.call(r2, t7);
    } catch (t8) {
      try {
        uu(e2);
      } finally {
        throw t8;
      }
    }
  }
}, error: function(t7) {
  var e2 = this._s;
  if (su(e2))
    throw t7;
  var r2 = e2._o;
  e2._o = void 0;
  try {
    var n2 = au(r2.error);
    if (!n2)
      throw t7;
    t7 = n2.call(r2, t7);
  } catch (t8) {
    try {
      ou(e2);
    } finally {
      throw t8;
    }
  }
  return ou(e2), t7;
}, complete: function(t7) {
  var e2 = this._s;
  if (!su(e2)) {
    var r2 = e2._o;
    e2._o = void 0;
    try {
      var n2 = au(r2.complete);
      t7 = n2 ? n2.call(r2, t7) : void 0;
    } catch (t8) {
      try {
        ou(e2);
      } finally {
        throw t8;
      }
    }
    return ou(e2), t7;
  }
} });
var lu = function(t7) {
  ga(this, lu, "Observable", "_f")._f = X(t7);
};
Ga(lu.prototype, { subscribe: function(t7) {
  return new cu(t7, this._f);
}, forEach: function(t7) {
  var e2 = this;
  return new (O.Promise || _.Promise)(function(r2, n2) {
    X(t7);
    var i2 = e2.subscribe({ next: function(e3) {
      try {
        return t7(e3);
      } catch (t8) {
        n2(t8), i2.unsubscribe();
      }
    }, error: n2, complete: r2 });
  });
} }), Ga(lu, { from: function(t7) {
  var e2 = typeof this == "function" ? this : lu, r2 = au(P(t7)[nu]);
  if (r2) {
    var n2 = P(r2.call(t7));
    return n2.constructor === e2 ? n2 : new e2(function(t8) {
      return n2.subscribe(t8);
    });
  }
  return new e2(function(e3) {
    var r3 = false;
    return ru(function() {
      if (!r3) {
        try {
          if (va(t7, false, function(t8) {
            if (e3.next(t8), r3)
              return iu;
          }) === iu)
            return;
        } catch (t8) {
          if (r3)
            throw t8;
          return void e3.error(t8);
        }
        e3.complete();
      }
    }), function() {
      r3 = true;
    };
  });
}, of: function() {
  for (var t7 = 0, e2 = arguments.length, r2 = new Array(e2); t7 < e2; )
    r2[t7] = arguments[t7++];
  return new (typeof this == "function" ? this : lu)(function(t8) {
    var e3 = false;
    return ru(function() {
      if (!e3) {
        for (var n2 = 0; n2 < r2.length; ++n2)
          if (t8.next(r2[n2]), e3)
            return;
        t8.complete();
      }
    }), function() {
      e3 = true;
    };
  });
} }), q(lu.prototype, nu, function() {
  return this;
}), J(J.G, { Observable: lu }), wi("Observable");
var hu = [].slice, pu = /MSIE .\./.test(Ka), du = function(t7) {
  return function(e2, r2) {
    var n2 = arguments.length > 2, i2 = !!n2 && hu.call(arguments, 2);
    return t7(n2 ? function() {
      (typeof e2 == "function" ? e2 : Function(e2)).apply(this, i2);
    } : e2, r2);
  };
};
J(J.G + J.B + J.F * pu, { setTimeout: du(_.setTimeout), setInterval: du(_.setInterval) }), J(J.G + J.B, { setImmediate: _a.set, clearImmediate: _a.clear });
for (var yu = et("iterator"), gu = et("toStringTag"), vu = ln.Array, mu = { CSSRuleList: true, CSSStyleDeclaration: false, CSSValueList: false, ClientRectList: false, DOMRectList: false, DOMStringList: false, DOMTokenList: true, DataTransferItemList: false, FileList: false, HTMLAllCollection: false, HTMLCollection: false, HTMLFormElement: false, HTMLSelectElement: false, MediaList: true, MimeTypeArray: false, NamedNodeMap: false, NodeList: true, PaintRequestList: false, Plugin: false, PluginArray: false, SVGLengthList: false, SVGNumberList: false, SVGPathSegList: false, SVGPointList: false, SVGStringList: false, SVGTransformList: false, SourceBufferList: false, StyleSheetList: true, TextTrackCueList: false, TextTrackList: false, TouchList: false }, Cu = Bt(mu), Eu = 0; Eu < Cu.length; Eu++) {
  var Su, bu = Cu[Eu], Tu = mu[bu], Iu = _[bu], Au = Iu && Iu.prototype;
  if (Au && (Au[yu] || q(Au, yu, vu), Au[gu] || q(Au, gu, bu), ln[bu] = vu, Tu))
    for (Su in Bi)
      Au[Su] || Y(Au, Su, Bi[Su], true);
}
w(function(t7) {
  !function(e2) {
    var r2, n2 = Object.prototype, i2 = n2.hasOwnProperty, a2 = typeof Symbol == "function" ? Symbol : {}, o2 = a2.iterator || "@@iterator", s2 = a2.asyncIterator || "@@asyncIterator", u2 = a2.toStringTag || "@@toStringTag", c2 = e2.regeneratorRuntime;
    if (c2)
      t7.exports = c2;
    else {
      (c2 = e2.regeneratorRuntime = t7.exports).wrap = C2;
      var f2 = "suspendedStart", l2 = "suspendedYield", h2 = "executing", p2 = "completed", d2 = {}, y2 = {};
      y2[o2] = function() {
        return this;
      };
      var g2 = Object.getPrototypeOf, v2 = g2 && g2(g2(k2([])));
      v2 && v2 !== n2 && i2.call(v2, o2) && (y2 = v2);
      var m2 = T2.prototype = S2.prototype = Object.create(y2);
      b2.prototype = m2.constructor = T2, T2.constructor = b2, T2[u2] = b2.displayName = "GeneratorFunction", c2.isGeneratorFunction = function(t8) {
        var e3 = typeof t8 == "function" && t8.constructor;
        return !!e3 && (e3 === b2 || (e3.displayName || e3.name) === "GeneratorFunction");
      }, c2.mark = function(t8) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t8, T2) : (t8.__proto__ = T2, u2 in t8 || (t8[u2] = "GeneratorFunction")), t8.prototype = Object.create(m2), t8;
      }, c2.awrap = function(t8) {
        return { __await: t8 };
      }, I2(A2.prototype), A2.prototype[s2] = function() {
        return this;
      }, c2.AsyncIterator = A2, c2.async = function(t8, e3, r3, n3) {
        var i3 = new A2(C2(t8, e3, r3, n3));
        return c2.isGeneratorFunction(e3) ? i3 : i3.next().then(function(t9) {
          return t9.done ? t9.value : i3.next();
        });
      }, I2(m2), m2[u2] = "Generator", m2[o2] = function() {
        return this;
      }, m2.toString = function() {
        return "[object Generator]";
      }, c2.keys = function(t8) {
        var e3 = [];
        for (var r3 in t8)
          e3.push(r3);
        return e3.reverse(), function r4() {
          for (; e3.length; ) {
            var n3 = e3.pop();
            if (n3 in t8)
              return r4.value = n3, r4.done = false, r4;
          }
          return r4.done = true, r4;
        };
      }, c2.values = k2, N2.prototype = { constructor: N2, reset: function(t8) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = r2, this.done = false, this.delegate = null, this.method = "next", this.arg = r2, this.tryEntries.forEach(B2), !t8)
          for (var e3 in this)
            e3.charAt(0) === "t" && i2.call(this, e3) && !isNaN(+e3.slice(1)) && (this[e3] = r2);
      }, stop: function() {
        this.done = true;
        var t8 = this.tryEntries[0].completion;
        if (t8.type === "throw")
          throw t8.arg;
        return this.rval;
      }, dispatchException: function(t8) {
        if (this.done)
          throw t8;
        var e3 = this;
        function n3(n4, i3) {
          return s3.type = "throw", s3.arg = t8, e3.next = n4, i3 && (e3.method = "next", e3.arg = r2), !!i3;
        }
        for (var a3 = this.tryEntries.length - 1; a3 >= 0; --a3) {
          var o3 = this.tryEntries[a3], s3 = o3.completion;
          if (o3.tryLoc === "root")
            return n3("end");
          if (o3.tryLoc <= this.prev) {
            var u3 = i2.call(o3, "catchLoc"), c3 = i2.call(o3, "finallyLoc");
            if (u3 && c3) {
              if (this.prev < o3.catchLoc)
                return n3(o3.catchLoc, true);
              if (this.prev < o3.finallyLoc)
                return n3(o3.finallyLoc);
            } else if (u3) {
              if (this.prev < o3.catchLoc)
                return n3(o3.catchLoc, true);
            } else {
              if (!c3)
                throw new Error("try statement without catch or finally");
              if (this.prev < o3.finallyLoc)
                return n3(o3.finallyLoc);
            }
          }
        }
      }, abrupt: function(t8, e3) {
        for (var r3 = this.tryEntries.length - 1; r3 >= 0; --r3) {
          var n3 = this.tryEntries[r3];
          if (n3.tryLoc <= this.prev && i2.call(n3, "finallyLoc") && this.prev < n3.finallyLoc) {
            var a3 = n3;
            break;
          }
        }
        a3 && (t8 === "break" || t8 === "continue") && a3.tryLoc <= e3 && e3 <= a3.finallyLoc && (a3 = null);
        var o3 = a3 ? a3.completion : {};
        return o3.type = t8, o3.arg = e3, a3 ? (this.method = "next", this.next = a3.finallyLoc, d2) : this.complete(o3);
      }, complete: function(t8, e3) {
        if (t8.type === "throw")
          throw t8.arg;
        return t8.type === "break" || t8.type === "continue" ? this.next = t8.arg : t8.type === "return" ? (this.rval = this.arg = t8.arg, this.method = "return", this.next = "end") : t8.type === "normal" && e3 && (this.next = e3), d2;
      }, finish: function(t8) {
        for (var e3 = this.tryEntries.length - 1; e3 >= 0; --e3) {
          var r3 = this.tryEntries[e3];
          if (r3.finallyLoc === t8)
            return this.complete(r3.completion, r3.afterLoc), B2(r3), d2;
        }
      }, catch: function(t8) {
        for (var e3 = this.tryEntries.length - 1; e3 >= 0; --e3) {
          var r3 = this.tryEntries[e3];
          if (r3.tryLoc === t8) {
            var n3 = r3.completion;
            if (n3.type === "throw") {
              var i3 = n3.arg;
              B2(r3);
            }
            return i3;
          }
        }
        throw new Error("illegal catch attempt");
      }, delegateYield: function(t8, e3, n3) {
        return this.delegate = { iterator: k2(t8), resultName: e3, nextLoc: n3 }, this.method === "next" && (this.arg = r2), d2;
      } };
    }
    function C2(t8, e3, r3, n3) {
      var i3 = e3 && e3.prototype instanceof S2 ? e3 : S2, a3 = Object.create(i3.prototype), o3 = new N2(n3 || []);
      return a3._invoke = function(t9, e4, r4) {
        var n4 = f2;
        return function(i4, a4) {
          if (n4 === h2)
            throw new Error("Generator is already running");
          if (n4 === p2) {
            if (i4 === "throw")
              throw a4;
            return R2();
          }
          for (r4.method = i4, r4.arg = a4; ; ) {
            var o4 = r4.delegate;
            if (o4) {
              var s3 = w2(o4, r4);
              if (s3) {
                if (s3 === d2)
                  continue;
                return s3;
              }
            }
            if (r4.method === "next")
              r4.sent = r4._sent = r4.arg;
            else if (r4.method === "throw") {
              if (n4 === f2)
                throw n4 = p2, r4.arg;
              r4.dispatchException(r4.arg);
            } else
              r4.method === "return" && r4.abrupt("return", r4.arg);
            n4 = h2;
            var u3 = E2(t9, e4, r4);
            if (u3.type === "normal") {
              if (n4 = r4.done ? p2 : l2, u3.arg === d2)
                continue;
              return { value: u3.arg, done: r4.done };
            }
            u3.type === "throw" && (n4 = p2, r4.method = "throw", r4.arg = u3.arg);
          }
        };
      }(t8, r3, o3), a3;
    }
    function E2(t8, e3, r3) {
      try {
        return { type: "normal", arg: t8.call(e3, r3) };
      } catch (t9) {
        return { type: "throw", arg: t9 };
      }
    }
    function S2() {
    }
    function b2() {
    }
    function T2() {
    }
    function I2(t8) {
      ["next", "throw", "return"].forEach(function(e3) {
        t8[e3] = function(t9) {
          return this._invoke(e3, t9);
        };
      });
    }
    function A2(t8) {
      function r3(e3, n4, a3, o3) {
        var s3 = E2(t8[e3], t8, n4);
        if (s3.type !== "throw") {
          var u3 = s3.arg, c3 = u3.value;
          return c3 && typeof c3 == "object" && i2.call(c3, "__await") ? Promise.resolve(c3.__await).then(function(t9) {
            r3("next", t9, a3, o3);
          }, function(t9) {
            r3("throw", t9, a3, o3);
          }) : Promise.resolve(c3).then(function(t9) {
            u3.value = t9, a3(u3);
          }, o3);
        }
        o3(s3.arg);
      }
      var n3;
      typeof e2.process == "object" && e2.process.domain && (r3 = e2.process.domain.bind(r3)), this._invoke = function(t9, e3) {
        function i3() {
          return new Promise(function(n4, i4) {
            r3(t9, e3, n4, i4);
          });
        }
        return n3 = n3 ? n3.then(i3, i3) : i3();
      };
    }
    function w2(t8, e3) {
      var n3 = t8.iterator[e3.method];
      if (n3 === r2) {
        if (e3.delegate = null, e3.method === "throw") {
          if (t8.iterator.return && (e3.method = "return", e3.arg = r2, w2(t8, e3), e3.method === "throw"))
            return d2;
          e3.method = "throw", e3.arg = new TypeError("The iterator does not provide a 'throw' method");
        }
        return d2;
      }
      var i3 = E2(n3, t8.iterator, e3.arg);
      if (i3.type === "throw")
        return e3.method = "throw", e3.arg = i3.arg, e3.delegate = null, d2;
      var a3 = i3.arg;
      return a3 ? a3.done ? (e3[t8.resultName] = a3.value, e3.next = t8.nextLoc, e3.method !== "return" && (e3.method = "next", e3.arg = r2), e3.delegate = null, d2) : a3 : (e3.method = "throw", e3.arg = new TypeError("iterator result is not an object"), e3.delegate = null, d2);
    }
    function _2(t8) {
      var e3 = { tryLoc: t8[0] };
      1 in t8 && (e3.catchLoc = t8[1]), 2 in t8 && (e3.finallyLoc = t8[2], e3.afterLoc = t8[3]), this.tryEntries.push(e3);
    }
    function B2(t8) {
      var e3 = t8.completion || {};
      e3.type = "normal", delete e3.arg, t8.completion = e3;
    }
    function N2(t8) {
      this.tryEntries = [{ tryLoc: "root" }], t8.forEach(_2, this), this.reset(true);
    }
    function k2(t8) {
      if (t8) {
        var e3 = t8[o2];
        if (e3)
          return e3.call(t8);
        if (typeof t8.next == "function")
          return t8;
        if (!isNaN(t8.length)) {
          var n3 = -1, a3 = function e4() {
            for (; ++n3 < t8.length; )
              if (i2.call(t8, n3))
                return e4.value = t8[n3], e4.done = false, e4;
            return e4.value = r2, e4.done = true, e4;
          };
          return a3.next = a3;
        }
      }
      return { next: R2 };
    }
    function R2() {
      return { value: r2, done: true };
    }
  }(typeof A == "object" ? A : typeof window == "object" ? window : typeof self == "object" ? self : A);
});
var wu, _u, Bu, Nu = (wu = /[\\^$*+?.()|[\]{}]/g, Bu = (_u = "\\$&") === Object(_u) ? function(t7) {
  return _u[t7];
} : _u, function(t7) {
  return String(t7).replace(wu, Bu);
});
if (J(J.S, "RegExp", { escape: function(t7) {
  return Nu(t7);
} }), O.RegExp.escape, A._babelPolyfill)
  throw new Error("only one instance of babel-polyfill is allowed");
A._babelPolyfill = true;
function ku(t7, e2, r2) {
  t7[e2] || Object.defineProperty(t7, e2, { writable: true, configurable: true, value: r2 });
}
ku(String.prototype, "padLeft", "".padStart), ku(String.prototype, "padRight", "".padEnd), "pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function(t7) {
  [][t7] && ku(Array, t7, Function.call.bind([][t7]));
});
var Ru = w(function(t7, e2) {
  var r2 = e2;
  r2.caCertFileName = "node-mitmproxy.ca.crt", r2.caKeyFileName = "node-mitmproxy.ca.key.pem", r2.defaultPort = 6789, r2.caName = "node-mitmproxy CA", r2.getDefaultCABasePath = function() {
    var t8 = process.env.HOME || process.env.USERPROFILE;
    return d.default.resolve(t8, "./.node-mitmproxy");
  }, r2.getDefaultCACertPath = function() {
    return d.default.resolve(r2.getDefaultCABasePath(), r2.caCertFileName);
  }, r2.getDefaultCACertPath = function() {
    return d.default.resolve(r2.getDefaultCABasePath(), r2.caKeyFileName);
  };
}), Ou = w(function(t7, e2) {
  (function() {
    var r2, n2 = "Expected a function", i2 = "__lodash_hash_undefined__", a2 = "__lodash_placeholder__", o2 = 16, s2 = 32, u2 = 64, c2 = 128, f2 = 256, l2 = 1 / 0, h2 = 9007199254740991, p2 = NaN, d2 = 4294967295, y2 = [["ary", c2], ["bind", 1], ["bindKey", 2], ["curry", 8], ["curryRight", o2], ["flip", 512], ["partial", s2], ["partialRight", u2], ["rearg", f2]], g2 = "[object Arguments]", v2 = "[object Array]", m2 = "[object Boolean]", C2 = "[object Date]", E2 = "[object Error]", S2 = "[object Function]", b2 = "[object GeneratorFunction]", T2 = "[object Map]", I2 = "[object Number]", w2 = "[object Object]", _2 = "[object Promise]", B2 = "[object RegExp]", N2 = "[object Set]", k2 = "[object String]", R2 = "[object Symbol]", O2 = "[object WeakMap]", L2 = "[object ArrayBuffer]", P2 = "[object DataView]", U2 = "[object Float32Array]", x2 = "[object Float64Array]", D2 = "[object Int8Array]", V2 = "[object Int16Array]", M2 = "[object Int32Array]", j2 = "[object Uint8Array]", F2 = "[object Uint8ClampedArray]", K2 = "[object Uint16Array]", q2 = "[object Uint32Array]", G2 = /\b__p \+= '';/g, z2 = /\b(__p \+=) '' \+/g, W2 = /(__e\(.*?\)|\b__t\)) \+\n'';/g, H2 = /&(?:amp|lt|gt|quot|#39);/g, Q2 = /[&<>"']/g, Y2 = RegExp(H2.source), X2 = RegExp(Q2.source), $2 = /<%-([\s\S]+?)%>/g, Z2 = /<%([\s\S]+?)%>/g, J2 = /<%=([\s\S]+?)%>/g, tt2 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, et2 = /^\w*$/, rt2 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, nt2 = /[\\^$.*+?()[\]{}|]/g, it2 = RegExp(nt2.source), at2 = /^\s+/, ot2 = /\s/, st2 = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, ut2 = /\{\n\/\* \[wrapped with (.+)\] \*/, ct2 = /,? & /, ft2 = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, lt2 = /[()=,{}\[\]\/\s]/, ht2 = /\\(\\)?/g, pt2 = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, dt2 = /\w*$/, yt2 = /^[-+]0x[0-9a-f]+$/i, gt2 = /^0b[01]+$/i, vt2 = /^\[object .+?Constructor\]$/, mt2 = /^0o[0-7]+$/i, Ct2 = /^(?:0|[1-9]\d*)$/, Et2 = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, St2 = /($^)/, bt2 = /['\n\r\u2028\u2029\\]/g, Tt2 = "\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff", It2 = "\\u2700-\\u27bf", At2 = "a-z\\xdf-\\xf6\\xf8-\\xff", wt2 = "A-Z\\xc0-\\xd6\\xd8-\\xde", _t2 = "\\ufe0e\\ufe0f", Bt2 = "\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", Nt2 = "['\u2019]", kt2 = "[\\ud800-\\udfff]", Rt2 = "[" + Bt2 + "]", Ot2 = "[" + Tt2 + "]", Lt2 = "\\d+", Pt2 = "[\\u2700-\\u27bf]", Ut2 = "[" + At2 + "]", xt2 = "[^\\ud800-\\udfff" + Bt2 + Lt2 + It2 + At2 + wt2 + "]", Dt2 = "\\ud83c[\\udffb-\\udfff]", Vt2 = "[^\\ud800-\\udfff]", Mt2 = "(?:\\ud83c[\\udde6-\\uddff]){2}", jt2 = "[\\ud800-\\udbff][\\udc00-\\udfff]", Ft2 = "[" + wt2 + "]", Kt2 = "(?:" + Ut2 + "|" + xt2 + ")", qt2 = "(?:" + Ft2 + "|" + xt2 + ")", Gt2 = "(?:['\u2019](?:d|ll|m|re|s|t|ve))?", zt2 = "(?:['\u2019](?:D|LL|M|RE|S|T|VE))?", Wt2 = "(?:" + Ot2 + "|" + Dt2 + ")?", Ht2 = "[\\ufe0e\\ufe0f]?", Qt2 = Ht2 + Wt2 + ("(?:\\u200d(?:" + [Vt2, Mt2, jt2].join("|") + ")" + Ht2 + Wt2 + ")*"), Yt2 = "(?:" + [Pt2, Mt2, jt2].join("|") + ")" + Qt2, Xt2 = "(?:" + [Vt2 + Ot2 + "?", Ot2, Mt2, jt2, kt2].join("|") + ")", $t2 = RegExp(Nt2, "g"), Zt2 = RegExp(Ot2, "g"), Jt2 = RegExp(Dt2 + "(?=" + Dt2 + ")|" + Xt2 + Qt2, "g"), te2 = RegExp([Ft2 + "?" + Ut2 + "+" + Gt2 + "(?=" + [Rt2, Ft2, "$"].join("|") + ")", qt2 + "+" + zt2 + "(?=" + [Rt2, Ft2 + Kt2, "$"].join("|") + ")", Ft2 + "?" + Kt2 + "+" + Gt2, Ft2 + "+" + zt2, "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", Lt2, Yt2].join("|"), "g"), ee2 = RegExp("[\\u200d\\ud800-\\udfff" + Tt2 + _t2 + "]"), re2 = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, ne2 = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"], ie2 = -1, ae2 = {};
    ae2[U2] = ae2[x2] = ae2[D2] = ae2[V2] = ae2[M2] = ae2[j2] = ae2[F2] = ae2[K2] = ae2[q2] = true, ae2[g2] = ae2[v2] = ae2[L2] = ae2[m2] = ae2[P2] = ae2[C2] = ae2[E2] = ae2[S2] = ae2[T2] = ae2[I2] = ae2[w2] = ae2[B2] = ae2[N2] = ae2[k2] = ae2[O2] = false;
    var oe2 = {};
    oe2[g2] = oe2[v2] = oe2[L2] = oe2[P2] = oe2[m2] = oe2[C2] = oe2[U2] = oe2[x2] = oe2[D2] = oe2[V2] = oe2[M2] = oe2[T2] = oe2[I2] = oe2[w2] = oe2[B2] = oe2[N2] = oe2[k2] = oe2[R2] = oe2[j2] = oe2[F2] = oe2[K2] = oe2[q2] = true, oe2[E2] = oe2[S2] = oe2[O2] = false;
    var se2 = { "\\": "\\", "'": "'", "\n": "n", "\r": "r", "\u2028": "u2028", "\u2029": "u2029" }, ue2 = parseFloat, ce2 = parseInt, fe2 = typeof A == "object" && A && A.Object === Object && A, le2 = typeof self == "object" && self && self.Object === Object && self, he2 = fe2 || le2 || Function("return this")(), pe2 = e2 && !e2.nodeType && e2, de2 = pe2 && t7 && !t7.nodeType && t7, ye2 = de2 && de2.exports === pe2, ge2 = ye2 && fe2.process, ve2 = function() {
      try {
        var t8 = de2 && de2.require && de2.require("util").types;
        return t8 || ge2 && ge2.binding && ge2.binding("util");
      } catch (t9) {
      }
    }(), me2 = ve2 && ve2.isArrayBuffer, Ce2 = ve2 && ve2.isDate, Ee = ve2 && ve2.isMap, Se = ve2 && ve2.isRegExp, be = ve2 && ve2.isSet, Te = ve2 && ve2.isTypedArray;
    function Ie2(t8, e3, r3) {
      switch (r3.length) {
        case 0:
          return t8.call(e3);
        case 1:
          return t8.call(e3, r3[0]);
        case 2:
          return t8.call(e3, r3[0], r3[1]);
        case 3:
          return t8.call(e3, r3[0], r3[1], r3[2]);
      }
      return t8.apply(e3, r3);
    }
    function Ae2(t8, e3, r3, n3) {
      for (var i3 = -1, a3 = t8 == null ? 0 : t8.length; ++i3 < a3; ) {
        var o3 = t8[i3];
        e3(n3, o3, r3(o3), t8);
      }
      return n3;
    }
    function we2(t8, e3) {
      for (var r3 = -1, n3 = t8 == null ? 0 : t8.length; ++r3 < n3 && e3(t8[r3], r3, t8) !== false; )
        ;
      return t8;
    }
    function _e2(t8, e3) {
      for (var r3 = t8 == null ? 0 : t8.length; r3-- && e3(t8[r3], r3, t8) !== false; )
        ;
      return t8;
    }
    function Be2(t8, e3) {
      for (var r3 = -1, n3 = t8 == null ? 0 : t8.length; ++r3 < n3; )
        if (!e3(t8[r3], r3, t8))
          return false;
      return true;
    }
    function Ne2(t8, e3) {
      for (var r3 = -1, n3 = t8 == null ? 0 : t8.length, i3 = 0, a3 = []; ++r3 < n3; ) {
        var o3 = t8[r3];
        e3(o3, r3, t8) && (a3[i3++] = o3);
      }
      return a3;
    }
    function ke2(t8, e3) {
      return !!(t8 == null ? 0 : t8.length) && je2(t8, e3, 0) > -1;
    }
    function Re2(t8, e3, r3) {
      for (var n3 = -1, i3 = t8 == null ? 0 : t8.length; ++n3 < i3; )
        if (r3(e3, t8[n3]))
          return true;
      return false;
    }
    function Oe2(t8, e3) {
      for (var r3 = -1, n3 = t8 == null ? 0 : t8.length, i3 = Array(n3); ++r3 < n3; )
        i3[r3] = e3(t8[r3], r3, t8);
      return i3;
    }
    function Le2(t8, e3) {
      for (var r3 = -1, n3 = e3.length, i3 = t8.length; ++r3 < n3; )
        t8[i3 + r3] = e3[r3];
      return t8;
    }
    function Pe2(t8, e3, r3, n3) {
      var i3 = -1, a3 = t8 == null ? 0 : t8.length;
      for (n3 && a3 && (r3 = t8[++i3]); ++i3 < a3; )
        r3 = e3(r3, t8[i3], i3, t8);
      return r3;
    }
    function Ue2(t8, e3, r3, n3) {
      var i3 = t8 == null ? 0 : t8.length;
      for (n3 && i3 && (r3 = t8[--i3]); i3--; )
        r3 = e3(r3, t8[i3], i3, t8);
      return r3;
    }
    function xe2(t8, e3) {
      for (var r3 = -1, n3 = t8 == null ? 0 : t8.length; ++r3 < n3; )
        if (e3(t8[r3], r3, t8))
          return true;
      return false;
    }
    var De2 = Ge2("length");
    function Ve2(t8, e3, r3) {
      var n3;
      return r3(t8, function(t9, r4, i3) {
        if (e3(t9, r4, i3))
          return n3 = r4, false;
      }), n3;
    }
    function Me2(t8, e3, r3, n3) {
      for (var i3 = t8.length, a3 = r3 + (n3 ? 1 : -1); n3 ? a3-- : ++a3 < i3; )
        if (e3(t8[a3], a3, t8))
          return a3;
      return -1;
    }
    function je2(t8, e3, r3) {
      return e3 == e3 ? function(t9, e4, r4) {
        var n3 = r4 - 1, i3 = t9.length;
        for (; ++n3 < i3; )
          if (t9[n3] === e4)
            return n3;
        return -1;
      }(t8, e3, r3) : Me2(t8, Ke2, r3);
    }
    function Fe2(t8, e3, r3, n3) {
      for (var i3 = r3 - 1, a3 = t8.length; ++i3 < a3; )
        if (n3(t8[i3], e3))
          return i3;
      return -1;
    }
    function Ke2(t8) {
      return t8 != t8;
    }
    function qe2(t8, e3) {
      var r3 = t8 == null ? 0 : t8.length;
      return r3 ? He2(t8, e3) / r3 : p2;
    }
    function Ge2(t8) {
      return function(e3) {
        return e3 == null ? r2 : e3[t8];
      };
    }
    function ze2(t8) {
      return function(e3) {
        return t8 == null ? r2 : t8[e3];
      };
    }
    function We2(t8, e3, r3, n3, i3) {
      return i3(t8, function(t9, i4, a3) {
        r3 = n3 ? (n3 = false, t9) : e3(r3, t9, i4, a3);
      }), r3;
    }
    function He2(t8, e3) {
      for (var n3, i3 = -1, a3 = t8.length; ++i3 < a3; ) {
        var o3 = e3(t8[i3]);
        o3 !== r2 && (n3 = n3 === r2 ? o3 : n3 + o3);
      }
      return n3;
    }
    function Qe2(t8, e3) {
      for (var r3 = -1, n3 = Array(t8); ++r3 < t8; )
        n3[r3] = e3(r3);
      return n3;
    }
    function Ye2(t8) {
      return t8 ? t8.slice(0, pr2(t8) + 1).replace(at2, "") : t8;
    }
    function Xe2(t8) {
      return function(e3) {
        return t8(e3);
      };
    }
    function $e2(t8, e3) {
      return Oe2(e3, function(e4) {
        return t8[e4];
      });
    }
    function Ze2(t8, e3) {
      return t8.has(e3);
    }
    function Je2(t8, e3) {
      for (var r3 = -1, n3 = t8.length; ++r3 < n3 && je2(e3, t8[r3], 0) > -1; )
        ;
      return r3;
    }
    function tr2(t8, e3) {
      for (var r3 = t8.length; r3-- && je2(e3, t8[r3], 0) > -1; )
        ;
      return r3;
    }
    function er2(t8, e3) {
      for (var r3 = t8.length, n3 = 0; r3--; )
        t8[r3] === e3 && ++n3;
      return n3;
    }
    var rr2 = ze2({ "\xC0": "A", "\xC1": "A", "\xC2": "A", "\xC3": "A", "\xC4": "A", "\xC5": "A", "\xE0": "a", "\xE1": "a", "\xE2": "a", "\xE3": "a", "\xE4": "a", "\xE5": "a", "\xC7": "C", "\xE7": "c", "\xD0": "D", "\xF0": "d", "\xC8": "E", "\xC9": "E", "\xCA": "E", "\xCB": "E", "\xE8": "e", "\xE9": "e", "\xEA": "e", "\xEB": "e", "\xCC": "I", "\xCD": "I", "\xCE": "I", "\xCF": "I", "\xEC": "i", "\xED": "i", "\xEE": "i", "\xEF": "i", "\xD1": "N", "\xF1": "n", "\xD2": "O", "\xD3": "O", "\xD4": "O", "\xD5": "O", "\xD6": "O", "\xD8": "O", "\xF2": "o", "\xF3": "o", "\xF4": "o", "\xF5": "o", "\xF6": "o", "\xF8": "o", "\xD9": "U", "\xDA": "U", "\xDB": "U", "\xDC": "U", "\xF9": "u", "\xFA": "u", "\xFB": "u", "\xFC": "u", "\xDD": "Y", "\xFD": "y", "\xFF": "y", "\xC6": "Ae", "\xE6": "ae", "\xDE": "Th", "\xFE": "th", "\xDF": "ss", "\u0100": "A", "\u0102": "A", "\u0104": "A", "\u0101": "a", "\u0103": "a", "\u0105": "a", "\u0106": "C", "\u0108": "C", "\u010A": "C", "\u010C": "C", "\u0107": "c", "\u0109": "c", "\u010B": "c", "\u010D": "c", "\u010E": "D", "\u0110": "D", "\u010F": "d", "\u0111": "d", "\u0112": "E", "\u0114": "E", "\u0116": "E", "\u0118": "E", "\u011A": "E", "\u0113": "e", "\u0115": "e", "\u0117": "e", "\u0119": "e", "\u011B": "e", "\u011C": "G", "\u011E": "G", "\u0120": "G", "\u0122": "G", "\u011D": "g", "\u011F": "g", "\u0121": "g", "\u0123": "g", "\u0124": "H", "\u0126": "H", "\u0125": "h", "\u0127": "h", "\u0128": "I", "\u012A": "I", "\u012C": "I", "\u012E": "I", "\u0130": "I", "\u0129": "i", "\u012B": "i", "\u012D": "i", "\u012F": "i", "\u0131": "i", "\u0134": "J", "\u0135": "j", "\u0136": "K", "\u0137": "k", "\u0138": "k", "\u0139": "L", "\u013B": "L", "\u013D": "L", "\u013F": "L", "\u0141": "L", "\u013A": "l", "\u013C": "l", "\u013E": "l", "\u0140": "l", "\u0142": "l", "\u0143": "N", "\u0145": "N", "\u0147": "N", "\u014A": "N", "\u0144": "n", "\u0146": "n", "\u0148": "n", "\u014B": "n", "\u014C": "O", "\u014E": "O", "\u0150": "O", "\u014D": "o", "\u014F": "o", "\u0151": "o", "\u0154": "R", "\u0156": "R", "\u0158": "R", "\u0155": "r", "\u0157": "r", "\u0159": "r", "\u015A": "S", "\u015C": "S", "\u015E": "S", "\u0160": "S", "\u015B": "s", "\u015D": "s", "\u015F": "s", "\u0161": "s", "\u0162": "T", "\u0164": "T", "\u0166": "T", "\u0163": "t", "\u0165": "t", "\u0167": "t", "\u0168": "U", "\u016A": "U", "\u016C": "U", "\u016E": "U", "\u0170": "U", "\u0172": "U", "\u0169": "u", "\u016B": "u", "\u016D": "u", "\u016F": "u", "\u0171": "u", "\u0173": "u", "\u0174": "W", "\u0175": "w", "\u0176": "Y", "\u0177": "y", "\u0178": "Y", "\u0179": "Z", "\u017B": "Z", "\u017D": "Z", "\u017A": "z", "\u017C": "z", "\u017E": "z", "\u0132": "IJ", "\u0133": "ij", "\u0152": "Oe", "\u0153": "oe", "\u0149": "'n", "\u017F": "s" }), nr2 = ze2({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" });
    function ir2(t8) {
      return "\\" + se2[t8];
    }
    function ar2(t8) {
      return ee2.test(t8);
    }
    function or2(t8) {
      var e3 = -1, r3 = Array(t8.size);
      return t8.forEach(function(t9, n3) {
        r3[++e3] = [n3, t9];
      }), r3;
    }
    function sr2(t8, e3) {
      return function(r3) {
        return t8(e3(r3));
      };
    }
    function ur2(t8, e3) {
      for (var r3 = -1, n3 = t8.length, i3 = 0, o3 = []; ++r3 < n3; ) {
        var s3 = t8[r3];
        s3 !== e3 && s3 !== a2 || (t8[r3] = a2, o3[i3++] = r3);
      }
      return o3;
    }
    function cr2(t8) {
      var e3 = -1, r3 = Array(t8.size);
      return t8.forEach(function(t9) {
        r3[++e3] = t9;
      }), r3;
    }
    function fr2(t8) {
      var e3 = -1, r3 = Array(t8.size);
      return t8.forEach(function(t9) {
        r3[++e3] = [t9, t9];
      }), r3;
    }
    function lr2(t8) {
      return ar2(t8) ? function(t9) {
        var e3 = Jt2.lastIndex = 0;
        for (; Jt2.test(t9); )
          ++e3;
        return e3;
      }(t8) : De2(t8);
    }
    function hr2(t8) {
      return ar2(t8) ? function(t9) {
        return t9.match(Jt2) || [];
      }(t8) : function(t9) {
        return t9.split("");
      }(t8);
    }
    function pr2(t8) {
      for (var e3 = t8.length; e3-- && ot2.test(t8.charAt(e3)); )
        ;
      return e3;
    }
    var dr2 = ze2({ "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"', "&#39;": "'" });
    var yr2 = function t8(e3) {
      var A2, ot3 = (e3 = e3 == null ? he2 : yr2.defaults(he2.Object(), e3, yr2.pick(he2, ne2))).Array, Tt3 = e3.Date, It3 = e3.Error, At3 = e3.Function, wt3 = e3.Math, _t3 = e3.Object, Bt3 = e3.RegExp, Nt3 = e3.String, kt3 = e3.TypeError, Rt3 = ot3.prototype, Ot3 = At3.prototype, Lt3 = _t3.prototype, Pt3 = e3["__core-js_shared__"], Ut3 = Ot3.toString, xt3 = Lt3.hasOwnProperty, Dt3 = 0, Vt3 = (A2 = /[^.]+$/.exec(Pt3 && Pt3.keys && Pt3.keys.IE_PROTO || "")) ? "Symbol(src)_1." + A2 : "", Mt3 = Lt3.toString, jt3 = Ut3.call(_t3), Ft3 = he2._, Kt3 = Bt3("^" + Ut3.call(xt3).replace(nt2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), qt3 = ye2 ? e3.Buffer : r2, Gt3 = e3.Symbol, zt3 = e3.Uint8Array, Wt3 = qt3 ? qt3.allocUnsafe : r2, Ht3 = sr2(_t3.getPrototypeOf, _t3), Qt3 = _t3.create, Yt3 = Lt3.propertyIsEnumerable, Xt3 = Rt3.splice, Jt3 = Gt3 ? Gt3.isConcatSpreadable : r2, ee3 = Gt3 ? Gt3.iterator : r2, se3 = Gt3 ? Gt3.toStringTag : r2, fe3 = function() {
        try {
          var t9 = pa2(_t3, "defineProperty");
          return t9({}, "", {}), t9;
        } catch (t10) {
        }
      }(), le3 = e3.clearTimeout !== he2.clearTimeout && e3.clearTimeout, pe3 = Tt3 && Tt3.now !== he2.Date.now && Tt3.now, de3 = e3.setTimeout !== he2.setTimeout && e3.setTimeout, ge3 = wt3.ceil, ve3 = wt3.floor, De3 = _t3.getOwnPropertySymbols, ze3 = qt3 ? qt3.isBuffer : r2, gr2 = e3.isFinite, vr2 = Rt3.join, mr2 = sr2(_t3.keys, _t3), Cr2 = wt3.max, Er2 = wt3.min, Sr2 = Tt3.now, br2 = e3.parseInt, Tr2 = wt3.random, Ir = Rt3.reverse, Ar = pa2(e3, "DataView"), wr = pa2(e3, "Map"), _r2 = pa2(e3, "Promise"), Br2 = pa2(e3, "Set"), Nr2 = pa2(e3, "WeakMap"), kr2 = pa2(_t3, "create"), Rr2 = Nr2 && new Nr2(), Or2 = {}, Lr2 = ja2(Ar), Pr2 = ja2(wr), Ur2 = ja2(_r2), xr2 = ja2(Br2), Dr2 = ja2(Nr2), Vr2 = Gt3 ? Gt3.prototype : r2, Mr2 = Vr2 ? Vr2.valueOf : r2, jr2 = Vr2 ? Vr2.toString : r2;
      function Fr2(t9) {
        if (is2(t9) && !Ho2(t9) && !(t9 instanceof zr2)) {
          if (t9 instanceof Gr2)
            return t9;
          if (xt3.call(t9, "__wrapped__"))
            return Fa2(t9);
        }
        return new Gr2(t9);
      }
      var Kr2 = function() {
        function t9() {
        }
        return function(e4) {
          if (!ns2(e4))
            return {};
          if (Qt3)
            return Qt3(e4);
          t9.prototype = e4;
          var n3 = new t9();
          return t9.prototype = r2, n3;
        };
      }();
      function qr2() {
      }
      function Gr2(t9, e4) {
        this.__wrapped__ = t9, this.__actions__ = [], this.__chain__ = !!e4, this.__index__ = 0, this.__values__ = r2;
      }
      function zr2(t9) {
        this.__wrapped__ = t9, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = false, this.__iteratees__ = [], this.__takeCount__ = d2, this.__views__ = [];
      }
      function Wr2(t9) {
        var e4 = -1, r3 = t9 == null ? 0 : t9.length;
        for (this.clear(); ++e4 < r3; ) {
          var n3 = t9[e4];
          this.set(n3[0], n3[1]);
        }
      }
      function Hr2(t9) {
        var e4 = -1, r3 = t9 == null ? 0 : t9.length;
        for (this.clear(); ++e4 < r3; ) {
          var n3 = t9[e4];
          this.set(n3[0], n3[1]);
        }
      }
      function Qr2(t9) {
        var e4 = -1, r3 = t9 == null ? 0 : t9.length;
        for (this.clear(); ++e4 < r3; ) {
          var n3 = t9[e4];
          this.set(n3[0], n3[1]);
        }
      }
      function Yr2(t9) {
        var e4 = -1, r3 = t9 == null ? 0 : t9.length;
        for (this.__data__ = new Qr2(); ++e4 < r3; )
          this.add(t9[e4]);
      }
      function Xr2(t9) {
        var e4 = this.__data__ = new Hr2(t9);
        this.size = e4.size;
      }
      function $r2(t9, e4) {
        var r3 = Ho2(t9), n3 = !r3 && Wo2(t9), i3 = !r3 && !n3 && $o2(t9), a3 = !r3 && !n3 && !i3 && hs2(t9), o3 = r3 || n3 || i3 || a3, s3 = o3 ? Qe2(t9.length, Nt3) : [], u3 = s3.length;
        for (var c3 in t9)
          !e4 && !xt3.call(t9, c3) || o3 && (c3 == "length" || i3 && (c3 == "offset" || c3 == "parent") || a3 && (c3 == "buffer" || c3 == "byteLength" || c3 == "byteOffset") || Ea2(c3, u3)) || s3.push(c3);
        return s3;
      }
      function Zr2(t9) {
        var e4 = t9.length;
        return e4 ? t9[Xn2(0, e4 - 1)] : r2;
      }
      function Jr2(t9, e4) {
        return Da2(Ri2(t9), cn2(e4, 0, t9.length));
      }
      function tn2(t9) {
        return Da2(Ri2(t9));
      }
      function en2(t9, e4, n3) {
        (n3 !== r2 && !qo2(t9[e4], n3) || n3 === r2 && !(e4 in t9)) && sn2(t9, e4, n3);
      }
      function rn2(t9, e4, n3) {
        var i3 = t9[e4];
        xt3.call(t9, e4) && qo2(i3, n3) && (n3 !== r2 || e4 in t9) || sn2(t9, e4, n3);
      }
      function nn2(t9, e4) {
        for (var r3 = t9.length; r3--; )
          if (qo2(t9[r3][0], e4))
            return r3;
        return -1;
      }
      function an2(t9, e4, r3, n3) {
        return dn2(t9, function(t10, i3, a3) {
          e4(n3, t10, r3(t10), a3);
        }), n3;
      }
      function on2(t9, e4) {
        return t9 && Oi2(e4, Ps2(e4), t9);
      }
      function sn2(t9, e4, r3) {
        e4 == "__proto__" && fe3 ? fe3(t9, e4, { configurable: true, enumerable: true, value: r3, writable: true }) : t9[e4] = r3;
      }
      function un2(t9, e4) {
        for (var n3 = -1, i3 = e4.length, a3 = ot3(i3), o3 = t9 == null; ++n3 < i3; )
          a3[n3] = o3 ? r2 : Ns2(t9, e4[n3]);
        return a3;
      }
      function cn2(t9, e4, n3) {
        return t9 == t9 && (n3 !== r2 && (t9 = t9 <= n3 ? t9 : n3), e4 !== r2 && (t9 = t9 >= e4 ? t9 : e4)), t9;
      }
      function fn2(t9, e4, n3, i3, a3, o3) {
        var s3, u3 = 1 & e4, c3 = 2 & e4, f3 = 4 & e4;
        if (n3 && (s3 = a3 ? n3(t9, i3, a3, o3) : n3(t9)), s3 !== r2)
          return s3;
        if (!ns2(t9))
          return t9;
        var l3 = Ho2(t9);
        if (l3) {
          if (s3 = function(t10) {
            var e5 = t10.length, r3 = new t10.constructor(e5);
            e5 && typeof t10[0] == "string" && xt3.call(t10, "index") && (r3.index = t10.index, r3.input = t10.input);
            return r3;
          }(t9), !u3)
            return Ri2(t9, s3);
        } else {
          var h3 = ga2(t9), p3 = h3 == S2 || h3 == b2;
          if ($o2(t9))
            return Ai2(t9, u3);
          if (h3 == w2 || h3 == g2 || p3 && !a3) {
            if (s3 = c3 || p3 ? {} : ma2(t9), !u3)
              return c3 ? function(t10, e5) {
                return Oi2(t10, ya2(t10), e5);
              }(t9, function(t10, e5) {
                return t10 && Oi2(e5, Us2(e5), t10);
              }(s3, t9)) : function(t10, e5) {
                return Oi2(t10, da2(t10), e5);
              }(t9, on2(s3, t9));
          } else {
            if (!oe2[h3])
              return a3 ? t9 : {};
            s3 = function(t10, e5, r3) {
              var n4 = t10.constructor;
              switch (e5) {
                case L2:
                  return wi2(t10);
                case m2:
                case C2:
                  return new n4(+t10);
                case P2:
                  return function(t11, e6) {
                    var r4 = e6 ? wi2(t11.buffer) : t11.buffer;
                    return new t11.constructor(r4, t11.byteOffset, t11.byteLength);
                  }(t10, r3);
                case U2:
                case x2:
                case D2:
                case V2:
                case M2:
                case j2:
                case F2:
                case K2:
                case q2:
                  return _i2(t10, r3);
                case T2:
                  return new n4();
                case I2:
                case k2:
                  return new n4(t10);
                case B2:
                  return function(t11) {
                    var e6 = new t11.constructor(t11.source, dt2.exec(t11));
                    return e6.lastIndex = t11.lastIndex, e6;
                  }(t10);
                case N2:
                  return new n4();
                case R2:
                  return i4 = t10, Mr2 ? _t3(Mr2.call(i4)) : {};
              }
              var i4;
            }(t9, h3, u3);
          }
        }
        o3 || (o3 = new Xr2());
        var d3 = o3.get(t9);
        if (d3)
          return d3;
        o3.set(t9, s3), cs2(t9) ? t9.forEach(function(r3) {
          s3.add(fn2(r3, e4, n3, r3, t9, o3));
        }) : as2(t9) && t9.forEach(function(r3, i4) {
          s3.set(i4, fn2(r3, e4, n3, i4, t9, o3));
        });
        var y3 = l3 ? r2 : (f3 ? c3 ? oa2 : aa2 : c3 ? Us2 : Ps2)(t9);
        return we2(y3 || t9, function(r3, i4) {
          y3 && (r3 = t9[i4 = r3]), rn2(s3, i4, fn2(r3, e4, n3, i4, t9, o3));
        }), s3;
      }
      function ln2(t9, e4, n3) {
        var i3 = n3.length;
        if (t9 == null)
          return !i3;
        for (t9 = _t3(t9); i3--; ) {
          var a3 = n3[i3], o3 = e4[a3], s3 = t9[a3];
          if (s3 === r2 && !(a3 in t9) || !o3(s3))
            return false;
        }
        return true;
      }
      function hn2(t9, e4, i3) {
        if (typeof t9 != "function")
          throw new kt3(n2);
        return La2(function() {
          t9.apply(r2, i3);
        }, e4);
      }
      function pn2(t9, e4, r3, n3) {
        var i3 = -1, a3 = ke2, o3 = true, s3 = t9.length, u3 = [], c3 = e4.length;
        if (!s3)
          return u3;
        r3 && (e4 = Oe2(e4, Xe2(r3))), n3 ? (a3 = Re2, o3 = false) : e4.length >= 200 && (a3 = Ze2, o3 = false, e4 = new Yr2(e4));
        t:
          for (; ++i3 < s3; ) {
            var f3 = t9[i3], l3 = r3 == null ? f3 : r3(f3);
            if (f3 = n3 || f3 !== 0 ? f3 : 0, o3 && l3 == l3) {
              for (var h3 = c3; h3--; )
                if (e4[h3] === l3)
                  continue t;
              u3.push(f3);
            } else
              a3(e4, l3, n3) || u3.push(f3);
          }
        return u3;
      }
      Fr2.templateSettings = { escape: $2, evaluate: Z2, interpolate: J2, variable: "", imports: { _: Fr2 } }, Fr2.prototype = qr2.prototype, Fr2.prototype.constructor = Fr2, Gr2.prototype = Kr2(qr2.prototype), Gr2.prototype.constructor = Gr2, zr2.prototype = Kr2(qr2.prototype), zr2.prototype.constructor = zr2, Wr2.prototype.clear = function() {
        this.__data__ = kr2 ? kr2(null) : {}, this.size = 0;
      }, Wr2.prototype.delete = function(t9) {
        var e4 = this.has(t9) && delete this.__data__[t9];
        return this.size -= e4 ? 1 : 0, e4;
      }, Wr2.prototype.get = function(t9) {
        var e4 = this.__data__;
        if (kr2) {
          var n3 = e4[t9];
          return n3 === i2 ? r2 : n3;
        }
        return xt3.call(e4, t9) ? e4[t9] : r2;
      }, Wr2.prototype.has = function(t9) {
        var e4 = this.__data__;
        return kr2 ? e4[t9] !== r2 : xt3.call(e4, t9);
      }, Wr2.prototype.set = function(t9, e4) {
        var n3 = this.__data__;
        return this.size += this.has(t9) ? 0 : 1, n3[t9] = kr2 && e4 === r2 ? i2 : e4, this;
      }, Hr2.prototype.clear = function() {
        this.__data__ = [], this.size = 0;
      }, Hr2.prototype.delete = function(t9) {
        var e4 = this.__data__, r3 = nn2(e4, t9);
        return !(r3 < 0) && (r3 == e4.length - 1 ? e4.pop() : Xt3.call(e4, r3, 1), --this.size, true);
      }, Hr2.prototype.get = function(t9) {
        var e4 = this.__data__, n3 = nn2(e4, t9);
        return n3 < 0 ? r2 : e4[n3][1];
      }, Hr2.prototype.has = function(t9) {
        return nn2(this.__data__, t9) > -1;
      }, Hr2.prototype.set = function(t9, e4) {
        var r3 = this.__data__, n3 = nn2(r3, t9);
        return n3 < 0 ? (++this.size, r3.push([t9, e4])) : r3[n3][1] = e4, this;
      }, Qr2.prototype.clear = function() {
        this.size = 0, this.__data__ = { hash: new Wr2(), map: new (wr || Hr2)(), string: new Wr2() };
      }, Qr2.prototype.delete = function(t9) {
        var e4 = la2(this, t9).delete(t9);
        return this.size -= e4 ? 1 : 0, e4;
      }, Qr2.prototype.get = function(t9) {
        return la2(this, t9).get(t9);
      }, Qr2.prototype.has = function(t9) {
        return la2(this, t9).has(t9);
      }, Qr2.prototype.set = function(t9, e4) {
        var r3 = la2(this, t9), n3 = r3.size;
        return r3.set(t9, e4), this.size += r3.size == n3 ? 0 : 1, this;
      }, Yr2.prototype.add = Yr2.prototype.push = function(t9) {
        return this.__data__.set(t9, i2), this;
      }, Yr2.prototype.has = function(t9) {
        return this.__data__.has(t9);
      }, Xr2.prototype.clear = function() {
        this.__data__ = new Hr2(), this.size = 0;
      }, Xr2.prototype.delete = function(t9) {
        var e4 = this.__data__, r3 = e4.delete(t9);
        return this.size = e4.size, r3;
      }, Xr2.prototype.get = function(t9) {
        return this.__data__.get(t9);
      }, Xr2.prototype.has = function(t9) {
        return this.__data__.has(t9);
      }, Xr2.prototype.set = function(t9, e4) {
        var r3 = this.__data__;
        if (r3 instanceof Hr2) {
          var n3 = r3.__data__;
          if (!wr || n3.length < 199)
            return n3.push([t9, e4]), this.size = ++r3.size, this;
          r3 = this.__data__ = new Qr2(n3);
        }
        return r3.set(t9, e4), this.size = r3.size, this;
      };
      var dn2 = Ui2(bn2), yn2 = Ui2(Tn2, true);
      function gn2(t9, e4) {
        var r3 = true;
        return dn2(t9, function(t10, n3, i3) {
          return r3 = !!e4(t10, n3, i3);
        }), r3;
      }
      function vn2(t9, e4, n3) {
        for (var i3 = -1, a3 = t9.length; ++i3 < a3; ) {
          var o3 = t9[i3], s3 = e4(o3);
          if (s3 != null && (u3 === r2 ? s3 == s3 && !ls2(s3) : n3(s3, u3)))
            var u3 = s3, c3 = o3;
        }
        return c3;
      }
      function mn2(t9, e4) {
        var r3 = [];
        return dn2(t9, function(t10, n3, i3) {
          e4(t10, n3, i3) && r3.push(t10);
        }), r3;
      }
      function Cn2(t9, e4, r3, n3, i3) {
        var a3 = -1, o3 = t9.length;
        for (r3 || (r3 = Ca2), i3 || (i3 = []); ++a3 < o3; ) {
          var s3 = t9[a3];
          e4 > 0 && r3(s3) ? e4 > 1 ? Cn2(s3, e4 - 1, r3, n3, i3) : Le2(i3, s3) : n3 || (i3[i3.length] = s3);
        }
        return i3;
      }
      var En2 = xi2(), Sn2 = xi2(true);
      function bn2(t9, e4) {
        return t9 && En2(t9, e4, Ps2);
      }
      function Tn2(t9, e4) {
        return t9 && Sn2(t9, e4, Ps2);
      }
      function In2(t9, e4) {
        return Ne2(e4, function(e5) {
          return ts2(t9[e5]);
        });
      }
      function An2(t9, e4) {
        for (var n3 = 0, i3 = (e4 = Si2(e4, t9)).length; t9 != null && n3 < i3; )
          t9 = t9[Ma2(e4[n3++])];
        return n3 && n3 == i3 ? t9 : r2;
      }
      function wn2(t9, e4, r3) {
        var n3 = e4(t9);
        return Ho2(t9) ? n3 : Le2(n3, r3(t9));
      }
      function _n2(t9) {
        return t9 == null ? t9 === r2 ? "[object Undefined]" : "[object Null]" : se3 && se3 in _t3(t9) ? function(t10) {
          var e4 = xt3.call(t10, se3), n3 = t10[se3];
          try {
            t10[se3] = r2;
            var i3 = true;
          } catch (t11) {
          }
          var a3 = Mt3.call(t10);
          i3 && (e4 ? t10[se3] = n3 : delete t10[se3]);
          return a3;
        }(t9) : function(t10) {
          return Mt3.call(t10);
        }(t9);
      }
      function Bn2(t9, e4) {
        return t9 > e4;
      }
      function Nn2(t9, e4) {
        return t9 != null && xt3.call(t9, e4);
      }
      function kn2(t9, e4) {
        return t9 != null && e4 in _t3(t9);
      }
      function Rn2(t9, e4, n3) {
        for (var i3 = n3 ? Re2 : ke2, a3 = t9[0].length, o3 = t9.length, s3 = o3, u3 = ot3(o3), c3 = 1 / 0, f3 = []; s3--; ) {
          var l3 = t9[s3];
          s3 && e4 && (l3 = Oe2(l3, Xe2(e4))), c3 = Er2(l3.length, c3), u3[s3] = !n3 && (e4 || a3 >= 120 && l3.length >= 120) ? new Yr2(s3 && l3) : r2;
        }
        l3 = t9[0];
        var h3 = -1, p3 = u3[0];
        t:
          for (; ++h3 < a3 && f3.length < c3; ) {
            var d3 = l3[h3], y3 = e4 ? e4(d3) : d3;
            if (d3 = n3 || d3 !== 0 ? d3 : 0, !(p3 ? Ze2(p3, y3) : i3(f3, y3, n3))) {
              for (s3 = o3; --s3; ) {
                var g3 = u3[s3];
                if (!(g3 ? Ze2(g3, y3) : i3(t9[s3], y3, n3)))
                  continue t;
              }
              p3 && p3.push(y3), f3.push(d3);
            }
          }
        return f3;
      }
      function On2(t9, e4, n3) {
        var i3 = (t9 = Na2(t9, e4 = Si2(e4, t9))) == null ? t9 : t9[Ma2(Za2(e4))];
        return i3 == null ? r2 : Ie2(i3, t9, n3);
      }
      function Ln2(t9) {
        return is2(t9) && _n2(t9) == g2;
      }
      function Pn2(t9, e4, n3, i3, a3) {
        return t9 === e4 || (t9 == null || e4 == null || !is2(t9) && !is2(e4) ? t9 != t9 && e4 != e4 : function(t10, e5, n4, i4, a4, o3) {
          var s3 = Ho2(t10), u3 = Ho2(e5), c3 = s3 ? v2 : ga2(t10), f3 = u3 ? v2 : ga2(e5), l3 = (c3 = c3 == g2 ? w2 : c3) == w2, h3 = (f3 = f3 == g2 ? w2 : f3) == w2, p3 = c3 == f3;
          if (p3 && $o2(t10)) {
            if (!$o2(e5))
              return false;
            s3 = true, l3 = false;
          }
          if (p3 && !l3)
            return o3 || (o3 = new Xr2()), s3 || hs2(t10) ? na2(t10, e5, n4, i4, a4, o3) : function(t11, e6, r3, n5, i5, a5, o4) {
              switch (r3) {
                case P2:
                  if (t11.byteLength != e6.byteLength || t11.byteOffset != e6.byteOffset)
                    return false;
                  t11 = t11.buffer, e6 = e6.buffer;
                case L2:
                  return !(t11.byteLength != e6.byteLength || !a5(new zt3(t11), new zt3(e6)));
                case m2:
                case C2:
                case I2:
                  return qo2(+t11, +e6);
                case E2:
                  return t11.name == e6.name && t11.message == e6.message;
                case B2:
                case k2:
                  return t11 == e6 + "";
                case T2:
                  var s4 = or2;
                case N2:
                  var u4 = 1 & n5;
                  if (s4 || (s4 = cr2), t11.size != e6.size && !u4)
                    return false;
                  var c4 = o4.get(t11);
                  if (c4)
                    return c4 == e6;
                  n5 |= 2, o4.set(t11, e6);
                  var f4 = na2(s4(t11), s4(e6), n5, i5, a5, o4);
                  return o4.delete(t11), f4;
                case R2:
                  if (Mr2)
                    return Mr2.call(t11) == Mr2.call(e6);
              }
              return false;
            }(t10, e5, c3, n4, i4, a4, o3);
          if (!(1 & n4)) {
            var d3 = l3 && xt3.call(t10, "__wrapped__"), y3 = h3 && xt3.call(e5, "__wrapped__");
            if (d3 || y3) {
              var S3 = d3 ? t10.value() : t10, b3 = y3 ? e5.value() : e5;
              return o3 || (o3 = new Xr2()), a4(S3, b3, n4, i4, o3);
            }
          }
          if (!p3)
            return false;
          return o3 || (o3 = new Xr2()), function(t11, e6, n5, i5, a5, o4) {
            var s4 = 1 & n5, u4 = aa2(t11), c4 = u4.length, f4 = aa2(e6).length;
            if (c4 != f4 && !s4)
              return false;
            var l4 = c4;
            for (; l4--; ) {
              var h4 = u4[l4];
              if (!(s4 ? h4 in e6 : xt3.call(e6, h4)))
                return false;
            }
            var p4 = o4.get(t11), d4 = o4.get(e6);
            if (p4 && d4)
              return p4 == e6 && d4 == t11;
            var y4 = true;
            o4.set(t11, e6), o4.set(e6, t11);
            var g3 = s4;
            for (; ++l4 < c4; ) {
              var v3 = t11[h4 = u4[l4]], m3 = e6[h4];
              if (i5)
                var C3 = s4 ? i5(m3, v3, h4, e6, t11, o4) : i5(v3, m3, h4, t11, e6, o4);
              if (!(C3 === r2 ? v3 === m3 || a5(v3, m3, n5, i5, o4) : C3)) {
                y4 = false;
                break;
              }
              g3 || (g3 = h4 == "constructor");
            }
            if (y4 && !g3) {
              var E3 = t11.constructor, S4 = e6.constructor;
              E3 == S4 || !("constructor" in t11) || !("constructor" in e6) || typeof E3 == "function" && E3 instanceof E3 && typeof S4 == "function" && S4 instanceof S4 || (y4 = false);
            }
            return o4.delete(t11), o4.delete(e6), y4;
          }(t10, e5, n4, i4, a4, o3);
        }(t9, e4, n3, i3, Pn2, a3));
      }
      function Un2(t9, e4, n3, i3) {
        var a3 = n3.length, o3 = a3, s3 = !i3;
        if (t9 == null)
          return !o3;
        for (t9 = _t3(t9); a3--; ) {
          var u3 = n3[a3];
          if (s3 && u3[2] ? u3[1] !== t9[u3[0]] : !(u3[0] in t9))
            return false;
        }
        for (; ++a3 < o3; ) {
          var c3 = (u3 = n3[a3])[0], f3 = t9[c3], l3 = u3[1];
          if (s3 && u3[2]) {
            if (f3 === r2 && !(c3 in t9))
              return false;
          } else {
            var h3 = new Xr2();
            if (i3)
              var p3 = i3(f3, l3, c3, t9, e4, h3);
            if (!(p3 === r2 ? Pn2(l3, f3, 3, i3, h3) : p3))
              return false;
          }
        }
        return true;
      }
      function xn2(t9) {
        return !(!ns2(t9) || (e4 = t9, Vt3 && Vt3 in e4)) && (ts2(t9) ? Kt3 : vt2).test(ja2(t9));
        var e4;
      }
      function Dn2(t9) {
        return typeof t9 == "function" ? t9 : t9 == null ? ou2 : typeof t9 == "object" ? Ho2(t9) ? qn2(t9[0], t9[1]) : Kn2(t9) : yu(t9);
      }
      function Vn2(t9) {
        if (!Aa2(t9))
          return mr2(t9);
        var e4 = [];
        for (var r3 in _t3(t9))
          xt3.call(t9, r3) && r3 != "constructor" && e4.push(r3);
        return e4;
      }
      function Mn2(t9) {
        if (!ns2(t9))
          return function(t10) {
            var e5 = [];
            if (t10 != null)
              for (var r4 in _t3(t10))
                e5.push(r4);
            return e5;
          }(t9);
        var e4 = Aa2(t9), r3 = [];
        for (var n3 in t9)
          (n3 != "constructor" || !e4 && xt3.call(t9, n3)) && r3.push(n3);
        return r3;
      }
      function jn2(t9, e4) {
        return t9 < e4;
      }
      function Fn2(t9, e4) {
        var r3 = -1, n3 = Yo2(t9) ? ot3(t9.length) : [];
        return dn2(t9, function(t10, i3, a3) {
          n3[++r3] = e4(t10, i3, a3);
        }), n3;
      }
      function Kn2(t9) {
        var e4 = ha2(t9);
        return e4.length == 1 && e4[0][2] ? _a2(e4[0][0], e4[0][1]) : function(r3) {
          return r3 === t9 || Un2(r3, t9, e4);
        };
      }
      function qn2(t9, e4) {
        return ba2(t9) && wa2(e4) ? _a2(Ma2(t9), e4) : function(n3) {
          var i3 = Ns2(n3, t9);
          return i3 === r2 && i3 === e4 ? ks2(n3, t9) : Pn2(e4, i3, 3);
        };
      }
      function Gn2(t9, e4, n3, i3, a3) {
        t9 !== e4 && En2(e4, function(o3, s3) {
          if (a3 || (a3 = new Xr2()), ns2(o3))
            !function(t10, e5, n4, i4, a4, o4, s4) {
              var u4 = Ra2(t10, n4), c3 = Ra2(e5, n4), f3 = s4.get(c3);
              if (f3)
                return void en2(t10, n4, f3);
              var l3 = o4 ? o4(u4, c3, n4 + "", t10, e5, s4) : r2, h3 = l3 === r2;
              if (h3) {
                var p3 = Ho2(c3), d3 = !p3 && $o2(c3), y3 = !p3 && !d3 && hs2(c3);
                l3 = c3, p3 || d3 || y3 ? Ho2(u4) ? l3 = u4 : Xo2(u4) ? l3 = Ri2(u4) : d3 ? (h3 = false, l3 = Ai2(c3, true)) : y3 ? (h3 = false, l3 = _i2(c3, true)) : l3 = [] : ss2(c3) || Wo2(c3) ? (l3 = u4, Wo2(u4) ? l3 = Es2(u4) : ns2(u4) && !ts2(u4) || (l3 = ma2(c3))) : h3 = false;
              }
              h3 && (s4.set(c3, l3), a4(l3, c3, i4, o4, s4), s4.delete(c3));
              en2(t10, n4, l3);
            }(t9, e4, s3, n3, Gn2, i3, a3);
          else {
            var u3 = i3 ? i3(Ra2(t9, s3), o3, s3 + "", t9, e4, a3) : r2;
            u3 === r2 && (u3 = o3), en2(t9, s3, u3);
          }
        }, Us2);
      }
      function zn2(t9, e4) {
        var n3 = t9.length;
        if (n3)
          return Ea2(e4 += e4 < 0 ? n3 : 0, n3) ? t9[e4] : r2;
      }
      function Wn2(t9, e4, r3) {
        e4 = e4.length ? Oe2(e4, function(t10) {
          return Ho2(t10) ? function(e5) {
            return An2(e5, t10.length === 1 ? t10[0] : t10);
          } : t10;
        }) : [ou2];
        var n3 = -1;
        return e4 = Oe2(e4, Xe2(fa2())), function(t10, e5) {
          var r4 = t10.length;
          for (t10.sort(e5); r4--; )
            t10[r4] = t10[r4].value;
          return t10;
        }(Fn2(t9, function(t10, r4, i3) {
          return { criteria: Oe2(e4, function(e5) {
            return e5(t10);
          }), index: ++n3, value: t10 };
        }), function(t10, e5) {
          return function(t11, e6, r4) {
            var n4 = -1, i3 = t11.criteria, a3 = e6.criteria, o3 = i3.length, s3 = r4.length;
            for (; ++n4 < o3; ) {
              var u3 = Bi2(i3[n4], a3[n4]);
              if (u3)
                return n4 >= s3 ? u3 : u3 * (r4[n4] == "desc" ? -1 : 1);
            }
            return t11.index - e6.index;
          }(t10, e5, r3);
        });
      }
      function Hn2(t9, e4, r3) {
        for (var n3 = -1, i3 = e4.length, a3 = {}; ++n3 < i3; ) {
          var o3 = e4[n3], s3 = An2(t9, o3);
          r3(s3, o3) && ei2(a3, Si2(o3, t9), s3);
        }
        return a3;
      }
      function Qn(t9, e4, r3, n3) {
        var i3 = n3 ? Fe2 : je2, a3 = -1, o3 = e4.length, s3 = t9;
        for (t9 === e4 && (e4 = Ri2(e4)), r3 && (s3 = Oe2(t9, Xe2(r3))); ++a3 < o3; )
          for (var u3 = 0, c3 = e4[a3], f3 = r3 ? r3(c3) : c3; (u3 = i3(s3, f3, u3, n3)) > -1; )
            s3 !== t9 && Xt3.call(s3, u3, 1), Xt3.call(t9, u3, 1);
        return t9;
      }
      function Yn2(t9, e4) {
        for (var r3 = t9 ? e4.length : 0, n3 = r3 - 1; r3--; ) {
          var i3 = e4[r3];
          if (r3 == n3 || i3 !== a3) {
            var a3 = i3;
            Ea2(i3) ? Xt3.call(t9, i3, 1) : pi2(t9, i3);
          }
        }
        return t9;
      }
      function Xn2(t9, e4) {
        return t9 + ve3(Tr2() * (e4 - t9 + 1));
      }
      function $n2(t9, e4) {
        var r3 = "";
        if (!t9 || e4 < 1 || e4 > h2)
          return r3;
        do {
          e4 % 2 && (r3 += t9), (e4 = ve3(e4 / 2)) && (t9 += t9);
        } while (e4);
        return r3;
      }
      function Zn2(t9, e4) {
        return Pa2(Ba2(t9, e4, ou2), t9 + "");
      }
      function Jn2(t9) {
        return Zr2(qs2(t9));
      }
      function ti2(t9, e4) {
        var r3 = qs2(t9);
        return Da2(r3, cn2(e4, 0, r3.length));
      }
      function ei2(t9, e4, n3, i3) {
        if (!ns2(t9))
          return t9;
        for (var a3 = -1, o3 = (e4 = Si2(e4, t9)).length, s3 = o3 - 1, u3 = t9; u3 != null && ++a3 < o3; ) {
          var c3 = Ma2(e4[a3]), f3 = n3;
          if (c3 === "__proto__" || c3 === "constructor" || c3 === "prototype")
            return t9;
          if (a3 != s3) {
            var l3 = u3[c3];
            (f3 = i3 ? i3(l3, c3, u3) : r2) === r2 && (f3 = ns2(l3) ? l3 : Ea2(e4[a3 + 1]) ? [] : {});
          }
          rn2(u3, c3, f3), u3 = u3[c3];
        }
        return t9;
      }
      var ri2 = Rr2 ? function(t9, e4) {
        return Rr2.set(t9, e4), t9;
      } : ou2, ni2 = fe3 ? function(t9, e4) {
        return fe3(t9, "toString", { configurable: true, enumerable: false, value: nu2(e4), writable: true });
      } : ou2;
      function ii2(t9) {
        return Da2(qs2(t9));
      }
      function ai2(t9, e4, r3) {
        var n3 = -1, i3 = t9.length;
        e4 < 0 && (e4 = -e4 > i3 ? 0 : i3 + e4), (r3 = r3 > i3 ? i3 : r3) < 0 && (r3 += i3), i3 = e4 > r3 ? 0 : r3 - e4 >>> 0, e4 >>>= 0;
        for (var a3 = ot3(i3); ++n3 < i3; )
          a3[n3] = t9[n3 + e4];
        return a3;
      }
      function oi2(t9, e4) {
        var r3;
        return dn2(t9, function(t10, n3, i3) {
          return !(r3 = e4(t10, n3, i3));
        }), !!r3;
      }
      function si2(t9, e4, r3) {
        var n3 = 0, i3 = t9 == null ? n3 : t9.length;
        if (typeof e4 == "number" && e4 == e4 && i3 <= 2147483647) {
          for (; n3 < i3; ) {
            var a3 = n3 + i3 >>> 1, o3 = t9[a3];
            o3 !== null && !ls2(o3) && (r3 ? o3 <= e4 : o3 < e4) ? n3 = a3 + 1 : i3 = a3;
          }
          return i3;
        }
        return ui2(t9, e4, ou2, r3);
      }
      function ui2(t9, e4, n3, i3) {
        var a3 = 0, o3 = t9 == null ? 0 : t9.length;
        if (o3 === 0)
          return 0;
        for (var s3 = (e4 = n3(e4)) != e4, u3 = e4 === null, c3 = ls2(e4), f3 = e4 === r2; a3 < o3; ) {
          var l3 = ve3((a3 + o3) / 2), h3 = n3(t9[l3]), p3 = h3 !== r2, d3 = h3 === null, y3 = h3 == h3, g3 = ls2(h3);
          if (s3)
            var v3 = i3 || y3;
          else
            v3 = f3 ? y3 && (i3 || p3) : u3 ? y3 && p3 && (i3 || !d3) : c3 ? y3 && p3 && !d3 && (i3 || !g3) : !d3 && !g3 && (i3 ? h3 <= e4 : h3 < e4);
          v3 ? a3 = l3 + 1 : o3 = l3;
        }
        return Er2(o3, 4294967294);
      }
      function ci2(t9, e4) {
        for (var r3 = -1, n3 = t9.length, i3 = 0, a3 = []; ++r3 < n3; ) {
          var o3 = t9[r3], s3 = e4 ? e4(o3) : o3;
          if (!r3 || !qo2(s3, u3)) {
            var u3 = s3;
            a3[i3++] = o3 === 0 ? 0 : o3;
          }
        }
        return a3;
      }
      function fi2(t9) {
        return typeof t9 == "number" ? t9 : ls2(t9) ? p2 : +t9;
      }
      function li2(t9) {
        if (typeof t9 == "string")
          return t9;
        if (Ho2(t9))
          return Oe2(t9, li2) + "";
        if (ls2(t9))
          return jr2 ? jr2.call(t9) : "";
        var e4 = t9 + "";
        return e4 == "0" && 1 / t9 == -1 / 0 ? "-0" : e4;
      }
      function hi2(t9, e4, r3) {
        var n3 = -1, i3 = ke2, a3 = t9.length, o3 = true, s3 = [], u3 = s3;
        if (r3)
          o3 = false, i3 = Re2;
        else if (a3 >= 200) {
          var c3 = e4 ? null : $i2(t9);
          if (c3)
            return cr2(c3);
          o3 = false, i3 = Ze2, u3 = new Yr2();
        } else
          u3 = e4 ? [] : s3;
        t:
          for (; ++n3 < a3; ) {
            var f3 = t9[n3], l3 = e4 ? e4(f3) : f3;
            if (f3 = r3 || f3 !== 0 ? f3 : 0, o3 && l3 == l3) {
              for (var h3 = u3.length; h3--; )
                if (u3[h3] === l3)
                  continue t;
              e4 && u3.push(l3), s3.push(f3);
            } else
              i3(u3, l3, r3) || (u3 !== s3 && u3.push(l3), s3.push(f3));
          }
        return s3;
      }
      function pi2(t9, e4) {
        return (t9 = Na2(t9, e4 = Si2(e4, t9))) == null || delete t9[Ma2(Za2(e4))];
      }
      function di2(t9, e4, r3, n3) {
        return ei2(t9, e4, r3(An2(t9, e4)), n3);
      }
      function yi2(t9, e4, r3, n3) {
        for (var i3 = t9.length, a3 = n3 ? i3 : -1; (n3 ? a3-- : ++a3 < i3) && e4(t9[a3], a3, t9); )
          ;
        return r3 ? ai2(t9, n3 ? 0 : a3, n3 ? a3 + 1 : i3) : ai2(t9, n3 ? a3 + 1 : 0, n3 ? i3 : a3);
      }
      function gi2(t9, e4) {
        var r3 = t9;
        return r3 instanceof zr2 && (r3 = r3.value()), Pe2(e4, function(t10, e5) {
          return e5.func.apply(e5.thisArg, Le2([t10], e5.args));
        }, r3);
      }
      function vi2(t9, e4, r3) {
        var n3 = t9.length;
        if (n3 < 2)
          return n3 ? hi2(t9[0]) : [];
        for (var i3 = -1, a3 = ot3(n3); ++i3 < n3; )
          for (var o3 = t9[i3], s3 = -1; ++s3 < n3; )
            s3 != i3 && (a3[i3] = pn2(a3[i3] || o3, t9[s3], e4, r3));
        return hi2(Cn2(a3, 1), e4, r3);
      }
      function mi2(t9, e4, n3) {
        for (var i3 = -1, a3 = t9.length, o3 = e4.length, s3 = {}; ++i3 < a3; ) {
          var u3 = i3 < o3 ? e4[i3] : r2;
          n3(s3, t9[i3], u3);
        }
        return s3;
      }
      function Ci2(t9) {
        return Xo2(t9) ? t9 : [];
      }
      function Ei2(t9) {
        return typeof t9 == "function" ? t9 : ou2;
      }
      function Si2(t9, e4) {
        return Ho2(t9) ? t9 : ba2(t9, e4) ? [t9] : Va2(Ss2(t9));
      }
      var bi2 = Zn2;
      function Ti2(t9, e4, n3) {
        var i3 = t9.length;
        return n3 = n3 === r2 ? i3 : n3, !e4 && n3 >= i3 ? t9 : ai2(t9, e4, n3);
      }
      var Ii2 = le3 || function(t9) {
        return he2.clearTimeout(t9);
      };
      function Ai2(t9, e4) {
        if (e4)
          return t9.slice();
        var r3 = t9.length, n3 = Wt3 ? Wt3(r3) : new t9.constructor(r3);
        return t9.copy(n3), n3;
      }
      function wi2(t9) {
        var e4 = new t9.constructor(t9.byteLength);
        return new zt3(e4).set(new zt3(t9)), e4;
      }
      function _i2(t9, e4) {
        var r3 = e4 ? wi2(t9.buffer) : t9.buffer;
        return new t9.constructor(r3, t9.byteOffset, t9.length);
      }
      function Bi2(t9, e4) {
        if (t9 !== e4) {
          var n3 = t9 !== r2, i3 = t9 === null, a3 = t9 == t9, o3 = ls2(t9), s3 = e4 !== r2, u3 = e4 === null, c3 = e4 == e4, f3 = ls2(e4);
          if (!u3 && !f3 && !o3 && t9 > e4 || o3 && s3 && c3 && !u3 && !f3 || i3 && s3 && c3 || !n3 && c3 || !a3)
            return 1;
          if (!i3 && !o3 && !f3 && t9 < e4 || f3 && n3 && a3 && !i3 && !o3 || u3 && n3 && a3 || !s3 && a3 || !c3)
            return -1;
        }
        return 0;
      }
      function Ni2(t9, e4, r3, n3) {
        for (var i3 = -1, a3 = t9.length, o3 = r3.length, s3 = -1, u3 = e4.length, c3 = Cr2(a3 - o3, 0), f3 = ot3(u3 + c3), l3 = !n3; ++s3 < u3; )
          f3[s3] = e4[s3];
        for (; ++i3 < o3; )
          (l3 || i3 < a3) && (f3[r3[i3]] = t9[i3]);
        for (; c3--; )
          f3[s3++] = t9[i3++];
        return f3;
      }
      function ki2(t9, e4, r3, n3) {
        for (var i3 = -1, a3 = t9.length, o3 = -1, s3 = r3.length, u3 = -1, c3 = e4.length, f3 = Cr2(a3 - s3, 0), l3 = ot3(f3 + c3), h3 = !n3; ++i3 < f3; )
          l3[i3] = t9[i3];
        for (var p3 = i3; ++u3 < c3; )
          l3[p3 + u3] = e4[u3];
        for (; ++o3 < s3; )
          (h3 || i3 < a3) && (l3[p3 + r3[o3]] = t9[i3++]);
        return l3;
      }
      function Ri2(t9, e4) {
        var r3 = -1, n3 = t9.length;
        for (e4 || (e4 = ot3(n3)); ++r3 < n3; )
          e4[r3] = t9[r3];
        return e4;
      }
      function Oi2(t9, e4, n3, i3) {
        var a3 = !n3;
        n3 || (n3 = {});
        for (var o3 = -1, s3 = e4.length; ++o3 < s3; ) {
          var u3 = e4[o3], c3 = i3 ? i3(n3[u3], t9[u3], u3, n3, t9) : r2;
          c3 === r2 && (c3 = t9[u3]), a3 ? sn2(n3, u3, c3) : rn2(n3, u3, c3);
        }
        return n3;
      }
      function Li2(t9, e4) {
        return function(r3, n3) {
          var i3 = Ho2(r3) ? Ae2 : an2, a3 = e4 ? e4() : {};
          return i3(r3, t9, fa2(n3, 2), a3);
        };
      }
      function Pi2(t9) {
        return Zn2(function(e4, n3) {
          var i3 = -1, a3 = n3.length, o3 = a3 > 1 ? n3[a3 - 1] : r2, s3 = a3 > 2 ? n3[2] : r2;
          for (o3 = t9.length > 3 && typeof o3 == "function" ? (a3--, o3) : r2, s3 && Sa2(n3[0], n3[1], s3) && (o3 = a3 < 3 ? r2 : o3, a3 = 1), e4 = _t3(e4); ++i3 < a3; ) {
            var u3 = n3[i3];
            u3 && t9(e4, u3, i3, o3);
          }
          return e4;
        });
      }
      function Ui2(t9, e4) {
        return function(r3, n3) {
          if (r3 == null)
            return r3;
          if (!Yo2(r3))
            return t9(r3, n3);
          for (var i3 = r3.length, a3 = e4 ? i3 : -1, o3 = _t3(r3); (e4 ? a3-- : ++a3 < i3) && n3(o3[a3], a3, o3) !== false; )
            ;
          return r3;
        };
      }
      function xi2(t9) {
        return function(e4, r3, n3) {
          for (var i3 = -1, a3 = _t3(e4), o3 = n3(e4), s3 = o3.length; s3--; ) {
            var u3 = o3[t9 ? s3 : ++i3];
            if (r3(a3[u3], u3, a3) === false)
              break;
          }
          return e4;
        };
      }
      function Di2(t9) {
        return function(e4) {
          var n3 = ar2(e4 = Ss2(e4)) ? hr2(e4) : r2, i3 = n3 ? n3[0] : e4.charAt(0), a3 = n3 ? Ti2(n3, 1).join("") : e4.slice(1);
          return i3[t9]() + a3;
        };
      }
      function Vi(t9) {
        return function(e4) {
          return Pe2(tu2(Ws2(e4).replace($t2, "")), t9, "");
        };
      }
      function Mi(t9) {
        return function() {
          var e4 = arguments;
          switch (e4.length) {
            case 0:
              return new t9();
            case 1:
              return new t9(e4[0]);
            case 2:
              return new t9(e4[0], e4[1]);
            case 3:
              return new t9(e4[0], e4[1], e4[2]);
            case 4:
              return new t9(e4[0], e4[1], e4[2], e4[3]);
            case 5:
              return new t9(e4[0], e4[1], e4[2], e4[3], e4[4]);
            case 6:
              return new t9(e4[0], e4[1], e4[2], e4[3], e4[4], e4[5]);
            case 7:
              return new t9(e4[0], e4[1], e4[2], e4[3], e4[4], e4[5], e4[6]);
          }
          var r3 = Kr2(t9.prototype), n3 = t9.apply(r3, e4);
          return ns2(n3) ? n3 : r3;
        };
      }
      function ji(t9) {
        return function(e4, n3, i3) {
          var a3 = _t3(e4);
          if (!Yo2(e4)) {
            var o3 = fa2(n3, 3);
            e4 = Ps2(e4), n3 = function(t10) {
              return o3(a3[t10], t10, a3);
            };
          }
          var s3 = t9(e4, n3, i3);
          return s3 > -1 ? a3[o3 ? e4[s3] : s3] : r2;
        };
      }
      function Fi2(t9) {
        return ia2(function(e4) {
          var i3 = e4.length, a3 = i3, o3 = Gr2.prototype.thru;
          for (t9 && e4.reverse(); a3--; ) {
            var s3 = e4[a3];
            if (typeof s3 != "function")
              throw new kt3(n2);
            if (o3 && !u3 && ua2(s3) == "wrapper")
              var u3 = new Gr2([], true);
          }
          for (a3 = u3 ? a3 : i3; ++a3 < i3; ) {
            var c3 = ua2(s3 = e4[a3]), f3 = c3 == "wrapper" ? sa2(s3) : r2;
            u3 = f3 && Ta2(f3[0]) && f3[1] == 424 && !f3[4].length && f3[9] == 1 ? u3[ua2(f3[0])].apply(u3, f3[3]) : s3.length == 1 && Ta2(s3) ? u3[c3]() : u3.thru(s3);
          }
          return function() {
            var t10 = arguments, r3 = t10[0];
            if (u3 && t10.length == 1 && Ho2(r3))
              return u3.plant(r3).value();
            for (var n3 = 0, a4 = i3 ? e4[n3].apply(this, t10) : r3; ++n3 < i3; )
              a4 = e4[n3].call(this, a4);
            return a4;
          };
        });
      }
      function Ki2(t9, e4, n3, i3, a3, o3, s3, u3, f3, l3) {
        var h3 = e4 & c2, p3 = 1 & e4, d3 = 2 & e4, y3 = 24 & e4, g3 = 512 & e4, v3 = d3 ? r2 : Mi(t9);
        return function r3() {
          for (var c3 = arguments.length, m3 = ot3(c3), C3 = c3; C3--; )
            m3[C3] = arguments[C3];
          if (y3)
            var E3 = ca2(r3), S3 = er2(m3, E3);
          if (i3 && (m3 = Ni2(m3, i3, a3, y3)), o3 && (m3 = ki2(m3, o3, s3, y3)), c3 -= S3, y3 && c3 < l3) {
            var b3 = ur2(m3, E3);
            return Yi2(t9, e4, Ki2, r3.placeholder, n3, m3, b3, u3, f3, l3 - c3);
          }
          var T3 = p3 ? n3 : this, I3 = d3 ? T3[t9] : t9;
          return c3 = m3.length, u3 ? m3 = ka2(m3, u3) : g3 && c3 > 1 && m3.reverse(), h3 && f3 < c3 && (m3.length = f3), this && this !== he2 && this instanceof r3 && (I3 = v3 || Mi(I3)), I3.apply(T3, m3);
        };
      }
      function qi2(t9, e4) {
        return function(r3, n3) {
          return function(t10, e5, r4, n4) {
            return bn2(t10, function(t11, i3, a3) {
              e5(n4, r4(t11), i3, a3);
            }), n4;
          }(r3, t9, e4(n3), {});
        };
      }
      function Gi2(t9, e4) {
        return function(n3, i3) {
          var a3;
          if (n3 === r2 && i3 === r2)
            return e4;
          if (n3 !== r2 && (a3 = n3), i3 !== r2) {
            if (a3 === r2)
              return i3;
            typeof n3 == "string" || typeof i3 == "string" ? (n3 = li2(n3), i3 = li2(i3)) : (n3 = fi2(n3), i3 = fi2(i3)), a3 = t9(n3, i3);
          }
          return a3;
        };
      }
      function zi2(t9) {
        return ia2(function(e4) {
          return e4 = Oe2(e4, Xe2(fa2())), Zn2(function(r3) {
            var n3 = this;
            return t9(e4, function(t10) {
              return Ie2(t10, n3, r3);
            });
          });
        });
      }
      function Wi2(t9, e4) {
        var n3 = (e4 = e4 === r2 ? " " : li2(e4)).length;
        if (n3 < 2)
          return n3 ? $n2(e4, t9) : e4;
        var i3 = $n2(e4, ge3(t9 / lr2(e4)));
        return ar2(e4) ? Ti2(hr2(i3), 0, t9).join("") : i3.slice(0, t9);
      }
      function Hi2(t9) {
        return function(e4, n3, i3) {
          return i3 && typeof i3 != "number" && Sa2(e4, n3, i3) && (n3 = i3 = r2), e4 = gs2(e4), n3 === r2 ? (n3 = e4, e4 = 0) : n3 = gs2(n3), function(t10, e5, r3, n4) {
            for (var i4 = -1, a3 = Cr2(ge3((e5 - t10) / (r3 || 1)), 0), o3 = ot3(a3); a3--; )
              o3[n4 ? a3 : ++i4] = t10, t10 += r3;
            return o3;
          }(e4, n3, i3 = i3 === r2 ? e4 < n3 ? 1 : -1 : gs2(i3), t9);
        };
      }
      function Qi2(t9) {
        return function(e4, r3) {
          return typeof e4 == "string" && typeof r3 == "string" || (e4 = Cs2(e4), r3 = Cs2(r3)), t9(e4, r3);
        };
      }
      function Yi2(t9, e4, n3, i3, a3, o3, c3, f3, l3, h3) {
        var p3 = 8 & e4;
        e4 |= p3 ? s2 : u2, 4 & (e4 &= ~(p3 ? u2 : s2)) || (e4 &= -4);
        var d3 = [t9, e4, a3, p3 ? o3 : r2, p3 ? c3 : r2, p3 ? r2 : o3, p3 ? r2 : c3, f3, l3, h3], y3 = n3.apply(r2, d3);
        return Ta2(t9) && Oa2(y3, d3), y3.placeholder = i3, Ua2(y3, t9, e4);
      }
      function Xi2(t9) {
        var e4 = wt3[t9];
        return function(t10, r3) {
          if (t10 = Cs2(t10), (r3 = r3 == null ? 0 : Er2(vs2(r3), 292)) && gr2(t10)) {
            var n3 = (Ss2(t10) + "e").split("e");
            return +((n3 = (Ss2(e4(n3[0] + "e" + (+n3[1] + r3))) + "e").split("e"))[0] + "e" + (+n3[1] - r3));
          }
          return e4(t10);
        };
      }
      var $i2 = Br2 && 1 / cr2(new Br2([, -0]))[1] == l2 ? function(t9) {
        return new Br2(t9);
      } : lu2;
      function Zi2(t9) {
        return function(e4) {
          var r3 = ga2(e4);
          return r3 == T2 ? or2(e4) : r3 == N2 ? fr2(e4) : function(t10, e5) {
            return Oe2(e5, function(e6) {
              return [e6, t10[e6]];
            });
          }(e4, t9(e4));
        };
      }
      function Ji2(t9, e4, i3, l3, h3, p3, d3, y3) {
        var g3 = 2 & e4;
        if (!g3 && typeof t9 != "function")
          throw new kt3(n2);
        var v3 = l3 ? l3.length : 0;
        if (v3 || (e4 &= -97, l3 = h3 = r2), d3 = d3 === r2 ? d3 : Cr2(vs2(d3), 0), y3 = y3 === r2 ? y3 : vs2(y3), v3 -= h3 ? h3.length : 0, e4 & u2) {
          var m3 = l3, C3 = h3;
          l3 = h3 = r2;
        }
        var E3 = g3 ? r2 : sa2(t9), S3 = [t9, e4, i3, l3, h3, m3, C3, p3, d3, y3];
        if (E3 && function(t10, e5) {
          var r3 = t10[1], n3 = e5[1], i4 = r3 | n3, o3 = i4 < 131, s3 = n3 == c2 && r3 == 8 || n3 == c2 && r3 == f2 && t10[7].length <= e5[8] || n3 == 384 && e5[7].length <= e5[8] && r3 == 8;
          if (!o3 && !s3)
            return t10;
          1 & n3 && (t10[2] = e5[2], i4 |= 1 & r3 ? 0 : 4);
          var u3 = e5[3];
          if (u3) {
            var l4 = t10[3];
            t10[3] = l4 ? Ni2(l4, u3, e5[4]) : u3, t10[4] = l4 ? ur2(t10[3], a2) : e5[4];
          }
          (u3 = e5[5]) && (l4 = t10[5], t10[5] = l4 ? ki2(l4, u3, e5[6]) : u3, t10[6] = l4 ? ur2(t10[5], a2) : e5[6]);
          (u3 = e5[7]) && (t10[7] = u3);
          n3 & c2 && (t10[8] = t10[8] == null ? e5[8] : Er2(t10[8], e5[8]));
          t10[9] == null && (t10[9] = e5[9]);
          t10[0] = e5[0], t10[1] = i4;
        }(S3, E3), t9 = S3[0], e4 = S3[1], i3 = S3[2], l3 = S3[3], h3 = S3[4], !(y3 = S3[9] = S3[9] === r2 ? g3 ? 0 : t9.length : Cr2(S3[9] - v3, 0)) && 24 & e4 && (e4 &= -25), e4 && e4 != 1)
          b3 = e4 == 8 || e4 == o2 ? function(t10, e5, n3) {
            var i4 = Mi(t10);
            return function a3() {
              for (var o3 = arguments.length, s3 = ot3(o3), u3 = o3, c3 = ca2(a3); u3--; )
                s3[u3] = arguments[u3];
              var f3 = o3 < 3 && s3[0] !== c3 && s3[o3 - 1] !== c3 ? [] : ur2(s3, c3);
              return (o3 -= f3.length) < n3 ? Yi2(t10, e5, Ki2, a3.placeholder, r2, s3, f3, r2, r2, n3 - o3) : Ie2(this && this !== he2 && this instanceof a3 ? i4 : t10, this, s3);
            };
          }(t9, e4, y3) : e4 != s2 && e4 != 33 || h3.length ? Ki2.apply(r2, S3) : function(t10, e5, r3, n3) {
            var i4 = 1 & e5, a3 = Mi(t10);
            return function e6() {
              for (var o3 = -1, s3 = arguments.length, u3 = -1, c3 = n3.length, f3 = ot3(c3 + s3), l4 = this && this !== he2 && this instanceof e6 ? a3 : t10; ++u3 < c3; )
                f3[u3] = n3[u3];
              for (; s3--; )
                f3[u3++] = arguments[++o3];
              return Ie2(l4, i4 ? r3 : this, f3);
            };
          }(t9, e4, i3, l3);
        else
          var b3 = function(t10, e5, r3) {
            var n3 = 1 & e5, i4 = Mi(t10);
            return function e6() {
              return (this && this !== he2 && this instanceof e6 ? i4 : t10).apply(n3 ? r3 : this, arguments);
            };
          }(t9, e4, i3);
        return Ua2((E3 ? ri2 : Oa2)(b3, S3), t9, e4);
      }
      function ta2(t9, e4, n3, i3) {
        return t9 === r2 || qo2(t9, Lt3[n3]) && !xt3.call(i3, n3) ? e4 : t9;
      }
      function ea2(t9, e4, n3, i3, a3, o3) {
        return ns2(t9) && ns2(e4) && (o3.set(e4, t9), Gn2(t9, e4, r2, ea2, o3), o3.delete(e4)), t9;
      }
      function ra2(t9) {
        return ss2(t9) ? r2 : t9;
      }
      function na2(t9, e4, n3, i3, a3, o3) {
        var s3 = 1 & n3, u3 = t9.length, c3 = e4.length;
        if (u3 != c3 && !(s3 && c3 > u3))
          return false;
        var f3 = o3.get(t9), l3 = o3.get(e4);
        if (f3 && l3)
          return f3 == e4 && l3 == t9;
        var h3 = -1, p3 = true, d3 = 2 & n3 ? new Yr2() : r2;
        for (o3.set(t9, e4), o3.set(e4, t9); ++h3 < u3; ) {
          var y3 = t9[h3], g3 = e4[h3];
          if (i3)
            var v3 = s3 ? i3(g3, y3, h3, e4, t9, o3) : i3(y3, g3, h3, t9, e4, o3);
          if (v3 !== r2) {
            if (v3)
              continue;
            p3 = false;
            break;
          }
          if (d3) {
            if (!xe2(e4, function(t10, e5) {
              if (!Ze2(d3, e5) && (y3 === t10 || a3(y3, t10, n3, i3, o3)))
                return d3.push(e5);
            })) {
              p3 = false;
              break;
            }
          } else if (y3 !== g3 && !a3(y3, g3, n3, i3, o3)) {
            p3 = false;
            break;
          }
        }
        return o3.delete(t9), o3.delete(e4), p3;
      }
      function ia2(t9) {
        return Pa2(Ba2(t9, r2, Ha2), t9 + "");
      }
      function aa2(t9) {
        return wn2(t9, Ps2, da2);
      }
      function oa2(t9) {
        return wn2(t9, Us2, ya2);
      }
      var sa2 = Rr2 ? function(t9) {
        return Rr2.get(t9);
      } : lu2;
      function ua2(t9) {
        for (var e4 = t9.name + "", r3 = Or2[e4], n3 = xt3.call(Or2, e4) ? r3.length : 0; n3--; ) {
          var i3 = r3[n3], a3 = i3.func;
          if (a3 == null || a3 == t9)
            return i3.name;
        }
        return e4;
      }
      function ca2(t9) {
        return (xt3.call(Fr2, "placeholder") ? Fr2 : t9).placeholder;
      }
      function fa2() {
        var t9 = Fr2.iteratee || su2;
        return t9 = t9 === su2 ? Dn2 : t9, arguments.length ? t9(arguments[0], arguments[1]) : t9;
      }
      function la2(t9, e4) {
        var r3, n3, i3 = t9.__data__;
        return ((n3 = typeof (r3 = e4)) == "string" || n3 == "number" || n3 == "symbol" || n3 == "boolean" ? r3 !== "__proto__" : r3 === null) ? i3[typeof e4 == "string" ? "string" : "hash"] : i3.map;
      }
      function ha2(t9) {
        for (var e4 = Ps2(t9), r3 = e4.length; r3--; ) {
          var n3 = e4[r3], i3 = t9[n3];
          e4[r3] = [n3, i3, wa2(i3)];
        }
        return e4;
      }
      function pa2(t9, e4) {
        var n3 = function(t10, e5) {
          return t10 == null ? r2 : t10[e5];
        }(t9, e4);
        return xn2(n3) ? n3 : r2;
      }
      var da2 = De3 ? function(t9) {
        return t9 == null ? [] : (t9 = _t3(t9), Ne2(De3(t9), function(e4) {
          return Yt3.call(t9, e4);
        }));
      } : mu, ya2 = De3 ? function(t9) {
        for (var e4 = []; t9; )
          Le2(e4, da2(t9)), t9 = Ht3(t9);
        return e4;
      } : mu, ga2 = _n2;
      function va2(t9, e4, r3) {
        for (var n3 = -1, i3 = (e4 = Si2(e4, t9)).length, a3 = false; ++n3 < i3; ) {
          var o3 = Ma2(e4[n3]);
          if (!(a3 = t9 != null && r3(t9, o3)))
            break;
          t9 = t9[o3];
        }
        return a3 || ++n3 != i3 ? a3 : !!(i3 = t9 == null ? 0 : t9.length) && rs2(i3) && Ea2(o3, i3) && (Ho2(t9) || Wo2(t9));
      }
      function ma2(t9) {
        return typeof t9.constructor != "function" || Aa2(t9) ? {} : Kr2(Ht3(t9));
      }
      function Ca2(t9) {
        return Ho2(t9) || Wo2(t9) || !!(Jt3 && t9 && t9[Jt3]);
      }
      function Ea2(t9, e4) {
        var r3 = typeof t9;
        return !!(e4 = e4 == null ? h2 : e4) && (r3 == "number" || r3 != "symbol" && Ct2.test(t9)) && t9 > -1 && t9 % 1 == 0 && t9 < e4;
      }
      function Sa2(t9, e4, r3) {
        if (!ns2(r3))
          return false;
        var n3 = typeof e4;
        return !!(n3 == "number" ? Yo2(r3) && Ea2(e4, r3.length) : n3 == "string" && e4 in r3) && qo2(r3[e4], t9);
      }
      function ba2(t9, e4) {
        if (Ho2(t9))
          return false;
        var r3 = typeof t9;
        return !(r3 != "number" && r3 != "symbol" && r3 != "boolean" && t9 != null && !ls2(t9)) || (et2.test(t9) || !tt2.test(t9) || e4 != null && t9 in _t3(e4));
      }
      function Ta2(t9) {
        var e4 = ua2(t9), r3 = Fr2[e4];
        if (typeof r3 != "function" || !(e4 in zr2.prototype))
          return false;
        if (t9 === r3)
          return true;
        var n3 = sa2(r3);
        return !!n3 && t9 === n3[0];
      }
      (Ar && ga2(new Ar(new ArrayBuffer(1))) != P2 || wr && ga2(new wr()) != T2 || _r2 && ga2(_r2.resolve()) != _2 || Br2 && ga2(new Br2()) != N2 || Nr2 && ga2(new Nr2()) != O2) && (ga2 = function(t9) {
        var e4 = _n2(t9), n3 = e4 == w2 ? t9.constructor : r2, i3 = n3 ? ja2(n3) : "";
        if (i3)
          switch (i3) {
            case Lr2:
              return P2;
            case Pr2:
              return T2;
            case Ur2:
              return _2;
            case xr2:
              return N2;
            case Dr2:
              return O2;
          }
        return e4;
      });
      var Ia2 = Pt3 ? ts2 : Cu;
      function Aa2(t9) {
        var e4 = t9 && t9.constructor;
        return t9 === (typeof e4 == "function" && e4.prototype || Lt3);
      }
      function wa2(t9) {
        return t9 == t9 && !ns2(t9);
      }
      function _a2(t9, e4) {
        return function(n3) {
          return n3 != null && (n3[t9] === e4 && (e4 !== r2 || t9 in _t3(n3)));
        };
      }
      function Ba2(t9, e4, n3) {
        return e4 = Cr2(e4 === r2 ? t9.length - 1 : e4, 0), function() {
          for (var r3 = arguments, i3 = -1, a3 = Cr2(r3.length - e4, 0), o3 = ot3(a3); ++i3 < a3; )
            o3[i3] = r3[e4 + i3];
          i3 = -1;
          for (var s3 = ot3(e4 + 1); ++i3 < e4; )
            s3[i3] = r3[i3];
          return s3[e4] = n3(o3), Ie2(t9, this, s3);
        };
      }
      function Na2(t9, e4) {
        return e4.length < 2 ? t9 : An2(t9, ai2(e4, 0, -1));
      }
      function ka2(t9, e4) {
        for (var n3 = t9.length, i3 = Er2(e4.length, n3), a3 = Ri2(t9); i3--; ) {
          var o3 = e4[i3];
          t9[i3] = Ea2(o3, n3) ? a3[o3] : r2;
        }
        return t9;
      }
      function Ra2(t9, e4) {
        if ((e4 !== "constructor" || typeof t9[e4] != "function") && e4 != "__proto__")
          return t9[e4];
      }
      var Oa2 = xa2(ri2), La2 = de3 || function(t9, e4) {
        return he2.setTimeout(t9, e4);
      }, Pa2 = xa2(ni2);
      function Ua2(t9, e4, r3) {
        var n3 = e4 + "";
        return Pa2(t9, function(t10, e5) {
          var r4 = e5.length;
          if (!r4)
            return t10;
          var n4 = r4 - 1;
          return e5[n4] = (r4 > 1 ? "& " : "") + e5[n4], e5 = e5.join(r4 > 2 ? ", " : " "), t10.replace(st2, "{\n/* [wrapped with " + e5 + "] */\n");
        }(n3, function(t10, e5) {
          return we2(y2, function(r4) {
            var n4 = "_." + r4[0];
            e5 & r4[1] && !ke2(t10, n4) && t10.push(n4);
          }), t10.sort();
        }(function(t10) {
          var e5 = t10.match(ut2);
          return e5 ? e5[1].split(ct2) : [];
        }(n3), r3)));
      }
      function xa2(t9) {
        var e4 = 0, n3 = 0;
        return function() {
          var i3 = Sr2(), a3 = 16 - (i3 - n3);
          if (n3 = i3, a3 > 0) {
            if (++e4 >= 800)
              return arguments[0];
          } else
            e4 = 0;
          return t9.apply(r2, arguments);
        };
      }
      function Da2(t9, e4) {
        var n3 = -1, i3 = t9.length, a3 = i3 - 1;
        for (e4 = e4 === r2 ? i3 : e4; ++n3 < e4; ) {
          var o3 = Xn2(n3, a3), s3 = t9[o3];
          t9[o3] = t9[n3], t9[n3] = s3;
        }
        return t9.length = e4, t9;
      }
      var Va2 = function(t9) {
        var e4 = Do2(t9, function(t10) {
          return r3.size === 500 && r3.clear(), t10;
        }), r3 = e4.cache;
        return e4;
      }(function(t9) {
        var e4 = [];
        return t9.charCodeAt(0) === 46 && e4.push(""), t9.replace(rt2, function(t10, r3, n3, i3) {
          e4.push(n3 ? i3.replace(ht2, "$1") : r3 || t10);
        }), e4;
      });
      function Ma2(t9) {
        if (typeof t9 == "string" || ls2(t9))
          return t9;
        var e4 = t9 + "";
        return e4 == "0" && 1 / t9 == -1 / 0 ? "-0" : e4;
      }
      function ja2(t9) {
        if (t9 != null) {
          try {
            return Ut3.call(t9);
          } catch (t10) {
          }
          try {
            return t9 + "";
          } catch (t10) {
          }
        }
        return "";
      }
      function Fa2(t9) {
        if (t9 instanceof zr2)
          return t9.clone();
        var e4 = new Gr2(t9.__wrapped__, t9.__chain__);
        return e4.__actions__ = Ri2(t9.__actions__), e4.__index__ = t9.__index__, e4.__values__ = t9.__values__, e4;
      }
      var Ka2 = Zn2(function(t9, e4) {
        return Xo2(t9) ? pn2(t9, Cn2(e4, 1, Xo2, true)) : [];
      }), qa2 = Zn2(function(t9, e4) {
        var n3 = Za2(e4);
        return Xo2(n3) && (n3 = r2), Xo2(t9) ? pn2(t9, Cn2(e4, 1, Xo2, true), fa2(n3, 2)) : [];
      }), Ga2 = Zn2(function(t9, e4) {
        var n3 = Za2(e4);
        return Xo2(n3) && (n3 = r2), Xo2(t9) ? pn2(t9, Cn2(e4, 1, Xo2, true), r2, n3) : [];
      });
      function za2(t9, e4, r3) {
        var n3 = t9 == null ? 0 : t9.length;
        if (!n3)
          return -1;
        var i3 = r3 == null ? 0 : vs2(r3);
        return i3 < 0 && (i3 = Cr2(n3 + i3, 0)), Me2(t9, fa2(e4, 3), i3);
      }
      function Wa2(t9, e4, n3) {
        var i3 = t9 == null ? 0 : t9.length;
        if (!i3)
          return -1;
        var a3 = i3 - 1;
        return n3 !== r2 && (a3 = vs2(n3), a3 = n3 < 0 ? Cr2(i3 + a3, 0) : Er2(a3, i3 - 1)), Me2(t9, fa2(e4, 3), a3, true);
      }
      function Ha2(t9) {
        return (t9 == null ? 0 : t9.length) ? Cn2(t9, 1) : [];
      }
      function Qa2(t9) {
        return t9 && t9.length ? t9[0] : r2;
      }
      var Ya2 = Zn2(function(t9) {
        var e4 = Oe2(t9, Ci2);
        return e4.length && e4[0] === t9[0] ? Rn2(e4) : [];
      }), Xa2 = Zn2(function(t9) {
        var e4 = Za2(t9), n3 = Oe2(t9, Ci2);
        return e4 === Za2(n3) ? e4 = r2 : n3.pop(), n3.length && n3[0] === t9[0] ? Rn2(n3, fa2(e4, 2)) : [];
      }), $a2 = Zn2(function(t9) {
        var e4 = Za2(t9), n3 = Oe2(t9, Ci2);
        return (e4 = typeof e4 == "function" ? e4 : r2) && n3.pop(), n3.length && n3[0] === t9[0] ? Rn2(n3, r2, e4) : [];
      });
      function Za2(t9) {
        var e4 = t9 == null ? 0 : t9.length;
        return e4 ? t9[e4 - 1] : r2;
      }
      var Ja2 = Zn2(to2);
      function to2(t9, e4) {
        return t9 && t9.length && e4 && e4.length ? Qn(t9, e4) : t9;
      }
      var eo2 = ia2(function(t9, e4) {
        var r3 = t9 == null ? 0 : t9.length, n3 = un2(t9, e4);
        return Yn2(t9, Oe2(e4, function(t10) {
          return Ea2(t10, r3) ? +t10 : t10;
        }).sort(Bi2)), n3;
      });
      function ro2(t9) {
        return t9 == null ? t9 : Ir.call(t9);
      }
      var no2 = Zn2(function(t9) {
        return hi2(Cn2(t9, 1, Xo2, true));
      }), io2 = Zn2(function(t9) {
        var e4 = Za2(t9);
        return Xo2(e4) && (e4 = r2), hi2(Cn2(t9, 1, Xo2, true), fa2(e4, 2));
      }), ao2 = Zn2(function(t9) {
        var e4 = Za2(t9);
        return e4 = typeof e4 == "function" ? e4 : r2, hi2(Cn2(t9, 1, Xo2, true), r2, e4);
      });
      function oo2(t9) {
        if (!t9 || !t9.length)
          return [];
        var e4 = 0;
        return t9 = Ne2(t9, function(t10) {
          if (Xo2(t10))
            return e4 = Cr2(t10.length, e4), true;
        }), Qe2(e4, function(e5) {
          return Oe2(t9, Ge2(e5));
        });
      }
      function so2(t9, e4) {
        if (!t9 || !t9.length)
          return [];
        var n3 = oo2(t9);
        return e4 == null ? n3 : Oe2(n3, function(t10) {
          return Ie2(e4, r2, t10);
        });
      }
      var uo2 = Zn2(function(t9, e4) {
        return Xo2(t9) ? pn2(t9, e4) : [];
      }), co2 = Zn2(function(t9) {
        return vi2(Ne2(t9, Xo2));
      }), fo2 = Zn2(function(t9) {
        var e4 = Za2(t9);
        return Xo2(e4) && (e4 = r2), vi2(Ne2(t9, Xo2), fa2(e4, 2));
      }), lo2 = Zn2(function(t9) {
        var e4 = Za2(t9);
        return e4 = typeof e4 == "function" ? e4 : r2, vi2(Ne2(t9, Xo2), r2, e4);
      }), ho2 = Zn2(oo2);
      var po2 = Zn2(function(t9) {
        var e4 = t9.length, n3 = e4 > 1 ? t9[e4 - 1] : r2;
        return n3 = typeof n3 == "function" ? (t9.pop(), n3) : r2, so2(t9, n3);
      });
      function yo2(t9) {
        var e4 = Fr2(t9);
        return e4.__chain__ = true, e4;
      }
      function go2(t9, e4) {
        return e4(t9);
      }
      var vo2 = ia2(function(t9) {
        var e4 = t9.length, n3 = e4 ? t9[0] : 0, i3 = this.__wrapped__, a3 = function(e5) {
          return un2(e5, t9);
        };
        return !(e4 > 1 || this.__actions__.length) && i3 instanceof zr2 && Ea2(n3) ? ((i3 = i3.slice(n3, +n3 + (e4 ? 1 : 0))).__actions__.push({ func: go2, args: [a3], thisArg: r2 }), new Gr2(i3, this.__chain__).thru(function(t10) {
          return e4 && !t10.length && t10.push(r2), t10;
        })) : this.thru(a3);
      });
      var mo2 = Li2(function(t9, e4, r3) {
        xt3.call(t9, r3) ? ++t9[r3] : sn2(t9, r3, 1);
      });
      var Co2 = ji(za2), Eo2 = ji(Wa2);
      function So2(t9, e4) {
        return (Ho2(t9) ? we2 : dn2)(t9, fa2(e4, 3));
      }
      function bo2(t9, e4) {
        return (Ho2(t9) ? _e2 : yn2)(t9, fa2(e4, 3));
      }
      var To2 = Li2(function(t9, e4, r3) {
        xt3.call(t9, r3) ? t9[r3].push(e4) : sn2(t9, r3, [e4]);
      });
      var Io2 = Zn2(function(t9, e4, r3) {
        var n3 = -1, i3 = typeof e4 == "function", a3 = Yo2(t9) ? ot3(t9.length) : [];
        return dn2(t9, function(t10) {
          a3[++n3] = i3 ? Ie2(e4, t10, r3) : On2(t10, e4, r3);
        }), a3;
      }), Ao2 = Li2(function(t9, e4, r3) {
        sn2(t9, r3, e4);
      });
      function wo2(t9, e4) {
        return (Ho2(t9) ? Oe2 : Fn2)(t9, fa2(e4, 3));
      }
      var _o2 = Li2(function(t9, e4, r3) {
        t9[r3 ? 0 : 1].push(e4);
      }, function() {
        return [[], []];
      });
      var Bo = Zn2(function(t9, e4) {
        if (t9 == null)
          return [];
        var r3 = e4.length;
        return r3 > 1 && Sa2(t9, e4[0], e4[1]) ? e4 = [] : r3 > 2 && Sa2(e4[0], e4[1], e4[2]) && (e4 = [e4[0]]), Wn2(t9, Cn2(e4, 1), []);
      }), No = pe3 || function() {
        return he2.Date.now();
      };
      function ko(t9, e4, n3) {
        return e4 = n3 ? r2 : e4, e4 = t9 && e4 == null ? t9.length : e4, Ji2(t9, c2, r2, r2, r2, r2, e4);
      }
      function Ro(t9, e4) {
        var i3;
        if (typeof e4 != "function")
          throw new kt3(n2);
        return t9 = vs2(t9), function() {
          return --t9 > 0 && (i3 = e4.apply(this, arguments)), t9 <= 1 && (e4 = r2), i3;
        };
      }
      var Oo = Zn2(function(t9, e4, r3) {
        var n3 = 1;
        if (r3.length) {
          var i3 = ur2(r3, ca2(Oo));
          n3 |= s2;
        }
        return Ji2(t9, n3, e4, r3, i3);
      }), Lo = Zn2(function(t9, e4, r3) {
        var n3 = 3;
        if (r3.length) {
          var i3 = ur2(r3, ca2(Lo));
          n3 |= s2;
        }
        return Ji2(e4, n3, t9, r3, i3);
      });
      function Po(t9, e4, i3) {
        var a3, o3, s3, u3, c3, f3, l3 = 0, h3 = false, p3 = false, d3 = true;
        if (typeof t9 != "function")
          throw new kt3(n2);
        function y3(e5) {
          var n3 = a3, i4 = o3;
          return a3 = o3 = r2, l3 = e5, u3 = t9.apply(i4, n3);
        }
        function g3(t10) {
          return l3 = t10, c3 = La2(m3, e4), h3 ? y3(t10) : u3;
        }
        function v3(t10) {
          var n3 = t10 - f3;
          return f3 === r2 || n3 >= e4 || n3 < 0 || p3 && t10 - l3 >= s3;
        }
        function m3() {
          var t10 = No();
          if (v3(t10))
            return C3(t10);
          c3 = La2(m3, function(t11) {
            var r3 = e4 - (t11 - f3);
            return p3 ? Er2(r3, s3 - (t11 - l3)) : r3;
          }(t10));
        }
        function C3(t10) {
          return c3 = r2, d3 && a3 ? y3(t10) : (a3 = o3 = r2, u3);
        }
        function E3() {
          var t10 = No(), n3 = v3(t10);
          if (a3 = arguments, o3 = this, f3 = t10, n3) {
            if (c3 === r2)
              return g3(f3);
            if (p3)
              return Ii2(c3), c3 = La2(m3, e4), y3(f3);
          }
          return c3 === r2 && (c3 = La2(m3, e4)), u3;
        }
        return e4 = Cs2(e4) || 0, ns2(i3) && (h3 = !!i3.leading, s3 = (p3 = "maxWait" in i3) ? Cr2(Cs2(i3.maxWait) || 0, e4) : s3, d3 = "trailing" in i3 ? !!i3.trailing : d3), E3.cancel = function() {
          c3 !== r2 && Ii2(c3), l3 = 0, a3 = f3 = o3 = c3 = r2;
        }, E3.flush = function() {
          return c3 === r2 ? u3 : C3(No());
        }, E3;
      }
      var Uo2 = Zn2(function(t9, e4) {
        return hn2(t9, 1, e4);
      }), xo2 = Zn2(function(t9, e4, r3) {
        return hn2(t9, Cs2(e4) || 0, r3);
      });
      function Do2(t9, e4) {
        if (typeof t9 != "function" || e4 != null && typeof e4 != "function")
          throw new kt3(n2);
        var r3 = function() {
          var n3 = arguments, i3 = e4 ? e4.apply(this, n3) : n3[0], a3 = r3.cache;
          if (a3.has(i3))
            return a3.get(i3);
          var o3 = t9.apply(this, n3);
          return r3.cache = a3.set(i3, o3) || a3, o3;
        };
        return r3.cache = new (Do2.Cache || Qr2)(), r3;
      }
      function Vo2(t9) {
        if (typeof t9 != "function")
          throw new kt3(n2);
        return function() {
          var e4 = arguments;
          switch (e4.length) {
            case 0:
              return !t9.call(this);
            case 1:
              return !t9.call(this, e4[0]);
            case 2:
              return !t9.call(this, e4[0], e4[1]);
            case 3:
              return !t9.call(this, e4[0], e4[1], e4[2]);
          }
          return !t9.apply(this, e4);
        };
      }
      Do2.Cache = Qr2;
      var Mo2 = bi2(function(t9, e4) {
        var r3 = (e4 = e4.length == 1 && Ho2(e4[0]) ? Oe2(e4[0], Xe2(fa2())) : Oe2(Cn2(e4, 1), Xe2(fa2()))).length;
        return Zn2(function(n3) {
          for (var i3 = -1, a3 = Er2(n3.length, r3); ++i3 < a3; )
            n3[i3] = e4[i3].call(this, n3[i3]);
          return Ie2(t9, this, n3);
        });
      }), jo2 = Zn2(function(t9, e4) {
        var n3 = ur2(e4, ca2(jo2));
        return Ji2(t9, s2, r2, e4, n3);
      }), Fo2 = Zn2(function(t9, e4) {
        var n3 = ur2(e4, ca2(Fo2));
        return Ji2(t9, u2, r2, e4, n3);
      }), Ko2 = ia2(function(t9, e4) {
        return Ji2(t9, f2, r2, r2, r2, e4);
      });
      function qo2(t9, e4) {
        return t9 === e4 || t9 != t9 && e4 != e4;
      }
      var Go2 = Qi2(Bn2), zo2 = Qi2(function(t9, e4) {
        return t9 >= e4;
      }), Wo2 = Ln2(function() {
        return arguments;
      }()) ? Ln2 : function(t9) {
        return is2(t9) && xt3.call(t9, "callee") && !Yt3.call(t9, "callee");
      }, Ho2 = ot3.isArray, Qo2 = me2 ? Xe2(me2) : function(t9) {
        return is2(t9) && _n2(t9) == L2;
      };
      function Yo2(t9) {
        return t9 != null && rs2(t9.length) && !ts2(t9);
      }
      function Xo2(t9) {
        return is2(t9) && Yo2(t9);
      }
      var $o2 = ze3 || Cu, Zo2 = Ce2 ? Xe2(Ce2) : function(t9) {
        return is2(t9) && _n2(t9) == C2;
      };
      function Jo2(t9) {
        if (!is2(t9))
          return false;
        var e4 = _n2(t9);
        return e4 == E2 || e4 == "[object DOMException]" || typeof t9.message == "string" && typeof t9.name == "string" && !ss2(t9);
      }
      function ts2(t9) {
        if (!ns2(t9))
          return false;
        var e4 = _n2(t9);
        return e4 == S2 || e4 == b2 || e4 == "[object AsyncFunction]" || e4 == "[object Proxy]";
      }
      function es2(t9) {
        return typeof t9 == "number" && t9 == vs2(t9);
      }
      function rs2(t9) {
        return typeof t9 == "number" && t9 > -1 && t9 % 1 == 0 && t9 <= h2;
      }
      function ns2(t9) {
        var e4 = typeof t9;
        return t9 != null && (e4 == "object" || e4 == "function");
      }
      function is2(t9) {
        return t9 != null && typeof t9 == "object";
      }
      var as2 = Ee ? Xe2(Ee) : function(t9) {
        return is2(t9) && ga2(t9) == T2;
      };
      function os2(t9) {
        return typeof t9 == "number" || is2(t9) && _n2(t9) == I2;
      }
      function ss2(t9) {
        if (!is2(t9) || _n2(t9) != w2)
          return false;
        var e4 = Ht3(t9);
        if (e4 === null)
          return true;
        var r3 = xt3.call(e4, "constructor") && e4.constructor;
        return typeof r3 == "function" && r3 instanceof r3 && Ut3.call(r3) == jt3;
      }
      var us2 = Se ? Xe2(Se) : function(t9) {
        return is2(t9) && _n2(t9) == B2;
      };
      var cs2 = be ? Xe2(be) : function(t9) {
        return is2(t9) && ga2(t9) == N2;
      };
      function fs2(t9) {
        return typeof t9 == "string" || !Ho2(t9) && is2(t9) && _n2(t9) == k2;
      }
      function ls2(t9) {
        return typeof t9 == "symbol" || is2(t9) && _n2(t9) == R2;
      }
      var hs2 = Te ? Xe2(Te) : function(t9) {
        return is2(t9) && rs2(t9.length) && !!ae2[_n2(t9)];
      };
      var ps2 = Qi2(jn2), ds2 = Qi2(function(t9, e4) {
        return t9 <= e4;
      });
      function ys2(t9) {
        if (!t9)
          return [];
        if (Yo2(t9))
          return fs2(t9) ? hr2(t9) : Ri2(t9);
        if (ee3 && t9[ee3])
          return function(t10) {
            for (var e5, r3 = []; !(e5 = t10.next()).done; )
              r3.push(e5.value);
            return r3;
          }(t9[ee3]());
        var e4 = ga2(t9);
        return (e4 == T2 ? or2 : e4 == N2 ? cr2 : qs2)(t9);
      }
      function gs2(t9) {
        return t9 ? (t9 = Cs2(t9)) === l2 || t9 === -1 / 0 ? 17976931348623157e292 * (t9 < 0 ? -1 : 1) : t9 == t9 ? t9 : 0 : t9 === 0 ? t9 : 0;
      }
      function vs2(t9) {
        var e4 = gs2(t9), r3 = e4 % 1;
        return e4 == e4 ? r3 ? e4 - r3 : e4 : 0;
      }
      function ms2(t9) {
        return t9 ? cn2(vs2(t9), 0, d2) : 0;
      }
      function Cs2(t9) {
        if (typeof t9 == "number")
          return t9;
        if (ls2(t9))
          return p2;
        if (ns2(t9)) {
          var e4 = typeof t9.valueOf == "function" ? t9.valueOf() : t9;
          t9 = ns2(e4) ? e4 + "" : e4;
        }
        if (typeof t9 != "string")
          return t9 === 0 ? t9 : +t9;
        t9 = Ye2(t9);
        var r3 = gt2.test(t9);
        return r3 || mt2.test(t9) ? ce2(t9.slice(2), r3 ? 2 : 8) : yt2.test(t9) ? p2 : +t9;
      }
      function Es2(t9) {
        return Oi2(t9, Us2(t9));
      }
      function Ss2(t9) {
        return t9 == null ? "" : li2(t9);
      }
      var bs2 = Pi2(function(t9, e4) {
        if (Aa2(e4) || Yo2(e4))
          Oi2(e4, Ps2(e4), t9);
        else
          for (var r3 in e4)
            xt3.call(e4, r3) && rn2(t9, r3, e4[r3]);
      }), Ts2 = Pi2(function(t9, e4) {
        Oi2(e4, Us2(e4), t9);
      }), Is2 = Pi2(function(t9, e4, r3, n3) {
        Oi2(e4, Us2(e4), t9, n3);
      }), As2 = Pi2(function(t9, e4, r3, n3) {
        Oi2(e4, Ps2(e4), t9, n3);
      }), ws2 = ia2(un2);
      var _s2 = Zn2(function(t9, e4) {
        t9 = _t3(t9);
        var n3 = -1, i3 = e4.length, a3 = i3 > 2 ? e4[2] : r2;
        for (a3 && Sa2(e4[0], e4[1], a3) && (i3 = 1); ++n3 < i3; )
          for (var o3 = e4[n3], s3 = Us2(o3), u3 = -1, c3 = s3.length; ++u3 < c3; ) {
            var f3 = s3[u3], l3 = t9[f3];
            (l3 === r2 || qo2(l3, Lt3[f3]) && !xt3.call(t9, f3)) && (t9[f3] = o3[f3]);
          }
        return t9;
      }), Bs2 = Zn2(function(t9) {
        return t9.push(r2, ea2), Ie2(Ds2, r2, t9);
      });
      function Ns2(t9, e4, n3) {
        var i3 = t9 == null ? r2 : An2(t9, e4);
        return i3 === r2 ? n3 : i3;
      }
      function ks2(t9, e4) {
        return t9 != null && va2(t9, e4, kn2);
      }
      var Rs2 = qi2(function(t9, e4, r3) {
        e4 != null && typeof e4.toString != "function" && (e4 = Mt3.call(e4)), t9[e4] = r3;
      }, nu2(ou2)), Os2 = qi2(function(t9, e4, r3) {
        e4 != null && typeof e4.toString != "function" && (e4 = Mt3.call(e4)), xt3.call(t9, e4) ? t9[e4].push(r3) : t9[e4] = [r3];
      }, fa2), Ls2 = Zn2(On2);
      function Ps2(t9) {
        return Yo2(t9) ? $r2(t9) : Vn2(t9);
      }
      function Us2(t9) {
        return Yo2(t9) ? $r2(t9, true) : Mn2(t9);
      }
      var xs2 = Pi2(function(t9, e4, r3) {
        Gn2(t9, e4, r3);
      }), Ds2 = Pi2(function(t9, e4, r3, n3) {
        Gn2(t9, e4, r3, n3);
      }), Vs2 = ia2(function(t9, e4) {
        var r3 = {};
        if (t9 == null)
          return r3;
        var n3 = false;
        e4 = Oe2(e4, function(e5) {
          return e5 = Si2(e5, t9), n3 || (n3 = e5.length > 1), e5;
        }), Oi2(t9, oa2(t9), r3), n3 && (r3 = fn2(r3, 7, ra2));
        for (var i3 = e4.length; i3--; )
          pi2(r3, e4[i3]);
        return r3;
      });
      var Ms2 = ia2(function(t9, e4) {
        return t9 == null ? {} : function(t10, e5) {
          return Hn2(t10, e5, function(e6, r3) {
            return ks2(t10, r3);
          });
        }(t9, e4);
      });
      function js2(t9, e4) {
        if (t9 == null)
          return {};
        var r3 = Oe2(oa2(t9), function(t10) {
          return [t10];
        });
        return e4 = fa2(e4), Hn2(t9, r3, function(t10, r4) {
          return e4(t10, r4[0]);
        });
      }
      var Fs2 = Zi2(Ps2), Ks2 = Zi2(Us2);
      function qs2(t9) {
        return t9 == null ? [] : $e2(t9, Ps2(t9));
      }
      var Gs2 = Vi(function(t9, e4, r3) {
        return e4 = e4.toLowerCase(), t9 + (r3 ? zs2(e4) : e4);
      });
      function zs2(t9) {
        return Js2(Ss2(t9).toLowerCase());
      }
      function Ws2(t9) {
        return (t9 = Ss2(t9)) && t9.replace(Et2, rr2).replace(Zt2, "");
      }
      var Hs2 = Vi(function(t9, e4, r3) {
        return t9 + (r3 ? "-" : "") + e4.toLowerCase();
      }), Qs2 = Vi(function(t9, e4, r3) {
        return t9 + (r3 ? " " : "") + e4.toLowerCase();
      }), Ys2 = Di2("toLowerCase");
      var Xs2 = Vi(function(t9, e4, r3) {
        return t9 + (r3 ? "_" : "") + e4.toLowerCase();
      });
      var $s2 = Vi(function(t9, e4, r3) {
        return t9 + (r3 ? " " : "") + Js2(e4);
      });
      var Zs2 = Vi(function(t9, e4, r3) {
        return t9 + (r3 ? " " : "") + e4.toUpperCase();
      }), Js2 = Di2("toUpperCase");
      function tu2(t9, e4, n3) {
        return t9 = Ss2(t9), (e4 = n3 ? r2 : e4) === r2 ? function(t10) {
          return re2.test(t10);
        }(t9) ? function(t10) {
          return t10.match(te2) || [];
        }(t9) : function(t10) {
          return t10.match(ft2) || [];
        }(t9) : t9.match(e4) || [];
      }
      var eu2 = Zn2(function(t9, e4) {
        try {
          return Ie2(t9, r2, e4);
        } catch (t10) {
          return Jo2(t10) ? t10 : new It3(t10);
        }
      }), ru2 = ia2(function(t9, e4) {
        return we2(e4, function(e5) {
          e5 = Ma2(e5), sn2(t9, e5, Oo(t9[e5], t9));
        }), t9;
      });
      function nu2(t9) {
        return function() {
          return t9;
        };
      }
      var iu2 = Fi2(), au2 = Fi2(true);
      function ou2(t9) {
        return t9;
      }
      function su2(t9) {
        return Dn2(typeof t9 == "function" ? t9 : fn2(t9, 1));
      }
      var uu2 = Zn2(function(t9, e4) {
        return function(r3) {
          return On2(r3, t9, e4);
        };
      }), cu2 = Zn2(function(t9, e4) {
        return function(r3) {
          return On2(t9, r3, e4);
        };
      });
      function fu2(t9, e4, r3) {
        var n3 = Ps2(e4), i3 = In2(e4, n3);
        r3 != null || ns2(e4) && (i3.length || !n3.length) || (r3 = e4, e4 = t9, t9 = this, i3 = In2(e4, Ps2(e4)));
        var a3 = !(ns2(r3) && "chain" in r3 && !r3.chain), o3 = ts2(t9);
        return we2(i3, function(r4) {
          var n4 = e4[r4];
          t9[r4] = n4, o3 && (t9.prototype[r4] = function() {
            var e5 = this.__chain__;
            if (a3 || e5) {
              var r5 = t9(this.__wrapped__), i4 = r5.__actions__ = Ri2(this.__actions__);
              return i4.push({ func: n4, args: arguments, thisArg: t9 }), r5.__chain__ = e5, r5;
            }
            return n4.apply(t9, Le2([this.value()], arguments));
          });
        }), t9;
      }
      function lu2() {
      }
      var hu2 = zi2(Oe2), pu2 = zi2(Be2), du2 = zi2(xe2);
      function yu(t9) {
        return ba2(t9) ? Ge2(Ma2(t9)) : function(t10) {
          return function(e4) {
            return An2(e4, t10);
          };
        }(t9);
      }
      var gu = Hi2(), vu = Hi2(true);
      function mu() {
        return [];
      }
      function Cu() {
        return false;
      }
      var Eu = Gi2(function(t9, e4) {
        return t9 + e4;
      }, 0), Su = Xi2("ceil"), bu = Gi2(function(t9, e4) {
        return t9 / e4;
      }, 1), Tu = Xi2("floor");
      var Iu, Au = Gi2(function(t9, e4) {
        return t9 * e4;
      }, 1), wu2 = Xi2("round"), _u2 = Gi2(function(t9, e4) {
        return t9 - e4;
      }, 0);
      return Fr2.after = function(t9, e4) {
        if (typeof e4 != "function")
          throw new kt3(n2);
        return t9 = vs2(t9), function() {
          if (--t9 < 1)
            return e4.apply(this, arguments);
        };
      }, Fr2.ary = ko, Fr2.assign = bs2, Fr2.assignIn = Ts2, Fr2.assignInWith = Is2, Fr2.assignWith = As2, Fr2.at = ws2, Fr2.before = Ro, Fr2.bind = Oo, Fr2.bindAll = ru2, Fr2.bindKey = Lo, Fr2.castArray = function() {
        if (!arguments.length)
          return [];
        var t9 = arguments[0];
        return Ho2(t9) ? t9 : [t9];
      }, Fr2.chain = yo2, Fr2.chunk = function(t9, e4, n3) {
        e4 = (n3 ? Sa2(t9, e4, n3) : e4 === r2) ? 1 : Cr2(vs2(e4), 0);
        var i3 = t9 == null ? 0 : t9.length;
        if (!i3 || e4 < 1)
          return [];
        for (var a3 = 0, o3 = 0, s3 = ot3(ge3(i3 / e4)); a3 < i3; )
          s3[o3++] = ai2(t9, a3, a3 += e4);
        return s3;
      }, Fr2.compact = function(t9) {
        for (var e4 = -1, r3 = t9 == null ? 0 : t9.length, n3 = 0, i3 = []; ++e4 < r3; ) {
          var a3 = t9[e4];
          a3 && (i3[n3++] = a3);
        }
        return i3;
      }, Fr2.concat = function() {
        var t9 = arguments.length;
        if (!t9)
          return [];
        for (var e4 = ot3(t9 - 1), r3 = arguments[0], n3 = t9; n3--; )
          e4[n3 - 1] = arguments[n3];
        return Le2(Ho2(r3) ? Ri2(r3) : [r3], Cn2(e4, 1));
      }, Fr2.cond = function(t9) {
        var e4 = t9 == null ? 0 : t9.length, r3 = fa2();
        return t9 = e4 ? Oe2(t9, function(t10) {
          if (typeof t10[1] != "function")
            throw new kt3(n2);
          return [r3(t10[0]), t10[1]];
        }) : [], Zn2(function(r4) {
          for (var n3 = -1; ++n3 < e4; ) {
            var i3 = t9[n3];
            if (Ie2(i3[0], this, r4))
              return Ie2(i3[1], this, r4);
          }
        });
      }, Fr2.conforms = function(t9) {
        return function(t10) {
          var e4 = Ps2(t10);
          return function(r3) {
            return ln2(r3, t10, e4);
          };
        }(fn2(t9, 1));
      }, Fr2.constant = nu2, Fr2.countBy = mo2, Fr2.create = function(t9, e4) {
        var r3 = Kr2(t9);
        return e4 == null ? r3 : on2(r3, e4);
      }, Fr2.curry = function t9(e4, n3, i3) {
        var a3 = Ji2(e4, 8, r2, r2, r2, r2, r2, n3 = i3 ? r2 : n3);
        return a3.placeholder = t9.placeholder, a3;
      }, Fr2.curryRight = function t9(e4, n3, i3) {
        var a3 = Ji2(e4, o2, r2, r2, r2, r2, r2, n3 = i3 ? r2 : n3);
        return a3.placeholder = t9.placeholder, a3;
      }, Fr2.debounce = Po, Fr2.defaults = _s2, Fr2.defaultsDeep = Bs2, Fr2.defer = Uo2, Fr2.delay = xo2, Fr2.difference = Ka2, Fr2.differenceBy = qa2, Fr2.differenceWith = Ga2, Fr2.drop = function(t9, e4, n3) {
        var i3 = t9 == null ? 0 : t9.length;
        return i3 ? ai2(t9, (e4 = n3 || e4 === r2 ? 1 : vs2(e4)) < 0 ? 0 : e4, i3) : [];
      }, Fr2.dropRight = function(t9, e4, n3) {
        var i3 = t9 == null ? 0 : t9.length;
        return i3 ? ai2(t9, 0, (e4 = i3 - (e4 = n3 || e4 === r2 ? 1 : vs2(e4))) < 0 ? 0 : e4) : [];
      }, Fr2.dropRightWhile = function(t9, e4) {
        return t9 && t9.length ? yi2(t9, fa2(e4, 3), true, true) : [];
      }, Fr2.dropWhile = function(t9, e4) {
        return t9 && t9.length ? yi2(t9, fa2(e4, 3), true) : [];
      }, Fr2.fill = function(t9, e4, n3, i3) {
        var a3 = t9 == null ? 0 : t9.length;
        return a3 ? (n3 && typeof n3 != "number" && Sa2(t9, e4, n3) && (n3 = 0, i3 = a3), function(t10, e5, n4, i4) {
          var a4 = t10.length;
          for ((n4 = vs2(n4)) < 0 && (n4 = -n4 > a4 ? 0 : a4 + n4), (i4 = i4 === r2 || i4 > a4 ? a4 : vs2(i4)) < 0 && (i4 += a4), i4 = n4 > i4 ? 0 : ms2(i4); n4 < i4; )
            t10[n4++] = e5;
          return t10;
        }(t9, e4, n3, i3)) : [];
      }, Fr2.filter = function(t9, e4) {
        return (Ho2(t9) ? Ne2 : mn2)(t9, fa2(e4, 3));
      }, Fr2.flatMap = function(t9, e4) {
        return Cn2(wo2(t9, e4), 1);
      }, Fr2.flatMapDeep = function(t9, e4) {
        return Cn2(wo2(t9, e4), l2);
      }, Fr2.flatMapDepth = function(t9, e4, n3) {
        return n3 = n3 === r2 ? 1 : vs2(n3), Cn2(wo2(t9, e4), n3);
      }, Fr2.flatten = Ha2, Fr2.flattenDeep = function(t9) {
        return (t9 == null ? 0 : t9.length) ? Cn2(t9, l2) : [];
      }, Fr2.flattenDepth = function(t9, e4) {
        return (t9 == null ? 0 : t9.length) ? Cn2(t9, e4 = e4 === r2 ? 1 : vs2(e4)) : [];
      }, Fr2.flip = function(t9) {
        return Ji2(t9, 512);
      }, Fr2.flow = iu2, Fr2.flowRight = au2, Fr2.fromPairs = function(t9) {
        for (var e4 = -1, r3 = t9 == null ? 0 : t9.length, n3 = {}; ++e4 < r3; ) {
          var i3 = t9[e4];
          n3[i3[0]] = i3[1];
        }
        return n3;
      }, Fr2.functions = function(t9) {
        return t9 == null ? [] : In2(t9, Ps2(t9));
      }, Fr2.functionsIn = function(t9) {
        return t9 == null ? [] : In2(t9, Us2(t9));
      }, Fr2.groupBy = To2, Fr2.initial = function(t9) {
        return (t9 == null ? 0 : t9.length) ? ai2(t9, 0, -1) : [];
      }, Fr2.intersection = Ya2, Fr2.intersectionBy = Xa2, Fr2.intersectionWith = $a2, Fr2.invert = Rs2, Fr2.invertBy = Os2, Fr2.invokeMap = Io2, Fr2.iteratee = su2, Fr2.keyBy = Ao2, Fr2.keys = Ps2, Fr2.keysIn = Us2, Fr2.map = wo2, Fr2.mapKeys = function(t9, e4) {
        var r3 = {};
        return e4 = fa2(e4, 3), bn2(t9, function(t10, n3, i3) {
          sn2(r3, e4(t10, n3, i3), t10);
        }), r3;
      }, Fr2.mapValues = function(t9, e4) {
        var r3 = {};
        return e4 = fa2(e4, 3), bn2(t9, function(t10, n3, i3) {
          sn2(r3, n3, e4(t10, n3, i3));
        }), r3;
      }, Fr2.matches = function(t9) {
        return Kn2(fn2(t9, 1));
      }, Fr2.matchesProperty = function(t9, e4) {
        return qn2(t9, fn2(e4, 1));
      }, Fr2.memoize = Do2, Fr2.merge = xs2, Fr2.mergeWith = Ds2, Fr2.method = uu2, Fr2.methodOf = cu2, Fr2.mixin = fu2, Fr2.negate = Vo2, Fr2.nthArg = function(t9) {
        return t9 = vs2(t9), Zn2(function(e4) {
          return zn2(e4, t9);
        });
      }, Fr2.omit = Vs2, Fr2.omitBy = function(t9, e4) {
        return js2(t9, Vo2(fa2(e4)));
      }, Fr2.once = function(t9) {
        return Ro(2, t9);
      }, Fr2.orderBy = function(t9, e4, n3, i3) {
        return t9 == null ? [] : (Ho2(e4) || (e4 = e4 == null ? [] : [e4]), Ho2(n3 = i3 ? r2 : n3) || (n3 = n3 == null ? [] : [n3]), Wn2(t9, e4, n3));
      }, Fr2.over = hu2, Fr2.overArgs = Mo2, Fr2.overEvery = pu2, Fr2.overSome = du2, Fr2.partial = jo2, Fr2.partialRight = Fo2, Fr2.partition = _o2, Fr2.pick = Ms2, Fr2.pickBy = js2, Fr2.property = yu, Fr2.propertyOf = function(t9) {
        return function(e4) {
          return t9 == null ? r2 : An2(t9, e4);
        };
      }, Fr2.pull = Ja2, Fr2.pullAll = to2, Fr2.pullAllBy = function(t9, e4, r3) {
        return t9 && t9.length && e4 && e4.length ? Qn(t9, e4, fa2(r3, 2)) : t9;
      }, Fr2.pullAllWith = function(t9, e4, n3) {
        return t9 && t9.length && e4 && e4.length ? Qn(t9, e4, r2, n3) : t9;
      }, Fr2.pullAt = eo2, Fr2.range = gu, Fr2.rangeRight = vu, Fr2.rearg = Ko2, Fr2.reject = function(t9, e4) {
        return (Ho2(t9) ? Ne2 : mn2)(t9, Vo2(fa2(e4, 3)));
      }, Fr2.remove = function(t9, e4) {
        var r3 = [];
        if (!t9 || !t9.length)
          return r3;
        var n3 = -1, i3 = [], a3 = t9.length;
        for (e4 = fa2(e4, 3); ++n3 < a3; ) {
          var o3 = t9[n3];
          e4(o3, n3, t9) && (r3.push(o3), i3.push(n3));
        }
        return Yn2(t9, i3), r3;
      }, Fr2.rest = function(t9, e4) {
        if (typeof t9 != "function")
          throw new kt3(n2);
        return Zn2(t9, e4 = e4 === r2 ? e4 : vs2(e4));
      }, Fr2.reverse = ro2, Fr2.sampleSize = function(t9, e4, n3) {
        return e4 = (n3 ? Sa2(t9, e4, n3) : e4 === r2) ? 1 : vs2(e4), (Ho2(t9) ? Jr2 : ti2)(t9, e4);
      }, Fr2.set = function(t9, e4, r3) {
        return t9 == null ? t9 : ei2(t9, e4, r3);
      }, Fr2.setWith = function(t9, e4, n3, i3) {
        return i3 = typeof i3 == "function" ? i3 : r2, t9 == null ? t9 : ei2(t9, e4, n3, i3);
      }, Fr2.shuffle = function(t9) {
        return (Ho2(t9) ? tn2 : ii2)(t9);
      }, Fr2.slice = function(t9, e4, n3) {
        var i3 = t9 == null ? 0 : t9.length;
        return i3 ? (n3 && typeof n3 != "number" && Sa2(t9, e4, n3) ? (e4 = 0, n3 = i3) : (e4 = e4 == null ? 0 : vs2(e4), n3 = n3 === r2 ? i3 : vs2(n3)), ai2(t9, e4, n3)) : [];
      }, Fr2.sortBy = Bo, Fr2.sortedUniq = function(t9) {
        return t9 && t9.length ? ci2(t9) : [];
      }, Fr2.sortedUniqBy = function(t9, e4) {
        return t9 && t9.length ? ci2(t9, fa2(e4, 2)) : [];
      }, Fr2.split = function(t9, e4, n3) {
        return n3 && typeof n3 != "number" && Sa2(t9, e4, n3) && (e4 = n3 = r2), (n3 = n3 === r2 ? d2 : n3 >>> 0) ? (t9 = Ss2(t9)) && (typeof e4 == "string" || e4 != null && !us2(e4)) && !(e4 = li2(e4)) && ar2(t9) ? Ti2(hr2(t9), 0, n3) : t9.split(e4, n3) : [];
      }, Fr2.spread = function(t9, e4) {
        if (typeof t9 != "function")
          throw new kt3(n2);
        return e4 = e4 == null ? 0 : Cr2(vs2(e4), 0), Zn2(function(r3) {
          var n3 = r3[e4], i3 = Ti2(r3, 0, e4);
          return n3 && Le2(i3, n3), Ie2(t9, this, i3);
        });
      }, Fr2.tail = function(t9) {
        var e4 = t9 == null ? 0 : t9.length;
        return e4 ? ai2(t9, 1, e4) : [];
      }, Fr2.take = function(t9, e4, n3) {
        return t9 && t9.length ? ai2(t9, 0, (e4 = n3 || e4 === r2 ? 1 : vs2(e4)) < 0 ? 0 : e4) : [];
      }, Fr2.takeRight = function(t9, e4, n3) {
        var i3 = t9 == null ? 0 : t9.length;
        return i3 ? ai2(t9, (e4 = i3 - (e4 = n3 || e4 === r2 ? 1 : vs2(e4))) < 0 ? 0 : e4, i3) : [];
      }, Fr2.takeRightWhile = function(t9, e4) {
        return t9 && t9.length ? yi2(t9, fa2(e4, 3), false, true) : [];
      }, Fr2.takeWhile = function(t9, e4) {
        return t9 && t9.length ? yi2(t9, fa2(e4, 3)) : [];
      }, Fr2.tap = function(t9, e4) {
        return e4(t9), t9;
      }, Fr2.throttle = function(t9, e4, r3) {
        var i3 = true, a3 = true;
        if (typeof t9 != "function")
          throw new kt3(n2);
        return ns2(r3) && (i3 = "leading" in r3 ? !!r3.leading : i3, a3 = "trailing" in r3 ? !!r3.trailing : a3), Po(t9, e4, { leading: i3, maxWait: e4, trailing: a3 });
      }, Fr2.thru = go2, Fr2.toArray = ys2, Fr2.toPairs = Fs2, Fr2.toPairsIn = Ks2, Fr2.toPath = function(t9) {
        return Ho2(t9) ? Oe2(t9, Ma2) : ls2(t9) ? [t9] : Ri2(Va2(Ss2(t9)));
      }, Fr2.toPlainObject = Es2, Fr2.transform = function(t9, e4, r3) {
        var n3 = Ho2(t9), i3 = n3 || $o2(t9) || hs2(t9);
        if (e4 = fa2(e4, 4), r3 == null) {
          var a3 = t9 && t9.constructor;
          r3 = i3 ? n3 ? new a3() : [] : ns2(t9) && ts2(a3) ? Kr2(Ht3(t9)) : {};
        }
        return (i3 ? we2 : bn2)(t9, function(t10, n4, i4) {
          return e4(r3, t10, n4, i4);
        }), r3;
      }, Fr2.unary = function(t9) {
        return ko(t9, 1);
      }, Fr2.union = no2, Fr2.unionBy = io2, Fr2.unionWith = ao2, Fr2.uniq = function(t9) {
        return t9 && t9.length ? hi2(t9) : [];
      }, Fr2.uniqBy = function(t9, e4) {
        return t9 && t9.length ? hi2(t9, fa2(e4, 2)) : [];
      }, Fr2.uniqWith = function(t9, e4) {
        return e4 = typeof e4 == "function" ? e4 : r2, t9 && t9.length ? hi2(t9, r2, e4) : [];
      }, Fr2.unset = function(t9, e4) {
        return t9 == null || pi2(t9, e4);
      }, Fr2.unzip = oo2, Fr2.unzipWith = so2, Fr2.update = function(t9, e4, r3) {
        return t9 == null ? t9 : di2(t9, e4, Ei2(r3));
      }, Fr2.updateWith = function(t9, e4, n3, i3) {
        return i3 = typeof i3 == "function" ? i3 : r2, t9 == null ? t9 : di2(t9, e4, Ei2(n3), i3);
      }, Fr2.values = qs2, Fr2.valuesIn = function(t9) {
        return t9 == null ? [] : $e2(t9, Us2(t9));
      }, Fr2.without = uo2, Fr2.words = tu2, Fr2.wrap = function(t9, e4) {
        return jo2(Ei2(e4), t9);
      }, Fr2.xor = co2, Fr2.xorBy = fo2, Fr2.xorWith = lo2, Fr2.zip = ho2, Fr2.zipObject = function(t9, e4) {
        return mi2(t9 || [], e4 || [], rn2);
      }, Fr2.zipObjectDeep = function(t9, e4) {
        return mi2(t9 || [], e4 || [], ei2);
      }, Fr2.zipWith = po2, Fr2.entries = Fs2, Fr2.entriesIn = Ks2, Fr2.extend = Ts2, Fr2.extendWith = Is2, fu2(Fr2, Fr2), Fr2.add = Eu, Fr2.attempt = eu2, Fr2.camelCase = Gs2, Fr2.capitalize = zs2, Fr2.ceil = Su, Fr2.clamp = function(t9, e4, n3) {
        return n3 === r2 && (n3 = e4, e4 = r2), n3 !== r2 && (n3 = (n3 = Cs2(n3)) == n3 ? n3 : 0), e4 !== r2 && (e4 = (e4 = Cs2(e4)) == e4 ? e4 : 0), cn2(Cs2(t9), e4, n3);
      }, Fr2.clone = function(t9) {
        return fn2(t9, 4);
      }, Fr2.cloneDeep = function(t9) {
        return fn2(t9, 5);
      }, Fr2.cloneDeepWith = function(t9, e4) {
        return fn2(t9, 5, e4 = typeof e4 == "function" ? e4 : r2);
      }, Fr2.cloneWith = function(t9, e4) {
        return fn2(t9, 4, e4 = typeof e4 == "function" ? e4 : r2);
      }, Fr2.conformsTo = function(t9, e4) {
        return e4 == null || ln2(t9, e4, Ps2(e4));
      }, Fr2.deburr = Ws2, Fr2.defaultTo = function(t9, e4) {
        return t9 == null || t9 != t9 ? e4 : t9;
      }, Fr2.divide = bu, Fr2.endsWith = function(t9, e4, n3) {
        t9 = Ss2(t9), e4 = li2(e4);
        var i3 = t9.length, a3 = n3 = n3 === r2 ? i3 : cn2(vs2(n3), 0, i3);
        return (n3 -= e4.length) >= 0 && t9.slice(n3, a3) == e4;
      }, Fr2.eq = qo2, Fr2.escape = function(t9) {
        return (t9 = Ss2(t9)) && X2.test(t9) ? t9.replace(Q2, nr2) : t9;
      }, Fr2.escapeRegExp = function(t9) {
        return (t9 = Ss2(t9)) && it2.test(t9) ? t9.replace(nt2, "\\$&") : t9;
      }, Fr2.every = function(t9, e4, n3) {
        var i3 = Ho2(t9) ? Be2 : gn2;
        return n3 && Sa2(t9, e4, n3) && (e4 = r2), i3(t9, fa2(e4, 3));
      }, Fr2.find = Co2, Fr2.findIndex = za2, Fr2.findKey = function(t9, e4) {
        return Ve2(t9, fa2(e4, 3), bn2);
      }, Fr2.findLast = Eo2, Fr2.findLastIndex = Wa2, Fr2.findLastKey = function(t9, e4) {
        return Ve2(t9, fa2(e4, 3), Tn2);
      }, Fr2.floor = Tu, Fr2.forEach = So2, Fr2.forEachRight = bo2, Fr2.forIn = function(t9, e4) {
        return t9 == null ? t9 : En2(t9, fa2(e4, 3), Us2);
      }, Fr2.forInRight = function(t9, e4) {
        return t9 == null ? t9 : Sn2(t9, fa2(e4, 3), Us2);
      }, Fr2.forOwn = function(t9, e4) {
        return t9 && bn2(t9, fa2(e4, 3));
      }, Fr2.forOwnRight = function(t9, e4) {
        return t9 && Tn2(t9, fa2(e4, 3));
      }, Fr2.get = Ns2, Fr2.gt = Go2, Fr2.gte = zo2, Fr2.has = function(t9, e4) {
        return t9 != null && va2(t9, e4, Nn2);
      }, Fr2.hasIn = ks2, Fr2.head = Qa2, Fr2.identity = ou2, Fr2.includes = function(t9, e4, r3, n3) {
        t9 = Yo2(t9) ? t9 : qs2(t9), r3 = r3 && !n3 ? vs2(r3) : 0;
        var i3 = t9.length;
        return r3 < 0 && (r3 = Cr2(i3 + r3, 0)), fs2(t9) ? r3 <= i3 && t9.indexOf(e4, r3) > -1 : !!i3 && je2(t9, e4, r3) > -1;
      }, Fr2.indexOf = function(t9, e4, r3) {
        var n3 = t9 == null ? 0 : t9.length;
        if (!n3)
          return -1;
        var i3 = r3 == null ? 0 : vs2(r3);
        return i3 < 0 && (i3 = Cr2(n3 + i3, 0)), je2(t9, e4, i3);
      }, Fr2.inRange = function(t9, e4, n3) {
        return e4 = gs2(e4), n3 === r2 ? (n3 = e4, e4 = 0) : n3 = gs2(n3), function(t10, e5, r3) {
          return t10 >= Er2(e5, r3) && t10 < Cr2(e5, r3);
        }(t9 = Cs2(t9), e4, n3);
      }, Fr2.invoke = Ls2, Fr2.isArguments = Wo2, Fr2.isArray = Ho2, Fr2.isArrayBuffer = Qo2, Fr2.isArrayLike = Yo2, Fr2.isArrayLikeObject = Xo2, Fr2.isBoolean = function(t9) {
        return t9 === true || t9 === false || is2(t9) && _n2(t9) == m2;
      }, Fr2.isBuffer = $o2, Fr2.isDate = Zo2, Fr2.isElement = function(t9) {
        return is2(t9) && t9.nodeType === 1 && !ss2(t9);
      }, Fr2.isEmpty = function(t9) {
        if (t9 == null)
          return true;
        if (Yo2(t9) && (Ho2(t9) || typeof t9 == "string" || typeof t9.splice == "function" || $o2(t9) || hs2(t9) || Wo2(t9)))
          return !t9.length;
        var e4 = ga2(t9);
        if (e4 == T2 || e4 == N2)
          return !t9.size;
        if (Aa2(t9))
          return !Vn2(t9).length;
        for (var r3 in t9)
          if (xt3.call(t9, r3))
            return false;
        return true;
      }, Fr2.isEqual = function(t9, e4) {
        return Pn2(t9, e4);
      }, Fr2.isEqualWith = function(t9, e4, n3) {
        var i3 = (n3 = typeof n3 == "function" ? n3 : r2) ? n3(t9, e4) : r2;
        return i3 === r2 ? Pn2(t9, e4, r2, n3) : !!i3;
      }, Fr2.isError = Jo2, Fr2.isFinite = function(t9) {
        return typeof t9 == "number" && gr2(t9);
      }, Fr2.isFunction = ts2, Fr2.isInteger = es2, Fr2.isLength = rs2, Fr2.isMap = as2, Fr2.isMatch = function(t9, e4) {
        return t9 === e4 || Un2(t9, e4, ha2(e4));
      }, Fr2.isMatchWith = function(t9, e4, n3) {
        return n3 = typeof n3 == "function" ? n3 : r2, Un2(t9, e4, ha2(e4), n3);
      }, Fr2.isNaN = function(t9) {
        return os2(t9) && t9 != +t9;
      }, Fr2.isNative = function(t9) {
        if (Ia2(t9))
          throw new It3("Unsupported core-js use. Try https://npms.io/search?q=ponyfill.");
        return xn2(t9);
      }, Fr2.isNil = function(t9) {
        return t9 == null;
      }, Fr2.isNull = function(t9) {
        return t9 === null;
      }, Fr2.isNumber = os2, Fr2.isObject = ns2, Fr2.isObjectLike = is2, Fr2.isPlainObject = ss2, Fr2.isRegExp = us2, Fr2.isSafeInteger = function(t9) {
        return es2(t9) && t9 >= -9007199254740991 && t9 <= h2;
      }, Fr2.isSet = cs2, Fr2.isString = fs2, Fr2.isSymbol = ls2, Fr2.isTypedArray = hs2, Fr2.isUndefined = function(t9) {
        return t9 === r2;
      }, Fr2.isWeakMap = function(t9) {
        return is2(t9) && ga2(t9) == O2;
      }, Fr2.isWeakSet = function(t9) {
        return is2(t9) && _n2(t9) == "[object WeakSet]";
      }, Fr2.join = function(t9, e4) {
        return t9 == null ? "" : vr2.call(t9, e4);
      }, Fr2.kebabCase = Hs2, Fr2.last = Za2, Fr2.lastIndexOf = function(t9, e4, n3) {
        var i3 = t9 == null ? 0 : t9.length;
        if (!i3)
          return -1;
        var a3 = i3;
        return n3 !== r2 && (a3 = (a3 = vs2(n3)) < 0 ? Cr2(i3 + a3, 0) : Er2(a3, i3 - 1)), e4 == e4 ? function(t10, e5, r3) {
          for (var n4 = r3 + 1; n4--; )
            if (t10[n4] === e5)
              return n4;
          return n4;
        }(t9, e4, a3) : Me2(t9, Ke2, a3, true);
      }, Fr2.lowerCase = Qs2, Fr2.lowerFirst = Ys2, Fr2.lt = ps2, Fr2.lte = ds2, Fr2.max = function(t9) {
        return t9 && t9.length ? vn2(t9, ou2, Bn2) : r2;
      }, Fr2.maxBy = function(t9, e4) {
        return t9 && t9.length ? vn2(t9, fa2(e4, 2), Bn2) : r2;
      }, Fr2.mean = function(t9) {
        return qe2(t9, ou2);
      }, Fr2.meanBy = function(t9, e4) {
        return qe2(t9, fa2(e4, 2));
      }, Fr2.min = function(t9) {
        return t9 && t9.length ? vn2(t9, ou2, jn2) : r2;
      }, Fr2.minBy = function(t9, e4) {
        return t9 && t9.length ? vn2(t9, fa2(e4, 2), jn2) : r2;
      }, Fr2.stubArray = mu, Fr2.stubFalse = Cu, Fr2.stubObject = function() {
        return {};
      }, Fr2.stubString = function() {
        return "";
      }, Fr2.stubTrue = function() {
        return true;
      }, Fr2.multiply = Au, Fr2.nth = function(t9, e4) {
        return t9 && t9.length ? zn2(t9, vs2(e4)) : r2;
      }, Fr2.noConflict = function() {
        return he2._ === this && (he2._ = Ft3), this;
      }, Fr2.noop = lu2, Fr2.now = No, Fr2.pad = function(t9, e4, r3) {
        t9 = Ss2(t9);
        var n3 = (e4 = vs2(e4)) ? lr2(t9) : 0;
        if (!e4 || n3 >= e4)
          return t9;
        var i3 = (e4 - n3) / 2;
        return Wi2(ve3(i3), r3) + t9 + Wi2(ge3(i3), r3);
      }, Fr2.padEnd = function(t9, e4, r3) {
        t9 = Ss2(t9);
        var n3 = (e4 = vs2(e4)) ? lr2(t9) : 0;
        return e4 && n3 < e4 ? t9 + Wi2(e4 - n3, r3) : t9;
      }, Fr2.padStart = function(t9, e4, r3) {
        t9 = Ss2(t9);
        var n3 = (e4 = vs2(e4)) ? lr2(t9) : 0;
        return e4 && n3 < e4 ? Wi2(e4 - n3, r3) + t9 : t9;
      }, Fr2.parseInt = function(t9, e4, r3) {
        return r3 || e4 == null ? e4 = 0 : e4 && (e4 = +e4), br2(Ss2(t9).replace(at2, ""), e4 || 0);
      }, Fr2.random = function(t9, e4, n3) {
        if (n3 && typeof n3 != "boolean" && Sa2(t9, e4, n3) && (e4 = n3 = r2), n3 === r2 && (typeof e4 == "boolean" ? (n3 = e4, e4 = r2) : typeof t9 == "boolean" && (n3 = t9, t9 = r2)), t9 === r2 && e4 === r2 ? (t9 = 0, e4 = 1) : (t9 = gs2(t9), e4 === r2 ? (e4 = t9, t9 = 0) : e4 = gs2(e4)), t9 > e4) {
          var i3 = t9;
          t9 = e4, e4 = i3;
        }
        if (n3 || t9 % 1 || e4 % 1) {
          var a3 = Tr2();
          return Er2(t9 + a3 * (e4 - t9 + ue2("1e-" + ((a3 + "").length - 1))), e4);
        }
        return Xn2(t9, e4);
      }, Fr2.reduce = function(t9, e4, r3) {
        var n3 = Ho2(t9) ? Pe2 : We2, i3 = arguments.length < 3;
        return n3(t9, fa2(e4, 4), r3, i3, dn2);
      }, Fr2.reduceRight = function(t9, e4, r3) {
        var n3 = Ho2(t9) ? Ue2 : We2, i3 = arguments.length < 3;
        return n3(t9, fa2(e4, 4), r3, i3, yn2);
      }, Fr2.repeat = function(t9, e4, n3) {
        return e4 = (n3 ? Sa2(t9, e4, n3) : e4 === r2) ? 1 : vs2(e4), $n2(Ss2(t9), e4);
      }, Fr2.replace = function() {
        var t9 = arguments, e4 = Ss2(t9[0]);
        return t9.length < 3 ? e4 : e4.replace(t9[1], t9[2]);
      }, Fr2.result = function(t9, e4, n3) {
        var i3 = -1, a3 = (e4 = Si2(e4, t9)).length;
        for (a3 || (a3 = 1, t9 = r2); ++i3 < a3; ) {
          var o3 = t9 == null ? r2 : t9[Ma2(e4[i3])];
          o3 === r2 && (i3 = a3, o3 = n3), t9 = ts2(o3) ? o3.call(t9) : o3;
        }
        return t9;
      }, Fr2.round = wu2, Fr2.runInContext = t8, Fr2.sample = function(t9) {
        return (Ho2(t9) ? Zr2 : Jn2)(t9);
      }, Fr2.size = function(t9) {
        if (t9 == null)
          return 0;
        if (Yo2(t9))
          return fs2(t9) ? lr2(t9) : t9.length;
        var e4 = ga2(t9);
        return e4 == T2 || e4 == N2 ? t9.size : Vn2(t9).length;
      }, Fr2.snakeCase = Xs2, Fr2.some = function(t9, e4, n3) {
        var i3 = Ho2(t9) ? xe2 : oi2;
        return n3 && Sa2(t9, e4, n3) && (e4 = r2), i3(t9, fa2(e4, 3));
      }, Fr2.sortedIndex = function(t9, e4) {
        return si2(t9, e4);
      }, Fr2.sortedIndexBy = function(t9, e4, r3) {
        return ui2(t9, e4, fa2(r3, 2));
      }, Fr2.sortedIndexOf = function(t9, e4) {
        var r3 = t9 == null ? 0 : t9.length;
        if (r3) {
          var n3 = si2(t9, e4);
          if (n3 < r3 && qo2(t9[n3], e4))
            return n3;
        }
        return -1;
      }, Fr2.sortedLastIndex = function(t9, e4) {
        return si2(t9, e4, true);
      }, Fr2.sortedLastIndexBy = function(t9, e4, r3) {
        return ui2(t9, e4, fa2(r3, 2), true);
      }, Fr2.sortedLastIndexOf = function(t9, e4) {
        if (t9 == null ? 0 : t9.length) {
          var r3 = si2(t9, e4, true) - 1;
          if (qo2(t9[r3], e4))
            return r3;
        }
        return -1;
      }, Fr2.startCase = $s2, Fr2.startsWith = function(t9, e4, r3) {
        return t9 = Ss2(t9), r3 = r3 == null ? 0 : cn2(vs2(r3), 0, t9.length), e4 = li2(e4), t9.slice(r3, r3 + e4.length) == e4;
      }, Fr2.subtract = _u2, Fr2.sum = function(t9) {
        return t9 && t9.length ? He2(t9, ou2) : 0;
      }, Fr2.sumBy = function(t9, e4) {
        return t9 && t9.length ? He2(t9, fa2(e4, 2)) : 0;
      }, Fr2.template = function(t9, e4, n3) {
        var i3 = Fr2.templateSettings;
        n3 && Sa2(t9, e4, n3) && (e4 = r2), t9 = Ss2(t9), e4 = Is2({}, e4, i3, ta2);
        var a3, o3, s3 = Is2({}, e4.imports, i3.imports, ta2), u3 = Ps2(s3), c3 = $e2(s3, u3), f3 = 0, l3 = e4.interpolate || St2, h3 = "__p += '", p3 = Bt3((e4.escape || St2).source + "|" + l3.source + "|" + (l3 === J2 ? pt2 : St2).source + "|" + (e4.evaluate || St2).source + "|$", "g"), d3 = "//# sourceURL=" + (xt3.call(e4, "sourceURL") ? (e4.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++ie2 + "]") + "\n";
        t9.replace(p3, function(e5, r3, n4, i4, s4, u4) {
          return n4 || (n4 = i4), h3 += t9.slice(f3, u4).replace(bt2, ir2), r3 && (a3 = true, h3 += "' +\n__e(" + r3 + ") +\n'"), s4 && (o3 = true, h3 += "';\n" + s4 + ";\n__p += '"), n4 && (h3 += "' +\n((__t = (" + n4 + ")) == null ? '' : __t) +\n'"), f3 = u4 + e5.length, e5;
        }), h3 += "';\n";
        var y3 = xt3.call(e4, "variable") && e4.variable;
        if (y3) {
          if (lt2.test(y3))
            throw new It3("Invalid `variable` option passed into `_.template`");
        } else
          h3 = "with (obj) {\n" + h3 + "\n}\n";
        h3 = (o3 ? h3.replace(G2, "") : h3).replace(z2, "$1").replace(W2, "$1;"), h3 = "function(" + (y3 || "obj") + ") {\n" + (y3 ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (a3 ? ", __e = _.escape" : "") + (o3 ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + h3 + "return __p\n}";
        var g3 = eu2(function() {
          return At3(u3, d3 + "return " + h3).apply(r2, c3);
        });
        if (g3.source = h3, Jo2(g3))
          throw g3;
        return g3;
      }, Fr2.times = function(t9, e4) {
        if ((t9 = vs2(t9)) < 1 || t9 > h2)
          return [];
        var r3 = d2, n3 = Er2(t9, d2);
        e4 = fa2(e4), t9 -= d2;
        for (var i3 = Qe2(n3, e4); ++r3 < t9; )
          e4(r3);
        return i3;
      }, Fr2.toFinite = gs2, Fr2.toInteger = vs2, Fr2.toLength = ms2, Fr2.toLower = function(t9) {
        return Ss2(t9).toLowerCase();
      }, Fr2.toNumber = Cs2, Fr2.toSafeInteger = function(t9) {
        return t9 ? cn2(vs2(t9), -9007199254740991, h2) : t9 === 0 ? t9 : 0;
      }, Fr2.toString = Ss2, Fr2.toUpper = function(t9) {
        return Ss2(t9).toUpperCase();
      }, Fr2.trim = function(t9, e4, n3) {
        if ((t9 = Ss2(t9)) && (n3 || e4 === r2))
          return Ye2(t9);
        if (!t9 || !(e4 = li2(e4)))
          return t9;
        var i3 = hr2(t9), a3 = hr2(e4);
        return Ti2(i3, Je2(i3, a3), tr2(i3, a3) + 1).join("");
      }, Fr2.trimEnd = function(t9, e4, n3) {
        if ((t9 = Ss2(t9)) && (n3 || e4 === r2))
          return t9.slice(0, pr2(t9) + 1);
        if (!t9 || !(e4 = li2(e4)))
          return t9;
        var i3 = hr2(t9);
        return Ti2(i3, 0, tr2(i3, hr2(e4)) + 1).join("");
      }, Fr2.trimStart = function(t9, e4, n3) {
        if ((t9 = Ss2(t9)) && (n3 || e4 === r2))
          return t9.replace(at2, "");
        if (!t9 || !(e4 = li2(e4)))
          return t9;
        var i3 = hr2(t9);
        return Ti2(i3, Je2(i3, hr2(e4))).join("");
      }, Fr2.truncate = function(t9, e4) {
        var n3 = 30, i3 = "...";
        if (ns2(e4)) {
          var a3 = "separator" in e4 ? e4.separator : a3;
          n3 = "length" in e4 ? vs2(e4.length) : n3, i3 = "omission" in e4 ? li2(e4.omission) : i3;
        }
        var o3 = (t9 = Ss2(t9)).length;
        if (ar2(t9)) {
          var s3 = hr2(t9);
          o3 = s3.length;
        }
        if (n3 >= o3)
          return t9;
        var u3 = n3 - lr2(i3);
        if (u3 < 1)
          return i3;
        var c3 = s3 ? Ti2(s3, 0, u3).join("") : t9.slice(0, u3);
        if (a3 === r2)
          return c3 + i3;
        if (s3 && (u3 += c3.length - u3), us2(a3)) {
          if (t9.slice(u3).search(a3)) {
            var f3, l3 = c3;
            for (a3.global || (a3 = Bt3(a3.source, Ss2(dt2.exec(a3)) + "g")), a3.lastIndex = 0; f3 = a3.exec(l3); )
              var h3 = f3.index;
            c3 = c3.slice(0, h3 === r2 ? u3 : h3);
          }
        } else if (t9.indexOf(li2(a3), u3) != u3) {
          var p3 = c3.lastIndexOf(a3);
          p3 > -1 && (c3 = c3.slice(0, p3));
        }
        return c3 + i3;
      }, Fr2.unescape = function(t9) {
        return (t9 = Ss2(t9)) && Y2.test(t9) ? t9.replace(H2, dr2) : t9;
      }, Fr2.uniqueId = function(t9) {
        var e4 = ++Dt3;
        return Ss2(t9) + e4;
      }, Fr2.upperCase = Zs2, Fr2.upperFirst = Js2, Fr2.each = So2, Fr2.eachRight = bo2, Fr2.first = Qa2, fu2(Fr2, (Iu = {}, bn2(Fr2, function(t9, e4) {
        xt3.call(Fr2.prototype, e4) || (Iu[e4] = t9);
      }), Iu), { chain: false }), Fr2.VERSION = "4.17.21", we2(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(t9) {
        Fr2[t9].placeholder = Fr2;
      }), we2(["drop", "take"], function(t9, e4) {
        zr2.prototype[t9] = function(n3) {
          n3 = n3 === r2 ? 1 : Cr2(vs2(n3), 0);
          var i3 = this.__filtered__ && !e4 ? new zr2(this) : this.clone();
          return i3.__filtered__ ? i3.__takeCount__ = Er2(n3, i3.__takeCount__) : i3.__views__.push({ size: Er2(n3, d2), type: t9 + (i3.__dir__ < 0 ? "Right" : "") }), i3;
        }, zr2.prototype[t9 + "Right"] = function(e5) {
          return this.reverse()[t9](e5).reverse();
        };
      }), we2(["filter", "map", "takeWhile"], function(t9, e4) {
        var r3 = e4 + 1, n3 = r3 == 1 || r3 == 3;
        zr2.prototype[t9] = function(t10) {
          var e5 = this.clone();
          return e5.__iteratees__.push({ iteratee: fa2(t10, 3), type: r3 }), e5.__filtered__ = e5.__filtered__ || n3, e5;
        };
      }), we2(["head", "last"], function(t9, e4) {
        var r3 = "take" + (e4 ? "Right" : "");
        zr2.prototype[t9] = function() {
          return this[r3](1).value()[0];
        };
      }), we2(["initial", "tail"], function(t9, e4) {
        var r3 = "drop" + (e4 ? "" : "Right");
        zr2.prototype[t9] = function() {
          return this.__filtered__ ? new zr2(this) : this[r3](1);
        };
      }), zr2.prototype.compact = function() {
        return this.filter(ou2);
      }, zr2.prototype.find = function(t9) {
        return this.filter(t9).head();
      }, zr2.prototype.findLast = function(t9) {
        return this.reverse().find(t9);
      }, zr2.prototype.invokeMap = Zn2(function(t9, e4) {
        return typeof t9 == "function" ? new zr2(this) : this.map(function(r3) {
          return On2(r3, t9, e4);
        });
      }), zr2.prototype.reject = function(t9) {
        return this.filter(Vo2(fa2(t9)));
      }, zr2.prototype.slice = function(t9, e4) {
        t9 = vs2(t9);
        var n3 = this;
        return n3.__filtered__ && (t9 > 0 || e4 < 0) ? new zr2(n3) : (t9 < 0 ? n3 = n3.takeRight(-t9) : t9 && (n3 = n3.drop(t9)), e4 !== r2 && (n3 = (e4 = vs2(e4)) < 0 ? n3.dropRight(-e4) : n3.take(e4 - t9)), n3);
      }, zr2.prototype.takeRightWhile = function(t9) {
        return this.reverse().takeWhile(t9).reverse();
      }, zr2.prototype.toArray = function() {
        return this.take(d2);
      }, bn2(zr2.prototype, function(t9, e4) {
        var n3 = /^(?:filter|find|map|reject)|While$/.test(e4), i3 = /^(?:head|last)$/.test(e4), a3 = Fr2[i3 ? "take" + (e4 == "last" ? "Right" : "") : e4], o3 = i3 || /^find/.test(e4);
        a3 && (Fr2.prototype[e4] = function() {
          var e5 = this.__wrapped__, s3 = i3 ? [1] : arguments, u3 = e5 instanceof zr2, c3 = s3[0], f3 = u3 || Ho2(e5), l3 = function(t10) {
            var e6 = a3.apply(Fr2, Le2([t10], s3));
            return i3 && h3 ? e6[0] : e6;
          };
          f3 && n3 && typeof c3 == "function" && c3.length != 1 && (u3 = f3 = false);
          var h3 = this.__chain__, p3 = !!this.__actions__.length, d3 = o3 && !h3, y3 = u3 && !p3;
          if (!o3 && f3) {
            e5 = y3 ? e5 : new zr2(this);
            var g3 = t9.apply(e5, s3);
            return g3.__actions__.push({ func: go2, args: [l3], thisArg: r2 }), new Gr2(g3, h3);
          }
          return d3 && y3 ? t9.apply(this, s3) : (g3 = this.thru(l3), d3 ? i3 ? g3.value()[0] : g3.value() : g3);
        });
      }), we2(["pop", "push", "shift", "sort", "splice", "unshift"], function(t9) {
        var e4 = Rt3[t9], r3 = /^(?:push|sort|unshift)$/.test(t9) ? "tap" : "thru", n3 = /^(?:pop|shift)$/.test(t9);
        Fr2.prototype[t9] = function() {
          var t10 = arguments;
          if (n3 && !this.__chain__) {
            var i3 = this.value();
            return e4.apply(Ho2(i3) ? i3 : [], t10);
          }
          return this[r3](function(r4) {
            return e4.apply(Ho2(r4) ? r4 : [], t10);
          });
        };
      }), bn2(zr2.prototype, function(t9, e4) {
        var r3 = Fr2[e4];
        if (r3) {
          var n3 = r3.name + "";
          xt3.call(Or2, n3) || (Or2[n3] = []), Or2[n3].push({ name: e4, func: r3 });
        }
      }), Or2[Ki2(r2, 2).name] = [{ name: "wrapper", func: r2 }], zr2.prototype.clone = function() {
        var t9 = new zr2(this.__wrapped__);
        return t9.__actions__ = Ri2(this.__actions__), t9.__dir__ = this.__dir__, t9.__filtered__ = this.__filtered__, t9.__iteratees__ = Ri2(this.__iteratees__), t9.__takeCount__ = this.__takeCount__, t9.__views__ = Ri2(this.__views__), t9;
      }, zr2.prototype.reverse = function() {
        if (this.__filtered__) {
          var t9 = new zr2(this);
          t9.__dir__ = -1, t9.__filtered__ = true;
        } else
          (t9 = this.clone()).__dir__ *= -1;
        return t9;
      }, zr2.prototype.value = function() {
        var t9 = this.__wrapped__.value(), e4 = this.__dir__, r3 = Ho2(t9), n3 = e4 < 0, i3 = r3 ? t9.length : 0, a3 = function(t10, e5, r4) {
          var n4 = -1, i4 = r4.length;
          for (; ++n4 < i4; ) {
            var a4 = r4[n4], o4 = a4.size;
            switch (a4.type) {
              case "drop":
                t10 += o4;
                break;
              case "dropRight":
                e5 -= o4;
                break;
              case "take":
                e5 = Er2(e5, t10 + o4);
                break;
              case "takeRight":
                t10 = Cr2(t10, e5 - o4);
            }
          }
          return { start: t10, end: e5 };
        }(0, i3, this.__views__), o3 = a3.start, s3 = a3.end, u3 = s3 - o3, c3 = n3 ? s3 : o3 - 1, f3 = this.__iteratees__, l3 = f3.length, h3 = 0, p3 = Er2(u3, this.__takeCount__);
        if (!r3 || !n3 && i3 == u3 && p3 == u3)
          return gi2(t9, this.__actions__);
        var d3 = [];
        t:
          for (; u3-- && h3 < p3; ) {
            for (var y3 = -1, g3 = t9[c3 += e4]; ++y3 < l3; ) {
              var v3 = f3[y3], m3 = v3.iteratee, C3 = v3.type, E3 = m3(g3);
              if (C3 == 2)
                g3 = E3;
              else if (!E3) {
                if (C3 == 1)
                  continue t;
                break t;
              }
            }
            d3[h3++] = g3;
          }
        return d3;
      }, Fr2.prototype.at = vo2, Fr2.prototype.chain = function() {
        return yo2(this);
      }, Fr2.prototype.commit = function() {
        return new Gr2(this.value(), this.__chain__);
      }, Fr2.prototype.next = function() {
        this.__values__ === r2 && (this.__values__ = ys2(this.value()));
        var t9 = this.__index__ >= this.__values__.length;
        return { done: t9, value: t9 ? r2 : this.__values__[this.__index__++] };
      }, Fr2.prototype.plant = function(t9) {
        for (var e4, n3 = this; n3 instanceof qr2; ) {
          var i3 = Fa2(n3);
          i3.__index__ = 0, i3.__values__ = r2, e4 ? a3.__wrapped__ = i3 : e4 = i3;
          var a3 = i3;
          n3 = n3.__wrapped__;
        }
        return a3.__wrapped__ = t9, e4;
      }, Fr2.prototype.reverse = function() {
        var t9 = this.__wrapped__;
        if (t9 instanceof zr2) {
          var e4 = t9;
          return this.__actions__.length && (e4 = new zr2(this)), (e4 = e4.reverse()).__actions__.push({ func: go2, args: [ro2], thisArg: r2 }), new Gr2(e4, this.__chain__);
        }
        return this.thru(ro2);
      }, Fr2.prototype.toJSON = Fr2.prototype.valueOf = Fr2.prototype.value = function() {
        return gi2(this.__wrapped__, this.__actions__);
      }, Fr2.prototype.first = Fr2.prototype.head, ee3 && (Fr2.prototype[ee3] = function() {
        return this;
      }), Fr2;
    }();
    de2 ? ((de2.exports = yr2)._ = yr2, pe2._ = yr2) : he2._ = yr2;
  }).call(A);
}), Lu = parseInt("0777", 8), Pu = Uu.mkdirp = Uu.mkdirP = Uu;
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
function Uu(t7, e2, r2, n2) {
  typeof e2 == "function" ? (r2 = e2, e2 = {}) : e2 && typeof e2 == "object" || (e2 = { mode: e2 });
  var i2 = e2.mode, a2 = e2.fs || p.default;
  i2 === void 0 && (i2 = Lu), n2 || (n2 = null);
  var o2 = r2 || function() {
  };
  t7 = d.default.resolve(t7), a2.mkdir(t7, i2, function(r3) {
    if (!r3)
      return o2(null, n2 = n2 || t7);
    switch (r3.code) {
      case "ENOENT":
        if (d.default.dirname(t7) === t7)
          return o2(r3);
        Uu(d.default.dirname(t7), e2, function(r4, n3) {
          r4 ? o2(r4, n3) : Uu(t7, e2, o2, n3);
        });
        break;
      default:
        a2.stat(t7, function(t8, e3) {
          t8 || !e3.isDirectory() ? o2(r3, n2) : o2(null, n2);
        });
    }
  });
}
Uu.sync = function t6(e2, r2, n2) {
  r2 && typeof r2 == "object" || (r2 = { mode: r2 });
  var i2 = r2.mode, a2 = r2.fs || p.default;
  i2 === void 0 && (i2 = Lu), n2 || (n2 = null), e2 = d.default.resolve(e2);
  try {
    a2.mkdirSync(e2, i2), n2 = n2 || e2;
  } catch (i3) {
    switch (i3.code) {
      case "ENOENT":
        n2 = t6(d.default.dirname(e2), r2, n2), t6(e2, r2, n2);
        break;
      default:
        var o2;
        try {
          o2 = a2.statSync(e2);
        } catch (t7) {
          throw i3;
        }
        if (!o2.isDirectory())
          throw i3;
    }
  }
  return n2;
};
var xu = { options: { usePureJavaScript: false } }, Du = {}, Vu = Du, Mu = {};
Du.encode = function(t7, e2, r2) {
  if (typeof e2 != "string")
    throw new TypeError('"alphabet" must be a string.');
  if (r2 !== void 0 && typeof r2 != "number")
    throw new TypeError('"maxline" must be a number.');
  var n2 = "";
  if (t7 instanceof Uint8Array) {
    var i2 = 0, a2 = e2.length, o2 = e2.charAt(0), s2 = [0];
    for (i2 = 0; i2 < t7.length; ++i2) {
      for (var u2 = 0, c2 = t7[i2]; u2 < s2.length; ++u2)
        c2 += s2[u2] << 8, s2[u2] = c2 % a2, c2 = c2 / a2 | 0;
      for (; c2 > 0; )
        s2.push(c2 % a2), c2 = c2 / a2 | 0;
    }
    for (i2 = 0; t7[i2] === 0 && i2 < t7.length - 1; ++i2)
      n2 += o2;
    for (i2 = s2.length - 1; i2 >= 0; --i2)
      n2 += e2[s2[i2]];
  } else
    n2 = function(t8, e3) {
      var r3 = 0, n3 = e3.length, i3 = e3.charAt(0), a3 = [0];
      for (r3 = 0; r3 < t8.length(); ++r3) {
        for (var o3 = 0, s3 = t8.at(r3); o3 < a3.length; ++o3)
          s3 += a3[o3] << 8, a3[o3] = s3 % n3, s3 = s3 / n3 | 0;
        for (; s3 > 0; )
          a3.push(s3 % n3), s3 = s3 / n3 | 0;
      }
      var u3 = "";
      for (r3 = 0; t8.at(r3) === 0 && r3 < t8.length() - 1; ++r3)
        u3 += i3;
      for (r3 = a3.length - 1; r3 >= 0; --r3)
        u3 += e3[a3[r3]];
      return u3;
    }(t7, e2);
  if (r2) {
    var f2 = new RegExp(".{1," + r2 + "}", "g");
    n2 = n2.match(f2).join("\r\n");
  }
  return n2;
}, Du.decode = function(t7, e2) {
  if (typeof t7 != "string")
    throw new TypeError('"input" must be a string.');
  if (typeof e2 != "string")
    throw new TypeError('"alphabet" must be a string.');
  var r2 = Mu[e2];
  if (!r2) {
    r2 = Mu[e2] = [];
    for (var n2 = 0; n2 < e2.length; ++n2)
      r2[e2.charCodeAt(n2)] = n2;
  }
  t7 = t7.replace(/\s/g, "");
  var i2 = e2.length, a2 = e2.charAt(0), o2 = [0];
  for (n2 = 0; n2 < t7.length; n2++) {
    var s2 = r2[t7.charCodeAt(n2)];
    if (s2 === void 0)
      return;
    for (var u2 = 0, c2 = s2; u2 < o2.length; ++u2)
      c2 += o2[u2] * i2, o2[u2] = 255 & c2, c2 >>= 8;
    for (; c2 > 0; )
      o2.push(255 & c2), c2 >>= 8;
  }
  for (var f2 = 0; t7[f2] === a2 && f2 < t7.length - 1; ++f2)
    o2.push(0);
  return typeof Buffer != "undefined" ? Buffer.from(o2.reverse()) : new Uint8Array(o2.reverse());
}, w(function(t7) {
  var e2 = t7.exports = xu.util = xu.util || {};
  function r2(t8) {
    if (t8 !== 8 && t8 !== 16 && t8 !== 24 && t8 !== 32)
      throw new Error("Only 8, 16, 24, or 32 bits supported: " + t8);
  }
  function n2(t8) {
    if (this.data = "", this.read = 0, typeof t8 == "string")
      this.data = t8;
    else if (e2.isArrayBuffer(t8) || e2.isArrayBufferView(t8))
      if (typeof Buffer != "undefined" && t8 instanceof Buffer)
        this.data = t8.toString("binary");
      else {
        var r3 = new Uint8Array(t8);
        try {
          this.data = String.fromCharCode.apply(null, r3);
        } catch (t9) {
          for (var i3 = 0; i3 < r3.length; ++i3)
            this.putByte(r3[i3]);
        }
      }
    else
      (t8 instanceof n2 || typeof t8 == "object" && typeof t8.data == "string" && typeof t8.read == "number") && (this.data = t8.data, this.read = t8.read);
    this._constructedStringLength = 0;
  }
  !function() {
    if (typeof process != "undefined" && process.nextTick && !process.browser)
      return e2.nextTick = process.nextTick, void (typeof setImmediate == "function" ? e2.setImmediate = setImmediate : e2.setImmediate = e2.nextTick);
    if (typeof setImmediate == "function")
      return e2.setImmediate = function() {
        return setImmediate.apply(void 0, arguments);
      }, void (e2.nextTick = function(t9) {
        return setImmediate(t9);
      });
    if (e2.setImmediate = function(t9) {
      setTimeout(t9, 0);
    }, typeof window != "undefined" && typeof window.postMessage == "function") {
      var t8 = "forge.setImmediate", r3 = [];
      e2.setImmediate = function(e3) {
        r3.push(e3), r3.length === 1 && window.postMessage(t8, "*");
      }, window.addEventListener("message", function(e3) {
        if (e3.source === window && e3.data === t8) {
          e3.stopPropagation();
          var n4 = r3.slice();
          r3.length = 0, n4.forEach(function(t9) {
            t9();
          });
        }
      }, true);
    }
    if (typeof MutationObserver != "undefined") {
      var n3 = Date.now(), i3 = true, a3 = document.createElement("div");
      r3 = [];
      new MutationObserver(function() {
        var t9 = r3.slice();
        r3.length = 0, t9.forEach(function(t10) {
          t10();
        });
      }).observe(a3, { attributes: true });
      var o3 = e2.setImmediate;
      e2.setImmediate = function(t9) {
        Date.now() - n3 > 15 ? (n3 = Date.now(), o3(t9)) : (r3.push(t9), r3.length === 1 && a3.setAttribute("a", i3 = !i3));
      };
    }
    e2.nextTick = e2.setImmediate;
  }(), e2.isNodejs = typeof process != "undefined" && process.versions && process.versions.node, e2.globalScope = e2.isNodejs ? A : typeof self == "undefined" ? window : self, e2.isArray = Array.isArray || function(t8) {
    return Object.prototype.toString.call(t8) === "[object Array]";
  }, e2.isArrayBuffer = function(t8) {
    return typeof ArrayBuffer != "undefined" && t8 instanceof ArrayBuffer;
  }, e2.isArrayBufferView = function(t8) {
    return t8 && e2.isArrayBuffer(t8.buffer) && t8.byteLength !== void 0;
  }, e2.ByteBuffer = n2, e2.ByteStringBuffer = n2;
  e2.ByteStringBuffer.prototype._optimizeConstructedString = function(t8) {
    this._constructedStringLength += t8, this._constructedStringLength > 4096 && (this.data.substr(0, 1), this._constructedStringLength = 0);
  }, e2.ByteStringBuffer.prototype.length = function() {
    return this.data.length - this.read;
  }, e2.ByteStringBuffer.prototype.isEmpty = function() {
    return this.length() <= 0;
  }, e2.ByteStringBuffer.prototype.putByte = function(t8) {
    return this.putBytes(String.fromCharCode(t8));
  }, e2.ByteStringBuffer.prototype.fillWithByte = function(t8, e3) {
    t8 = String.fromCharCode(t8);
    for (var r3 = this.data; e3 > 0; )
      1 & e3 && (r3 += t8), (e3 >>>= 1) > 0 && (t8 += t8);
    return this.data = r3, this._optimizeConstructedString(e3), this;
  }, e2.ByteStringBuffer.prototype.putBytes = function(t8) {
    return this.data += t8, this._optimizeConstructedString(t8.length), this;
  }, e2.ByteStringBuffer.prototype.putString = function(t8) {
    return this.putBytes(e2.encodeUtf8(t8));
  }, e2.ByteStringBuffer.prototype.putInt16 = function(t8) {
    return this.putBytes(String.fromCharCode(t8 >> 8 & 255) + String.fromCharCode(255 & t8));
  }, e2.ByteStringBuffer.prototype.putInt24 = function(t8) {
    return this.putBytes(String.fromCharCode(t8 >> 16 & 255) + String.fromCharCode(t8 >> 8 & 255) + String.fromCharCode(255 & t8));
  }, e2.ByteStringBuffer.prototype.putInt32 = function(t8) {
    return this.putBytes(String.fromCharCode(t8 >> 24 & 255) + String.fromCharCode(t8 >> 16 & 255) + String.fromCharCode(t8 >> 8 & 255) + String.fromCharCode(255 & t8));
  }, e2.ByteStringBuffer.prototype.putInt16Le = function(t8) {
    return this.putBytes(String.fromCharCode(255 & t8) + String.fromCharCode(t8 >> 8 & 255));
  }, e2.ByteStringBuffer.prototype.putInt24Le = function(t8) {
    return this.putBytes(String.fromCharCode(255 & t8) + String.fromCharCode(t8 >> 8 & 255) + String.fromCharCode(t8 >> 16 & 255));
  }, e2.ByteStringBuffer.prototype.putInt32Le = function(t8) {
    return this.putBytes(String.fromCharCode(255 & t8) + String.fromCharCode(t8 >> 8 & 255) + String.fromCharCode(t8 >> 16 & 255) + String.fromCharCode(t8 >> 24 & 255));
  }, e2.ByteStringBuffer.prototype.putInt = function(t8, e3) {
    r2(e3);
    var n3 = "";
    do {
      e3 -= 8, n3 += String.fromCharCode(t8 >> e3 & 255);
    } while (e3 > 0);
    return this.putBytes(n3);
  }, e2.ByteStringBuffer.prototype.putSignedInt = function(t8, e3) {
    return t8 < 0 && (t8 += 2 << e3 - 1), this.putInt(t8, e3);
  }, e2.ByteStringBuffer.prototype.putBuffer = function(t8) {
    return this.putBytes(t8.getBytes());
  }, e2.ByteStringBuffer.prototype.getByte = function() {
    return this.data.charCodeAt(this.read++);
  }, e2.ByteStringBuffer.prototype.getInt16 = function() {
    var t8 = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
    return this.read += 2, t8;
  }, e2.ByteStringBuffer.prototype.getInt24 = function() {
    var t8 = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
    return this.read += 3, t8;
  }, e2.ByteStringBuffer.prototype.getInt32 = function() {
    var t8 = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
    return this.read += 4, t8;
  }, e2.ByteStringBuffer.prototype.getInt16Le = function() {
    var t8 = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
    return this.read += 2, t8;
  }, e2.ByteStringBuffer.prototype.getInt24Le = function() {
    var t8 = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
    return this.read += 3, t8;
  }, e2.ByteStringBuffer.prototype.getInt32Le = function() {
    var t8 = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
    return this.read += 4, t8;
  }, e2.ByteStringBuffer.prototype.getInt = function(t8) {
    r2(t8);
    var e3 = 0;
    do {
      e3 = (e3 << 8) + this.data.charCodeAt(this.read++), t8 -= 8;
    } while (t8 > 0);
    return e3;
  }, e2.ByteStringBuffer.prototype.getSignedInt = function(t8) {
    var e3 = this.getInt(t8), r3 = 2 << t8 - 2;
    return e3 >= r3 && (e3 -= r3 << 1), e3;
  }, e2.ByteStringBuffer.prototype.getBytes = function(t8) {
    var e3;
    return t8 ? (t8 = Math.min(this.length(), t8), e3 = this.data.slice(this.read, this.read + t8), this.read += t8) : t8 === 0 ? e3 = "" : (e3 = this.read === 0 ? this.data : this.data.slice(this.read), this.clear()), e3;
  }, e2.ByteStringBuffer.prototype.bytes = function(t8) {
    return t8 === void 0 ? this.data.slice(this.read) : this.data.slice(this.read, this.read + t8);
  }, e2.ByteStringBuffer.prototype.at = function(t8) {
    return this.data.charCodeAt(this.read + t8);
  }, e2.ByteStringBuffer.prototype.setAt = function(t8, e3) {
    return this.data = this.data.substr(0, this.read + t8) + String.fromCharCode(e3) + this.data.substr(this.read + t8 + 1), this;
  }, e2.ByteStringBuffer.prototype.last = function() {
    return this.data.charCodeAt(this.data.length - 1);
  }, e2.ByteStringBuffer.prototype.copy = function() {
    var t8 = e2.createBuffer(this.data);
    return t8.read = this.read, t8;
  }, e2.ByteStringBuffer.prototype.compact = function() {
    return this.read > 0 && (this.data = this.data.slice(this.read), this.read = 0), this;
  }, e2.ByteStringBuffer.prototype.clear = function() {
    return this.data = "", this.read = 0, this;
  }, e2.ByteStringBuffer.prototype.truncate = function(t8) {
    var e3 = Math.max(0, this.length() - t8);
    return this.data = this.data.substr(this.read, e3), this.read = 0, this;
  }, e2.ByteStringBuffer.prototype.toHex = function() {
    for (var t8 = "", e3 = this.read; e3 < this.data.length; ++e3) {
      var r3 = this.data.charCodeAt(e3);
      r3 < 16 && (t8 += "0"), t8 += r3.toString(16);
    }
    return t8;
  }, e2.ByteStringBuffer.prototype.toString = function() {
    return e2.decodeUtf8(this.bytes());
  }, e2.DataBuffer = function(t8, r3) {
    r3 = r3 || {}, this.read = r3.readOffset || 0, this.growSize = r3.growSize || 1024;
    var n3 = e2.isArrayBuffer(t8), i3 = e2.isArrayBufferView(t8);
    if (n3 || i3)
      return this.data = n3 ? new DataView(t8) : new DataView(t8.buffer, t8.byteOffset, t8.byteLength), void (this.write = "writeOffset" in r3 ? r3.writeOffset : this.data.byteLength);
    this.data = new DataView(new ArrayBuffer(0)), this.write = 0, t8 != null && this.putBytes(t8), "writeOffset" in r3 && (this.write = r3.writeOffset);
  }, e2.DataBuffer.prototype.length = function() {
    return this.write - this.read;
  }, e2.DataBuffer.prototype.isEmpty = function() {
    return this.length() <= 0;
  }, e2.DataBuffer.prototype.accommodate = function(t8, e3) {
    if (this.length() >= t8)
      return this;
    e3 = Math.max(e3 || this.growSize, t8);
    var r3 = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength), n3 = new Uint8Array(this.length() + e3);
    return n3.set(r3), this.data = new DataView(n3.buffer), this;
  }, e2.DataBuffer.prototype.putByte = function(t8) {
    return this.accommodate(1), this.data.setUint8(this.write++, t8), this;
  }, e2.DataBuffer.prototype.fillWithByte = function(t8, e3) {
    this.accommodate(e3);
    for (var r3 = 0; r3 < e3; ++r3)
      this.data.setUint8(t8);
    return this;
  }, e2.DataBuffer.prototype.putBytes = function(t8, r3) {
    if (e2.isArrayBufferView(t8)) {
      var n3 = (i3 = new Uint8Array(t8.buffer, t8.byteOffset, t8.byteLength)).byteLength - i3.byteOffset;
      return this.accommodate(n3), new Uint8Array(this.data.buffer, this.write).set(i3), this.write += n3, this;
    }
    if (e2.isArrayBuffer(t8)) {
      var i3 = new Uint8Array(t8);
      return this.accommodate(i3.byteLength), new Uint8Array(this.data.buffer).set(i3, this.write), this.write += i3.byteLength, this;
    }
    if (t8 instanceof e2.DataBuffer || typeof t8 == "object" && typeof t8.read == "number" && typeof t8.write == "number" && e2.isArrayBufferView(t8.data)) {
      i3 = new Uint8Array(t8.data.byteLength, t8.read, t8.length());
      return this.accommodate(i3.byteLength), new Uint8Array(t8.data.byteLength, this.write).set(i3), this.write += i3.byteLength, this;
    }
    if (t8 instanceof e2.ByteStringBuffer && (t8 = t8.data, r3 = "binary"), r3 = r3 || "binary", typeof t8 == "string") {
      var a3;
      if (r3 === "hex")
        return this.accommodate(Math.ceil(t8.length / 2)), a3 = new Uint8Array(this.data.buffer, this.write), this.write += e2.binary.hex.decode(t8, a3, this.write), this;
      if (r3 === "base64")
        return this.accommodate(3 * Math.ceil(t8.length / 4)), a3 = new Uint8Array(this.data.buffer, this.write), this.write += e2.binary.base64.decode(t8, a3, this.write), this;
      if (r3 === "utf8" && (t8 = e2.encodeUtf8(t8), r3 = "binary"), r3 === "binary" || r3 === "raw")
        return this.accommodate(t8.length), a3 = new Uint8Array(this.data.buffer, this.write), this.write += e2.binary.raw.decode(a3), this;
      if (r3 === "utf16")
        return this.accommodate(2 * t8.length), a3 = new Uint16Array(this.data.buffer, this.write), this.write += e2.text.utf16.encode(a3), this;
      throw new Error("Invalid encoding: " + r3);
    }
    throw Error("Invalid parameter: " + t8);
  }, e2.DataBuffer.prototype.putBuffer = function(t8) {
    return this.putBytes(t8), t8.clear(), this;
  }, e2.DataBuffer.prototype.putString = function(t8) {
    return this.putBytes(t8, "utf16");
  }, e2.DataBuffer.prototype.putInt16 = function(t8) {
    return this.accommodate(2), this.data.setInt16(this.write, t8), this.write += 2, this;
  }, e2.DataBuffer.prototype.putInt24 = function(t8) {
    return this.accommodate(3), this.data.setInt16(this.write, t8 >> 8 & 65535), this.data.setInt8(this.write, t8 >> 16 & 255), this.write += 3, this;
  }, e2.DataBuffer.prototype.putInt32 = function(t8) {
    return this.accommodate(4), this.data.setInt32(this.write, t8), this.write += 4, this;
  }, e2.DataBuffer.prototype.putInt16Le = function(t8) {
    return this.accommodate(2), this.data.setInt16(this.write, t8, true), this.write += 2, this;
  }, e2.DataBuffer.prototype.putInt24Le = function(t8) {
    return this.accommodate(3), this.data.setInt8(this.write, t8 >> 16 & 255), this.data.setInt16(this.write, t8 >> 8 & 65535, true), this.write += 3, this;
  }, e2.DataBuffer.prototype.putInt32Le = function(t8) {
    return this.accommodate(4), this.data.setInt32(this.write, t8, true), this.write += 4, this;
  }, e2.DataBuffer.prototype.putInt = function(t8, e3) {
    r2(e3), this.accommodate(e3 / 8);
    do {
      e3 -= 8, this.data.setInt8(this.write++, t8 >> e3 & 255);
    } while (e3 > 0);
    return this;
  }, e2.DataBuffer.prototype.putSignedInt = function(t8, e3) {
    return r2(e3), this.accommodate(e3 / 8), t8 < 0 && (t8 += 2 << e3 - 1), this.putInt(t8, e3);
  }, e2.DataBuffer.prototype.getByte = function() {
    return this.data.getInt8(this.read++);
  }, e2.DataBuffer.prototype.getInt16 = function() {
    var t8 = this.data.getInt16(this.read);
    return this.read += 2, t8;
  }, e2.DataBuffer.prototype.getInt24 = function() {
    var t8 = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
    return this.read += 3, t8;
  }, e2.DataBuffer.prototype.getInt32 = function() {
    var t8 = this.data.getInt32(this.read);
    return this.read += 4, t8;
  }, e2.DataBuffer.prototype.getInt16Le = function() {
    var t8 = this.data.getInt16(this.read, true);
    return this.read += 2, t8;
  }, e2.DataBuffer.prototype.getInt24Le = function() {
    var t8 = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
    return this.read += 3, t8;
  }, e2.DataBuffer.prototype.getInt32Le = function() {
    var t8 = this.data.getInt32(this.read, true);
    return this.read += 4, t8;
  }, e2.DataBuffer.prototype.getInt = function(t8) {
    r2(t8);
    var e3 = 0;
    do {
      e3 = (e3 << 8) + this.data.getInt8(this.read++), t8 -= 8;
    } while (t8 > 0);
    return e3;
  }, e2.DataBuffer.prototype.getSignedInt = function(t8) {
    var e3 = this.getInt(t8), r3 = 2 << t8 - 2;
    return e3 >= r3 && (e3 -= r3 << 1), e3;
  }, e2.DataBuffer.prototype.getBytes = function(t8) {
    var e3;
    return t8 ? (t8 = Math.min(this.length(), t8), e3 = this.data.slice(this.read, this.read + t8), this.read += t8) : t8 === 0 ? e3 = "" : (e3 = this.read === 0 ? this.data : this.data.slice(this.read), this.clear()), e3;
  }, e2.DataBuffer.prototype.bytes = function(t8) {
    return t8 === void 0 ? this.data.slice(this.read) : this.data.slice(this.read, this.read + t8);
  }, e2.DataBuffer.prototype.at = function(t8) {
    return this.data.getUint8(this.read + t8);
  }, e2.DataBuffer.prototype.setAt = function(t8, e3) {
    return this.data.setUint8(t8, e3), this;
  }, e2.DataBuffer.prototype.last = function() {
    return this.data.getUint8(this.write - 1);
  }, e2.DataBuffer.prototype.copy = function() {
    return new e2.DataBuffer(this);
  }, e2.DataBuffer.prototype.compact = function() {
    if (this.read > 0) {
      var t8 = new Uint8Array(this.data.buffer, this.read), e3 = new Uint8Array(t8.byteLength);
      e3.set(t8), this.data = new DataView(e3), this.write -= this.read, this.read = 0;
    }
    return this;
  }, e2.DataBuffer.prototype.clear = function() {
    return this.data = new DataView(new ArrayBuffer(0)), this.read = this.write = 0, this;
  }, e2.DataBuffer.prototype.truncate = function(t8) {
    return this.write = Math.max(0, this.length() - t8), this.read = Math.min(this.read, this.write), this;
  }, e2.DataBuffer.prototype.toHex = function() {
    for (var t8 = "", e3 = this.read; e3 < this.data.byteLength; ++e3) {
      var r3 = this.data.getUint8(e3);
      r3 < 16 && (t8 += "0"), t8 += r3.toString(16);
    }
    return t8;
  }, e2.DataBuffer.prototype.toString = function(t8) {
    var r3 = new Uint8Array(this.data, this.read, this.length());
    if ((t8 = t8 || "utf8") === "binary" || t8 === "raw")
      return e2.binary.raw.encode(r3);
    if (t8 === "hex")
      return e2.binary.hex.encode(r3);
    if (t8 === "base64")
      return e2.binary.base64.encode(r3);
    if (t8 === "utf8")
      return e2.text.utf8.decode(r3);
    if (t8 === "utf16")
      return e2.text.utf16.decode(r3);
    throw new Error("Invalid encoding: " + t8);
  }, e2.createBuffer = function(t8, r3) {
    return r3 = r3 || "raw", t8 !== void 0 && r3 === "utf8" && (t8 = e2.encodeUtf8(t8)), new e2.ByteBuffer(t8);
  }, e2.fillString = function(t8, e3) {
    for (var r3 = ""; e3 > 0; )
      1 & e3 && (r3 += t8), (e3 >>>= 1) > 0 && (t8 += t8);
    return r3;
  }, e2.xorBytes = function(t8, e3, r3) {
    for (var n3 = "", i3 = "", a3 = "", o3 = 0, s3 = 0; r3 > 0; --r3, ++o3)
      i3 = t8.charCodeAt(o3) ^ e3.charCodeAt(o3), s3 >= 10 && (n3 += a3, a3 = "", s3 = 0), a3 += String.fromCharCode(i3), ++s3;
    return n3 += a3;
  }, e2.hexToBytes = function(t8) {
    var e3 = "", r3 = 0;
    for (true & t8.length && (r3 = 1, e3 += String.fromCharCode(parseInt(t8[0], 16))); r3 < t8.length; r3 += 2)
      e3 += String.fromCharCode(parseInt(t8.substr(r3, 2), 16));
    return e3;
  }, e2.bytesToHex = function(t8) {
    return e2.createBuffer(t8).toHex();
  }, e2.int32ToBytes = function(t8) {
    return String.fromCharCode(t8 >> 24 & 255) + String.fromCharCode(t8 >> 16 & 255) + String.fromCharCode(t8 >> 8 & 255) + String.fromCharCode(255 & t8);
  };
  var i2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", a2 = [62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, 64, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], o2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  e2.encode64 = function(t8, e3) {
    for (var r3, n3, a3, o3 = "", s3 = "", u3 = 0; u3 < t8.length; )
      r3 = t8.charCodeAt(u3++), n3 = t8.charCodeAt(u3++), a3 = t8.charCodeAt(u3++), o3 += i2.charAt(r3 >> 2), o3 += i2.charAt((3 & r3) << 4 | n3 >> 4), isNaN(n3) ? o3 += "==" : (o3 += i2.charAt((15 & n3) << 2 | a3 >> 6), o3 += isNaN(a3) ? "=" : i2.charAt(63 & a3)), e3 && o3.length > e3 && (s3 += o3.substr(0, e3) + "\r\n", o3 = o3.substr(e3));
    return s3 += o3;
  }, e2.decode64 = function(t8) {
    t8 = t8.replace(/[^A-Za-z0-9\+\/\=]/g, "");
    for (var e3, r3, n3, i3, o3 = "", s3 = 0; s3 < t8.length; )
      e3 = a2[t8.charCodeAt(s3++) - 43], r3 = a2[t8.charCodeAt(s3++) - 43], n3 = a2[t8.charCodeAt(s3++) - 43], i3 = a2[t8.charCodeAt(s3++) - 43], o3 += String.fromCharCode(e3 << 2 | r3 >> 4), n3 !== 64 && (o3 += String.fromCharCode((15 & r3) << 4 | n3 >> 2), i3 !== 64 && (o3 += String.fromCharCode((3 & n3) << 6 | i3)));
    return o3;
  }, e2.encodeUtf8 = function(t8) {
    return unescape(encodeURIComponent(t8));
  }, e2.decodeUtf8 = function(t8) {
    return decodeURIComponent(escape(t8));
  }, e2.binary = { raw: {}, hex: {}, base64: {}, base58: {}, baseN: { encode: Vu.encode, decode: Vu.decode } }, e2.binary.raw.encode = function(t8) {
    return String.fromCharCode.apply(null, t8);
  }, e2.binary.raw.decode = function(t8, e3, r3) {
    var n3 = e3;
    n3 || (n3 = new Uint8Array(t8.length));
    for (var i3 = r3 = r3 || 0, a3 = 0; a3 < t8.length; ++a3)
      n3[i3++] = t8.charCodeAt(a3);
    return e3 ? i3 - r3 : n3;
  }, e2.binary.hex.encode = e2.bytesToHex, e2.binary.hex.decode = function(t8, e3, r3) {
    var n3 = e3;
    n3 || (n3 = new Uint8Array(Math.ceil(t8.length / 2)));
    var i3 = 0, a3 = r3 = r3 || 0;
    for (1 & t8.length && (i3 = 1, n3[a3++] = parseInt(t8[0], 16)); i3 < t8.length; i3 += 2)
      n3[a3++] = parseInt(t8.substr(i3, 2), 16);
    return e3 ? a3 - r3 : n3;
  }, e2.binary.base64.encode = function(t8, e3) {
    for (var r3, n3, a3, o3 = "", s3 = "", u3 = 0; u3 < t8.byteLength; )
      r3 = t8[u3++], n3 = t8[u3++], a3 = t8[u3++], o3 += i2.charAt(r3 >> 2), o3 += i2.charAt((3 & r3) << 4 | n3 >> 4), isNaN(n3) ? o3 += "==" : (o3 += i2.charAt((15 & n3) << 2 | a3 >> 6), o3 += isNaN(a3) ? "=" : i2.charAt(63 & a3)), e3 && o3.length > e3 && (s3 += o3.substr(0, e3) + "\r\n", o3 = o3.substr(e3));
    return s3 += o3;
  }, e2.binary.base64.decode = function(t8, e3, r3) {
    var n3, i3, o3, s3, u3 = e3;
    u3 || (u3 = new Uint8Array(3 * Math.ceil(t8.length / 4))), t8 = t8.replace(/[^A-Za-z0-9\+\/\=]/g, "");
    for (var c3 = 0, f3 = r3 = r3 || 0; c3 < t8.length; )
      n3 = a2[t8.charCodeAt(c3++) - 43], i3 = a2[t8.charCodeAt(c3++) - 43], o3 = a2[t8.charCodeAt(c3++) - 43], s3 = a2[t8.charCodeAt(c3++) - 43], u3[f3++] = n3 << 2 | i3 >> 4, o3 !== 64 && (u3[f3++] = (15 & i3) << 4 | o3 >> 2, s3 !== 64 && (u3[f3++] = (3 & o3) << 6 | s3));
    return e3 ? f3 - r3 : u3.subarray(0, f3);
  }, e2.binary.base58.encode = function(t8, r3) {
    return e2.binary.baseN.encode(t8, o2, r3);
  }, e2.binary.base58.decode = function(t8, r3) {
    return e2.binary.baseN.decode(t8, o2, r3);
  }, e2.text = { utf8: {}, utf16: {} }, e2.text.utf8.encode = function(t8, r3, n3) {
    t8 = e2.encodeUtf8(t8);
    var i3 = r3;
    i3 || (i3 = new Uint8Array(t8.length));
    for (var a3 = n3 = n3 || 0, o3 = 0; o3 < t8.length; ++o3)
      i3[a3++] = t8.charCodeAt(o3);
    return r3 ? a3 - n3 : i3;
  }, e2.text.utf8.decode = function(t8) {
    return e2.decodeUtf8(String.fromCharCode.apply(null, t8));
  }, e2.text.utf16.encode = function(t8, e3, r3) {
    var n3 = e3;
    n3 || (n3 = new Uint8Array(2 * t8.length));
    for (var i3 = new Uint16Array(n3.buffer), a3 = r3 = r3 || 0, o3 = r3, s3 = 0; s3 < t8.length; ++s3)
      i3[o3++] = t8.charCodeAt(s3), a3 += 2;
    return e3 ? a3 - r3 : n3;
  }, e2.text.utf16.decode = function(t8) {
    return String.fromCharCode.apply(null, new Uint16Array(t8.buffer));
  }, e2.deflate = function(t8, r3, n3) {
    if (r3 = e2.decode64(t8.deflate(e2.encode64(r3)).rval), n3) {
      var i3 = 2;
      32 & r3.charCodeAt(1) && (i3 = 6), r3 = r3.substring(i3, r3.length - 4);
    }
    return r3;
  }, e2.inflate = function(t8, r3, n3) {
    var i3 = t8.inflate(e2.encode64(r3)).rval;
    return i3 === null ? null : e2.decode64(i3);
  };
  var s2 = function(t8, r3, n3) {
    if (!t8)
      throw new Error("WebStorage not available.");
    var i3;
    if (n3 === null ? i3 = t8.removeItem(r3) : (n3 = e2.encode64(JSON.stringify(n3)), i3 = t8.setItem(r3, n3)), i3 !== void 0 && i3.rval !== true) {
      var a3 = new Error(i3.error.message);
      throw a3.id = i3.error.id, a3.name = i3.error.name, a3;
    }
  }, u2 = function(t8, r3) {
    if (!t8)
      throw new Error("WebStorage not available.");
    var n3 = t8.getItem(r3);
    if (t8.init)
      if (n3.rval === null) {
        if (n3.error) {
          var i3 = new Error(n3.error.message);
          throw i3.id = n3.error.id, i3.name = n3.error.name, i3;
        }
        n3 = null;
      } else
        n3 = n3.rval;
    return n3 !== null && (n3 = JSON.parse(e2.decode64(n3))), n3;
  }, c2 = function(t8, e3, r3, n3) {
    var i3 = u2(t8, e3);
    i3 === null && (i3 = {}), i3[r3] = n3, s2(t8, e3, i3);
  }, f2 = function(t8, e3, r3) {
    var n3 = u2(t8, e3);
    return n3 !== null && (n3 = r3 in n3 ? n3[r3] : null), n3;
  }, l2 = function(t8, e3, r3) {
    var n3 = u2(t8, e3);
    if (n3 !== null && r3 in n3) {
      delete n3[r3];
      var i3 = true;
      for (var a3 in n3) {
        i3 = false;
        break;
      }
      i3 && (n3 = null), s2(t8, e3, n3);
    }
  }, h2 = function(t8, e3) {
    s2(t8, e3, null);
  }, p2 = function(t8, e3, r3) {
    var n3, i3 = null;
    r3 === void 0 && (r3 = ["web", "flash"]);
    var a3 = false, o3 = null;
    for (var s3 in r3) {
      n3 = r3[s3];
      try {
        if (n3 === "flash" || n3 === "both") {
          if (e3[0] === null)
            throw new Error("Flash local storage not available.");
          i3 = t8.apply(this, e3), a3 = n3 === "flash";
        }
        n3 !== "web" && n3 !== "both" || (e3[0] = localStorage, i3 = t8.apply(this, e3), a3 = true);
      } catch (t9) {
        o3 = t9;
      }
      if (a3)
        break;
    }
    if (!a3)
      throw o3;
    return i3;
  };
  e2.setItem = function(t8, e3, r3, n3, i3) {
    p2(c2, arguments, i3);
  }, e2.getItem = function(t8, e3, r3, n3) {
    return p2(f2, arguments, n3);
  }, e2.removeItem = function(t8, e3, r3, n3) {
    p2(l2, arguments, n3);
  }, e2.clearItems = function(t8, e3, r3) {
    p2(h2, arguments, r3);
  }, e2.parseUrl = function(t8) {
    var e3 = /^(https?):\/\/([^:&^\/]*):?(\d*)(.*)$/g;
    e3.lastIndex = 0;
    var r3 = e3.exec(t8), n3 = r3 === null ? null : { full: t8, scheme: r3[1], host: r3[2], port: r3[3], path: r3[4] };
    return n3 && (n3.fullHost = n3.host, n3.port ? (n3.port !== 80 && n3.scheme === "http" || n3.port !== 443 && n3.scheme === "https") && (n3.fullHost += ":" + n3.port) : n3.scheme === "http" ? n3.port = 80 : n3.scheme === "https" && (n3.port = 443), n3.full = n3.scheme + "://" + n3.fullHost), n3;
  };
  var d2 = null;
  e2.getQueryVariables = function(t8) {
    var e3, r3 = function(t9) {
      for (var e4 = {}, r4 = t9.split("&"), n3 = 0; n3 < r4.length; n3++) {
        var i3, a3, o3 = r4[n3].indexOf("=");
        o3 > 0 ? (i3 = r4[n3].substring(0, o3), a3 = r4[n3].substring(o3 + 1)) : (i3 = r4[n3], a3 = null), i3 in e4 || (e4[i3] = []), i3 in Object.prototype || a3 === null || e4[i3].push(unescape(a3));
      }
      return e4;
    };
    return t8 === void 0 ? (d2 === null && (d2 = typeof window != "undefined" && window.location && window.location.search ? r3(window.location.search.substring(1)) : {}), e3 = d2) : e3 = r3(t8), e3;
  }, e2.parseFragment = function(t8) {
    var r3 = t8, n3 = "", i3 = t8.indexOf("?");
    i3 > 0 && (r3 = t8.substring(0, i3), n3 = t8.substring(i3 + 1));
    var a3 = r3.split("/");
    return a3.length > 0 && a3[0] === "" && a3.shift(), { pathString: r3, queryString: n3, path: a3, query: n3 === "" ? {} : e2.getQueryVariables(n3) };
  }, e2.makeRequest = function(t8) {
    var r3 = e2.parseFragment(t8), n3 = { path: r3.pathString, query: r3.queryString, getPath: function(t9) {
      return t9 === void 0 ? r3.path : r3.path[t9];
    }, getQuery: function(t9, e3) {
      var n4;
      return t9 === void 0 ? n4 = r3.query : (n4 = r3.query[t9]) && e3 !== void 0 && (n4 = n4[e3]), n4;
    }, getQueryLast: function(t9, e3) {
      var r4 = n3.getQuery(t9);
      return r4 ? r4[r4.length - 1] : e3;
    } };
    return n3;
  }, e2.makeLink = function(t8, e3, r3) {
    t8 = jQuery.isArray(t8) ? t8.join("/") : t8;
    var n3 = jQuery.param(e3 || {});
    return r3 = r3 || "", t8 + (n3.length > 0 ? "?" + n3 : "") + (r3.length > 0 ? "#" + r3 : "");
  }, e2.isEmpty = function(t8) {
    for (var e3 in t8)
      if (t8.hasOwnProperty(e3))
        return false;
    return true;
  }, e2.format = function(t8) {
    for (var e3, r3, n3 = /%./g, i3 = 0, a3 = [], o3 = 0; e3 = n3.exec(t8); ) {
      (r3 = t8.substring(o3, n3.lastIndex - 2)).length > 0 && a3.push(r3), o3 = n3.lastIndex;
      var s3 = e3[0][1];
      switch (s3) {
        case "s":
        case "o":
          i3 < arguments.length ? a3.push(arguments[1 + i3++]) : a3.push("<?>");
          break;
        case "%":
          a3.push("%");
          break;
        default:
          a3.push("<%" + s3 + "?>");
      }
    }
    return a3.push(t8.substring(o3)), a3.join("");
  }, e2.formatNumber = function(t8, e3, r3, n3) {
    var i3 = t8, a3 = isNaN(e3 = Math.abs(e3)) ? 2 : e3, o3 = r3 === void 0 ? "," : r3, s3 = n3 === void 0 ? "." : n3, u3 = i3 < 0 ? "-" : "", c3 = parseInt(i3 = Math.abs(+i3 || 0).toFixed(a3), 10) + "", f3 = c3.length > 3 ? c3.length % 3 : 0;
    return u3 + (f3 ? c3.substr(0, f3) + s3 : "") + c3.substr(f3).replace(/(\d{3})(?=\d)/g, "$1" + s3) + (a3 ? o3 + Math.abs(i3 - c3).toFixed(a3).slice(2) : "");
  }, e2.formatSize = function(t8) {
    return t8 = t8 >= 1073741824 ? e2.formatNumber(t8 / 1073741824, 2, ".", "") + " GiB" : t8 >= 1048576 ? e2.formatNumber(t8 / 1048576, 2, ".", "") + " MiB" : t8 >= 1024 ? e2.formatNumber(t8 / 1024, 0) + " KiB" : e2.formatNumber(t8, 0) + " bytes";
  }, e2.bytesFromIP = function(t8) {
    return t8.indexOf(".") !== -1 ? e2.bytesFromIPv4(t8) : t8.indexOf(":") !== -1 ? e2.bytesFromIPv6(t8) : null;
  }, e2.bytesFromIPv4 = function(t8) {
    if ((t8 = t8.split(".")).length !== 4)
      return null;
    for (var r3 = e2.createBuffer(), n3 = 0; n3 < t8.length; ++n3) {
      var i3 = parseInt(t8[n3], 10);
      if (isNaN(i3))
        return null;
      r3.putByte(i3);
    }
    return r3.getBytes();
  }, e2.bytesFromIPv6 = function(t8) {
    for (var r3 = 0, n3 = 2 * (8 - (t8 = t8.split(":").filter(function(t9) {
      return t9.length === 0 && ++r3, true;
    })).length + r3), i3 = e2.createBuffer(), a3 = 0; a3 < 8; ++a3)
      if (t8[a3] && t8[a3].length !== 0) {
        var o3 = e2.hexToBytes(t8[a3]);
        o3.length < 2 && i3.putByte(0), i3.putBytes(o3);
      } else
        i3.fillWithByte(0, n3), n3 = 0;
    return i3.getBytes();
  }, e2.bytesToIP = function(t8) {
    return t8.length === 4 ? e2.bytesToIPv4(t8) : t8.length === 16 ? e2.bytesToIPv6(t8) : null;
  }, e2.bytesToIPv4 = function(t8) {
    if (t8.length !== 4)
      return null;
    for (var e3 = [], r3 = 0; r3 < t8.length; ++r3)
      e3.push(t8.charCodeAt(r3));
    return e3.join(".");
  }, e2.bytesToIPv6 = function(t8) {
    if (t8.length !== 16)
      return null;
    for (var r3 = [], n3 = [], i3 = 0, a3 = 0; a3 < t8.length; a3 += 2) {
      for (var o3 = e2.bytesToHex(t8[a3] + t8[a3 + 1]); o3[0] === "0" && o3 !== "0"; )
        o3 = o3.substr(1);
      if (o3 === "0") {
        var s3 = n3[n3.length - 1], u3 = r3.length;
        s3 && u3 === s3.end + 1 ? (s3.end = u3, s3.end - s3.start > n3[i3].end - n3[i3].start && (i3 = n3.length - 1)) : n3.push({ start: u3, end: u3 });
      }
      r3.push(o3);
    }
    if (n3.length > 0) {
      var c3 = n3[i3];
      c3.end - c3.start > 0 && (r3.splice(c3.start, c3.end - c3.start + 1, ""), c3.start === 0 && r3.unshift(""), c3.end === 7 && r3.push(""));
    }
    return r3.join(":");
  }, e2.estimateCores = function(t8, r3) {
    if (typeof t8 == "function" && (r3 = t8, t8 = {}), t8 = t8 || {}, "cores" in e2 && !t8.update)
      return r3(null, e2.cores);
    if (typeof navigator != "undefined" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0)
      return e2.cores = navigator.hardwareConcurrency, r3(null, e2.cores);
    if (typeof Worker == "undefined")
      return e2.cores = 1, r3(null, e2.cores);
    if (typeof Blob == "undefined")
      return e2.cores = 2, r3(null, e2.cores);
    var n3 = URL.createObjectURL(new Blob(["(", function() {
      self.addEventListener("message", function(t9) {
        var e3 = Date.now(), r4 = e3 + 4;
        self.postMessage({ st: e3, et: r4 });
      });
    }.toString(), ")()"], { type: "application/javascript" }));
    !function t9(i3, a3, o3) {
      if (a3 === 0) {
        var s3 = Math.floor(i3.reduce(function(t10, e3) {
          return t10 + e3;
        }, 0) / i3.length);
        return e2.cores = Math.max(1, s3), URL.revokeObjectURL(n3), r3(null, e2.cores);
      }
      !function(t10, e3) {
        for (var r4 = [], i4 = [], a4 = 0; a4 < t10; ++a4) {
          var o4 = new Worker(n3);
          o4.addEventListener("message", function(n4) {
            if (i4.push(n4.data), i4.length === t10) {
              for (var a5 = 0; a5 < t10; ++a5)
                r4[a5].terminate();
              e3(null, i4);
            }
          }), r4.push(o4);
        }
        for (a4 = 0; a4 < t10; ++a4)
          r4[a4].postMessage(a4);
      }(o3, function(e3, r4) {
        i3.push(function(t10, e4) {
          for (var r5 = [], n4 = 0; n4 < t10; ++n4)
            for (var i4 = e4[n4], a4 = r5[n4] = [], o4 = 0; o4 < t10; ++o4)
              if (n4 !== o4) {
                var s4 = e4[o4];
                (i4.st > s4.st && i4.st < s4.et || s4.st > i4.st && s4.st < i4.et) && a4.push(o4);
              }
          return r5.reduce(function(t11, e5) {
            return Math.max(t11, e5.length);
          }, 0);
        }(o3, r4)), t9(i3, a3 - 1, o3);
      });
    }([], 5, 16);
  };
}), w(function(t7) {
  xu.pki = xu.pki || {};
  var e2 = t7.exports = xu.pki.oids = xu.oids = xu.oids || {};
  function r2(t8, r3) {
    e2[t8] = r3, e2[r3] = t8;
  }
  function n2(t8, r3) {
    e2[t8] = r3;
  }
  r2("1.2.840.113549.1.1.1", "rsaEncryption"), r2("1.2.840.113549.1.1.4", "md5WithRSAEncryption"), r2("1.2.840.113549.1.1.5", "sha1WithRSAEncryption"), r2("1.2.840.113549.1.1.7", "RSAES-OAEP"), r2("1.2.840.113549.1.1.8", "mgf1"), r2("1.2.840.113549.1.1.9", "pSpecified"), r2("1.2.840.113549.1.1.10", "RSASSA-PSS"), r2("1.2.840.113549.1.1.11", "sha256WithRSAEncryption"), r2("1.2.840.113549.1.1.12", "sha384WithRSAEncryption"), r2("1.2.840.113549.1.1.13", "sha512WithRSAEncryption"), r2("1.3.101.112", "EdDSA25519"), r2("1.2.840.10040.4.3", "dsa-with-sha1"), r2("1.3.14.3.2.7", "desCBC"), r2("1.3.14.3.2.26", "sha1"), r2("2.16.840.1.101.3.4.2.1", "sha256"), r2("2.16.840.1.101.3.4.2.2", "sha384"), r2("2.16.840.1.101.3.4.2.3", "sha512"), r2("1.2.840.113549.2.5", "md5"), r2("1.2.840.113549.1.7.1", "data"), r2("1.2.840.113549.1.7.2", "signedData"), r2("1.2.840.113549.1.7.3", "envelopedData"), r2("1.2.840.113549.1.7.4", "signedAndEnvelopedData"), r2("1.2.840.113549.1.7.5", "digestedData"), r2("1.2.840.113549.1.7.6", "encryptedData"), r2("1.2.840.113549.1.9.1", "emailAddress"), r2("1.2.840.113549.1.9.2", "unstructuredName"), r2("1.2.840.113549.1.9.3", "contentType"), r2("1.2.840.113549.1.9.4", "messageDigest"), r2("1.2.840.113549.1.9.5", "signingTime"), r2("1.2.840.113549.1.9.6", "counterSignature"), r2("1.2.840.113549.1.9.7", "challengePassword"), r2("1.2.840.113549.1.9.8", "unstructuredAddress"), r2("1.2.840.113549.1.9.14", "extensionRequest"), r2("1.2.840.113549.1.9.20", "friendlyName"), r2("1.2.840.113549.1.9.21", "localKeyId"), r2("1.2.840.113549.1.9.22.1", "x509Certificate"), r2("1.2.840.113549.1.12.10.1.1", "keyBag"), r2("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag"), r2("1.2.840.113549.1.12.10.1.3", "certBag"), r2("1.2.840.113549.1.12.10.1.4", "crlBag"), r2("1.2.840.113549.1.12.10.1.5", "secretBag"), r2("1.2.840.113549.1.12.10.1.6", "safeContentsBag"), r2("1.2.840.113549.1.5.13", "pkcs5PBES2"), r2("1.2.840.113549.1.5.12", "pkcs5PBKDF2"), r2("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4"), r2("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4"), r2("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC"), r2("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC"), r2("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC"), r2("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC"), r2("1.2.840.113549.2.7", "hmacWithSHA1"), r2("1.2.840.113549.2.8", "hmacWithSHA224"), r2("1.2.840.113549.2.9", "hmacWithSHA256"), r2("1.2.840.113549.2.10", "hmacWithSHA384"), r2("1.2.840.113549.2.11", "hmacWithSHA512"), r2("1.2.840.113549.3.7", "des-EDE3-CBC"), r2("2.16.840.1.101.3.4.1.2", "aes128-CBC"), r2("2.16.840.1.101.3.4.1.22", "aes192-CBC"), r2("2.16.840.1.101.3.4.1.42", "aes256-CBC"), r2("2.5.4.3", "commonName"), r2("2.5.4.5", "serialName"), r2("2.5.4.6", "countryName"), r2("2.5.4.7", "localityName"), r2("2.5.4.8", "stateOrProvinceName"), r2("2.5.4.9", "streetAddress"), r2("2.5.4.10", "organizationName"), r2("2.5.4.11", "organizationalUnitName"), r2("2.5.4.13", "description"), r2("2.5.4.15", "businessCategory"), r2("2.5.4.17", "postalCode"), r2("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName"), r2("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName"), r2("2.16.840.1.113730.1.1", "nsCertType"), r2("2.16.840.1.113730.1.13", "nsComment"), n2("2.5.29.1", "authorityKeyIdentifier"), n2("2.5.29.2", "keyAttributes"), n2("2.5.29.3", "certificatePolicies"), n2("2.5.29.4", "keyUsageRestriction"), n2("2.5.29.5", "policyMapping"), n2("2.5.29.6", "subtreesConstraint"), n2("2.5.29.7", "subjectAltName"), n2("2.5.29.8", "issuerAltName"), n2("2.5.29.9", "subjectDirectoryAttributes"), n2("2.5.29.10", "basicConstraints"), n2("2.5.29.11", "nameConstraints"), n2("2.5.29.12", "policyConstraints"), n2("2.5.29.13", "basicConstraints"), r2("2.5.29.14", "subjectKeyIdentifier"), r2("2.5.29.15", "keyUsage"), n2("2.5.29.16", "privateKeyUsagePeriod"), r2("2.5.29.17", "subjectAltName"), r2("2.5.29.18", "issuerAltName"), r2("2.5.29.19", "basicConstraints"), n2("2.5.29.20", "cRLNumber"), n2("2.5.29.21", "cRLReason"), n2("2.5.29.22", "expirationDate"), n2("2.5.29.23", "instructionCode"), n2("2.5.29.24", "invalidityDate"), n2("2.5.29.25", "cRLDistributionPoints"), n2("2.5.29.26", "issuingDistributionPoint"), n2("2.5.29.27", "deltaCRLIndicator"), n2("2.5.29.28", "issuingDistributionPoint"), n2("2.5.29.29", "certificateIssuer"), n2("2.5.29.30", "nameConstraints"), r2("2.5.29.31", "cRLDistributionPoints"), r2("2.5.29.32", "certificatePolicies"), n2("2.5.29.33", "policyMappings"), n2("2.5.29.34", "policyConstraints"), r2("2.5.29.35", "authorityKeyIdentifier"), n2("2.5.29.36", "policyConstraints"), r2("2.5.29.37", "extKeyUsage"), n2("2.5.29.46", "freshestCRL"), n2("2.5.29.54", "inhibitAnyPolicy"), r2("1.3.6.1.4.1.11129.2.4.2", "timestampList"), r2("1.3.6.1.5.5.7.1.1", "authorityInfoAccess"), r2("1.3.6.1.5.5.7.3.1", "serverAuth"), r2("1.3.6.1.5.5.7.3.2", "clientAuth"), r2("1.3.6.1.5.5.7.3.3", "codeSigning"), r2("1.3.6.1.5.5.7.3.4", "emailProtection"), r2("1.3.6.1.5.5.7.3.8", "timeStamping");
});
var ju = w(function(t7) {
  var e2 = t7.exports = xu.asn1 = xu.asn1 || {};
  function r2(t8, e3, r3) {
    if (r3 > e3) {
      var n3 = new Error("Too few bytes to parse DER.");
      throw n3.available = t8.length(), n3.remaining = e3, n3.requested = r3, n3;
    }
  }
  e2.Class = { UNIVERSAL: 0, APPLICATION: 64, CONTEXT_SPECIFIC: 128, PRIVATE: 192 }, e2.Type = { NONE: 0, BOOLEAN: 1, INTEGER: 2, BITSTRING: 3, OCTETSTRING: 4, NULL: 5, OID: 6, ODESC: 7, EXTERNAL: 8, REAL: 9, ENUMERATED: 10, EMBEDDED: 11, UTF8: 12, ROID: 13, SEQUENCE: 16, SET: 17, PRINTABLESTRING: 19, IA5STRING: 22, UTCTIME: 23, GENERALIZEDTIME: 24, BMPSTRING: 30 }, e2.create = function(t8, r3, n3, i3, a2) {
    if (xu.util.isArray(i3)) {
      for (var o2 = [], s2 = 0; s2 < i3.length; ++s2)
        i3[s2] !== void 0 && o2.push(i3[s2]);
      i3 = o2;
    }
    var u2 = { tagClass: t8, type: r3, constructed: n3, composed: n3 || xu.util.isArray(i3), value: i3 };
    return a2 && "bitStringContents" in a2 && (u2.bitStringContents = a2.bitStringContents, u2.original = e2.copy(u2)), u2;
  }, e2.copy = function(t8, r3) {
    var n3;
    if (xu.util.isArray(t8)) {
      n3 = [];
      for (var i3 = 0; i3 < t8.length; ++i3)
        n3.push(e2.copy(t8[i3], r3));
      return n3;
    }
    return typeof t8 == "string" ? t8 : (n3 = { tagClass: t8.tagClass, type: t8.type, constructed: t8.constructed, composed: t8.composed, value: e2.copy(t8.value, r3) }, r3 && !r3.excludeBitStringContents && (n3.bitStringContents = t8.bitStringContents), n3);
  }, e2.equals = function(t8, r3, n3) {
    if (xu.util.isArray(t8)) {
      if (!xu.util.isArray(r3))
        return false;
      if (t8.length !== r3.length)
        return false;
      for (var i3 = 0; i3 < t8.length; ++i3)
        if (!e2.equals(t8[i3], r3[i3]))
          return false;
      return true;
    }
    if (typeof t8 != typeof r3)
      return false;
    if (typeof t8 == "string")
      return t8 === r3;
    var a2 = t8.tagClass === r3.tagClass && t8.type === r3.type && t8.constructed === r3.constructed && t8.composed === r3.composed && e2.equals(t8.value, r3.value);
    return n3 && n3.includeBitStringContents && (a2 = a2 && t8.bitStringContents === r3.bitStringContents), a2;
  }, e2.getBerValueLength = function(t8) {
    var e3 = t8.getByte();
    if (e3 !== 128)
      return 128 & e3 ? t8.getInt((127 & e3) << 3) : e3;
  };
  function n2(t8, i3, a2, o2) {
    var s2;
    r2(t8, i3, 2);
    var u2 = t8.getByte();
    i3--;
    var c2 = 192 & u2, f2 = 31 & u2;
    s2 = t8.length();
    var l2, h2, p2 = function(t9, e3) {
      var n3 = t9.getByte();
      if (e3--, n3 !== 128) {
        var i4;
        if (128 & n3) {
          var a3 = 127 & n3;
          r2(t9, e3, a3), i4 = t9.getInt(a3 << 3);
        } else
          i4 = n3;
        if (i4 < 0)
          throw new Error("Negative length: " + i4);
        return i4;
      }
    }(t8, i3);
    if (i3 -= s2 - t8.length(), p2 !== void 0 && p2 > i3) {
      if (o2.strict) {
        var d2 = new Error("Too few bytes to read ASN.1 value.");
        throw d2.available = t8.length(), d2.remaining = i3, d2.requested = p2, d2;
      }
      p2 = i3;
    }
    var y2 = (32 & u2) == 32;
    if (y2)
      if (l2 = [], p2 === void 0)
        for (; ; ) {
          if (r2(t8, i3, 2), t8.bytes(2) === String.fromCharCode(0, 0)) {
            t8.getBytes(2), i3 -= 2;
            break;
          }
          s2 = t8.length(), l2.push(n2(t8, i3, a2 + 1, o2)), i3 -= s2 - t8.length();
        }
      else
        for (; p2 > 0; )
          s2 = t8.length(), l2.push(n2(t8, p2, a2 + 1, o2)), i3 -= s2 - t8.length(), p2 -= s2 - t8.length();
    if (l2 === void 0 && c2 === e2.Class.UNIVERSAL && f2 === e2.Type.BITSTRING && (h2 = t8.bytes(p2)), l2 === void 0 && o2.decodeBitStrings && c2 === e2.Class.UNIVERSAL && f2 === e2.Type.BITSTRING && p2 > 1) {
      var g2 = t8.read, v2 = i3, m2 = 0;
      if (f2 === e2.Type.BITSTRING && (r2(t8, i3, 1), m2 = t8.getByte(), i3--), m2 === 0)
        try {
          s2 = t8.length();
          var C2 = n2(t8, i3, a2 + 1, { verbose: o2.verbose, strict: true, decodeBitStrings: true }), E2 = s2 - t8.length();
          i3 -= E2, f2 == e2.Type.BITSTRING && E2++;
          var S2 = C2.tagClass;
          E2 !== p2 || S2 !== e2.Class.UNIVERSAL && S2 !== e2.Class.CONTEXT_SPECIFIC || (l2 = [C2]);
        } catch (t9) {
        }
      l2 === void 0 && (t8.read = g2, i3 = v2);
    }
    if (l2 === void 0) {
      if (p2 === void 0) {
        if (o2.strict)
          throw new Error("Non-constructed ASN.1 object of indefinite length.");
        p2 = i3;
      }
      if (f2 === e2.Type.BMPSTRING)
        for (l2 = ""; p2 > 0; p2 -= 2)
          r2(t8, i3, 2), l2 += String.fromCharCode(t8.getInt16()), i3 -= 2;
      else
        l2 = t8.getBytes(p2);
    }
    var b2 = h2 === void 0 ? null : { bitStringContents: h2 };
    return e2.create(c2, f2, y2, l2, b2);
  }
  e2.fromDer = function(t8, e3) {
    return e3 === void 0 && (e3 = { strict: true, decodeBitStrings: true }), typeof e3 == "boolean" && (e3 = { strict: e3, decodeBitStrings: true }), "strict" in e3 || (e3.strict = true), "decodeBitStrings" in e3 || (e3.decodeBitStrings = true), typeof t8 == "string" && (t8 = xu.util.createBuffer(t8)), n2(t8, t8.length(), 0, e3);
  }, e2.toDer = function(t8) {
    var r3 = xu.util.createBuffer(), n3 = t8.tagClass | t8.type, i3 = xu.util.createBuffer(), a2 = false;
    if ("bitStringContents" in t8 && (a2 = true, t8.original && (a2 = e2.equals(t8, t8.original))), a2)
      i3.putBytes(t8.bitStringContents);
    else if (t8.composed) {
      t8.constructed ? n3 |= 32 : i3.putByte(0);
      for (var o2 = 0; o2 < t8.value.length; ++o2)
        t8.value[o2] !== void 0 && i3.putBuffer(e2.toDer(t8.value[o2]));
    } else if (t8.type === e2.Type.BMPSTRING)
      for (o2 = 0; o2 < t8.value.length; ++o2)
        i3.putInt16(t8.value.charCodeAt(o2));
    else
      t8.type === e2.Type.INTEGER && t8.value.length > 1 && (t8.value.charCodeAt(0) === 0 && (128 & t8.value.charCodeAt(1)) == 0 || t8.value.charCodeAt(0) === 255 && (128 & t8.value.charCodeAt(1)) == 128) ? i3.putBytes(t8.value.substr(1)) : i3.putBytes(t8.value);
    if (r3.putByte(n3), i3.length() <= 127)
      r3.putByte(127 & i3.length());
    else {
      var s2 = i3.length(), u2 = "";
      do {
        u2 += String.fromCharCode(255 & s2), s2 >>>= 8;
      } while (s2 > 0);
      r3.putByte(128 | u2.length);
      for (o2 = u2.length - 1; o2 >= 0; --o2)
        r3.putByte(u2.charCodeAt(o2));
    }
    return r3.putBuffer(i3), r3;
  }, e2.oidToDer = function(t8) {
    var e3, r3, n3, i3, a2 = t8.split("."), o2 = xu.util.createBuffer();
    o2.putByte(40 * parseInt(a2[0], 10) + parseInt(a2[1], 10));
    for (var s2 = 2; s2 < a2.length; ++s2) {
      e3 = true, r3 = [], n3 = parseInt(a2[s2], 10);
      do {
        i3 = 127 & n3, n3 >>>= 7, e3 || (i3 |= 128), r3.push(i3), e3 = false;
      } while (n3 > 0);
      for (var u2 = r3.length - 1; u2 >= 0; --u2)
        o2.putByte(r3[u2]);
    }
    return o2;
  }, e2.derToOid = function(t8) {
    var e3;
    typeof t8 == "string" && (t8 = xu.util.createBuffer(t8));
    var r3 = t8.getByte();
    e3 = Math.floor(r3 / 40) + "." + r3 % 40;
    for (var n3 = 0; t8.length() > 0; )
      n3 <<= 7, 128 & (r3 = t8.getByte()) ? n3 += 127 & r3 : (e3 += "." + (n3 + r3), n3 = 0);
    return e3;
  }, e2.utcTimeToDate = function(t8) {
    var e3 = new Date(), r3 = parseInt(t8.substr(0, 2), 10);
    r3 = r3 >= 50 ? 1900 + r3 : 2e3 + r3;
    var n3 = parseInt(t8.substr(2, 2), 10) - 1, i3 = parseInt(t8.substr(4, 2), 10), a2 = parseInt(t8.substr(6, 2), 10), o2 = parseInt(t8.substr(8, 2), 10), s2 = 0;
    if (t8.length > 11) {
      var u2 = t8.charAt(10), c2 = 10;
      u2 !== "+" && u2 !== "-" && (s2 = parseInt(t8.substr(10, 2), 10), c2 += 2);
    }
    if (e3.setUTCFullYear(r3, n3, i3), e3.setUTCHours(a2, o2, s2, 0), c2 && ((u2 = t8.charAt(c2)) === "+" || u2 === "-")) {
      var f2 = 60 * parseInt(t8.substr(c2 + 1, 2), 10) + parseInt(t8.substr(c2 + 4, 2), 10);
      f2 *= 6e4, u2 === "+" ? e3.setTime(+e3 - f2) : e3.setTime(+e3 + f2);
    }
    return e3;
  }, e2.generalizedTimeToDate = function(t8) {
    var e3 = new Date(), r3 = parseInt(t8.substr(0, 4), 10), n3 = parseInt(t8.substr(4, 2), 10) - 1, i3 = parseInt(t8.substr(6, 2), 10), a2 = parseInt(t8.substr(8, 2), 10), o2 = parseInt(t8.substr(10, 2), 10), s2 = parseInt(t8.substr(12, 2), 10), u2 = 0, c2 = 0, f2 = false;
    t8.charAt(t8.length - 1) === "Z" && (f2 = true);
    var l2 = t8.length - 5, h2 = t8.charAt(l2);
    h2 !== "+" && h2 !== "-" || (c2 = 60 * parseInt(t8.substr(l2 + 1, 2), 10) + parseInt(t8.substr(l2 + 4, 2), 10), c2 *= 6e4, h2 === "+" && (c2 *= -1), f2 = true);
    return t8.charAt(14) === "." && (u2 = 1e3 * parseFloat(t8.substr(14), 10)), f2 ? (e3.setUTCFullYear(r3, n3, i3), e3.setUTCHours(a2, o2, s2, u2), e3.setTime(+e3 + c2)) : (e3.setFullYear(r3, n3, i3), e3.setHours(a2, o2, s2, u2)), e3;
  }, e2.dateToUtcTime = function(t8) {
    if (typeof t8 == "string")
      return t8;
    var e3 = "", r3 = [];
    r3.push(("" + t8.getUTCFullYear()).substr(2)), r3.push("" + (t8.getUTCMonth() + 1)), r3.push("" + t8.getUTCDate()), r3.push("" + t8.getUTCHours()), r3.push("" + t8.getUTCMinutes()), r3.push("" + t8.getUTCSeconds());
    for (var n3 = 0; n3 < r3.length; ++n3)
      r3[n3].length < 2 && (e3 += "0"), e3 += r3[n3];
    return e3 += "Z";
  }, e2.dateToGeneralizedTime = function(t8) {
    if (typeof t8 == "string")
      return t8;
    var e3 = "", r3 = [];
    r3.push("" + t8.getUTCFullYear()), r3.push("" + (t8.getUTCMonth() + 1)), r3.push("" + t8.getUTCDate()), r3.push("" + t8.getUTCHours()), r3.push("" + t8.getUTCMinutes()), r3.push("" + t8.getUTCSeconds());
    for (var n3 = 0; n3 < r3.length; ++n3)
      r3[n3].length < 2 && (e3 += "0"), e3 += r3[n3];
    return e3 += "Z";
  }, e2.integerToDer = function(t8) {
    var e3 = xu.util.createBuffer();
    if (t8 >= -128 && t8 < 128)
      return e3.putSignedInt(t8, 8);
    if (t8 >= -32768 && t8 < 32768)
      return e3.putSignedInt(t8, 16);
    if (t8 >= -8388608 && t8 < 8388608)
      return e3.putSignedInt(t8, 24);
    if (t8 >= -2147483648 && t8 < 2147483648)
      return e3.putSignedInt(t8, 32);
    var r3 = new Error("Integer too large; max is 32-bits.");
    throw r3.integer = t8, r3;
  }, e2.derToInteger = function(t8) {
    typeof t8 == "string" && (t8 = xu.util.createBuffer(t8));
    var e3 = 8 * t8.length();
    if (e3 > 32)
      throw new Error("Integer too large; max is 32-bits.");
    return t8.getSignedInt(e3);
  }, e2.validate = function(t8, r3, n3, i3) {
    var a2 = false;
    if (t8.tagClass !== r3.tagClass && r3.tagClass !== void 0 || t8.type !== r3.type && r3.type !== void 0)
      i3 && (t8.tagClass !== r3.tagClass && i3.push("[" + r3.name + '] Expected tag class "' + r3.tagClass + '", got "' + t8.tagClass + '"'), t8.type !== r3.type && i3.push("[" + r3.name + '] Expected type "' + r3.type + '", got "' + t8.type + '"'));
    else if (t8.constructed === r3.constructed || r3.constructed === void 0) {
      if (a2 = true, r3.value && xu.util.isArray(r3.value))
        for (var o2 = 0, s2 = 0; a2 && s2 < r3.value.length; ++s2)
          a2 = r3.value[s2].optional || false, t8.value[o2] && ((a2 = e2.validate(t8.value[o2], r3.value[s2], n3, i3)) ? ++o2 : r3.value[s2].optional && (a2 = true)), !a2 && i3 && i3.push("[" + r3.name + '] Tag class "' + r3.tagClass + '", type "' + r3.type + '" expected value length "' + r3.value.length + '", got "' + t8.value.length + '"');
      if (a2 && n3 && (r3.capture && (n3[r3.capture] = t8.value), r3.captureAsn1 && (n3[r3.captureAsn1] = t8), r3.captureBitStringContents && "bitStringContents" in t8 && (n3[r3.captureBitStringContents] = t8.bitStringContents), r3.captureBitStringValue && "bitStringContents" in t8))
        if (t8.bitStringContents.length < 2)
          n3[r3.captureBitStringValue] = "";
        else {
          if (t8.bitStringContents.charCodeAt(0) !== 0)
            throw new Error("captureBitStringValue only supported for zero unused bits");
          n3[r3.captureBitStringValue] = t8.bitStringContents.slice(1);
        }
    } else
      i3 && i3.push("[" + r3.name + '] Expected constructed "' + r3.constructed + '", got "' + t8.constructed + '"');
    return a2;
  };
  var i2 = /[^\\u0000-\\u00ff]/;
  e2.prettyPrint = function(t8, r3, n3) {
    var a2 = "";
    n3 = n3 || 2, (r3 = r3 || 0) > 0 && (a2 += "\n");
    for (var o2 = "", s2 = 0; s2 < r3 * n3; ++s2)
      o2 += " ";
    switch (a2 += o2 + "Tag: ", t8.tagClass) {
      case e2.Class.UNIVERSAL:
        a2 += "Universal:";
        break;
      case e2.Class.APPLICATION:
        a2 += "Application:";
        break;
      case e2.Class.CONTEXT_SPECIFIC:
        a2 += "Context-Specific:";
        break;
      case e2.Class.PRIVATE:
        a2 += "Private:";
    }
    if (t8.tagClass === e2.Class.UNIVERSAL)
      switch (a2 += t8.type, t8.type) {
        case e2.Type.NONE:
          a2 += " (None)";
          break;
        case e2.Type.BOOLEAN:
          a2 += " (Boolean)";
          break;
        case e2.Type.INTEGER:
          a2 += " (Integer)";
          break;
        case e2.Type.BITSTRING:
          a2 += " (Bit string)";
          break;
        case e2.Type.OCTETSTRING:
          a2 += " (Octet string)";
          break;
        case e2.Type.NULL:
          a2 += " (Null)";
          break;
        case e2.Type.OID:
          a2 += " (Object Identifier)";
          break;
        case e2.Type.ODESC:
          a2 += " (Object Descriptor)";
          break;
        case e2.Type.EXTERNAL:
          a2 += " (External or Instance of)";
          break;
        case e2.Type.REAL:
          a2 += " (Real)";
          break;
        case e2.Type.ENUMERATED:
          a2 += " (Enumerated)";
          break;
        case e2.Type.EMBEDDED:
          a2 += " (Embedded PDV)";
          break;
        case e2.Type.UTF8:
          a2 += " (UTF8)";
          break;
        case e2.Type.ROID:
          a2 += " (Relative Object Identifier)";
          break;
        case e2.Type.SEQUENCE:
          a2 += " (Sequence)";
          break;
        case e2.Type.SET:
          a2 += " (Set)";
          break;
        case e2.Type.PRINTABLESTRING:
          a2 += " (Printable String)";
          break;
        case e2.Type.IA5String:
          a2 += " (IA5String (ASCII))";
          break;
        case e2.Type.UTCTIME:
          a2 += " (UTC time)";
          break;
        case e2.Type.GENERALIZEDTIME:
          a2 += " (Generalized time)";
          break;
        case e2.Type.BMPSTRING:
          a2 += " (BMP String)";
      }
    else
      a2 += t8.type;
    if (a2 += "\n", a2 += o2 + "Constructed: " + t8.constructed + "\n", t8.composed) {
      var u2 = 0, c2 = "";
      for (s2 = 0; s2 < t8.value.length; ++s2)
        t8.value[s2] !== void 0 && (u2 += 1, c2 += e2.prettyPrint(t8.value[s2], r3 + 1, n3), s2 + 1 < t8.value.length && (c2 += ","));
      a2 += o2 + "Sub values: " + u2 + c2;
    } else {
      if (a2 += o2 + "Value: ", t8.type === e2.Type.OID) {
        var f2 = e2.derToOid(t8.value);
        a2 += f2, xu.pki && xu.pki.oids && f2 in xu.pki.oids && (a2 += " (" + xu.pki.oids[f2] + ") ");
      }
      if (t8.type === e2.Type.INTEGER)
        try {
          a2 += e2.derToInteger(t8.value);
        } catch (e3) {
          a2 += "0x" + xu.util.bytesToHex(t8.value);
        }
      else if (t8.type === e2.Type.BITSTRING) {
        if (t8.value.length > 1 ? a2 += "0x" + xu.util.bytesToHex(t8.value.slice(1)) : a2 += "(none)", t8.value.length > 0) {
          var l2 = t8.value.charCodeAt(0);
          l2 == 1 ? a2 += " (1 unused bit shown)" : l2 > 1 && (a2 += " (" + l2 + " unused bits shown)");
        }
      } else
        t8.type === e2.Type.OCTETSTRING ? (i2.test(t8.value) || (a2 += "(" + t8.value + ") "), a2 += "0x" + xu.util.bytesToHex(t8.value)) : t8.type === e2.Type.UTF8 ? a2 += xu.util.decodeUtf8(t8.value) : t8.type === e2.Type.PRINTABLESTRING || t8.type === e2.Type.IA5String ? a2 += t8.value : i2.test(t8.value) ? a2 += "0x" + xu.util.bytesToHex(t8.value) : t8.value.length === 0 ? a2 += "[null]" : a2 += t8.value;
    }
    return a2;
  };
});
xu.cipher = xu.cipher || {}, xu.cipher.algorithms = xu.cipher.algorithms || {}, xu.cipher.createCipher = function(t7, e2) {
  var r2 = t7;
  if (typeof r2 == "string" && (r2 = xu.cipher.getAlgorithm(r2)) && (r2 = r2()), !r2)
    throw new Error("Unsupported algorithm: " + t7);
  return new xu.cipher.BlockCipher({ algorithm: r2, key: e2, decrypt: false });
}, xu.cipher.createDecipher = function(t7, e2) {
  var r2 = t7;
  if (typeof r2 == "string" && (r2 = xu.cipher.getAlgorithm(r2)) && (r2 = r2()), !r2)
    throw new Error("Unsupported algorithm: " + t7);
  return new xu.cipher.BlockCipher({ algorithm: r2, key: e2, decrypt: true });
}, xu.cipher.registerAlgorithm = function(t7, e2) {
  t7 = t7.toUpperCase(), xu.cipher.algorithms[t7] = e2;
}, xu.cipher.getAlgorithm = function(t7) {
  return (t7 = t7.toUpperCase()) in xu.cipher.algorithms ? xu.cipher.algorithms[t7] : null;
};
var Fu = xu.cipher.BlockCipher = function(t7) {
  this.algorithm = t7.algorithm, this.mode = this.algorithm.mode, this.blockSize = this.mode.blockSize, this._finish = false, this._input = null, this.output = null, this._op = t7.decrypt ? this.mode.decrypt : this.mode.encrypt, this._decrypt = t7.decrypt, this.algorithm.initialize(t7);
};
function Ku(t7, e2) {
  xu.cipher.registerAlgorithm(t7, function() {
    return new xu.aes.Algorithm(t7, e2);
  });
}
Fu.prototype.start = function(t7) {
  t7 = t7 || {};
  var e2 = {};
  for (var r2 in t7)
    e2[r2] = t7[r2];
  e2.decrypt = this._decrypt, this._finish = false, this._input = xu.util.createBuffer(), this.output = t7.output || xu.util.createBuffer(), this.mode.start(e2);
}, Fu.prototype.update = function(t7) {
  for (t7 && this._input.putBuffer(t7); !this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish; )
    ;
  this._input.compact();
}, Fu.prototype.finish = function(t7) {
  !t7 || this.mode.name !== "ECB" && this.mode.name !== "CBC" || (this.mode.pad = function(e3) {
    return t7(this.blockSize, e3, false);
  }, this.mode.unpad = function(e3) {
    return t7(this.blockSize, e3, true);
  });
  var e2 = {};
  return e2.decrypt = this._decrypt, e2.overflow = this._input.length() % this.blockSize, !(!this._decrypt && this.mode.pad && !this.mode.pad(this._input, e2)) && (this._finish = true, this.update(), !(this._decrypt && this.mode.unpad && !this.mode.unpad(this.output, e2)) && !(this.mode.afterFinish && !this.mode.afterFinish(this.output, e2)));
}, w(function(t7) {
  xu.cipher = xu.cipher || {};
  var e2 = t7.exports = xu.cipher.modes = xu.cipher.modes || {};
  function r2(t8, e3) {
    if (typeof t8 == "string" && (t8 = xu.util.createBuffer(t8)), xu.util.isArray(t8) && t8.length > 4) {
      var r3 = t8;
      t8 = xu.util.createBuffer();
      for (var n3 = 0; n3 < r3.length; ++n3)
        t8.putByte(r3[n3]);
    }
    if (t8.length() < e3)
      throw new Error("Invalid IV length; got " + t8.length() + " bytes and expected " + e3 + " bytes.");
    if (!xu.util.isArray(t8)) {
      var i3 = [], a2 = e3 / 4;
      for (n3 = 0; n3 < a2; ++n3)
        i3.push(t8.getInt32());
      t8 = i3;
    }
    return t8;
  }
  function n2(t8) {
    t8[t8.length - 1] = t8[t8.length - 1] + 1 & 4294967295;
  }
  function i2(t8) {
    return [t8 / 4294967296 | 0, 4294967295 & t8];
  }
  e2.ecb = function(t8) {
    t8 = t8 || {}, this.name = "ECB", this.cipher = t8.cipher, this.blockSize = t8.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints);
  }, e2.ecb.prototype.start = function(t8) {
  }, e2.ecb.prototype.encrypt = function(t8, e3, r3) {
    if (t8.length() < this.blockSize && !(r3 && t8.length() > 0))
      return true;
    for (var n3 = 0; n3 < this._ints; ++n3)
      this._inBlock[n3] = t8.getInt32();
    this.cipher.encrypt(this._inBlock, this._outBlock);
    for (n3 = 0; n3 < this._ints; ++n3)
      e3.putInt32(this._outBlock[n3]);
  }, e2.ecb.prototype.decrypt = function(t8, e3, r3) {
    if (t8.length() < this.blockSize && !(r3 && t8.length() > 0))
      return true;
    for (var n3 = 0; n3 < this._ints; ++n3)
      this._inBlock[n3] = t8.getInt32();
    this.cipher.decrypt(this._inBlock, this._outBlock);
    for (n3 = 0; n3 < this._ints; ++n3)
      e3.putInt32(this._outBlock[n3]);
  }, e2.ecb.prototype.pad = function(t8, e3) {
    var r3 = t8.length() === this.blockSize ? this.blockSize : this.blockSize - t8.length();
    return t8.fillWithByte(r3, r3), true;
  }, e2.ecb.prototype.unpad = function(t8, e3) {
    if (e3.overflow > 0)
      return false;
    var r3 = t8.length(), n3 = t8.at(r3 - 1);
    return !(n3 > this.blockSize << 2) && (t8.truncate(n3), true);
  }, e2.cbc = function(t8) {
    t8 = t8 || {}, this.name = "CBC", this.cipher = t8.cipher, this.blockSize = t8.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints);
  }, e2.cbc.prototype.start = function(t8) {
    if (t8.iv === null) {
      if (!this._prev)
        throw new Error("Invalid IV parameter.");
      this._iv = this._prev.slice(0);
    } else {
      if (!("iv" in t8))
        throw new Error("Invalid IV parameter.");
      this._iv = r2(t8.iv, this.blockSize), this._prev = this._iv.slice(0);
    }
  }, e2.cbc.prototype.encrypt = function(t8, e3, r3) {
    if (t8.length() < this.blockSize && !(r3 && t8.length() > 0))
      return true;
    for (var n3 = 0; n3 < this._ints; ++n3)
      this._inBlock[n3] = this._prev[n3] ^ t8.getInt32();
    this.cipher.encrypt(this._inBlock, this._outBlock);
    for (n3 = 0; n3 < this._ints; ++n3)
      e3.putInt32(this._outBlock[n3]);
    this._prev = this._outBlock;
  }, e2.cbc.prototype.decrypt = function(t8, e3, r3) {
    if (t8.length() < this.blockSize && !(r3 && t8.length() > 0))
      return true;
    for (var n3 = 0; n3 < this._ints; ++n3)
      this._inBlock[n3] = t8.getInt32();
    this.cipher.decrypt(this._inBlock, this._outBlock);
    for (n3 = 0; n3 < this._ints; ++n3)
      e3.putInt32(this._prev[n3] ^ this._outBlock[n3]);
    this._prev = this._inBlock.slice(0);
  }, e2.cbc.prototype.pad = function(t8, e3) {
    var r3 = t8.length() === this.blockSize ? this.blockSize : this.blockSize - t8.length();
    return t8.fillWithByte(r3, r3), true;
  }, e2.cbc.prototype.unpad = function(t8, e3) {
    if (e3.overflow > 0)
      return false;
    var r3 = t8.length(), n3 = t8.at(r3 - 1);
    return !(n3 > this.blockSize << 2) && (t8.truncate(n3), true);
  }, e2.cfb = function(t8) {
    t8 = t8 || {}, this.name = "CFB", this.cipher = t8.cipher, this.blockSize = t8.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialBlock = new Array(this._ints), this._partialOutput = xu.util.createBuffer(), this._partialBytes = 0;
  }, e2.cfb.prototype.start = function(t8) {
    if (!("iv" in t8))
      throw new Error("Invalid IV parameter.");
    this._iv = r2(t8.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0;
  }, e2.cfb.prototype.encrypt = function(t8, e3, r3) {
    var n3 = t8.length();
    if (n3 === 0)
      return true;
    if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && n3 >= this.blockSize)
      for (var i3 = 0; i3 < this._ints; ++i3)
        this._inBlock[i3] = t8.getInt32() ^ this._outBlock[i3], e3.putInt32(this._inBlock[i3]);
    else {
      var a2 = (this.blockSize - n3) % this.blockSize;
      a2 > 0 && (a2 = this.blockSize - a2), this._partialOutput.clear();
      for (i3 = 0; i3 < this._ints; ++i3)
        this._partialBlock[i3] = t8.getInt32() ^ this._outBlock[i3], this._partialOutput.putInt32(this._partialBlock[i3]);
      if (a2 > 0)
        t8.read -= this.blockSize;
      else
        for (i3 = 0; i3 < this._ints; ++i3)
          this._inBlock[i3] = this._partialBlock[i3];
      if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), a2 > 0 && !r3)
        return e3.putBytes(this._partialOutput.getBytes(a2 - this._partialBytes)), this._partialBytes = a2, true;
      e3.putBytes(this._partialOutput.getBytes(n3 - this._partialBytes)), this._partialBytes = 0;
    }
  }, e2.cfb.prototype.decrypt = function(t8, e3, r3) {
    var n3 = t8.length();
    if (n3 === 0)
      return true;
    if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && n3 >= this.blockSize)
      for (var i3 = 0; i3 < this._ints; ++i3)
        this._inBlock[i3] = t8.getInt32(), e3.putInt32(this._inBlock[i3] ^ this._outBlock[i3]);
    else {
      var a2 = (this.blockSize - n3) % this.blockSize;
      a2 > 0 && (a2 = this.blockSize - a2), this._partialOutput.clear();
      for (i3 = 0; i3 < this._ints; ++i3)
        this._partialBlock[i3] = t8.getInt32(), this._partialOutput.putInt32(this._partialBlock[i3] ^ this._outBlock[i3]);
      if (a2 > 0)
        t8.read -= this.blockSize;
      else
        for (i3 = 0; i3 < this._ints; ++i3)
          this._inBlock[i3] = this._partialBlock[i3];
      if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), a2 > 0 && !r3)
        return e3.putBytes(this._partialOutput.getBytes(a2 - this._partialBytes)), this._partialBytes = a2, true;
      e3.putBytes(this._partialOutput.getBytes(n3 - this._partialBytes)), this._partialBytes = 0;
    }
  }, e2.ofb = function(t8) {
    t8 = t8 || {}, this.name = "OFB", this.cipher = t8.cipher, this.blockSize = t8.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialOutput = xu.util.createBuffer(), this._partialBytes = 0;
  }, e2.ofb.prototype.start = function(t8) {
    if (!("iv" in t8))
      throw new Error("Invalid IV parameter.");
    this._iv = r2(t8.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0;
  }, e2.ofb.prototype.encrypt = function(t8, e3, r3) {
    var n3 = t8.length();
    if (t8.length() === 0)
      return true;
    if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && n3 >= this.blockSize)
      for (var i3 = 0; i3 < this._ints; ++i3)
        e3.putInt32(t8.getInt32() ^ this._outBlock[i3]), this._inBlock[i3] = this._outBlock[i3];
    else {
      var a2 = (this.blockSize - n3) % this.blockSize;
      a2 > 0 && (a2 = this.blockSize - a2), this._partialOutput.clear();
      for (i3 = 0; i3 < this._ints; ++i3)
        this._partialOutput.putInt32(t8.getInt32() ^ this._outBlock[i3]);
      if (a2 > 0)
        t8.read -= this.blockSize;
      else
        for (i3 = 0; i3 < this._ints; ++i3)
          this._inBlock[i3] = this._outBlock[i3];
      if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), a2 > 0 && !r3)
        return e3.putBytes(this._partialOutput.getBytes(a2 - this._partialBytes)), this._partialBytes = a2, true;
      e3.putBytes(this._partialOutput.getBytes(n3 - this._partialBytes)), this._partialBytes = 0;
    }
  }, e2.ofb.prototype.decrypt = e2.ofb.prototype.encrypt, e2.ctr = function(t8) {
    t8 = t8 || {}, this.name = "CTR", this.cipher = t8.cipher, this.blockSize = t8.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialOutput = xu.util.createBuffer(), this._partialBytes = 0;
  }, e2.ctr.prototype.start = function(t8) {
    if (!("iv" in t8))
      throw new Error("Invalid IV parameter.");
    this._iv = r2(t8.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0;
  }, e2.ctr.prototype.encrypt = function(t8, e3, r3) {
    var i3 = t8.length();
    if (i3 === 0)
      return true;
    if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && i3 >= this.blockSize)
      for (var a2 = 0; a2 < this._ints; ++a2)
        e3.putInt32(t8.getInt32() ^ this._outBlock[a2]);
    else {
      var o2 = (this.blockSize - i3) % this.blockSize;
      o2 > 0 && (o2 = this.blockSize - o2), this._partialOutput.clear();
      for (a2 = 0; a2 < this._ints; ++a2)
        this._partialOutput.putInt32(t8.getInt32() ^ this._outBlock[a2]);
      if (o2 > 0 && (t8.read -= this.blockSize), this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), o2 > 0 && !r3)
        return e3.putBytes(this._partialOutput.getBytes(o2 - this._partialBytes)), this._partialBytes = o2, true;
      e3.putBytes(this._partialOutput.getBytes(i3 - this._partialBytes)), this._partialBytes = 0;
    }
    n2(this._inBlock);
  }, e2.ctr.prototype.decrypt = e2.ctr.prototype.encrypt, e2.gcm = function(t8) {
    t8 = t8 || {}, this.name = "GCM", this.cipher = t8.cipher, this.blockSize = t8.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints), this._partialOutput = xu.util.createBuffer(), this._partialBytes = 0, this._R = 3774873600;
  }, e2.gcm.prototype.start = function(t8) {
    if (!("iv" in t8))
      throw new Error("Invalid IV parameter.");
    var e3, r3 = xu.util.createBuffer(t8.iv);
    if (this._cipherLength = 0, e3 = "additionalData" in t8 ? xu.util.createBuffer(t8.additionalData) : xu.util.createBuffer(), this._tagLength = "tagLength" in t8 ? t8.tagLength : 128, this._tag = null, t8.decrypt && (this._tag = xu.util.createBuffer(t8.tag).getBytes(), this._tag.length !== this._tagLength / 8))
      throw new Error("Authentication tag does not match tag length.");
    this._hashBlock = new Array(this._ints), this.tag = null, this._hashSubkey = new Array(this._ints), this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey), this.componentBits = 4, this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
    var a2 = r3.length();
    if (a2 === 12)
      this._j0 = [r3.getInt32(), r3.getInt32(), r3.getInt32(), 1];
    else {
      for (this._j0 = [0, 0, 0, 0]; r3.length() > 0; )
        this._j0 = this.ghash(this._hashSubkey, this._j0, [r3.getInt32(), r3.getInt32(), r3.getInt32(), r3.getInt32()]);
      this._j0 = this.ghash(this._hashSubkey, this._j0, [0, 0].concat(i2(8 * a2)));
    }
    this._inBlock = this._j0.slice(0), n2(this._inBlock), this._partialBytes = 0, e3 = xu.util.createBuffer(e3), this._aDataLength = i2(8 * e3.length());
    var o2 = e3.length() % this.blockSize;
    for (o2 && e3.fillWithByte(0, this.blockSize - o2), this._s = [0, 0, 0, 0]; e3.length() > 0; )
      this._s = this.ghash(this._hashSubkey, this._s, [e3.getInt32(), e3.getInt32(), e3.getInt32(), e3.getInt32()]);
  }, e2.gcm.prototype.encrypt = function(t8, e3, r3) {
    var i3 = t8.length();
    if (i3 === 0)
      return true;
    if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && i3 >= this.blockSize) {
      for (var a2 = 0; a2 < this._ints; ++a2)
        e3.putInt32(this._outBlock[a2] ^= t8.getInt32());
      this._cipherLength += this.blockSize;
    } else {
      var o2 = (this.blockSize - i3) % this.blockSize;
      o2 > 0 && (o2 = this.blockSize - o2), this._partialOutput.clear();
      for (a2 = 0; a2 < this._ints; ++a2)
        this._partialOutput.putInt32(t8.getInt32() ^ this._outBlock[a2]);
      if (o2 <= 0 || r3) {
        if (r3) {
          var s2 = i3 % this.blockSize;
          this._cipherLength += s2, this._partialOutput.truncate(this.blockSize - s2);
        } else
          this._cipherLength += this.blockSize;
        for (a2 = 0; a2 < this._ints; ++a2)
          this._outBlock[a2] = this._partialOutput.getInt32();
        this._partialOutput.read -= this.blockSize;
      }
      if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), o2 > 0 && !r3)
        return t8.read -= this.blockSize, e3.putBytes(this._partialOutput.getBytes(o2 - this._partialBytes)), this._partialBytes = o2, true;
      e3.putBytes(this._partialOutput.getBytes(i3 - this._partialBytes)), this._partialBytes = 0;
    }
    this._s = this.ghash(this._hashSubkey, this._s, this._outBlock), n2(this._inBlock);
  }, e2.gcm.prototype.decrypt = function(t8, e3, r3) {
    var i3 = t8.length();
    if (i3 < this.blockSize && !(r3 && i3 > 0))
      return true;
    this.cipher.encrypt(this._inBlock, this._outBlock), n2(this._inBlock), this._hashBlock[0] = t8.getInt32(), this._hashBlock[1] = t8.getInt32(), this._hashBlock[2] = t8.getInt32(), this._hashBlock[3] = t8.getInt32(), this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
    for (var a2 = 0; a2 < this._ints; ++a2)
      e3.putInt32(this._outBlock[a2] ^ this._hashBlock[a2]);
    i3 < this.blockSize ? this._cipherLength += i3 % this.blockSize : this._cipherLength += this.blockSize;
  }, e2.gcm.prototype.afterFinish = function(t8, e3) {
    var r3 = true;
    e3.decrypt && e3.overflow && t8.truncate(this.blockSize - e3.overflow), this.tag = xu.util.createBuffer();
    var n3 = this._aDataLength.concat(i2(8 * this._cipherLength));
    this._s = this.ghash(this._hashSubkey, this._s, n3);
    var a2 = [];
    this.cipher.encrypt(this._j0, a2);
    for (var o2 = 0; o2 < this._ints; ++o2)
      this.tag.putInt32(this._s[o2] ^ a2[o2]);
    return this.tag.truncate(this.tag.length() % (this._tagLength / 8)), e3.decrypt && this.tag.bytes() !== this._tag && (r3 = false), r3;
  }, e2.gcm.prototype.multiply = function(t8, e3) {
    for (var r3 = [0, 0, 0, 0], n3 = e3.slice(0), i3 = 0; i3 < 128; ++i3) {
      t8[i3 / 32 | 0] & 1 << 31 - i3 % 32 && (r3[0] ^= n3[0], r3[1] ^= n3[1], r3[2] ^= n3[2], r3[3] ^= n3[3]), this.pow(n3, n3);
    }
    return r3;
  }, e2.gcm.prototype.pow = function(t8, e3) {
    for (var r3 = 1 & t8[3], n3 = 3; n3 > 0; --n3)
      e3[n3] = t8[n3] >>> 1 | (1 & t8[n3 - 1]) << 31;
    e3[0] = t8[0] >>> 1, r3 && (e3[0] ^= this._R);
  }, e2.gcm.prototype.tableMultiply = function(t8) {
    for (var e3 = [0, 0, 0, 0], r3 = 0; r3 < 32; ++r3) {
      var n3 = t8[r3 / 8 | 0] >>> 4 * (7 - r3 % 8) & 15, i3 = this._m[r3][n3];
      e3[0] ^= i3[0], e3[1] ^= i3[1], e3[2] ^= i3[2], e3[3] ^= i3[3];
    }
    return e3;
  }, e2.gcm.prototype.ghash = function(t8, e3, r3) {
    return e3[0] ^= r3[0], e3[1] ^= r3[1], e3[2] ^= r3[2], e3[3] ^= r3[3], this.tableMultiply(e3);
  }, e2.gcm.prototype.generateHashTable = function(t8, e3) {
    for (var r3 = 8 / e3, n3 = 4 * r3, i3 = 16 * r3, a2 = new Array(i3), o2 = 0; o2 < i3; ++o2) {
      var s2 = [0, 0, 0, 0], u2 = (n3 - 1 - o2 % n3) * e3;
      s2[o2 / n3 | 0] = 1 << e3 - 1 << u2, a2[o2] = this.generateSubHashTable(this.multiply(s2, t8), e3);
    }
    return a2;
  }, e2.gcm.prototype.generateSubHashTable = function(t8, e3) {
    var r3 = 1 << e3, n3 = r3 >>> 1, i3 = new Array(r3);
    i3[n3] = t8.slice(0);
    for (var a2 = n3 >>> 1; a2 > 0; )
      this.pow(i3[2 * a2], i3[a2] = []), a2 >>= 1;
    for (a2 = 2; a2 < n3; ) {
      for (var o2 = 1; o2 < a2; ++o2) {
        var s2 = i3[a2], u2 = i3[o2];
        i3[a2 + o2] = [s2[0] ^ u2[0], s2[1] ^ u2[1], s2[2] ^ u2[2], s2[3] ^ u2[3]];
      }
      a2 *= 2;
    }
    for (i3[0] = [0, 0, 0, 0], a2 = n3 + 1; a2 < r3; ++a2) {
      var c2 = i3[a2 ^ n3];
      i3[a2] = [t8[0] ^ c2[0], t8[1] ^ c2[1], t8[2] ^ c2[2], t8[3] ^ c2[3]];
    }
    return i3;
  };
}), xu.aes = xu.aes || {}, xu.aes.startEncrypting = function(t7, e2, r2, n2) {
  var i2 = Zu({ key: t7, output: r2, decrypt: false, mode: n2 });
  return i2.start(e2), i2;
}, xu.aes.createEncryptionCipher = function(t7, e2) {
  return Zu({ key: t7, output: null, decrypt: false, mode: e2 });
}, xu.aes.startDecrypting = function(t7, e2, r2, n2) {
  var i2 = Zu({ key: t7, output: r2, decrypt: true, mode: n2 });
  return i2.start(e2), i2;
}, xu.aes.createDecryptionCipher = function(t7, e2) {
  return Zu({ key: t7, output: null, decrypt: true, mode: e2 });
}, xu.aes.Algorithm = function(t7, e2) {
  Qu || Yu();
  var r2 = this;
  r2.name = t7, r2.mode = new e2({ blockSize: 16, cipher: { encrypt: function(t8, e3) {
    return $u(r2._w, t8, e3, false);
  }, decrypt: function(t8, e3) {
    return $u(r2._w, t8, e3, true);
  } } }), r2._init = false;
}, xu.aes.Algorithm.prototype.initialize = function(t7) {
  if (!this._init) {
    var e2, r2 = t7.key;
    if (typeof r2 != "string" || r2.length !== 16 && r2.length !== 24 && r2.length !== 32) {
      if (xu.util.isArray(r2) && (r2.length === 16 || r2.length === 24 || r2.length === 32)) {
        e2 = r2, r2 = xu.util.createBuffer();
        for (var n2 = 0; n2 < e2.length; ++n2)
          r2.putByte(e2[n2]);
      }
    } else
      r2 = xu.util.createBuffer(r2);
    if (!xu.util.isArray(r2)) {
      e2 = r2, r2 = [];
      var i2 = e2.length();
      if (i2 === 16 || i2 === 24 || i2 === 32) {
        i2 >>>= 2;
        for (n2 = 0; n2 < i2; ++n2)
          r2.push(e2.getInt32());
      }
    }
    if (!xu.util.isArray(r2) || r2.length !== 4 && r2.length !== 6 && r2.length !== 8)
      throw new Error("Invalid key parameter.");
    var a2 = this.mode.name, o2 = ["CFB", "OFB", "CTR", "GCM"].indexOf(a2) !== -1;
    this._w = Xu(r2, t7.decrypt && !o2), this._init = true;
  }
}, xu.aes._expandKey = function(t7, e2) {
  return Qu || Yu(), Xu(t7, e2);
}, xu.aes._updateBlock = $u, Ku("AES-ECB", xu.cipher.modes.ecb), Ku("AES-CBC", xu.cipher.modes.cbc), Ku("AES-CFB", xu.cipher.modes.cfb), Ku("AES-OFB", xu.cipher.modes.ofb), Ku("AES-CTR", xu.cipher.modes.ctr), Ku("AES-GCM", xu.cipher.modes.gcm);
var qu, Gu, zu, Wu, Hu, Qu = false;
function Yu() {
  Qu = true, zu = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
  for (var t7 = new Array(256), e2 = 0; e2 < 128; ++e2)
    t7[e2] = e2 << 1, t7[e2 + 128] = e2 + 128 << 1 ^ 283;
  qu = new Array(256), Gu = new Array(256), Wu = new Array(4), Hu = new Array(4);
  for (e2 = 0; e2 < 4; ++e2)
    Wu[e2] = new Array(256), Hu[e2] = new Array(256);
  var r2, n2, i2, a2, o2, s2, u2, c2 = 0, f2 = 0;
  for (e2 = 0; e2 < 256; ++e2) {
    a2 = (a2 = f2 ^ f2 << 1 ^ f2 << 2 ^ f2 << 3 ^ f2 << 4) >> 8 ^ 255 & a2 ^ 99, qu[c2] = a2, Gu[a2] = c2, s2 = (o2 = t7[a2]) << 24 ^ a2 << 16 ^ a2 << 8 ^ a2 ^ o2, u2 = ((r2 = t7[c2]) ^ (n2 = t7[r2]) ^ (i2 = t7[n2])) << 24 ^ (c2 ^ i2) << 16 ^ (c2 ^ n2 ^ i2) << 8 ^ c2 ^ r2 ^ i2;
    for (var l2 = 0; l2 < 4; ++l2)
      Wu[l2][c2] = s2, Hu[l2][a2] = u2, s2 = s2 << 24 | s2 >>> 8, u2 = u2 << 24 | u2 >>> 8;
    c2 === 0 ? c2 = f2 = 1 : (c2 = r2 ^ t7[t7[t7[r2 ^ i2]]], f2 ^= t7[t7[f2]]);
  }
}
function Xu(t7, e2) {
  for (var r2, n2 = t7.slice(0), i2 = 1, a2 = n2.length, o2 = 4 * (a2 + 6 + 1), s2 = a2; s2 < o2; ++s2)
    r2 = n2[s2 - 1], s2 % a2 == 0 ? (r2 = qu[r2 >>> 16 & 255] << 24 ^ qu[r2 >>> 8 & 255] << 16 ^ qu[255 & r2] << 8 ^ qu[r2 >>> 24] ^ zu[i2] << 24, i2++) : a2 > 6 && s2 % a2 == 4 && (r2 = qu[r2 >>> 24] << 24 ^ qu[r2 >>> 16 & 255] << 16 ^ qu[r2 >>> 8 & 255] << 8 ^ qu[255 & r2]), n2[s2] = n2[s2 - a2] ^ r2;
  if (e2) {
    for (var u2, c2 = Hu[0], f2 = Hu[1], l2 = Hu[2], h2 = Hu[3], p2 = n2.slice(0), d2 = (s2 = 0, (o2 = n2.length) - 4); s2 < o2; s2 += 4, d2 -= 4)
      if (s2 === 0 || s2 === o2 - 4)
        p2[s2] = n2[d2], p2[s2 + 1] = n2[d2 + 3], p2[s2 + 2] = n2[d2 + 2], p2[s2 + 3] = n2[d2 + 1];
      else
        for (var y2 = 0; y2 < 4; ++y2)
          u2 = n2[d2 + y2], p2[s2 + (3 & -y2)] = c2[qu[u2 >>> 24]] ^ f2[qu[u2 >>> 16 & 255]] ^ l2[qu[u2 >>> 8 & 255]] ^ h2[qu[255 & u2]];
    n2 = p2;
  }
  return n2;
}
function $u(t7, e2, r2, n2) {
  var i2, a2, o2, s2, u2, c2, f2, l2, h2, p2, d2, y2, g2 = t7.length / 4 - 1;
  n2 ? (i2 = Hu[0], a2 = Hu[1], o2 = Hu[2], s2 = Hu[3], u2 = Gu) : (i2 = Wu[0], a2 = Wu[1], o2 = Wu[2], s2 = Wu[3], u2 = qu), c2 = e2[0] ^ t7[0], f2 = e2[n2 ? 3 : 1] ^ t7[1], l2 = e2[2] ^ t7[2], h2 = e2[n2 ? 1 : 3] ^ t7[3];
  for (var v2 = 3, m2 = 1; m2 < g2; ++m2)
    p2 = i2[c2 >>> 24] ^ a2[f2 >>> 16 & 255] ^ o2[l2 >>> 8 & 255] ^ s2[255 & h2] ^ t7[++v2], d2 = i2[f2 >>> 24] ^ a2[l2 >>> 16 & 255] ^ o2[h2 >>> 8 & 255] ^ s2[255 & c2] ^ t7[++v2], y2 = i2[l2 >>> 24] ^ a2[h2 >>> 16 & 255] ^ o2[c2 >>> 8 & 255] ^ s2[255 & f2] ^ t7[++v2], h2 = i2[h2 >>> 24] ^ a2[c2 >>> 16 & 255] ^ o2[f2 >>> 8 & 255] ^ s2[255 & l2] ^ t7[++v2], c2 = p2, f2 = d2, l2 = y2;
  r2[0] = u2[c2 >>> 24] << 24 ^ u2[f2 >>> 16 & 255] << 16 ^ u2[l2 >>> 8 & 255] << 8 ^ u2[255 & h2] ^ t7[++v2], r2[n2 ? 3 : 1] = u2[f2 >>> 24] << 24 ^ u2[l2 >>> 16 & 255] << 16 ^ u2[h2 >>> 8 & 255] << 8 ^ u2[255 & c2] ^ t7[++v2], r2[2] = u2[l2 >>> 24] << 24 ^ u2[h2 >>> 16 & 255] << 16 ^ u2[c2 >>> 8 & 255] << 8 ^ u2[255 & f2] ^ t7[++v2], r2[n2 ? 1 : 3] = u2[h2 >>> 24] << 24 ^ u2[c2 >>> 16 & 255] << 16 ^ u2[f2 >>> 8 & 255] << 8 ^ u2[255 & l2] ^ t7[++v2];
}
function Zu(t7) {
  var e2, r2 = "AES-" + ((t7 = t7 || {}).mode || "CBC").toUpperCase(), n2 = (e2 = t7.decrypt ? xu.cipher.createDecipher(r2, t7.key) : xu.cipher.createCipher(r2, t7.key)).start;
  return e2.start = function(t8, r3) {
    var i2 = null;
    r3 instanceof xu.util.ByteBuffer && (i2 = r3, r3 = {}), (r3 = r3 || {}).output = i2, r3.iv = t8, n2.call(e2, r3);
  }, e2;
}
function Ju(t7, e2) {
  xu.cipher.registerAlgorithm(t7, function() {
    return new xu.des.Algorithm(t7, e2);
  });
}
xu.des = xu.des || {}, xu.des.startEncrypting = function(t7, e2, r2, n2) {
  var i2 = cc({ key: t7, output: r2, decrypt: false, mode: n2 || (e2 === null ? "ECB" : "CBC") });
  return i2.start(e2), i2;
}, xu.des.createEncryptionCipher = function(t7, e2) {
  return cc({ key: t7, output: null, decrypt: false, mode: e2 });
}, xu.des.startDecrypting = function(t7, e2, r2, n2) {
  var i2 = cc({ key: t7, output: r2, decrypt: true, mode: n2 || (e2 === null ? "ECB" : "CBC") });
  return i2.start(e2), i2;
}, xu.des.createDecryptionCipher = function(t7, e2) {
  return cc({ key: t7, output: null, decrypt: true, mode: e2 });
}, xu.des.Algorithm = function(t7, e2) {
  var r2 = this;
  r2.name = t7, r2.mode = new e2({ blockSize: 8, cipher: { encrypt: function(t8, e3) {
    return uc(r2._keys, t8, e3, false);
  }, decrypt: function(t8, e3) {
    return uc(r2._keys, t8, e3, true);
  } } }), r2._init = false;
}, xu.des.Algorithm.prototype.initialize = function(t7) {
  if (!this._init) {
    var e2 = xu.util.createBuffer(t7.key);
    if (this.name.indexOf("3DES") === 0 && e2.length() !== 24)
      throw new Error("Invalid Triple-DES key size: " + 8 * e2.length());
    this._keys = function(t8) {
      for (var e3, r2 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], n2 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], i2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], a2 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], o2 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], s2 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], u2 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], c2 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], f2 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], l2 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], h2 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], p2 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], d2 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], y2 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261], g2 = t8.length() > 8 ? 3 : 1, v2 = [], m2 = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0], C2 = 0, E2 = 0; E2 < g2; E2++) {
        var S2 = t8.getInt32(), b2 = t8.getInt32();
        S2 ^= (e3 = 252645135 & (S2 >>> 4 ^ b2)) << 4, S2 ^= e3 = 65535 & ((b2 ^= e3) >>> -16 ^ S2), S2 ^= (e3 = 858993459 & (S2 >>> 2 ^ (b2 ^= e3 << -16))) << 2, S2 ^= e3 = 65535 & ((b2 ^= e3) >>> -16 ^ S2), S2 ^= (e3 = 1431655765 & (S2 >>> 1 ^ (b2 ^= e3 << -16))) << 1, S2 ^= e3 = 16711935 & ((b2 ^= e3) >>> 8 ^ S2), e3 = (S2 ^= (e3 = 1431655765 & (S2 >>> 1 ^ (b2 ^= e3 << 8))) << 1) << 8 | (b2 ^= e3) >>> 20 & 240, S2 = b2 << 24 | b2 << 8 & 16711680 | b2 >>> 8 & 65280 | b2 >>> 24 & 240, b2 = e3;
        for (var T2 = 0; T2 < m2.length; ++T2) {
          m2[T2] ? (S2 = S2 << 2 | S2 >>> 26, b2 = b2 << 2 | b2 >>> 26) : (S2 = S2 << 1 | S2 >>> 27, b2 = b2 << 1 | b2 >>> 27), b2 &= -15;
          var I2 = r2[(S2 &= -15) >>> 28] | n2[S2 >>> 24 & 15] | i2[S2 >>> 20 & 15] | a2[S2 >>> 16 & 15] | o2[S2 >>> 12 & 15] | s2[S2 >>> 8 & 15] | u2[S2 >>> 4 & 15], A2 = c2[b2 >>> 28] | f2[b2 >>> 24 & 15] | l2[b2 >>> 20 & 15] | h2[b2 >>> 16 & 15] | p2[b2 >>> 12 & 15] | d2[b2 >>> 8 & 15] | y2[b2 >>> 4 & 15];
          e3 = 65535 & (A2 >>> 16 ^ I2), v2[C2++] = I2 ^ e3, v2[C2++] = A2 ^ e3 << 16;
        }
      }
      return v2;
    }(e2), this._init = true;
  }
}, Ju("DES-ECB", xu.cipher.modes.ecb), Ju("DES-CBC", xu.cipher.modes.cbc), Ju("DES-CFB", xu.cipher.modes.cfb), Ju("DES-OFB", xu.cipher.modes.ofb), Ju("DES-CTR", xu.cipher.modes.ctr), Ju("3DES-ECB", xu.cipher.modes.ecb), Ju("3DES-CBC", xu.cipher.modes.cbc), Ju("3DES-CFB", xu.cipher.modes.cfb), Ju("3DES-OFB", xu.cipher.modes.ofb), Ju("3DES-CTR", xu.cipher.modes.ctr);
var tc = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756], ec = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344], rc = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584], nc = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928], ic = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080], ac = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312], oc = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154], sc = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
function uc(t7, e2, r2, n2) {
  var i2, a2, o2 = t7.length === 32 ? 3 : 9;
  i2 = o2 === 3 ? n2 ? [30, -2, -2] : [0, 32, 2] : n2 ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
  var s2 = e2[0], u2 = e2[1];
  s2 ^= (a2 = 252645135 & (s2 >>> 4 ^ u2)) << 4, s2 ^= (a2 = 65535 & (s2 >>> 16 ^ (u2 ^= a2))) << 16, s2 ^= a2 = 858993459 & ((u2 ^= a2) >>> 2 ^ s2), s2 ^= a2 = 16711935 & ((u2 ^= a2 << 2) >>> 8 ^ s2), s2 = (s2 ^= (a2 = 1431655765 & (s2 >>> 1 ^ (u2 ^= a2 << 8))) << 1) << 1 | s2 >>> 31, u2 = (u2 ^= a2) << 1 | u2 >>> 31;
  for (var c2 = 0; c2 < o2; c2 += 3) {
    for (var f2 = i2[c2 + 1], l2 = i2[c2 + 2], h2 = i2[c2]; h2 != f2; h2 += l2) {
      var p2 = u2 ^ t7[h2], d2 = (u2 >>> 4 | u2 << 28) ^ t7[h2 + 1];
      a2 = s2, s2 = u2, u2 = a2 ^ (ec[p2 >>> 24 & 63] | nc[p2 >>> 16 & 63] | ac[p2 >>> 8 & 63] | sc[63 & p2] | tc[d2 >>> 24 & 63] | rc[d2 >>> 16 & 63] | ic[d2 >>> 8 & 63] | oc[63 & d2]);
    }
    a2 = s2, s2 = u2, u2 = a2;
  }
  u2 = u2 >>> 1 | u2 << 31, u2 ^= a2 = 1431655765 & ((s2 = s2 >>> 1 | s2 << 31) >>> 1 ^ u2), u2 ^= (a2 = 16711935 & (u2 >>> 8 ^ (s2 ^= a2 << 1))) << 8, u2 ^= (a2 = 858993459 & (u2 >>> 2 ^ (s2 ^= a2))) << 2, u2 ^= a2 = 65535 & ((s2 ^= a2) >>> 16 ^ u2), u2 ^= a2 = 252645135 & ((s2 ^= a2 << 16) >>> 4 ^ u2), s2 ^= a2 << 4, r2[0] = s2, r2[1] = u2;
}
function cc(t7) {
  var e2, r2 = "DES-" + ((t7 = t7 || {}).mode || "CBC").toUpperCase(), n2 = (e2 = t7.decrypt ? xu.cipher.createDecipher(r2, t7.key) : xu.cipher.createCipher(r2, t7.key)).start;
  return e2.start = function(t8, r3) {
    var i2 = null;
    r3 instanceof xu.util.ByteBuffer && (i2 = r3, r3 = {}), (r3 = r3 || {}).output = i2, r3.iv = t8, n2.call(e2, r3);
  }, e2;
}
var fc = xu.md = xu.md || {};
xu.md.algorithms = xu.md.algorithms || {}, w(function(t7) {
  (t7.exports = xu.hmac = xu.hmac || {}).create = function() {
    var t8 = null, e2 = null, r2 = null, n2 = null, i2 = { start: function(i3, a2) {
      if (i3 !== null)
        if (typeof i3 == "string") {
          if (!((i3 = i3.toLowerCase()) in xu.md.algorithms))
            throw new Error('Unknown hash algorithm "' + i3 + '"');
          e2 = xu.md.algorithms[i3].create();
        } else
          e2 = i3;
      if (a2 === null)
        a2 = t8;
      else {
        if (typeof a2 == "string")
          a2 = xu.util.createBuffer(a2);
        else if (xu.util.isArray(a2)) {
          var o2 = a2;
          a2 = xu.util.createBuffer();
          for (var s2 = 0; s2 < o2.length; ++s2)
            a2.putByte(o2[s2]);
        }
        var u2 = a2.length();
        u2 > e2.blockLength && (e2.start(), e2.update(a2.bytes()), a2 = e2.digest()), r2 = xu.util.createBuffer(), n2 = xu.util.createBuffer(), u2 = a2.length();
        for (s2 = 0; s2 < u2; ++s2) {
          o2 = a2.at(s2);
          r2.putByte(54 ^ o2), n2.putByte(92 ^ o2);
        }
        if (u2 < e2.blockLength)
          for (o2 = e2.blockLength - u2, s2 = 0; s2 < o2; ++s2)
            r2.putByte(54), n2.putByte(92);
        t8 = a2, r2 = r2.bytes(), n2 = n2.bytes();
      }
      e2.start(), e2.update(r2);
    }, update: function(t9) {
      e2.update(t9);
    }, getMac: function() {
      var t9 = e2.digest().bytes();
      return e2.start(), e2.update(n2), e2.update(t9), e2.digest();
    } };
    return i2.digest = i2.getMac, i2;
  };
});
var lc, hc = xu.pkcs5 = xu.pkcs5 || {};
xu.util.isNodejs && !xu.options.usePureJavaScript && (lc = y.default), xu.pbkdf2 = hc.pbkdf2 = function(t7, e2, r2, n2, i2, a2) {
  if (typeof i2 == "function" && (a2 = i2, i2 = null), xu.util.isNodejs && !xu.options.usePureJavaScript && lc.pbkdf2 && (i2 === null || typeof i2 != "object") && (lc.pbkdf2Sync.length > 4 || !i2 || i2 === "sha1"))
    return typeof i2 != "string" && (i2 = "sha1"), t7 = Buffer.from(t7, "binary"), e2 = Buffer.from(e2, "binary"), a2 ? lc.pbkdf2Sync.length === 4 ? lc.pbkdf2(t7, e2, r2, n2, function(t8, e3) {
      if (t8)
        return a2(t8);
      a2(null, e3.toString("binary"));
    }) : lc.pbkdf2(t7, e2, r2, n2, i2, function(t8, e3) {
      if (t8)
        return a2(t8);
      a2(null, e3.toString("binary"));
    }) : lc.pbkdf2Sync.length === 4 ? lc.pbkdf2Sync(t7, e2, r2, n2).toString("binary") : lc.pbkdf2Sync(t7, e2, r2, n2, i2).toString("binary");
  if (i2 == null && (i2 = "sha1"), typeof i2 == "string") {
    if (!(i2 in xu.md.algorithms))
      throw new Error("Unknown hash algorithm: " + i2);
    i2 = xu.md[i2].create();
  }
  var o2 = i2.digestLength;
  if (n2 > 4294967295 * o2) {
    var s2 = new Error("Derived key is too long.");
    if (a2)
      return a2(s2);
    throw s2;
  }
  var u2 = Math.ceil(n2 / o2), c2 = n2 - (u2 - 1) * o2, f2 = xu.hmac.create();
  f2.start(i2, t7);
  var l2, h2, p2, d2 = "";
  if (!a2) {
    for (var y2 = 1; y2 <= u2; ++y2) {
      f2.start(null, null), f2.update(e2), f2.update(xu.util.int32ToBytes(y2)), l2 = p2 = f2.digest().getBytes();
      for (var g2 = 2; g2 <= r2; ++g2)
        f2.start(null, null), f2.update(p2), h2 = f2.digest().getBytes(), l2 = xu.util.xorBytes(l2, h2, o2), p2 = h2;
      d2 += y2 < u2 ? l2 : l2.substr(0, c2);
    }
    return d2;
  }
  y2 = 1;
  function v2() {
    if (y2 > u2)
      return a2(null, d2);
    f2.start(null, null), f2.update(e2), f2.update(xu.util.int32ToBytes(y2)), l2 = p2 = f2.digest().getBytes(), g2 = 2, m2();
  }
  function m2() {
    if (g2 <= r2)
      return f2.start(null, null), f2.update(p2), h2 = f2.digest().getBytes(), l2 = xu.util.xorBytes(l2, h2, o2), p2 = h2, ++g2, xu.util.setImmediate(m2);
    d2 += y2 < u2 ? l2 : l2.substr(0, c2), ++y2, v2();
  }
  v2();
}, w(function(t7) {
  var e2 = t7.exports = xu.pem = xu.pem || {};
  function r2(t8) {
    for (var e3 = t8.name + ": ", r3 = [], n3 = function(t9, e4) {
      return " " + e4;
    }, i2 = 0; i2 < t8.values.length; ++i2)
      r3.push(t8.values[i2].replace(/^(\S+\r\n)/, n3));
    e3 += r3.join(",") + "\r\n";
    var a2 = 0, o2 = -1;
    for (i2 = 0; i2 < e3.length; ++i2, ++a2)
      if (a2 > 65 && o2 !== -1) {
        var s2 = e3[o2];
        s2 === "," ? (++o2, e3 = e3.substr(0, o2) + "\r\n " + e3.substr(o2)) : e3 = e3.substr(0, o2) + "\r\n" + s2 + e3.substr(o2 + 1), a2 = i2 - o2 - 1, o2 = -1, ++i2;
      } else
        e3[i2] !== " " && e3[i2] !== "	" && e3[i2] !== "," || (o2 = i2);
    return e3;
  }
  function n2(t8) {
    return t8.replace(/^\s+/, "");
  }
  e2.encode = function(t8, e3) {
    e3 = e3 || {};
    var n3, i2 = "-----BEGIN " + t8.type + "-----\r\n";
    if (t8.procType && (i2 += r2(n3 = { name: "Proc-Type", values: [String(t8.procType.version), t8.procType.type] })), t8.contentDomain && (i2 += r2(n3 = { name: "Content-Domain", values: [t8.contentDomain] })), t8.dekInfo && (n3 = { name: "DEK-Info", values: [t8.dekInfo.algorithm] }, t8.dekInfo.parameters && n3.values.push(t8.dekInfo.parameters), i2 += r2(n3)), t8.headers)
      for (var a2 = 0; a2 < t8.headers.length; ++a2)
        i2 += r2(t8.headers[a2]);
    return t8.procType && (i2 += "\r\n"), i2 += xu.util.encode64(t8.body, e3.maxline || 64) + "\r\n", i2 += "-----END " + t8.type + "-----\r\n";
  }, e2.decode = function(t8) {
    for (var e3, r3 = [], i2 = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g, a2 = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/, o2 = /\r?\n/; e3 = i2.exec(t8); ) {
      var s2 = { type: e3[1], procType: null, contentDomain: null, dekInfo: null, headers: [], body: xu.util.decode64(e3[3]) };
      if (r3.push(s2), e3[2]) {
        for (var u2 = e3[2].split(o2), c2 = 0; e3 && c2 < u2.length; ) {
          for (var f2 = u2[c2].replace(/\s+$/, ""), l2 = c2 + 1; l2 < u2.length; ++l2) {
            var h2 = u2[l2];
            if (!/\s/.test(h2[0]))
              break;
            f2 += h2, c2 = l2;
          }
          if (e3 = f2.match(a2)) {
            for (var p2 = { name: e3[1], values: [] }, d2 = e3[2].split(","), y2 = 0; y2 < d2.length; ++y2)
              p2.values.push(n2(d2[y2]));
            if (s2.procType)
              if (s2.contentDomain || p2.name !== "Content-Domain")
                if (s2.dekInfo || p2.name !== "DEK-Info")
                  s2.headers.push(p2);
                else {
                  if (p2.values.length === 0)
                    throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
                  s2.dekInfo = { algorithm: d2[0], parameters: d2[1] || null };
                }
              else
                s2.contentDomain = d2[0] || "";
            else {
              if (p2.name !== "Proc-Type")
                throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
              if (p2.values.length !== 2)
                throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
              s2.procType = { version: d2[0], type: d2[1] };
            }
          }
          ++c2;
        }
        if (s2.procType === "ENCRYPTED" && !s2.dekInfo)
          throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
      }
    }
    if (r3.length === 0)
      throw new Error("Invalid PEM formatted message.");
    return r3;
  };
}), w(function(t7) {
  var e2 = t7.exports = xu.sha256 = xu.sha256 || {};
  xu.md.sha256 = xu.md.algorithms.sha256 = e2, e2.create = function() {
    n2 || (r2 = String.fromCharCode(128), r2 += xu.util.fillString(String.fromCharCode(0), 64), i2 = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], n2 = true);
    var t8 = null, e3 = xu.util.createBuffer(), o2 = new Array(64), s2 = { algorithm: "sha256", blockLength: 64, digestLength: 32, messageLength: 0, fullMessageLength: null, messageLengthSize: 8, start: function() {
      s2.messageLength = 0, s2.fullMessageLength = s2.messageLength64 = [];
      for (var r3 = s2.messageLengthSize / 4, n3 = 0; n3 < r3; ++n3)
        s2.fullMessageLength.push(0);
      return e3 = xu.util.createBuffer(), t8 = { h0: 1779033703, h1: 3144134277, h2: 1013904242, h3: 2773480762, h4: 1359893119, h5: 2600822924, h6: 528734635, h7: 1541459225 }, s2;
    } };
    return s2.start(), s2.update = function(r3, n3) {
      n3 === "utf8" && (r3 = xu.util.encodeUtf8(r3));
      var i3 = r3.length;
      s2.messageLength += i3, i3 = [i3 / 4294967296 >>> 0, i3 >>> 0];
      for (var u2 = s2.fullMessageLength.length - 1; u2 >= 0; --u2)
        s2.fullMessageLength[u2] += i3[1], i3[1] = i3[0] + (s2.fullMessageLength[u2] / 4294967296 >>> 0), s2.fullMessageLength[u2] = s2.fullMessageLength[u2] >>> 0, i3[0] = i3[1] / 4294967296 >>> 0;
      return e3.putBytes(r3), a2(t8, o2, e3), (e3.read > 2048 || e3.length() === 0) && e3.compact(), s2;
    }, s2.digest = function() {
      var n3 = xu.util.createBuffer();
      n3.putBytes(e3.bytes());
      var i3, u2 = s2.fullMessageLength[s2.fullMessageLength.length - 1] + s2.messageLengthSize & s2.blockLength - 1;
      n3.putBytes(r2.substr(0, s2.blockLength - u2));
      for (var c2 = 8 * s2.fullMessageLength[0], f2 = 0; f2 < s2.fullMessageLength.length - 1; ++f2)
        c2 += (i3 = 8 * s2.fullMessageLength[f2 + 1]) / 4294967296 >>> 0, n3.putInt32(c2 >>> 0), c2 = i3 >>> 0;
      n3.putInt32(c2);
      var l2 = { h0: t8.h0, h1: t8.h1, h2: t8.h2, h3: t8.h3, h4: t8.h4, h5: t8.h5, h6: t8.h6, h7: t8.h7 };
      a2(l2, o2, n3);
      var h2 = xu.util.createBuffer();
      return h2.putInt32(l2.h0), h2.putInt32(l2.h1), h2.putInt32(l2.h2), h2.putInt32(l2.h3), h2.putInt32(l2.h4), h2.putInt32(l2.h5), h2.putInt32(l2.h6), h2.putInt32(l2.h7), h2;
    }, s2;
  };
  var r2 = null, n2 = false, i2 = null;
  function a2(t8, e3, r3) {
    for (var n3, a3, o2, s2, u2, c2, f2, l2, h2, p2, d2, y2, g2, v2 = r3.length(); v2 >= 64; ) {
      for (u2 = 0; u2 < 16; ++u2)
        e3[u2] = r3.getInt32();
      for (; u2 < 64; ++u2)
        n3 = ((n3 = e3[u2 - 2]) >>> 17 | n3 << 15) ^ (n3 >>> 19 | n3 << 13) ^ n3 >>> 10, a3 = ((a3 = e3[u2 - 15]) >>> 7 | a3 << 25) ^ (a3 >>> 18 | a3 << 14) ^ a3 >>> 3, e3[u2] = n3 + e3[u2 - 7] + a3 + e3[u2 - 16] | 0;
      for (c2 = t8.h0, f2 = t8.h1, l2 = t8.h2, h2 = t8.h3, p2 = t8.h4, d2 = t8.h5, y2 = t8.h6, g2 = t8.h7, u2 = 0; u2 < 64; ++u2)
        o2 = (c2 >>> 2 | c2 << 30) ^ (c2 >>> 13 | c2 << 19) ^ (c2 >>> 22 | c2 << 10), s2 = c2 & f2 | l2 & (c2 ^ f2), n3 = g2 + ((p2 >>> 6 | p2 << 26) ^ (p2 >>> 11 | p2 << 21) ^ (p2 >>> 25 | p2 << 7)) + (y2 ^ p2 & (d2 ^ y2)) + i2[u2] + e3[u2], g2 = y2, y2 = d2, d2 = p2, p2 = h2 + n3 >>> 0, h2 = l2, l2 = f2, f2 = c2, c2 = n3 + (a3 = o2 + s2) >>> 0;
      t8.h0 = t8.h0 + c2 | 0, t8.h1 = t8.h1 + f2 | 0, t8.h2 = t8.h2 + l2 | 0, t8.h3 = t8.h3 + h2 | 0, t8.h4 = t8.h4 + p2 | 0, t8.h5 = t8.h5 + d2 | 0, t8.h6 = t8.h6 + y2 | 0, t8.h7 = t8.h7 + g2 | 0, v2 -= 64;
    }
  }
}), w(function(t7) {
  var e2 = null;
  !xu.util.isNodejs || xu.options.usePureJavaScript || process.versions["node-webkit"] || (e2 = y.default), (t7.exports = xu.prng = xu.prng || {}).create = function(t8) {
    for (var r2 = { plugin: t8, key: null, seed: null, time: null, reseeds: 0, generated: 0, keyBytes: "" }, n2 = t8.md, i2 = new Array(32), a2 = 0; a2 < 32; ++a2)
      i2[a2] = n2.create();
    function o2() {
      if (r2.pools[0].messageLength >= 32)
        return s2();
      var t9 = 32 - r2.pools[0].messageLength << 5;
      r2.collect(r2.seedFileSync(t9)), s2();
    }
    function s2() {
      r2.reseeds = r2.reseeds === 4294967295 ? 0 : r2.reseeds + 1;
      var t9 = r2.plugin.md.create();
      t9.update(r2.keyBytes);
      for (var e3 = 1, n3 = 0; n3 < 32; ++n3)
        r2.reseeds % e3 == 0 && (t9.update(r2.pools[n3].digest().getBytes()), r2.pools[n3].start()), e3 <<= 1;
      r2.keyBytes = t9.digest().getBytes(), t9.start(), t9.update(r2.keyBytes);
      var i3 = t9.digest().getBytes();
      r2.key = r2.plugin.formatKey(r2.keyBytes), r2.seed = r2.plugin.formatSeed(i3), r2.generated = 0;
    }
    function u2(t9) {
      var e3 = null, r3 = xu.util.globalScope, n3 = r3.crypto || r3.msCrypto;
      n3 && n3.getRandomValues && (e3 = function(t10) {
        return n3.getRandomValues(t10);
      });
      var i3 = xu.util.createBuffer();
      if (e3)
        for (; i3.length() < t9; ) {
          var a3 = Math.max(1, Math.min(t9 - i3.length(), 65536) / 4), o3 = new Uint32Array(Math.floor(a3));
          try {
            e3(o3);
            for (var s3 = 0; s3 < o3.length; ++s3)
              i3.putInt32(o3[s3]);
          } catch (t10) {
            if (!(typeof QuotaExceededError != "undefined" && t10 instanceof QuotaExceededError))
              throw t10;
          }
        }
      if (i3.length() < t9)
        for (var u3, c2, f2, l2 = Math.floor(65536 * Math.random()); i3.length() < t9; ) {
          c2 = 16807 * (65535 & l2), c2 += (32767 & (u3 = 16807 * (l2 >> 16))) << 16, l2 = 4294967295 & (c2 = (2147483647 & (c2 += u3 >> 15)) + (c2 >> 31));
          for (s3 = 0; s3 < 3; ++s3)
            f2 = l2 >>> (s3 << 3), f2 ^= Math.floor(256 * Math.random()), i3.putByte(String.fromCharCode(255 & f2));
        }
      return i3.getBytes(t9);
    }
    return r2.pools = i2, r2.pool = 0, r2.generate = function(t9, e3) {
      if (!e3)
        return r2.generateSync(t9);
      var n3 = r2.plugin.cipher, i3 = r2.plugin.increment, a3 = r2.plugin.formatKey, o3 = r2.plugin.formatSeed, u3 = xu.util.createBuffer();
      r2.key = null, function c2(f2) {
        if (f2)
          return e3(f2);
        if (u3.length() >= t9)
          return e3(null, u3.getBytes(t9));
        r2.generated > 1048575 && (r2.key = null);
        if (r2.key === null)
          return xu.util.nextTick(function() {
            !function(t10) {
              if (r2.pools[0].messageLength >= 32)
                return s2(), t10();
              var e4 = 32 - r2.pools[0].messageLength << 5;
              r2.seedFile(e4, function(e5, n4) {
                if (e5)
                  return t10(e5);
                r2.collect(n4), s2(), t10();
              });
            }(c2);
          });
        var l2 = n3(r2.key, r2.seed);
        r2.generated += l2.length, u3.putBytes(l2), r2.key = a3(n3(r2.key, i3(r2.seed))), r2.seed = o3(n3(r2.key, r2.seed)), xu.util.setImmediate(c2);
      }();
    }, r2.generateSync = function(t9) {
      var e3 = r2.plugin.cipher, n3 = r2.plugin.increment, i3 = r2.plugin.formatKey, a3 = r2.plugin.formatSeed;
      r2.key = null;
      for (var s3 = xu.util.createBuffer(); s3.length() < t9; ) {
        r2.generated > 1048575 && (r2.key = null), r2.key === null && o2();
        var u3 = e3(r2.key, r2.seed);
        r2.generated += u3.length, s3.putBytes(u3), r2.key = i3(e3(r2.key, n3(r2.seed))), r2.seed = a3(e3(r2.key, r2.seed));
      }
      return s3.getBytes(t9);
    }, e2 ? (r2.seedFile = function(t9, r3) {
      e2.randomBytes(t9, function(t10, e3) {
        if (t10)
          return r3(t10);
        r3(null, e3.toString());
      });
    }, r2.seedFileSync = function(t9) {
      return e2.randomBytes(t9).toString();
    }) : (r2.seedFile = function(t9, e3) {
      try {
        e3(null, u2(t9));
      } catch (t10) {
        e3(t10);
      }
    }, r2.seedFileSync = u2), r2.collect = function(t9) {
      for (var e3 = t9.length, n3 = 0; n3 < e3; ++n3)
        r2.pools[r2.pool].update(t9.substr(n3, 1)), r2.pool = r2.pool === 31 ? 0 : r2.pool + 1;
    }, r2.collectInt = function(t9, e3) {
      for (var n3 = "", i3 = 0; i3 < e3; i3 += 8)
        n3 += String.fromCharCode(t9 >> i3 & 255);
      r2.collect(n3);
    }, r2.registerWorker = function(t9) {
      if (t9 === self)
        r2.seedFile = function(t10, e3) {
          self.addEventListener("message", function t11(r3) {
            var n3 = r3.data;
            n3.forge && n3.forge.prng && (self.removeEventListener("message", t11), e3(n3.forge.prng.err, n3.forge.prng.bytes));
          }), self.postMessage({ forge: { prng: { needed: t10 } } });
        };
      else {
        t9.addEventListener("message", function(e3) {
          var n3 = e3.data;
          n3.forge && n3.forge.prng && r2.seedFile(n3.forge.prng.needed, function(e4, r3) {
            t9.postMessage({ forge: { prng: { err: e4, bytes: r3 } } });
          });
        });
      }
    }, r2;
  };
}), w(function(t7) {
  xu.random && xu.random.getBytes ? t7.exports = xu.random : function(e2) {
    var r2 = {}, n2 = new Array(4), i2 = xu.util.createBuffer();
    function a2() {
      var t8 = xu.prng.create(r2);
      return t8.getBytes = function(e3, r3) {
        return t8.generate(e3, r3);
      }, t8.getBytesSync = function(e3) {
        return t8.generate(e3);
      }, t8;
    }
    r2.formatKey = function(t8) {
      var e3 = xu.util.createBuffer(t8);
      return (t8 = new Array(4))[0] = e3.getInt32(), t8[1] = e3.getInt32(), t8[2] = e3.getInt32(), t8[3] = e3.getInt32(), xu.aes._expandKey(t8, false);
    }, r2.formatSeed = function(t8) {
      var e3 = xu.util.createBuffer(t8);
      return (t8 = new Array(4))[0] = e3.getInt32(), t8[1] = e3.getInt32(), t8[2] = e3.getInt32(), t8[3] = e3.getInt32(), t8;
    }, r2.cipher = function(t8, e3) {
      return xu.aes._updateBlock(t8, e3, n2, false), i2.putInt32(n2[0]), i2.putInt32(n2[1]), i2.putInt32(n2[2]), i2.putInt32(n2[3]), i2.getBytes();
    }, r2.increment = function(t8) {
      return ++t8[3], t8;
    }, r2.md = xu.md.sha256;
    var o2 = a2(), s2 = null, u2 = xu.util.globalScope, c2 = u2.crypto || u2.msCrypto;
    if (c2 && c2.getRandomValues && (s2 = function(t8) {
      return c2.getRandomValues(t8);
    }), !xu.util.isNodejs && !s2) {
      if (o2.collectInt(+new Date(), 32), typeof navigator != "undefined") {
        var f2 = "";
        for (var l2 in navigator)
          try {
            typeof navigator[l2] == "string" && (f2 += navigator[l2]);
          } catch (t8) {
          }
        o2.collect(f2), f2 = null;
      }
      e2 && (e2().mousemove(function(t8) {
        o2.collectInt(t8.clientX, 16), o2.collectInt(t8.clientY, 16);
      }), e2().keypress(function(t8) {
        o2.collectInt(t8.charCode, 8);
      }));
    }
    if (xu.random)
      for (var l2 in o2)
        xu.random[l2] = o2[l2];
    else
      xu.random = o2;
    xu.random.createInstance = a2, t7.exports = xu.random;
  }(typeof jQuery != "undefined" ? jQuery : null);
});
var pc = [217, 120, 249, 196, 25, 221, 181, 237, 40, 233, 253, 121, 74, 160, 216, 157, 198, 126, 55, 131, 43, 118, 83, 142, 98, 76, 100, 136, 68, 139, 251, 162, 23, 154, 89, 245, 135, 179, 79, 19, 97, 69, 109, 141, 9, 129, 125, 50, 189, 143, 64, 235, 134, 183, 123, 11, 240, 149, 33, 34, 92, 107, 78, 130, 84, 214, 101, 147, 206, 96, 178, 28, 115, 86, 192, 20, 167, 140, 241, 220, 18, 117, 202, 31, 59, 190, 228, 209, 66, 61, 212, 48, 163, 60, 182, 38, 111, 191, 14, 218, 70, 105, 7, 87, 39, 242, 29, 155, 188, 148, 67, 3, 248, 17, 199, 246, 144, 239, 62, 231, 6, 195, 213, 47, 200, 102, 30, 215, 8, 232, 234, 222, 128, 82, 238, 247, 132, 170, 114, 172, 53, 77, 106, 42, 150, 26, 210, 113, 90, 21, 73, 116, 75, 159, 208, 94, 4, 24, 164, 236, 194, 224, 65, 110, 15, 81, 203, 204, 36, 145, 175, 80, 161, 244, 112, 57, 153, 124, 58, 133, 35, 184, 180, 122, 252, 2, 54, 91, 37, 85, 151, 49, 45, 93, 250, 152, 227, 138, 146, 174, 5, 223, 41, 16, 103, 108, 186, 201, 211, 0, 230, 207, 225, 158, 168, 44, 99, 22, 1, 63, 88, 226, 137, 169, 13, 56, 52, 27, 171, 51, 255, 176, 187, 72, 12, 95, 185, 177, 205, 46, 197, 243, 219, 71, 229, 165, 156, 119, 10, 166, 32, 104, 254, 127, 193, 173], dc = [1, 2, 3, 5], yc = function(t7, e2) {
  return t7 << e2 & 65535 | (65535 & t7) >> 16 - e2;
}, gc = function(t7, e2) {
  return (65535 & t7) >> e2 | t7 << 16 - e2 & 65535;
};
xu.rc2 = xu.rc2 || {}, xu.rc2.expandKey = function(t7, e2) {
  typeof t7 == "string" && (t7 = xu.util.createBuffer(t7)), e2 = e2 || 128;
  var r2, n2 = t7, i2 = t7.length(), a2 = e2, o2 = Math.ceil(a2 / 8), s2 = 255 >> (7 & a2);
  for (r2 = i2; r2 < 128; r2++)
    n2.putByte(pc[n2.at(r2 - 1) + n2.at(r2 - i2) & 255]);
  for (n2.setAt(128 - o2, pc[n2.at(128 - o2) & s2]), r2 = 127 - o2; r2 >= 0; r2--)
    n2.setAt(r2, pc[n2.at(r2 + 1) ^ n2.at(r2 + o2)]);
  return n2;
};
var vc, mc = function(t7, e2, r2) {
  var n2, i2, a2, o2, s2 = false, u2 = null, c2 = null, f2 = null, l2 = [];
  for (t7 = xu.rc2.expandKey(t7, e2), a2 = 0; a2 < 64; a2++)
    l2.push(t7.getInt16Le());
  r2 ? (n2 = function(t8) {
    for (a2 = 0; a2 < 4; a2++)
      t8[a2] += l2[o2] + (t8[(a2 + 3) % 4] & t8[(a2 + 2) % 4]) + (~t8[(a2 + 3) % 4] & t8[(a2 + 1) % 4]), t8[a2] = yc(t8[a2], dc[a2]), o2++;
  }, i2 = function(t8) {
    for (a2 = 0; a2 < 4; a2++)
      t8[a2] += l2[63 & t8[(a2 + 3) % 4]];
  }) : (n2 = function(t8) {
    for (a2 = 3; a2 >= 0; a2--)
      t8[a2] = gc(t8[a2], dc[a2]), t8[a2] -= l2[o2] + (t8[(a2 + 3) % 4] & t8[(a2 + 2) % 4]) + (~t8[(a2 + 3) % 4] & t8[(a2 + 1) % 4]), o2--;
  }, i2 = function(t8) {
    for (a2 = 3; a2 >= 0; a2--)
      t8[a2] -= l2[63 & t8[(a2 + 3) % 4]];
  });
  var h2 = function(t8) {
    var e3 = [];
    for (a2 = 0; a2 < 4; a2++) {
      var n3 = u2.getInt16Le();
      f2 !== null && (r2 ? n3 ^= f2.getInt16Le() : f2.putInt16Le(n3)), e3.push(65535 & n3);
    }
    o2 = r2 ? 0 : 63;
    for (var i3 = 0; i3 < t8.length; i3++)
      for (var s3 = 0; s3 < t8[i3][0]; s3++)
        t8[i3][1](e3);
    for (a2 = 0; a2 < 4; a2++)
      f2 !== null && (r2 ? f2.putInt16Le(e3[a2]) : e3[a2] ^= f2.getInt16Le()), c2.putInt16Le(e3[a2]);
  }, p2 = null;
  return p2 = { start: function(t8, e3) {
    t8 && typeof t8 == "string" && (t8 = xu.util.createBuffer(t8)), s2 = false, u2 = xu.util.createBuffer(), c2 = e3 || new xu.util.createBuffer(), f2 = t8, p2.output = c2;
  }, update: function(t8) {
    for (s2 || u2.putBuffer(t8); u2.length() >= 8; )
      h2([[5, n2], [1, i2], [6, n2], [1, i2], [5, n2]]);
  }, finish: function(t8) {
    var e3 = true;
    if (r2)
      if (t8)
        e3 = t8(8, u2, !r2);
      else {
        var n3 = u2.length() === 8 ? 8 : 8 - u2.length();
        u2.fillWithByte(n3, n3);
      }
    if (e3 && (s2 = true, p2.update()), !r2 && (e3 = u2.length() === 0))
      if (t8)
        e3 = t8(8, c2, !r2);
      else {
        var i3 = c2.length(), a3 = c2.at(i3 - 1);
        a3 > i3 ? e3 = false : c2.truncate(a3);
      }
    return e3;
  } };
};
function Cc(t7, e2, r2) {
  this.data = [], t7 != null && (typeof t7 == "number" ? this.fromNumber(t7, e2, r2) : e2 == null && typeof t7 != "string" ? this.fromString(t7, 256) : this.fromString(t7, e2));
}
function Ec() {
  return new Cc(null);
}
function Sc(t7, e2, r2, n2, i2, a2) {
  for (var o2 = 16383 & e2, s2 = e2 >> 14; --a2 >= 0; ) {
    var u2 = 16383 & this.data[t7], c2 = this.data[t7++] >> 14, f2 = s2 * u2 + c2 * o2;
    i2 = ((u2 = o2 * u2 + ((16383 & f2) << 14) + r2.data[n2] + i2) >> 28) + (f2 >> 14) + s2 * c2, r2.data[n2++] = 268435455 & u2;
  }
  return i2;
}
xu.rc2.startEncrypting = function(t7, e2, r2) {
  var n2 = xu.rc2.createEncryptionCipher(t7, 128);
  return n2.start(e2, r2), n2;
}, xu.rc2.createEncryptionCipher = function(t7, e2) {
  return mc(t7, e2, true);
}, xu.rc2.startDecrypting = function(t7, e2, r2) {
  var n2 = xu.rc2.createDecryptionCipher(t7, 128);
  return n2.start(e2, r2), n2;
}, xu.rc2.createDecryptionCipher = function(t7, e2) {
  return mc(t7, e2, false);
}, xu.jsbn = xu.jsbn || {}, xu.jsbn.BigInteger = Cc, typeof navigator == "undefined" ? (Cc.prototype.am = Sc, vc = 28) : navigator.appName == "Microsoft Internet Explorer" ? (Cc.prototype.am = function(t7, e2, r2, n2, i2, a2) {
  for (var o2 = 32767 & e2, s2 = e2 >> 15; --a2 >= 0; ) {
    var u2 = 32767 & this.data[t7], c2 = this.data[t7++] >> 15, f2 = s2 * u2 + c2 * o2;
    i2 = ((u2 = o2 * u2 + ((32767 & f2) << 15) + r2.data[n2] + (1073741823 & i2)) >>> 30) + (f2 >>> 15) + s2 * c2 + (i2 >>> 30), r2.data[n2++] = 1073741823 & u2;
  }
  return i2;
}, vc = 30) : navigator.appName != "Netscape" ? (Cc.prototype.am = function(t7, e2, r2, n2, i2, a2) {
  for (; --a2 >= 0; ) {
    var o2 = e2 * this.data[t7++] + r2.data[n2] + i2;
    i2 = Math.floor(o2 / 67108864), r2.data[n2++] = 67108863 & o2;
  }
  return i2;
}, vc = 26) : (Cc.prototype.am = Sc, vc = 28), Cc.prototype.DB = vc, Cc.prototype.DM = (1 << vc) - 1, Cc.prototype.DV = 1 << vc;
Cc.prototype.FV = Math.pow(2, 52), Cc.prototype.F1 = 52 - vc, Cc.prototype.F2 = 2 * vc - 52;
var bc, Tc, Ic = new Array();
for (bc = "0".charCodeAt(0), Tc = 0; Tc <= 9; ++Tc)
  Ic[bc++] = Tc;
for (bc = "a".charCodeAt(0), Tc = 10; Tc < 36; ++Tc)
  Ic[bc++] = Tc;
for (bc = "A".charCodeAt(0), Tc = 10; Tc < 36; ++Tc)
  Ic[bc++] = Tc;
function Ac(t7) {
  return "0123456789abcdefghijklmnopqrstuvwxyz".charAt(t7);
}
function wc(t7, e2) {
  var r2 = Ic[t7.charCodeAt(e2)];
  return r2 == null ? -1 : r2;
}
function _c(t7) {
  var e2 = Ec();
  return e2.fromInt(t7), e2;
}
function Bc(t7) {
  var e2, r2 = 1;
  return (e2 = t7 >>> 16) != 0 && (t7 = e2, r2 += 16), (e2 = t7 >> 8) != 0 && (t7 = e2, r2 += 8), (e2 = t7 >> 4) != 0 && (t7 = e2, r2 += 4), (e2 = t7 >> 2) != 0 && (t7 = e2, r2 += 2), (e2 = t7 >> 1) != 0 && (t7 = e2, r2 += 1), r2;
}
function Nc(t7) {
  this.m = t7;
}
function kc(t7) {
  this.m = t7, this.mp = t7.invDigit(), this.mpl = 32767 & this.mp, this.mph = this.mp >> 15, this.um = (1 << t7.DB - 15) - 1, this.mt2 = 2 * t7.t;
}
function Rc(t7, e2) {
  return t7 & e2;
}
function Oc(t7, e2) {
  return t7 | e2;
}
function Lc(t7, e2) {
  return t7 ^ e2;
}
function Pc(t7, e2) {
  return t7 & ~e2;
}
function Uc(t7) {
  if (t7 == 0)
    return -1;
  var e2 = 0;
  return (65535 & t7) == 0 && (t7 >>= 16, e2 += 16), (255 & t7) == 0 && (t7 >>= 8, e2 += 8), (15 & t7) == 0 && (t7 >>= 4, e2 += 4), (3 & t7) == 0 && (t7 >>= 2, e2 += 2), (1 & t7) == 0 && ++e2, e2;
}
function xc(t7) {
  for (var e2 = 0; t7 != 0; )
    t7 &= t7 - 1, ++e2;
  return e2;
}
function Dc() {
}
function Vc(t7) {
  return t7;
}
function Mc(t7) {
  this.r2 = Ec(), this.q3 = Ec(), Cc.ONE.dlShiftTo(2 * t7.t, this.r2), this.mu = this.r2.divide(t7), this.m = t7;
}
Nc.prototype.convert = function(t7) {
  return t7.s < 0 || t7.compareTo(this.m) >= 0 ? t7.mod(this.m) : t7;
}, Nc.prototype.revert = function(t7) {
  return t7;
}, Nc.prototype.reduce = function(t7) {
  t7.divRemTo(this.m, null, t7);
}, Nc.prototype.mulTo = function(t7, e2, r2) {
  t7.multiplyTo(e2, r2), this.reduce(r2);
}, Nc.prototype.sqrTo = function(t7, e2) {
  t7.squareTo(e2), this.reduce(e2);
}, kc.prototype.convert = function(t7) {
  var e2 = Ec();
  return t7.abs().dlShiftTo(this.m.t, e2), e2.divRemTo(this.m, null, e2), t7.s < 0 && e2.compareTo(Cc.ZERO) > 0 && this.m.subTo(e2, e2), e2;
}, kc.prototype.revert = function(t7) {
  var e2 = Ec();
  return t7.copyTo(e2), this.reduce(e2), e2;
}, kc.prototype.reduce = function(t7) {
  for (; t7.t <= this.mt2; )
    t7.data[t7.t++] = 0;
  for (var e2 = 0; e2 < this.m.t; ++e2) {
    var r2 = 32767 & t7.data[e2], n2 = r2 * this.mpl + ((r2 * this.mph + (t7.data[e2] >> 15) * this.mpl & this.um) << 15) & t7.DM;
    for (r2 = e2 + this.m.t, t7.data[r2] += this.m.am(0, n2, t7, e2, 0, this.m.t); t7.data[r2] >= t7.DV; )
      t7.data[r2] -= t7.DV, t7.data[++r2]++;
  }
  t7.clamp(), t7.drShiftTo(this.m.t, t7), t7.compareTo(this.m) >= 0 && t7.subTo(this.m, t7);
}, kc.prototype.mulTo = function(t7, e2, r2) {
  t7.multiplyTo(e2, r2), this.reduce(r2);
}, kc.prototype.sqrTo = function(t7, e2) {
  t7.squareTo(e2), this.reduce(e2);
}, Cc.prototype.copyTo = function(t7) {
  for (var e2 = this.t - 1; e2 >= 0; --e2)
    t7.data[e2] = this.data[e2];
  t7.t = this.t, t7.s = this.s;
}, Cc.prototype.fromInt = function(t7) {
  this.t = 1, this.s = t7 < 0 ? -1 : 0, t7 > 0 ? this.data[0] = t7 : t7 < -1 ? this.data[0] = t7 + this.DV : this.t = 0;
}, Cc.prototype.fromString = function(t7, e2) {
  var r2;
  if (e2 == 16)
    r2 = 4;
  else if (e2 == 8)
    r2 = 3;
  else if (e2 == 256)
    r2 = 8;
  else if (e2 == 2)
    r2 = 1;
  else if (e2 == 32)
    r2 = 5;
  else {
    if (e2 != 4)
      return void this.fromRadix(t7, e2);
    r2 = 2;
  }
  this.t = 0, this.s = 0;
  for (var n2 = t7.length, i2 = false, a2 = 0; --n2 >= 0; ) {
    var o2 = r2 == 8 ? 255 & t7[n2] : wc(t7, n2);
    o2 < 0 ? t7.charAt(n2) == "-" && (i2 = true) : (i2 = false, a2 == 0 ? this.data[this.t++] = o2 : a2 + r2 > this.DB ? (this.data[this.t - 1] |= (o2 & (1 << this.DB - a2) - 1) << a2, this.data[this.t++] = o2 >> this.DB - a2) : this.data[this.t - 1] |= o2 << a2, (a2 += r2) >= this.DB && (a2 -= this.DB));
  }
  r2 == 8 && (128 & t7[0]) != 0 && (this.s = -1, a2 > 0 && (this.data[this.t - 1] |= (1 << this.DB - a2) - 1 << a2)), this.clamp(), i2 && Cc.ZERO.subTo(this, this);
}, Cc.prototype.clamp = function() {
  for (var t7 = this.s & this.DM; this.t > 0 && this.data[this.t - 1] == t7; )
    --this.t;
}, Cc.prototype.dlShiftTo = function(t7, e2) {
  var r2;
  for (r2 = this.t - 1; r2 >= 0; --r2)
    e2.data[r2 + t7] = this.data[r2];
  for (r2 = t7 - 1; r2 >= 0; --r2)
    e2.data[r2] = 0;
  e2.t = this.t + t7, e2.s = this.s;
}, Cc.prototype.drShiftTo = function(t7, e2) {
  for (var r2 = t7; r2 < this.t; ++r2)
    e2.data[r2 - t7] = this.data[r2];
  e2.t = Math.max(this.t - t7, 0), e2.s = this.s;
}, Cc.prototype.lShiftTo = function(t7, e2) {
  var r2, n2 = t7 % this.DB, i2 = this.DB - n2, a2 = (1 << i2) - 1, o2 = Math.floor(t7 / this.DB), s2 = this.s << n2 & this.DM;
  for (r2 = this.t - 1; r2 >= 0; --r2)
    e2.data[r2 + o2 + 1] = this.data[r2] >> i2 | s2, s2 = (this.data[r2] & a2) << n2;
  for (r2 = o2 - 1; r2 >= 0; --r2)
    e2.data[r2] = 0;
  e2.data[o2] = s2, e2.t = this.t + o2 + 1, e2.s = this.s, e2.clamp();
}, Cc.prototype.rShiftTo = function(t7, e2) {
  e2.s = this.s;
  var r2 = Math.floor(t7 / this.DB);
  if (r2 >= this.t)
    e2.t = 0;
  else {
    var n2 = t7 % this.DB, i2 = this.DB - n2, a2 = (1 << n2) - 1;
    e2.data[0] = this.data[r2] >> n2;
    for (var o2 = r2 + 1; o2 < this.t; ++o2)
      e2.data[o2 - r2 - 1] |= (this.data[o2] & a2) << i2, e2.data[o2 - r2] = this.data[o2] >> n2;
    n2 > 0 && (e2.data[this.t - r2 - 1] |= (this.s & a2) << i2), e2.t = this.t - r2, e2.clamp();
  }
}, Cc.prototype.subTo = function(t7, e2) {
  for (var r2 = 0, n2 = 0, i2 = Math.min(t7.t, this.t); r2 < i2; )
    n2 += this.data[r2] - t7.data[r2], e2.data[r2++] = n2 & this.DM, n2 >>= this.DB;
  if (t7.t < this.t) {
    for (n2 -= t7.s; r2 < this.t; )
      n2 += this.data[r2], e2.data[r2++] = n2 & this.DM, n2 >>= this.DB;
    n2 += this.s;
  } else {
    for (n2 += this.s; r2 < t7.t; )
      n2 -= t7.data[r2], e2.data[r2++] = n2 & this.DM, n2 >>= this.DB;
    n2 -= t7.s;
  }
  e2.s = n2 < 0 ? -1 : 0, n2 < -1 ? e2.data[r2++] = this.DV + n2 : n2 > 0 && (e2.data[r2++] = n2), e2.t = r2, e2.clamp();
}, Cc.prototype.multiplyTo = function(t7, e2) {
  var r2 = this.abs(), n2 = t7.abs(), i2 = r2.t;
  for (e2.t = i2 + n2.t; --i2 >= 0; )
    e2.data[i2] = 0;
  for (i2 = 0; i2 < n2.t; ++i2)
    e2.data[i2 + r2.t] = r2.am(0, n2.data[i2], e2, i2, 0, r2.t);
  e2.s = 0, e2.clamp(), this.s != t7.s && Cc.ZERO.subTo(e2, e2);
}, Cc.prototype.squareTo = function(t7) {
  for (var e2 = this.abs(), r2 = t7.t = 2 * e2.t; --r2 >= 0; )
    t7.data[r2] = 0;
  for (r2 = 0; r2 < e2.t - 1; ++r2) {
    var n2 = e2.am(r2, e2.data[r2], t7, 2 * r2, 0, 1);
    (t7.data[r2 + e2.t] += e2.am(r2 + 1, 2 * e2.data[r2], t7, 2 * r2 + 1, n2, e2.t - r2 - 1)) >= e2.DV && (t7.data[r2 + e2.t] -= e2.DV, t7.data[r2 + e2.t + 1] = 1);
  }
  t7.t > 0 && (t7.data[t7.t - 1] += e2.am(r2, e2.data[r2], t7, 2 * r2, 0, 1)), t7.s = 0, t7.clamp();
}, Cc.prototype.divRemTo = function(t7, e2, r2) {
  var n2 = t7.abs();
  if (!(n2.t <= 0)) {
    var i2 = this.abs();
    if (i2.t < n2.t)
      return e2 != null && e2.fromInt(0), void (r2 != null && this.copyTo(r2));
    r2 == null && (r2 = Ec());
    var a2 = Ec(), o2 = this.s, s2 = t7.s, u2 = this.DB - Bc(n2.data[n2.t - 1]);
    u2 > 0 ? (n2.lShiftTo(u2, a2), i2.lShiftTo(u2, r2)) : (n2.copyTo(a2), i2.copyTo(r2));
    var c2 = a2.t, f2 = a2.data[c2 - 1];
    if (f2 != 0) {
      var l2 = f2 * (1 << this.F1) + (c2 > 1 ? a2.data[c2 - 2] >> this.F2 : 0), h2 = this.FV / l2, p2 = (1 << this.F1) / l2, d2 = 1 << this.F2, y2 = r2.t, g2 = y2 - c2, v2 = e2 == null ? Ec() : e2;
      for (a2.dlShiftTo(g2, v2), r2.compareTo(v2) >= 0 && (r2.data[r2.t++] = 1, r2.subTo(v2, r2)), Cc.ONE.dlShiftTo(c2, v2), v2.subTo(a2, a2); a2.t < c2; )
        a2.data[a2.t++] = 0;
      for (; --g2 >= 0; ) {
        var m2 = r2.data[--y2] == f2 ? this.DM : Math.floor(r2.data[y2] * h2 + (r2.data[y2 - 1] + d2) * p2);
        if ((r2.data[y2] += a2.am(0, m2, r2, g2, 0, c2)) < m2)
          for (a2.dlShiftTo(g2, v2), r2.subTo(v2, r2); r2.data[y2] < --m2; )
            r2.subTo(v2, r2);
      }
      e2 != null && (r2.drShiftTo(c2, e2), o2 != s2 && Cc.ZERO.subTo(e2, e2)), r2.t = c2, r2.clamp(), u2 > 0 && r2.rShiftTo(u2, r2), o2 < 0 && Cc.ZERO.subTo(r2, r2);
    }
  }
}, Cc.prototype.invDigit = function() {
  if (this.t < 1)
    return 0;
  var t7 = this.data[0];
  if ((1 & t7) == 0)
    return 0;
  var e2 = 3 & t7;
  return (e2 = (e2 = (e2 = (e2 = e2 * (2 - (15 & t7) * e2) & 15) * (2 - (255 & t7) * e2) & 255) * (2 - ((65535 & t7) * e2 & 65535)) & 65535) * (2 - t7 * e2 % this.DV) % this.DV) > 0 ? this.DV - e2 : -e2;
}, Cc.prototype.isEven = function() {
  return (this.t > 0 ? 1 & this.data[0] : this.s) == 0;
}, Cc.prototype.exp = function(t7, e2) {
  if (t7 > 4294967295 || t7 < 1)
    return Cc.ONE;
  var r2 = Ec(), n2 = Ec(), i2 = e2.convert(this), a2 = Bc(t7) - 1;
  for (i2.copyTo(r2); --a2 >= 0; )
    if (e2.sqrTo(r2, n2), (t7 & 1 << a2) > 0)
      e2.mulTo(n2, i2, r2);
    else {
      var o2 = r2;
      r2 = n2, n2 = o2;
    }
  return e2.revert(r2);
}, Cc.prototype.toString = function(t7) {
  if (this.s < 0)
    return "-" + this.negate().toString(t7);
  var e2;
  if (t7 == 16)
    e2 = 4;
  else if (t7 == 8)
    e2 = 3;
  else if (t7 == 2)
    e2 = 1;
  else if (t7 == 32)
    e2 = 5;
  else {
    if (t7 != 4)
      return this.toRadix(t7);
    e2 = 2;
  }
  var r2, n2 = (1 << e2) - 1, i2 = false, a2 = "", o2 = this.t, s2 = this.DB - o2 * this.DB % e2;
  if (o2-- > 0)
    for (s2 < this.DB && (r2 = this.data[o2] >> s2) > 0 && (i2 = true, a2 = Ac(r2)); o2 >= 0; )
      s2 < e2 ? (r2 = (this.data[o2] & (1 << s2) - 1) << e2 - s2, r2 |= this.data[--o2] >> (s2 += this.DB - e2)) : (r2 = this.data[o2] >> (s2 -= e2) & n2, s2 <= 0 && (s2 += this.DB, --o2)), r2 > 0 && (i2 = true), i2 && (a2 += Ac(r2));
  return i2 ? a2 : "0";
}, Cc.prototype.negate = function() {
  var t7 = Ec();
  return Cc.ZERO.subTo(this, t7), t7;
}, Cc.prototype.abs = function() {
  return this.s < 0 ? this.negate() : this;
}, Cc.prototype.compareTo = function(t7) {
  var e2 = this.s - t7.s;
  if (e2 != 0)
    return e2;
  var r2 = this.t;
  if ((e2 = r2 - t7.t) != 0)
    return this.s < 0 ? -e2 : e2;
  for (; --r2 >= 0; )
    if ((e2 = this.data[r2] - t7.data[r2]) != 0)
      return e2;
  return 0;
}, Cc.prototype.bitLength = function() {
  return this.t <= 0 ? 0 : this.DB * (this.t - 1) + Bc(this.data[this.t - 1] ^ this.s & this.DM);
}, Cc.prototype.mod = function(t7) {
  var e2 = Ec();
  return this.abs().divRemTo(t7, null, e2), this.s < 0 && e2.compareTo(Cc.ZERO) > 0 && t7.subTo(e2, e2), e2;
}, Cc.prototype.modPowInt = function(t7, e2) {
  var r2;
  return r2 = t7 < 256 || e2.isEven() ? new Nc(e2) : new kc(e2), this.exp(t7, r2);
}, Cc.ZERO = _c(0), Cc.ONE = _c(1), Dc.prototype.convert = Vc, Dc.prototype.revert = Vc, Dc.prototype.mulTo = function(t7, e2, r2) {
  t7.multiplyTo(e2, r2);
}, Dc.prototype.sqrTo = function(t7, e2) {
  t7.squareTo(e2);
}, Mc.prototype.convert = function(t7) {
  if (t7.s < 0 || t7.t > 2 * this.m.t)
    return t7.mod(this.m);
  if (t7.compareTo(this.m) < 0)
    return t7;
  var e2 = Ec();
  return t7.copyTo(e2), this.reduce(e2), e2;
}, Mc.prototype.revert = function(t7) {
  return t7;
}, Mc.prototype.reduce = function(t7) {
  for (t7.drShiftTo(this.m.t - 1, this.r2), t7.t > this.m.t + 1 && (t7.t = this.m.t + 1, t7.clamp()), this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3), this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); t7.compareTo(this.r2) < 0; )
    t7.dAddOffset(1, this.m.t + 1);
  for (t7.subTo(this.r2, t7); t7.compareTo(this.m) >= 0; )
    t7.subTo(this.m, t7);
}, Mc.prototype.mulTo = function(t7, e2, r2) {
  t7.multiplyTo(e2, r2), this.reduce(r2);
}, Mc.prototype.sqrTo = function(t7, e2) {
  t7.squareTo(e2), this.reduce(e2);
};
var jc = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509], Fc = (1 << 26) / jc[jc.length - 1];
if (Cc.prototype.chunkSize = function(t7) {
  return Math.floor(Math.LN2 * this.DB / Math.log(t7));
}, Cc.prototype.toRadix = function(t7) {
  if (t7 == null && (t7 = 10), this.signum() == 0 || t7 < 2 || t7 > 36)
    return "0";
  var e2 = this.chunkSize(t7), r2 = Math.pow(t7, e2), n2 = _c(r2), i2 = Ec(), a2 = Ec(), o2 = "";
  for (this.divRemTo(n2, i2, a2); i2.signum() > 0; )
    o2 = (r2 + a2.intValue()).toString(t7).substr(1) + o2, i2.divRemTo(n2, i2, a2);
  return a2.intValue().toString(t7) + o2;
}, Cc.prototype.fromRadix = function(t7, e2) {
  this.fromInt(0), e2 == null && (e2 = 10);
  for (var r2 = this.chunkSize(e2), n2 = Math.pow(e2, r2), i2 = false, a2 = 0, o2 = 0, s2 = 0; s2 < t7.length; ++s2) {
    var u2 = wc(t7, s2);
    u2 < 0 ? t7.charAt(s2) == "-" && this.signum() == 0 && (i2 = true) : (o2 = e2 * o2 + u2, ++a2 >= r2 && (this.dMultiply(n2), this.dAddOffset(o2, 0), a2 = 0, o2 = 0));
  }
  a2 > 0 && (this.dMultiply(Math.pow(e2, a2)), this.dAddOffset(o2, 0)), i2 && Cc.ZERO.subTo(this, this);
}, Cc.prototype.fromNumber = function(t7, e2, r2) {
  if (typeof e2 == "number")
    if (t7 < 2)
      this.fromInt(1);
    else
      for (this.fromNumber(t7, r2), this.testBit(t7 - 1) || this.bitwiseTo(Cc.ONE.shiftLeft(t7 - 1), Oc, this), this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(e2); )
        this.dAddOffset(2, 0), this.bitLength() > t7 && this.subTo(Cc.ONE.shiftLeft(t7 - 1), this);
  else {
    var n2 = new Array(), i2 = 7 & t7;
    n2.length = 1 + (t7 >> 3), e2.nextBytes(n2), i2 > 0 ? n2[0] &= (1 << i2) - 1 : n2[0] = 0, this.fromString(n2, 256);
  }
}, Cc.prototype.bitwiseTo = function(t7, e2, r2) {
  var n2, i2, a2 = Math.min(t7.t, this.t);
  for (n2 = 0; n2 < a2; ++n2)
    r2.data[n2] = e2(this.data[n2], t7.data[n2]);
  if (t7.t < this.t) {
    for (i2 = t7.s & this.DM, n2 = a2; n2 < this.t; ++n2)
      r2.data[n2] = e2(this.data[n2], i2);
    r2.t = this.t;
  } else {
    for (i2 = this.s & this.DM, n2 = a2; n2 < t7.t; ++n2)
      r2.data[n2] = e2(i2, t7.data[n2]);
    r2.t = t7.t;
  }
  r2.s = e2(this.s, t7.s), r2.clamp();
}, Cc.prototype.changeBit = function(t7, e2) {
  var r2 = Cc.ONE.shiftLeft(t7);
  return this.bitwiseTo(r2, e2, r2), r2;
}, Cc.prototype.addTo = function(t7, e2) {
  for (var r2 = 0, n2 = 0, i2 = Math.min(t7.t, this.t); r2 < i2; )
    n2 += this.data[r2] + t7.data[r2], e2.data[r2++] = n2 & this.DM, n2 >>= this.DB;
  if (t7.t < this.t) {
    for (n2 += t7.s; r2 < this.t; )
      n2 += this.data[r2], e2.data[r2++] = n2 & this.DM, n2 >>= this.DB;
    n2 += this.s;
  } else {
    for (n2 += this.s; r2 < t7.t; )
      n2 += t7.data[r2], e2.data[r2++] = n2 & this.DM, n2 >>= this.DB;
    n2 += t7.s;
  }
  e2.s = n2 < 0 ? -1 : 0, n2 > 0 ? e2.data[r2++] = n2 : n2 < -1 && (e2.data[r2++] = this.DV + n2), e2.t = r2, e2.clamp();
}, Cc.prototype.dMultiply = function(t7) {
  this.data[this.t] = this.am(0, t7 - 1, this, 0, 0, this.t), ++this.t, this.clamp();
}, Cc.prototype.dAddOffset = function(t7, e2) {
  if (t7 != 0) {
    for (; this.t <= e2; )
      this.data[this.t++] = 0;
    for (this.data[e2] += t7; this.data[e2] >= this.DV; )
      this.data[e2] -= this.DV, ++e2 >= this.t && (this.data[this.t++] = 0), ++this.data[e2];
  }
}, Cc.prototype.multiplyLowerTo = function(t7, e2, r2) {
  var n2, i2 = Math.min(this.t + t7.t, e2);
  for (r2.s = 0, r2.t = i2; i2 > 0; )
    r2.data[--i2] = 0;
  for (n2 = r2.t - this.t; i2 < n2; ++i2)
    r2.data[i2 + this.t] = this.am(0, t7.data[i2], r2, i2, 0, this.t);
  for (n2 = Math.min(t7.t, e2); i2 < n2; ++i2)
    this.am(0, t7.data[i2], r2, i2, 0, e2 - i2);
  r2.clamp();
}, Cc.prototype.multiplyUpperTo = function(t7, e2, r2) {
  --e2;
  var n2 = r2.t = this.t + t7.t - e2;
  for (r2.s = 0; --n2 >= 0; )
    r2.data[n2] = 0;
  for (n2 = Math.max(e2 - this.t, 0); n2 < t7.t; ++n2)
    r2.data[this.t + n2 - e2] = this.am(e2 - n2, t7.data[n2], r2, 0, 0, this.t + n2 - e2);
  r2.clamp(), r2.drShiftTo(1, r2);
}, Cc.prototype.modInt = function(t7) {
  if (t7 <= 0)
    return 0;
  var e2 = this.DV % t7, r2 = this.s < 0 ? t7 - 1 : 0;
  if (this.t > 0)
    if (e2 == 0)
      r2 = this.data[0] % t7;
    else
      for (var n2 = this.t - 1; n2 >= 0; --n2)
        r2 = (e2 * r2 + this.data[n2]) % t7;
  return r2;
}, Cc.prototype.millerRabin = function(t7) {
  var e2 = this.subtract(Cc.ONE), r2 = e2.getLowestSetBit();
  if (r2 <= 0)
    return false;
  for (var n2, i2 = e2.shiftRight(r2), a2 = { nextBytes: function(t8) {
    for (var e3 = 0; e3 < t8.length; ++e3)
      t8[e3] = Math.floor(256 * Math.random());
  } }, o2 = 0; o2 < t7; ++o2) {
    do {
      n2 = new Cc(this.bitLength(), a2);
    } while (n2.compareTo(Cc.ONE) <= 0 || n2.compareTo(e2) >= 0);
    var s2 = n2.modPow(i2, this);
    if (s2.compareTo(Cc.ONE) != 0 && s2.compareTo(e2) != 0) {
      for (var u2 = 1; u2++ < r2 && s2.compareTo(e2) != 0; )
        if ((s2 = s2.modPowInt(2, this)).compareTo(Cc.ONE) == 0)
          return false;
      if (s2.compareTo(e2) != 0)
        return false;
    }
  }
  return true;
}, Cc.prototype.clone = function() {
  var t7 = Ec();
  return this.copyTo(t7), t7;
}, Cc.prototype.intValue = function() {
  if (this.s < 0) {
    if (this.t == 1)
      return this.data[0] - this.DV;
    if (this.t == 0)
      return -1;
  } else {
    if (this.t == 1)
      return this.data[0];
    if (this.t == 0)
      return 0;
  }
  return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
}, Cc.prototype.byteValue = function() {
  return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
}, Cc.prototype.shortValue = function() {
  return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
}, Cc.prototype.signum = function() {
  return this.s < 0 ? -1 : this.t <= 0 || this.t == 1 && this.data[0] <= 0 ? 0 : 1;
}, Cc.prototype.toByteArray = function() {
  var t7 = this.t, e2 = new Array();
  e2[0] = this.s;
  var r2, n2 = this.DB - t7 * this.DB % 8, i2 = 0;
  if (t7-- > 0)
    for (n2 < this.DB && (r2 = this.data[t7] >> n2) != (this.s & this.DM) >> n2 && (e2[i2++] = r2 | this.s << this.DB - n2); t7 >= 0; )
      n2 < 8 ? (r2 = (this.data[t7] & (1 << n2) - 1) << 8 - n2, r2 |= this.data[--t7] >> (n2 += this.DB - 8)) : (r2 = this.data[t7] >> (n2 -= 8) & 255, n2 <= 0 && (n2 += this.DB, --t7)), (128 & r2) != 0 && (r2 |= -256), i2 == 0 && (128 & this.s) != (128 & r2) && ++i2, (i2 > 0 || r2 != this.s) && (e2[i2++] = r2);
  return e2;
}, Cc.prototype.equals = function(t7) {
  return this.compareTo(t7) == 0;
}, Cc.prototype.min = function(t7) {
  return this.compareTo(t7) < 0 ? this : t7;
}, Cc.prototype.max = function(t7) {
  return this.compareTo(t7) > 0 ? this : t7;
}, Cc.prototype.and = function(t7) {
  var e2 = Ec();
  return this.bitwiseTo(t7, Rc, e2), e2;
}, Cc.prototype.or = function(t7) {
  var e2 = Ec();
  return this.bitwiseTo(t7, Oc, e2), e2;
}, Cc.prototype.xor = function(t7) {
  var e2 = Ec();
  return this.bitwiseTo(t7, Lc, e2), e2;
}, Cc.prototype.andNot = function(t7) {
  var e2 = Ec();
  return this.bitwiseTo(t7, Pc, e2), e2;
}, Cc.prototype.not = function() {
  for (var t7 = Ec(), e2 = 0; e2 < this.t; ++e2)
    t7.data[e2] = this.DM & ~this.data[e2];
  return t7.t = this.t, t7.s = ~this.s, t7;
}, Cc.prototype.shiftLeft = function(t7) {
  var e2 = Ec();
  return t7 < 0 ? this.rShiftTo(-t7, e2) : this.lShiftTo(t7, e2), e2;
}, Cc.prototype.shiftRight = function(t7) {
  var e2 = Ec();
  return t7 < 0 ? this.lShiftTo(-t7, e2) : this.rShiftTo(t7, e2), e2;
}, Cc.prototype.getLowestSetBit = function() {
  for (var t7 = 0; t7 < this.t; ++t7)
    if (this.data[t7] != 0)
      return t7 * this.DB + Uc(this.data[t7]);
  return this.s < 0 ? this.t * this.DB : -1;
}, Cc.prototype.bitCount = function() {
  for (var t7 = 0, e2 = this.s & this.DM, r2 = 0; r2 < this.t; ++r2)
    t7 += xc(this.data[r2] ^ e2);
  return t7;
}, Cc.prototype.testBit = function(t7) {
  var e2 = Math.floor(t7 / this.DB);
  return e2 >= this.t ? this.s != 0 : (this.data[e2] & 1 << t7 % this.DB) != 0;
}, Cc.prototype.setBit = function(t7) {
  return this.changeBit(t7, Oc);
}, Cc.prototype.clearBit = function(t7) {
  return this.changeBit(t7, Pc);
}, Cc.prototype.flipBit = function(t7) {
  return this.changeBit(t7, Lc);
}, Cc.prototype.add = function(t7) {
  var e2 = Ec();
  return this.addTo(t7, e2), e2;
}, Cc.prototype.subtract = function(t7) {
  var e2 = Ec();
  return this.subTo(t7, e2), e2;
}, Cc.prototype.multiply = function(t7) {
  var e2 = Ec();
  return this.multiplyTo(t7, e2), e2;
}, Cc.prototype.divide = function(t7) {
  var e2 = Ec();
  return this.divRemTo(t7, e2, null), e2;
}, Cc.prototype.remainder = function(t7) {
  var e2 = Ec();
  return this.divRemTo(t7, null, e2), e2;
}, Cc.prototype.divideAndRemainder = function(t7) {
  var e2 = Ec(), r2 = Ec();
  return this.divRemTo(t7, e2, r2), new Array(e2, r2);
}, Cc.prototype.modPow = function(t7, e2) {
  var r2, n2, i2 = t7.bitLength(), a2 = _c(1);
  if (i2 <= 0)
    return a2;
  r2 = i2 < 18 ? 1 : i2 < 48 ? 3 : i2 < 144 ? 4 : i2 < 768 ? 5 : 6, n2 = i2 < 8 ? new Nc(e2) : e2.isEven() ? new Mc(e2) : new kc(e2);
  var o2 = new Array(), s2 = 3, u2 = r2 - 1, c2 = (1 << r2) - 1;
  if (o2[1] = n2.convert(this), r2 > 1) {
    var f2 = Ec();
    for (n2.sqrTo(o2[1], f2); s2 <= c2; )
      o2[s2] = Ec(), n2.mulTo(f2, o2[s2 - 2], o2[s2]), s2 += 2;
  }
  var l2, h2, p2 = t7.t - 1, d2 = true, y2 = Ec();
  for (i2 = Bc(t7.data[p2]) - 1; p2 >= 0; ) {
    for (i2 >= u2 ? l2 = t7.data[p2] >> i2 - u2 & c2 : (l2 = (t7.data[p2] & (1 << i2 + 1) - 1) << u2 - i2, p2 > 0 && (l2 |= t7.data[p2 - 1] >> this.DB + i2 - u2)), s2 = r2; (1 & l2) == 0; )
      l2 >>= 1, --s2;
    if ((i2 -= s2) < 0 && (i2 += this.DB, --p2), d2)
      o2[l2].copyTo(a2), d2 = false;
    else {
      for (; s2 > 1; )
        n2.sqrTo(a2, y2), n2.sqrTo(y2, a2), s2 -= 2;
      s2 > 0 ? n2.sqrTo(a2, y2) : (h2 = a2, a2 = y2, y2 = h2), n2.mulTo(y2, o2[l2], a2);
    }
    for (; p2 >= 0 && (t7.data[p2] & 1 << i2) == 0; )
      n2.sqrTo(a2, y2), h2 = a2, a2 = y2, y2 = h2, --i2 < 0 && (i2 = this.DB - 1, --p2);
  }
  return n2.revert(a2);
}, Cc.prototype.modInverse = function(t7) {
  var e2 = t7.isEven();
  if (this.isEven() && e2 || t7.signum() == 0)
    return Cc.ZERO;
  for (var r2 = t7.clone(), n2 = this.clone(), i2 = _c(1), a2 = _c(0), o2 = _c(0), s2 = _c(1); r2.signum() != 0; ) {
    for (; r2.isEven(); )
      r2.rShiftTo(1, r2), e2 ? (i2.isEven() && a2.isEven() || (i2.addTo(this, i2), a2.subTo(t7, a2)), i2.rShiftTo(1, i2)) : a2.isEven() || a2.subTo(t7, a2), a2.rShiftTo(1, a2);
    for (; n2.isEven(); )
      n2.rShiftTo(1, n2), e2 ? (o2.isEven() && s2.isEven() || (o2.addTo(this, o2), s2.subTo(t7, s2)), o2.rShiftTo(1, o2)) : s2.isEven() || s2.subTo(t7, s2), s2.rShiftTo(1, s2);
    r2.compareTo(n2) >= 0 ? (r2.subTo(n2, r2), e2 && i2.subTo(o2, i2), a2.subTo(s2, a2)) : (n2.subTo(r2, n2), e2 && o2.subTo(i2, o2), s2.subTo(a2, s2));
  }
  return n2.compareTo(Cc.ONE) != 0 ? Cc.ZERO : s2.compareTo(t7) >= 0 ? s2.subtract(t7) : s2.signum() < 0 ? (s2.addTo(t7, s2), s2.signum() < 0 ? s2.add(t7) : s2) : s2;
}, Cc.prototype.pow = function(t7) {
  return this.exp(t7, new Dc());
}, Cc.prototype.gcd = function(t7) {
  var e2 = this.s < 0 ? this.negate() : this.clone(), r2 = t7.s < 0 ? t7.negate() : t7.clone();
  if (e2.compareTo(r2) < 0) {
    var n2 = e2;
    e2 = r2, r2 = n2;
  }
  var i2 = e2.getLowestSetBit(), a2 = r2.getLowestSetBit();
  if (a2 < 0)
    return e2;
  for (i2 < a2 && (a2 = i2), a2 > 0 && (e2.rShiftTo(a2, e2), r2.rShiftTo(a2, r2)); e2.signum() > 0; )
    (i2 = e2.getLowestSetBit()) > 0 && e2.rShiftTo(i2, e2), (i2 = r2.getLowestSetBit()) > 0 && r2.rShiftTo(i2, r2), e2.compareTo(r2) >= 0 ? (e2.subTo(r2, e2), e2.rShiftTo(1, e2)) : (r2.subTo(e2, r2), r2.rShiftTo(1, r2));
  return a2 > 0 && r2.lShiftTo(a2, r2), r2;
}, Cc.prototype.isProbablePrime = function(t7) {
  var e2, r2 = this.abs();
  if (r2.t == 1 && r2.data[0] <= jc[jc.length - 1]) {
    for (e2 = 0; e2 < jc.length; ++e2)
      if (r2.data[0] == jc[e2])
        return true;
    return false;
  }
  if (r2.isEven())
    return false;
  for (e2 = 1; e2 < jc.length; ) {
    for (var n2 = jc[e2], i2 = e2 + 1; i2 < jc.length && n2 < Fc; )
      n2 *= jc[i2++];
    for (n2 = r2.modInt(n2); e2 < i2; )
      if (n2 % jc[e2++] == 0)
        return false;
  }
  return r2.millerRabin(t7);
}, w(function(t7) {
  var e2 = t7.exports = xu.sha1 = xu.sha1 || {};
  xu.md.sha1 = xu.md.algorithms.sha1 = e2, e2.create = function() {
    n2 || (r2 = String.fromCharCode(128), r2 += xu.util.fillString(String.fromCharCode(0), 64), n2 = true);
    var t8 = null, e3 = xu.util.createBuffer(), a2 = new Array(80), o2 = { algorithm: "sha1", blockLength: 64, digestLength: 20, messageLength: 0, fullMessageLength: null, messageLengthSize: 8, start: function() {
      o2.messageLength = 0, o2.fullMessageLength = o2.messageLength64 = [];
      for (var r3 = o2.messageLengthSize / 4, n3 = 0; n3 < r3; ++n3)
        o2.fullMessageLength.push(0);
      return e3 = xu.util.createBuffer(), t8 = { h0: 1732584193, h1: 4023233417, h2: 2562383102, h3: 271733878, h4: 3285377520 }, o2;
    } };
    return o2.start(), o2.update = function(r3, n3) {
      n3 === "utf8" && (r3 = xu.util.encodeUtf8(r3));
      var s2 = r3.length;
      o2.messageLength += s2, s2 = [s2 / 4294967296 >>> 0, s2 >>> 0];
      for (var u2 = o2.fullMessageLength.length - 1; u2 >= 0; --u2)
        o2.fullMessageLength[u2] += s2[1], s2[1] = s2[0] + (o2.fullMessageLength[u2] / 4294967296 >>> 0), o2.fullMessageLength[u2] = o2.fullMessageLength[u2] >>> 0, s2[0] = s2[1] / 4294967296 >>> 0;
      return e3.putBytes(r3), i2(t8, a2, e3), (e3.read > 2048 || e3.length() === 0) && e3.compact(), o2;
    }, o2.digest = function() {
      var n3 = xu.util.createBuffer();
      n3.putBytes(e3.bytes());
      var s2, u2 = o2.fullMessageLength[o2.fullMessageLength.length - 1] + o2.messageLengthSize & o2.blockLength - 1;
      n3.putBytes(r2.substr(0, o2.blockLength - u2));
      for (var c2 = 8 * o2.fullMessageLength[0], f2 = 0; f2 < o2.fullMessageLength.length - 1; ++f2)
        c2 += (s2 = 8 * o2.fullMessageLength[f2 + 1]) / 4294967296 >>> 0, n3.putInt32(c2 >>> 0), c2 = s2 >>> 0;
      n3.putInt32(c2);
      var l2 = { h0: t8.h0, h1: t8.h1, h2: t8.h2, h3: t8.h3, h4: t8.h4 };
      i2(l2, a2, n3);
      var h2 = xu.util.createBuffer();
      return h2.putInt32(l2.h0), h2.putInt32(l2.h1), h2.putInt32(l2.h2), h2.putInt32(l2.h3), h2.putInt32(l2.h4), h2;
    }, o2;
  };
  var r2 = null, n2 = false;
  function i2(t8, e3, r3) {
    for (var n3, i3, a2, o2, s2, u2, c2, f2 = r3.length(); f2 >= 64; ) {
      for (i3 = t8.h0, a2 = t8.h1, o2 = t8.h2, s2 = t8.h3, u2 = t8.h4, c2 = 0; c2 < 16; ++c2)
        n3 = r3.getInt32(), e3[c2] = n3, n3 = (i3 << 5 | i3 >>> 27) + (s2 ^ a2 & (o2 ^ s2)) + u2 + 1518500249 + n3, u2 = s2, s2 = o2, o2 = (a2 << 30 | a2 >>> 2) >>> 0, a2 = i3, i3 = n3;
      for (; c2 < 20; ++c2)
        n3 = (n3 = e3[c2 - 3] ^ e3[c2 - 8] ^ e3[c2 - 14] ^ e3[c2 - 16]) << 1 | n3 >>> 31, e3[c2] = n3, n3 = (i3 << 5 | i3 >>> 27) + (s2 ^ a2 & (o2 ^ s2)) + u2 + 1518500249 + n3, u2 = s2, s2 = o2, o2 = (a2 << 30 | a2 >>> 2) >>> 0, a2 = i3, i3 = n3;
      for (; c2 < 32; ++c2)
        n3 = (n3 = e3[c2 - 3] ^ e3[c2 - 8] ^ e3[c2 - 14] ^ e3[c2 - 16]) << 1 | n3 >>> 31, e3[c2] = n3, n3 = (i3 << 5 | i3 >>> 27) + (a2 ^ o2 ^ s2) + u2 + 1859775393 + n3, u2 = s2, s2 = o2, o2 = (a2 << 30 | a2 >>> 2) >>> 0, a2 = i3, i3 = n3;
      for (; c2 < 40; ++c2)
        n3 = (n3 = e3[c2 - 6] ^ e3[c2 - 16] ^ e3[c2 - 28] ^ e3[c2 - 32]) << 2 | n3 >>> 30, e3[c2] = n3, n3 = (i3 << 5 | i3 >>> 27) + (a2 ^ o2 ^ s2) + u2 + 1859775393 + n3, u2 = s2, s2 = o2, o2 = (a2 << 30 | a2 >>> 2) >>> 0, a2 = i3, i3 = n3;
      for (; c2 < 60; ++c2)
        n3 = (n3 = e3[c2 - 6] ^ e3[c2 - 16] ^ e3[c2 - 28] ^ e3[c2 - 32]) << 2 | n3 >>> 30, e3[c2] = n3, n3 = (i3 << 5 | i3 >>> 27) + (a2 & o2 | s2 & (a2 ^ o2)) + u2 + 2400959708 + n3, u2 = s2, s2 = o2, o2 = (a2 << 30 | a2 >>> 2) >>> 0, a2 = i3, i3 = n3;
      for (; c2 < 80; ++c2)
        n3 = (n3 = e3[c2 - 6] ^ e3[c2 - 16] ^ e3[c2 - 28] ^ e3[c2 - 32]) << 2 | n3 >>> 30, e3[c2] = n3, n3 = (i3 << 5 | i3 >>> 27) + (a2 ^ o2 ^ s2) + u2 + 3395469782 + n3, u2 = s2, s2 = o2, o2 = (a2 << 30 | a2 >>> 2) >>> 0, a2 = i3, i3 = n3;
      t8.h0 = t8.h0 + i3 | 0, t8.h1 = t8.h1 + a2 | 0, t8.h2 = t8.h2 + o2 | 0, t8.h3 = t8.h3 + s2 | 0, t8.h4 = t8.h4 + u2 | 0, f2 -= 64;
    }
  }
}), w(function(t7) {
  var e2 = t7.exports = xu.pkcs1 = xu.pkcs1 || {};
  function r2(t8, e3, r3) {
    r3 || (r3 = xu.md.sha1.create());
    for (var n2 = "", i2 = Math.ceil(e3 / r3.digestLength), a2 = 0; a2 < i2; ++a2) {
      var o2 = String.fromCharCode(a2 >> 24 & 255, a2 >> 16 & 255, a2 >> 8 & 255, 255 & a2);
      r3.start(), r3.update(t8 + o2), n2 += r3.digest().getBytes();
    }
    return n2.substring(0, e3);
  }
  e2.encode_rsa_oaep = function(t8, e3, n2) {
    var i2, a2, o2, s2;
    typeof n2 == "string" ? (i2 = n2, a2 = arguments[3] || void 0, o2 = arguments[4] || void 0) : n2 && (i2 = n2.label || void 0, a2 = n2.seed || void 0, o2 = n2.md || void 0, n2.mgf1 && n2.mgf1.md && (s2 = n2.mgf1.md)), o2 ? o2.start() : o2 = xu.md.sha1.create(), s2 || (s2 = o2);
    var u2 = Math.ceil(t8.n.bitLength() / 8), c2 = u2 - 2 * o2.digestLength - 2;
    if (e3.length > c2)
      throw (y2 = new Error("RSAES-OAEP input message length is too long.")).length = e3.length, y2.maxLength = c2, y2;
    i2 || (i2 = ""), o2.update(i2, "raw");
    for (var f2 = o2.digest(), l2 = "", h2 = c2 - e3.length, p2 = 0; p2 < h2; p2++)
      l2 += "\0";
    var d2 = f2.getBytes() + l2 + "" + e3;
    if (a2) {
      if (a2.length !== o2.digestLength) {
        var y2;
        throw (y2 = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.")).seedLength = a2.length, y2.digestLength = o2.digestLength, y2;
      }
    } else
      a2 = xu.random.getBytes(o2.digestLength);
    var g2 = r2(a2, u2 - o2.digestLength - 1, s2), v2 = xu.util.xorBytes(d2, g2, d2.length), m2 = r2(v2, o2.digestLength, s2), C2 = xu.util.xorBytes(a2, m2, a2.length);
    return "\0" + C2 + v2;
  }, e2.decode_rsa_oaep = function(t8, e3, n2) {
    var i2, a2, o2;
    typeof n2 == "string" ? (i2 = n2, a2 = arguments[3] || void 0) : n2 && (i2 = n2.label || void 0, a2 = n2.md || void 0, n2.mgf1 && n2.mgf1.md && (o2 = n2.mgf1.md));
    var s2 = Math.ceil(t8.n.bitLength() / 8);
    if (e3.length !== s2)
      throw (v2 = new Error("RSAES-OAEP encoded message length is invalid.")).length = e3.length, v2.expectedLength = s2, v2;
    if (a2 === void 0 ? a2 = xu.md.sha1.create() : a2.start(), o2 || (o2 = a2), s2 < 2 * a2.digestLength + 2)
      throw new Error("RSAES-OAEP key is too short for the hash function.");
    i2 || (i2 = ""), a2.update(i2, "raw");
    for (var u2 = a2.digest().getBytes(), c2 = e3.charAt(0), f2 = e3.substring(1, a2.digestLength + 1), l2 = e3.substring(1 + a2.digestLength), h2 = r2(l2, a2.digestLength, o2), p2 = xu.util.xorBytes(f2, h2, f2.length), d2 = r2(p2, s2 - a2.digestLength - 1, o2), y2 = xu.util.xorBytes(l2, d2, l2.length), g2 = y2.substring(0, a2.digestLength), v2 = c2 !== "\0", m2 = 0; m2 < a2.digestLength; ++m2)
      v2 |= u2.charAt(m2) !== g2.charAt(m2);
    for (var C2 = 1, E2 = a2.digestLength, S2 = a2.digestLength; S2 < y2.length; S2++) {
      var b2 = y2.charCodeAt(S2), T2 = 1 & b2 ^ 1, I2 = C2 ? 65534 : 0;
      v2 |= b2 & I2, E2 += C2 &= T2;
    }
    if (v2 || y2.charCodeAt(E2) !== 1)
      throw new Error("Invalid RSAES-OAEP padding.");
    return y2.substring(E2 + 1);
  };
}), w(function(t7) {
  !function() {
    if (xu.prime)
      t7.exports = xu.prime;
    else {
      var e2 = t7.exports = xu.prime = xu.prime || {}, r2 = xu.jsbn.BigInteger, n2 = [6, 4, 2, 4, 2, 4, 6, 2], i2 = new r2(null);
      i2.fromInt(30);
      var a2 = function(t8, e3) {
        return t8 | e3;
      };
      e2.generateProbablePrime = function(t8, e3, n3) {
        typeof e3 == "function" && (n3 = e3, e3 = {});
        var i3 = (e3 = e3 || {}).algorithm || "PRIMEINC";
        typeof i3 == "string" && (i3 = { name: i3 }), i3.options = i3.options || {};
        var a3 = e3.prng || xu.random, s3 = { nextBytes: function(t9) {
          for (var e4 = a3.getBytesSync(t9.length), r3 = 0; r3 < t9.length; ++r3)
            t9[r3] = e4.charCodeAt(r3);
        } };
        if (i3.name === "PRIMEINC")
          return function(t9, e4, n4, i4) {
            if ("workers" in n4)
              return function(t10, e5, n5, i5) {
                if (typeof Worker == "undefined")
                  return o2(t10, e5, n5, i5);
                var a4 = u2(t10, e5), s4 = n5.workers, c2 = n5.workLoad || 100, f2 = 30 * c2 / 8, l2 = n5.workerScript || "forge/prime.worker.js";
                if (s4 === -1)
                  return xu.util.estimateCores(function(t11, e6) {
                    t11 && (e6 = 2), s4 = e6 - 1, h2();
                  });
                function h2() {
                  s4 = Math.max(1, s4);
                  for (var n6 = [], o3 = 0; o3 < s4; ++o3)
                    n6[o3] = new Worker(l2);
                  for (o3 = 0; o3 < s4; ++o3)
                    n6[o3].addEventListener("message", p2);
                  var h3 = false;
                  function p2(o4) {
                    if (!h3) {
                      var s5 = o4.data;
                      if (s5.found) {
                        for (var l3 = 0; l3 < n6.length; ++l3)
                          n6[l3].terminate();
                        return h3 = true, i5(null, new r2(s5.prime, 16));
                      }
                      a4.bitLength() > t10 && (a4 = u2(t10, e5));
                      var p3 = a4.toString(16);
                      o4.target.postMessage({ hex: p3, workLoad: c2 }), a4.dAddOffset(f2, 0);
                    }
                  }
                }
                h2();
              }(t9, e4, n4, i4);
            return o2(t9, e4, n4, i4);
          }(t8, s3, i3.options, n3);
        throw new Error("Invalid prime generation algorithm: " + i3.name);
      };
    }
    function o2(t8, e3, r3, n3) {
      var i3 = u2(t8, e3), a3 = function(t9) {
        return t9 <= 100 ? 27 : t9 <= 150 ? 18 : t9 <= 200 ? 15 : t9 <= 250 ? 12 : t9 <= 300 ? 9 : t9 <= 350 ? 8 : t9 <= 400 ? 7 : t9 <= 500 ? 6 : t9 <= 600 ? 5 : t9 <= 800 ? 4 : t9 <= 1250 ? 3 : 2;
      }(i3.bitLength());
      "millerRabinTests" in r3 && (a3 = r3.millerRabinTests);
      var o3 = 10;
      "maxBlockTime" in r3 && (o3 = r3.maxBlockTime), s2(i3, t8, e3, 0, a3, o3, n3);
    }
    function s2(t8, e3, r3, i3, a3, o3, c2) {
      var f2 = +new Date();
      do {
        if (t8.bitLength() > e3 && (t8 = u2(e3, r3)), t8.isProbablePrime(a3))
          return c2(null, t8);
        t8.dAddOffset(n2[i3++ % 8], 0);
      } while (o3 < 0 || +new Date() - f2 < o3);
      xu.util.setImmediate(function() {
        s2(t8, e3, r3, i3, a3, o3, c2);
      });
    }
    function u2(t8, e3) {
      var n3 = new r2(t8, e3), o3 = t8 - 1;
      return n3.testBit(o3) || n3.bitwiseTo(r2.ONE.shiftLeft(o3), a2, n3), n3.dAddOffset(31 - n3.mod(i2).byteValue(), 0), n3;
    }
  }();
}), Kc === void 0)
  var Kc = xu.jsbn.BigInteger;
var qc = xu.util.isNodejs ? y.default : null, Gc = xu.asn1, zc = xu.util;
xu.pki = xu.pki || {}, xu.pki.rsa = xu.rsa = xu.rsa || {};
var Wc = xu.pki, Hc = [6, 4, 2, 4, 2, 4, 6, 2], Qc = { name: "PrivateKeyInfo", tagClass: Gc.Class.UNIVERSAL, type: Gc.Type.SEQUENCE, constructed: true, value: [{ name: "PrivateKeyInfo.version", tagClass: Gc.Class.UNIVERSAL, type: Gc.Type.INTEGER, constructed: false, capture: "privateKeyVersion" }, { name: "PrivateKeyInfo.privateKeyAlgorithm", tagClass: Gc.Class.UNIVERSAL, type: Gc.Type.SEQUENCE, constructed: true, value: [{ name: "AlgorithmIdentifier.algorithm", tagClass: Gc.Class.UNIVERSAL, type: Gc.Type.OID, constructed: false, capture: "privateKeyOid" }] }, { name: "PrivateKeyInfo", tagClass: Gc.Class.UNIVERSAL, type: Gc.Type.OCTETSTRING, constructed: false, capture: "privateKey" }] }, Yc = { name: "RSAPrivateKey", tagClass: Gc.Class.UNIVERSAL, type: Gc.Type.SEQUENCE, constructed: true, value: [{ name: "RSAPrivateKey.version", tagClass: Gc.Class.UNIVERSAL, type: Gc.Type.INTEGER, constructed: false, capture: "privateKeyVersion" }, { name: "RSAPrivateKey.modulus", tagClass: Gc.Class.UNIVERSAL, type: Gc.Type.INTEGER, constructed: false, capture: "privateKeyModulus" }, { name: "RSAPrivateKey.publicExponent", tagClass: Gc.Class.UNIVERSAL, type: Gc.Type.INTEGER, constructed: false, capture: "privateKeyPublicExponent" }, { name: "RSAPrivateKey.privateExponent", tagClass: Gc.Class.UNIVERSAL, type: Gc.Type.INTEGER, constructed: false, capture: "privateKeyPrivateExponent" }, { name: "RSAPrivateKey.prime1", tagClass: Gc.Class.UNIVERSAL, type: Gc.Type.INTEGER, constructed: false, capture: "privateKeyPrime1" }, { name: "RSAPrivateKey.prime2", tagClass: Gc.Class.UNIVERSAL, type: Gc.Type.INTEGER, constructed: false, capture: "privateKeyPrime2" }, { name: "RSAPrivateKey.exponent1", tagClass: Gc.Class.UNIVERSAL, type: Gc.Type.INTEGER, constructed: false, capture: "privateKeyExponent1" }, { name: "RSAPrivateKey.exponent2", tagClass: Gc.Class.UNIVERSAL, type: Gc.Type.INTEGER, constructed: false, capture: "privateKeyExponent2" }, { name: "RSAPrivateKey.coefficient", tagClass: Gc.Class.UNIVERSAL, type: Gc.Type.INTEGER, constructed: false, capture: "privateKeyCoefficient" }] }, Xc = { name: "RSAPublicKey", tagClass: Gc.Class.UNIVERSAL, type: Gc.Type.SEQUENCE, constructed: true, value: [{ name: "RSAPublicKey.modulus", tagClass: Gc.Class.UNIVERSAL, type: Gc.Type.INTEGER, constructed: false, capture: "publicKeyModulus" }, { name: "RSAPublicKey.exponent", tagClass: Gc.Class.UNIVERSAL, type: Gc.Type.INTEGER, constructed: false, capture: "publicKeyExponent" }] }, $c = xu.pki.rsa.publicKeyValidator = { name: "SubjectPublicKeyInfo", tagClass: Gc.Class.UNIVERSAL, type: Gc.Type.SEQUENCE, constructed: true, captureAsn1: "subjectPublicKeyInfo", value: [{ name: "SubjectPublicKeyInfo.AlgorithmIdentifier", tagClass: Gc.Class.UNIVERSAL, type: Gc.Type.SEQUENCE, constructed: true, value: [{ name: "AlgorithmIdentifier.algorithm", tagClass: Gc.Class.UNIVERSAL, type: Gc.Type.OID, constructed: false, capture: "publicKeyOid" }] }, { name: "SubjectPublicKeyInfo.subjectPublicKey", tagClass: Gc.Class.UNIVERSAL, type: Gc.Type.BITSTRING, constructed: false, value: [{ name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey", tagClass: Gc.Class.UNIVERSAL, type: Gc.Type.SEQUENCE, constructed: true, optional: true, captureAsn1: "rsaPublicKey" }] }] }, Zc = function(t7) {
  var e2;
  if (!(t7.algorithm in Wc.oids)) {
    var r2 = new Error("Unknown message digest algorithm.");
    throw r2.algorithm = t7.algorithm, r2;
  }
  e2 = Wc.oids[t7.algorithm];
  var n2 = Gc.oidToDer(e2).getBytes(), i2 = Gc.create(Gc.Class.UNIVERSAL, Gc.Type.SEQUENCE, true, []), a2 = Gc.create(Gc.Class.UNIVERSAL, Gc.Type.SEQUENCE, true, []);
  a2.value.push(Gc.create(Gc.Class.UNIVERSAL, Gc.Type.OID, false, n2)), a2.value.push(Gc.create(Gc.Class.UNIVERSAL, Gc.Type.NULL, false, ""));
  var o2 = Gc.create(Gc.Class.UNIVERSAL, Gc.Type.OCTETSTRING, false, t7.digest().getBytes());
  return i2.value.push(a2), i2.value.push(o2), Gc.toDer(i2).getBytes();
}, Jc = function(t7, e2, r2) {
  if (r2)
    return t7.modPow(e2.e, e2.n);
  if (!e2.p || !e2.q)
    return t7.modPow(e2.d, e2.n);
  var n2;
  e2.dP || (e2.dP = e2.d.mod(e2.p.subtract(Kc.ONE))), e2.dQ || (e2.dQ = e2.d.mod(e2.q.subtract(Kc.ONE))), e2.qInv || (e2.qInv = e2.q.modInverse(e2.p));
  do {
    n2 = new Kc(xu.util.bytesToHex(xu.random.getBytes(e2.n.bitLength() / 8)), 16);
  } while (n2.compareTo(e2.n) >= 0 || !n2.gcd(e2.n).equals(Kc.ONE));
  for (var i2 = (t7 = t7.multiply(n2.modPow(e2.e, e2.n)).mod(e2.n)).mod(e2.p).modPow(e2.dP, e2.p), a2 = t7.mod(e2.q).modPow(e2.dQ, e2.q); i2.compareTo(a2) < 0; )
    i2 = i2.add(e2.p);
  var o2 = i2.subtract(a2).multiply(e2.qInv).mod(e2.p).multiply(e2.q).add(a2);
  return o2 = o2.multiply(n2.modInverse(e2.n)).mod(e2.n);
};
function tf(t7, e2, r2) {
  var n2 = xu.util.createBuffer(), i2 = Math.ceil(e2.n.bitLength() / 8);
  if (t7.length > i2 - 11) {
    var a2 = new Error("Message is too long for PKCS#1 v1.5 padding.");
    throw a2.length = t7.length, a2.max = i2 - 11, a2;
  }
  n2.putByte(0), n2.putByte(r2);
  var o2, s2 = i2 - 3 - t7.length;
  if (r2 === 0 || r2 === 1) {
    o2 = r2 === 0 ? 0 : 255;
    for (var u2 = 0; u2 < s2; ++u2)
      n2.putByte(o2);
  } else
    for (; s2 > 0; ) {
      var c2 = 0, f2 = xu.random.getBytes(s2);
      for (u2 = 0; u2 < s2; ++u2)
        (o2 = f2.charCodeAt(u2)) === 0 ? ++c2 : n2.putByte(o2);
      s2 = c2;
    }
  return n2.putByte(0), n2.putBytes(t7), n2;
}
function ef(t7, e2, r2, n2) {
  var i2 = Math.ceil(e2.n.bitLength() / 8), a2 = xu.util.createBuffer(t7), o2 = a2.getByte(), s2 = a2.getByte();
  if (o2 !== 0 || r2 && s2 !== 0 && s2 !== 1 || !r2 && s2 != 2 || r2 && s2 === 0 && n2 === void 0)
    throw new Error("Encryption block is invalid.");
  var u2 = 0;
  if (s2 === 0) {
    u2 = i2 - 3 - n2;
    for (var c2 = 0; c2 < u2; ++c2)
      if (a2.getByte() !== 0)
        throw new Error("Encryption block is invalid.");
  } else if (s2 === 1)
    for (u2 = 0; a2.length() > 1; ) {
      if (a2.getByte() !== 255) {
        --a2.read;
        break;
      }
      ++u2;
    }
  else if (s2 === 2)
    for (u2 = 0; a2.length() > 1; ) {
      if (a2.getByte() === 0) {
        --a2.read;
        break;
      }
      ++u2;
    }
  if (a2.getByte() !== 0 || u2 !== i2 - 3 - a2.length())
    throw new Error("Encryption block is invalid.");
  return a2.getBytes();
}
function rf(t7, e2, r2) {
  typeof e2 == "function" && (r2 = e2, e2 = {});
  var n2 = { algorithm: { name: (e2 = e2 || {}).algorithm || "PRIMEINC", options: { workers: e2.workers || 2, workLoad: e2.workLoad || 100, workerScript: e2.workerScript } } };
  function i2() {
    a2(t7.pBits, function(e3, n3) {
      return e3 ? r2(e3) : (t7.p = n3, t7.q !== null ? o2(e3, t7.q) : void a2(t7.qBits, o2));
    });
  }
  function a2(t8, e3) {
    xu.prime.generateProbablePrime(t8, n2, e3);
  }
  function o2(e3, n3) {
    if (e3)
      return r2(e3);
    if (t7.q = n3, t7.p.compareTo(t7.q) < 0) {
      var s2 = t7.p;
      t7.p = t7.q, t7.q = s2;
    }
    if (t7.p.subtract(Kc.ONE).gcd(t7.e).compareTo(Kc.ONE) !== 0)
      return t7.p = null, void i2();
    if (t7.q.subtract(Kc.ONE).gcd(t7.e).compareTo(Kc.ONE) !== 0)
      return t7.q = null, void a2(t7.qBits, o2);
    if (t7.p1 = t7.p.subtract(Kc.ONE), t7.q1 = t7.q.subtract(Kc.ONE), t7.phi = t7.p1.multiply(t7.q1), t7.phi.gcd(t7.e).compareTo(Kc.ONE) !== 0)
      return t7.p = t7.q = null, void i2();
    if (t7.n = t7.p.multiply(t7.q), t7.n.bitLength() !== t7.bits)
      return t7.q = null, void a2(t7.qBits, o2);
    var u2 = t7.e.modInverse(t7.phi);
    t7.keys = { privateKey: Wc.rsa.setPrivateKey(t7.n, t7.e, u2, t7.p, t7.q, u2.mod(t7.p1), u2.mod(t7.q1), t7.q.modInverse(t7.p)), publicKey: Wc.rsa.setPublicKey(t7.n, t7.e) }, r2(null, t7.keys);
  }
  "prng" in e2 && (n2.prng = e2.prng), i2();
}
function nf(t7) {
  var e2 = t7.toString(16);
  e2[0] >= "8" && (e2 = "00" + e2);
  var r2 = xu.util.hexToBytes(e2);
  return r2.length > 1 && (r2.charCodeAt(0) === 0 && (128 & r2.charCodeAt(1)) == 0 || r2.charCodeAt(0) === 255 && (128 & r2.charCodeAt(1)) == 128) ? r2.substr(1) : r2;
}
function af(t7) {
  return t7 <= 100 ? 27 : t7 <= 150 ? 18 : t7 <= 200 ? 15 : t7 <= 250 ? 12 : t7 <= 300 ? 9 : t7 <= 350 ? 8 : t7 <= 400 ? 7 : t7 <= 500 ? 6 : t7 <= 600 ? 5 : t7 <= 800 ? 4 : t7 <= 1250 ? 3 : 2;
}
function of(t7) {
  return xu.util.isNodejs && typeof qc[t7] == "function";
}
function sf(t7) {
  return zc.globalScope !== void 0 && typeof zc.globalScope.crypto == "object" && typeof zc.globalScope.crypto.subtle == "object" && typeof zc.globalScope.crypto.subtle[t7] == "function";
}
function uf(t7) {
  return zc.globalScope !== void 0 && typeof zc.globalScope.msCrypto == "object" && typeof zc.globalScope.msCrypto.subtle == "object" && typeof zc.globalScope.msCrypto.subtle[t7] == "function";
}
function cf(t7) {
  for (var e2 = xu.util.hexToBytes(t7.toString(16)), r2 = new Uint8Array(e2.length), n2 = 0; n2 < e2.length; ++n2)
    r2[n2] = e2.charCodeAt(n2);
  return r2;
}
if (Wc.rsa.encrypt = function(t7, e2, r2) {
  var n2, i2 = r2, a2 = Math.ceil(e2.n.bitLength() / 8);
  r2 !== false && r2 !== true ? (i2 = r2 === 2, n2 = tf(t7, e2, r2)) : (n2 = xu.util.createBuffer()).putBytes(t7);
  for (var o2 = new Kc(n2.toHex(), 16), s2 = Jc(o2, e2, i2).toString(16), u2 = xu.util.createBuffer(), c2 = a2 - Math.ceil(s2.length / 2); c2 > 0; )
    u2.putByte(0), --c2;
  return u2.putBytes(xu.util.hexToBytes(s2)), u2.getBytes();
}, Wc.rsa.decrypt = function(t7, e2, r2, n2) {
  var i2 = Math.ceil(e2.n.bitLength() / 8);
  if (t7.length !== i2) {
    var a2 = new Error("Encrypted message length is invalid.");
    throw a2.length = t7.length, a2.expected = i2, a2;
  }
  var o2 = new Kc(xu.util.createBuffer(t7).toHex(), 16);
  if (o2.compareTo(e2.n) >= 0)
    throw new Error("Encrypted message is invalid.");
  for (var s2 = Jc(o2, e2, r2).toString(16), u2 = xu.util.createBuffer(), c2 = i2 - Math.ceil(s2.length / 2); c2 > 0; )
    u2.putByte(0), --c2;
  return u2.putBytes(xu.util.hexToBytes(s2)), n2 !== false ? ef(u2.getBytes(), e2, r2) : u2.getBytes();
}, Wc.rsa.createKeyPairGenerationState = function(t7, e2, r2) {
  typeof t7 == "string" && (t7 = parseInt(t7, 10)), t7 = t7 || 2048;
  var n2, i2 = (r2 = r2 || {}).prng || xu.random, a2 = { nextBytes: function(t8) {
    for (var e3 = i2.getBytesSync(t8.length), r3 = 0; r3 < t8.length; ++r3)
      t8[r3] = e3.charCodeAt(r3);
  } }, o2 = r2.algorithm || "PRIMEINC";
  if (o2 !== "PRIMEINC")
    throw new Error("Invalid key generation algorithm: " + o2);
  return (n2 = { algorithm: o2, state: 0, bits: t7, rng: a2, eInt: e2 || 65537, e: new Kc(null), p: null, q: null, qBits: t7 >> 1, pBits: t7 - (t7 >> 1), pqState: 0, num: null, keys: null }).e.fromInt(n2.eInt), n2;
}, Wc.rsa.stepKeyPairGenerationState = function(t7, e2) {
  "algorithm" in t7 || (t7.algorithm = "PRIMEINC");
  var r2 = new Kc(null);
  r2.fromInt(30);
  for (var n2, i2 = 0, a2 = function(t8, e3) {
    return t8 | e3;
  }, o2 = +new Date(), s2 = 0; t7.keys === null && (e2 <= 0 || s2 < e2); ) {
    if (t7.state === 0) {
      var u2 = t7.p === null ? t7.pBits : t7.qBits, c2 = u2 - 1;
      t7.pqState === 0 ? (t7.num = new Kc(u2, t7.rng), t7.num.testBit(c2) || t7.num.bitwiseTo(Kc.ONE.shiftLeft(c2), a2, t7.num), t7.num.dAddOffset(31 - t7.num.mod(r2).byteValue(), 0), i2 = 0, ++t7.pqState) : t7.pqState === 1 ? t7.num.bitLength() > u2 ? t7.pqState = 0 : t7.num.isProbablePrime(af(t7.num.bitLength())) ? ++t7.pqState : t7.num.dAddOffset(Hc[i2++ % 8], 0) : t7.pqState === 2 ? t7.pqState = t7.num.subtract(Kc.ONE).gcd(t7.e).compareTo(Kc.ONE) === 0 ? 3 : 0 : t7.pqState === 3 && (t7.pqState = 0, t7.p === null ? t7.p = t7.num : t7.q = t7.num, t7.p !== null && t7.q !== null && ++t7.state, t7.num = null);
    } else if (t7.state === 1)
      t7.p.compareTo(t7.q) < 0 && (t7.num = t7.p, t7.p = t7.q, t7.q = t7.num), ++t7.state;
    else if (t7.state === 2)
      t7.p1 = t7.p.subtract(Kc.ONE), t7.q1 = t7.q.subtract(Kc.ONE), t7.phi = t7.p1.multiply(t7.q1), ++t7.state;
    else if (t7.state === 3)
      t7.phi.gcd(t7.e).compareTo(Kc.ONE) === 0 ? ++t7.state : (t7.p = null, t7.q = null, t7.state = 0);
    else if (t7.state === 4)
      t7.n = t7.p.multiply(t7.q), t7.n.bitLength() === t7.bits ? ++t7.state : (t7.q = null, t7.state = 0);
    else if (t7.state === 5) {
      var f2 = t7.e.modInverse(t7.phi);
      t7.keys = { privateKey: Wc.rsa.setPrivateKey(t7.n, t7.e, f2, t7.p, t7.q, f2.mod(t7.p1), f2.mod(t7.q1), t7.q.modInverse(t7.p)), publicKey: Wc.rsa.setPublicKey(t7.n, t7.e) };
    }
    s2 += (n2 = +new Date()) - o2, o2 = n2;
  }
  return t7.keys !== null;
}, Wc.rsa.generateKeyPair = function(t7, e2, r2, n2) {
  if (arguments.length === 1 ? typeof t7 == "object" ? (r2 = t7, t7 = void 0) : typeof t7 == "function" && (n2 = t7, t7 = void 0) : arguments.length === 2 ? typeof t7 == "number" ? typeof e2 == "function" ? (n2 = e2, e2 = void 0) : typeof e2 != "number" && (r2 = e2, e2 = void 0) : (r2 = t7, n2 = e2, t7 = void 0, e2 = void 0) : arguments.length === 3 && (typeof e2 == "number" ? typeof r2 == "function" && (n2 = r2, r2 = void 0) : (n2 = r2, r2 = e2, e2 = void 0)), r2 = r2 || {}, t7 === void 0 && (t7 = r2.bits || 2048), e2 === void 0 && (e2 = r2.e || 65537), !r2.prng && t7 >= 256 && t7 <= 16384 && (e2 === 65537 || e2 === 3)) {
    if (n2) {
      if (of("generateKeyPair"))
        return qc.generateKeyPair("rsa", { modulusLength: t7, publicExponent: e2, publicKeyEncoding: { type: "spki", format: "pem" }, privateKeyEncoding: { type: "pkcs8", format: "pem" } }, function(t8, e3, r3) {
          if (t8)
            return n2(t8);
          n2(null, { privateKey: Wc.privateKeyFromPem(r3), publicKey: Wc.publicKeyFromPem(e3) });
        });
      if (sf("generateKey") && sf("exportKey"))
        return zc.globalScope.crypto.subtle.generateKey({ name: "RSASSA-PKCS1-v1_5", modulusLength: t7, publicExponent: cf(e2), hash: { name: "SHA-256" } }, true, ["sign", "verify"]).then(function(t8) {
          return zc.globalScope.crypto.subtle.exportKey("pkcs8", t8.privateKey);
        }).then(void 0, function(t8) {
          n2(t8);
        }).then(function(t8) {
          if (t8) {
            var e3 = Wc.privateKeyFromAsn1(Gc.fromDer(xu.util.createBuffer(t8)));
            n2(null, { privateKey: e3, publicKey: Wc.setRsaPublicKey(e3.n, e3.e) });
          }
        });
      if (uf("generateKey") && uf("exportKey")) {
        var i2 = zc.globalScope.msCrypto.subtle.generateKey({ name: "RSASSA-PKCS1-v1_5", modulusLength: t7, publicExponent: cf(e2), hash: { name: "SHA-256" } }, true, ["sign", "verify"]);
        return i2.oncomplete = function(t8) {
          var e3 = t8.target.result, r3 = zc.globalScope.msCrypto.subtle.exportKey("pkcs8", e3.privateKey);
          r3.oncomplete = function(t9) {
            var e4 = t9.target.result, r4 = Wc.privateKeyFromAsn1(Gc.fromDer(xu.util.createBuffer(e4)));
            n2(null, { privateKey: r4, publicKey: Wc.setRsaPublicKey(r4.n, r4.e) });
          }, r3.onerror = function(t9) {
            n2(t9);
          };
        }, void (i2.onerror = function(t8) {
          n2(t8);
        });
      }
    } else if (of("generateKeyPairSync")) {
      var a2 = qc.generateKeyPairSync("rsa", { modulusLength: t7, publicExponent: e2, publicKeyEncoding: { type: "spki", format: "pem" }, privateKeyEncoding: { type: "pkcs8", format: "pem" } });
      return { privateKey: Wc.privateKeyFromPem(a2.privateKey), publicKey: Wc.publicKeyFromPem(a2.publicKey) };
    }
  }
  var o2 = Wc.rsa.createKeyPairGenerationState(t7, e2, r2);
  if (!n2)
    return Wc.rsa.stepKeyPairGenerationState(o2, 0), o2.keys;
  rf(o2, r2, n2);
}, Wc.setRsaPublicKey = Wc.rsa.setPublicKey = function(t7, e2) {
  var r2 = { n: t7, e: e2, encrypt: function(t8, e3, n2) {
    if (typeof e3 == "string" ? e3 = e3.toUpperCase() : e3 === void 0 && (e3 = "RSAES-PKCS1-V1_5"), e3 === "RSAES-PKCS1-V1_5")
      e3 = { encode: function(t9, e4, r3) {
        return tf(t9, e4, 2).getBytes();
      } };
    else if (e3 === "RSA-OAEP" || e3 === "RSAES-OAEP")
      e3 = { encode: function(t9, e4) {
        return xu.pkcs1.encode_rsa_oaep(e4, t9, n2);
      } };
    else if (["RAW", "NONE", "NULL", null].indexOf(e3) !== -1)
      e3 = { encode: function(t9) {
        return t9;
      } };
    else if (typeof e3 == "string")
      throw new Error('Unsupported encryption scheme: "' + e3 + '".');
    var i2 = e3.encode(t8, r2, true);
    return Wc.rsa.encrypt(i2, r2, true);
  }, verify: function(t8, e3, n2) {
    typeof n2 == "string" ? n2 = n2.toUpperCase() : n2 === void 0 && (n2 = "RSASSA-PKCS1-V1_5"), n2 === "RSASSA-PKCS1-V1_5" ? n2 = { verify: function(t9, e4) {
      return e4 = ef(e4, r2, true), t9 === Gc.fromDer(e4).value[1].value;
    } } : n2 !== "NONE" && n2 !== "NULL" && n2 !== null || (n2 = { verify: function(t9, e4) {
      return t9 === (e4 = ef(e4, r2, true));
    } });
    var i2 = Wc.rsa.decrypt(e3, r2, true, false);
    return n2.verify(t8, i2, r2.n.bitLength());
  } };
  return r2;
}, Wc.setRsaPrivateKey = Wc.rsa.setPrivateKey = function(t7, e2, r2, n2, i2, a2, o2, s2) {
  var u2 = { n: t7, e: e2, d: r2, p: n2, q: i2, dP: a2, dQ: o2, qInv: s2, decrypt: function(t8, e3, r3) {
    typeof e3 == "string" ? e3 = e3.toUpperCase() : e3 === void 0 && (e3 = "RSAES-PKCS1-V1_5");
    var n3 = Wc.rsa.decrypt(t8, u2, false, false);
    if (e3 === "RSAES-PKCS1-V1_5")
      e3 = { decode: ef };
    else if (e3 === "RSA-OAEP" || e3 === "RSAES-OAEP")
      e3 = { decode: function(t9, e4) {
        return xu.pkcs1.decode_rsa_oaep(e4, t9, r3);
      } };
    else {
      if (["RAW", "NONE", "NULL", null].indexOf(e3) === -1)
        throw new Error('Unsupported encryption scheme: "' + e3 + '".');
      e3 = { decode: function(t9) {
        return t9;
      } };
    }
    return e3.decode(n3, u2, false);
  }, sign: function(t8, e3) {
    var r3 = false;
    typeof e3 == "string" && (e3 = e3.toUpperCase()), e3 === void 0 || e3 === "RSASSA-PKCS1-V1_5" ? (e3 = { encode: Zc }, r3 = 1) : e3 !== "NONE" && e3 !== "NULL" && e3 !== null || (e3 = { encode: function() {
      return t8;
    } }, r3 = 1);
    var n3 = e3.encode(t8, u2.n.bitLength());
    return Wc.rsa.encrypt(n3, u2, r3);
  } };
  return u2;
}, Wc.wrapRsaPrivateKey = function(t7) {
  return Gc.create(Gc.Class.UNIVERSAL, Gc.Type.SEQUENCE, true, [Gc.create(Gc.Class.UNIVERSAL, Gc.Type.INTEGER, false, Gc.integerToDer(0).getBytes()), Gc.create(Gc.Class.UNIVERSAL, Gc.Type.SEQUENCE, true, [Gc.create(Gc.Class.UNIVERSAL, Gc.Type.OID, false, Gc.oidToDer(Wc.oids.rsaEncryption).getBytes()), Gc.create(Gc.Class.UNIVERSAL, Gc.Type.NULL, false, "")]), Gc.create(Gc.Class.UNIVERSAL, Gc.Type.OCTETSTRING, false, Gc.toDer(t7).getBytes())]);
}, Wc.privateKeyFromAsn1 = function(t7) {
  var e2, r2, n2, i2, a2, o2, s2, u2, c2 = {}, f2 = [];
  if (Gc.validate(t7, Qc, c2, f2) && (t7 = Gc.fromDer(xu.util.createBuffer(c2.privateKey))), c2 = {}, f2 = [], !Gc.validate(t7, Yc, c2, f2)) {
    var l2 = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
    throw l2.errors = f2, l2;
  }
  return e2 = xu.util.createBuffer(c2.privateKeyModulus).toHex(), r2 = xu.util.createBuffer(c2.privateKeyPublicExponent).toHex(), n2 = xu.util.createBuffer(c2.privateKeyPrivateExponent).toHex(), i2 = xu.util.createBuffer(c2.privateKeyPrime1).toHex(), a2 = xu.util.createBuffer(c2.privateKeyPrime2).toHex(), o2 = xu.util.createBuffer(c2.privateKeyExponent1).toHex(), s2 = xu.util.createBuffer(c2.privateKeyExponent2).toHex(), u2 = xu.util.createBuffer(c2.privateKeyCoefficient).toHex(), Wc.setRsaPrivateKey(new Kc(e2, 16), new Kc(r2, 16), new Kc(n2, 16), new Kc(i2, 16), new Kc(a2, 16), new Kc(o2, 16), new Kc(s2, 16), new Kc(u2, 16));
}, Wc.privateKeyToAsn1 = Wc.privateKeyToRSAPrivateKey = function(t7) {
  return Gc.create(Gc.Class.UNIVERSAL, Gc.Type.SEQUENCE, true, [Gc.create(Gc.Class.UNIVERSAL, Gc.Type.INTEGER, false, Gc.integerToDer(0).getBytes()), Gc.create(Gc.Class.UNIVERSAL, Gc.Type.INTEGER, false, nf(t7.n)), Gc.create(Gc.Class.UNIVERSAL, Gc.Type.INTEGER, false, nf(t7.e)), Gc.create(Gc.Class.UNIVERSAL, Gc.Type.INTEGER, false, nf(t7.d)), Gc.create(Gc.Class.UNIVERSAL, Gc.Type.INTEGER, false, nf(t7.p)), Gc.create(Gc.Class.UNIVERSAL, Gc.Type.INTEGER, false, nf(t7.q)), Gc.create(Gc.Class.UNIVERSAL, Gc.Type.INTEGER, false, nf(t7.dP)), Gc.create(Gc.Class.UNIVERSAL, Gc.Type.INTEGER, false, nf(t7.dQ)), Gc.create(Gc.Class.UNIVERSAL, Gc.Type.INTEGER, false, nf(t7.qInv))]);
}, Wc.publicKeyFromAsn1 = function(t7) {
  var e2 = {}, r2 = [];
  if (Gc.validate(t7, $c, e2, r2)) {
    var n2, i2 = Gc.derToOid(e2.publicKeyOid);
    if (i2 !== Wc.oids.rsaEncryption)
      throw (n2 = new Error("Cannot read public key. Unknown OID.")).oid = i2, n2;
    t7 = e2.rsaPublicKey;
  }
  if (r2 = [], !Gc.validate(t7, Xc, e2, r2))
    throw (n2 = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.")).errors = r2, n2;
  var a2 = xu.util.createBuffer(e2.publicKeyModulus).toHex(), o2 = xu.util.createBuffer(e2.publicKeyExponent).toHex();
  return Wc.setRsaPublicKey(new Kc(a2, 16), new Kc(o2, 16));
}, Wc.publicKeyToAsn1 = Wc.publicKeyToSubjectPublicKeyInfo = function(t7) {
  return Gc.create(Gc.Class.UNIVERSAL, Gc.Type.SEQUENCE, true, [Gc.create(Gc.Class.UNIVERSAL, Gc.Type.SEQUENCE, true, [Gc.create(Gc.Class.UNIVERSAL, Gc.Type.OID, false, Gc.oidToDer(Wc.oids.rsaEncryption).getBytes()), Gc.create(Gc.Class.UNIVERSAL, Gc.Type.NULL, false, "")]), Gc.create(Gc.Class.UNIVERSAL, Gc.Type.BITSTRING, false, [Wc.publicKeyToRSAPublicKey(t7)])]);
}, Wc.publicKeyToRSAPublicKey = function(t7) {
  return Gc.create(Gc.Class.UNIVERSAL, Gc.Type.SEQUENCE, true, [Gc.create(Gc.Class.UNIVERSAL, Gc.Type.INTEGER, false, nf(t7.n)), Gc.create(Gc.Class.UNIVERSAL, Gc.Type.INTEGER, false, nf(t7.e))]);
}, ff === void 0)
  var ff = xu.jsbn.BigInteger;
var lf = xu.asn1, hf = xu.pki = xu.pki || {};
hf.pbe = xu.pbe = xu.pbe || {};
var pf = hf.oids, df = { name: "EncryptedPrivateKeyInfo", tagClass: lf.Class.UNIVERSAL, type: lf.Type.SEQUENCE, constructed: true, value: [{ name: "EncryptedPrivateKeyInfo.encryptionAlgorithm", tagClass: lf.Class.UNIVERSAL, type: lf.Type.SEQUENCE, constructed: true, value: [{ name: "AlgorithmIdentifier.algorithm", tagClass: lf.Class.UNIVERSAL, type: lf.Type.OID, constructed: false, capture: "encryptionOid" }, { name: "AlgorithmIdentifier.parameters", tagClass: lf.Class.UNIVERSAL, type: lf.Type.SEQUENCE, constructed: true, captureAsn1: "encryptionParams" }] }, { name: "EncryptedPrivateKeyInfo.encryptedData", tagClass: lf.Class.UNIVERSAL, type: lf.Type.OCTETSTRING, constructed: false, capture: "encryptedData" }] }, yf = { name: "PBES2Algorithms", tagClass: lf.Class.UNIVERSAL, type: lf.Type.SEQUENCE, constructed: true, value: [{ name: "PBES2Algorithms.keyDerivationFunc", tagClass: lf.Class.UNIVERSAL, type: lf.Type.SEQUENCE, constructed: true, value: [{ name: "PBES2Algorithms.keyDerivationFunc.oid", tagClass: lf.Class.UNIVERSAL, type: lf.Type.OID, constructed: false, capture: "kdfOid" }, { name: "PBES2Algorithms.params", tagClass: lf.Class.UNIVERSAL, type: lf.Type.SEQUENCE, constructed: true, value: [{ name: "PBES2Algorithms.params.salt", tagClass: lf.Class.UNIVERSAL, type: lf.Type.OCTETSTRING, constructed: false, capture: "kdfSalt" }, { name: "PBES2Algorithms.params.iterationCount", tagClass: lf.Class.UNIVERSAL, type: lf.Type.INTEGER, constructed: false, capture: "kdfIterationCount" }, { name: "PBES2Algorithms.params.keyLength", tagClass: lf.Class.UNIVERSAL, type: lf.Type.INTEGER, constructed: false, optional: true, capture: "keyLength" }, { name: "PBES2Algorithms.params.prf", tagClass: lf.Class.UNIVERSAL, type: lf.Type.SEQUENCE, constructed: true, optional: true, value: [{ name: "PBES2Algorithms.params.prf.algorithm", tagClass: lf.Class.UNIVERSAL, type: lf.Type.OID, constructed: false, capture: "prfOid" }] }] }] }, { name: "PBES2Algorithms.encryptionScheme", tagClass: lf.Class.UNIVERSAL, type: lf.Type.SEQUENCE, constructed: true, value: [{ name: "PBES2Algorithms.encryptionScheme.oid", tagClass: lf.Class.UNIVERSAL, type: lf.Type.OID, constructed: false, capture: "encOid" }, { name: "PBES2Algorithms.encryptionScheme.iv", tagClass: lf.Class.UNIVERSAL, type: lf.Type.OCTETSTRING, constructed: false, capture: "encIv" }] }] }, gf = { name: "pkcs-12PbeParams", tagClass: lf.Class.UNIVERSAL, type: lf.Type.SEQUENCE, constructed: true, value: [{ name: "pkcs-12PbeParams.salt", tagClass: lf.Class.UNIVERSAL, type: lf.Type.OCTETSTRING, constructed: false, capture: "salt" }, { name: "pkcs-12PbeParams.iterations", tagClass: lf.Class.UNIVERSAL, type: lf.Type.INTEGER, constructed: false, capture: "iterations" }] };
function vf(t7, e2) {
  return t7.start().update(e2).digest().getBytes();
}
function mf(t7) {
  var e2;
  if (t7) {
    if (!(e2 = hf.oids[lf.derToOid(t7)])) {
      var r2 = new Error("Unsupported PRF OID.");
      throw r2.oid = t7, r2.supported = ["hmacWithSHA1", "hmacWithSHA224", "hmacWithSHA256", "hmacWithSHA384", "hmacWithSHA512"], r2;
    }
  } else
    e2 = "hmacWithSHA1";
  return Cf(e2);
}
function Cf(t7) {
  var e2 = xu.md;
  switch (t7) {
    case "hmacWithSHA224":
      e2 = xu.md.sha512;
    case "hmacWithSHA1":
    case "hmacWithSHA256":
    case "hmacWithSHA384":
    case "hmacWithSHA512":
      t7 = t7.substr(8).toLowerCase();
      break;
    default:
      var r2 = new Error("Unsupported PRF algorithm.");
      throw r2.algorithm = t7, r2.supported = ["hmacWithSHA1", "hmacWithSHA224", "hmacWithSHA256", "hmacWithSHA384", "hmacWithSHA512"], r2;
  }
  if (!e2 || !(t7 in e2))
    throw new Error("Unknown hash algorithm: " + t7);
  return e2[t7].create();
}
hf.encryptPrivateKeyInfo = function(t7, e2, r2) {
  (r2 = r2 || {}).saltSize = r2.saltSize || 8, r2.count = r2.count || 2048, r2.algorithm = r2.algorithm || "aes128", r2.prfAlgorithm = r2.prfAlgorithm || "sha1";
  var n2, i2, a2, o2 = xu.random.getBytesSync(r2.saltSize), s2 = r2.count, u2 = lf.integerToDer(s2);
  if (r2.algorithm.indexOf("aes") === 0 || r2.algorithm === "des") {
    var c2, f2, l2;
    switch (r2.algorithm) {
      case "aes128":
        n2 = 16, c2 = 16, f2 = pf["aes128-CBC"], l2 = xu.aes.createEncryptionCipher;
        break;
      case "aes192":
        n2 = 24, c2 = 16, f2 = pf["aes192-CBC"], l2 = xu.aes.createEncryptionCipher;
        break;
      case "aes256":
        n2 = 32, c2 = 16, f2 = pf["aes256-CBC"], l2 = xu.aes.createEncryptionCipher;
        break;
      case "des":
        n2 = 8, c2 = 8, f2 = pf.desCBC, l2 = xu.des.createEncryptionCipher;
        break;
      default:
        throw (v2 = new Error("Cannot encrypt private key. Unknown encryption algorithm.")).algorithm = r2.algorithm, v2;
    }
    var h2 = "hmacWith" + r2.prfAlgorithm.toUpperCase(), p2 = Cf(h2), d2 = xu.pkcs5.pbkdf2(e2, o2, s2, n2, p2), y2 = xu.random.getBytesSync(c2);
    (m2 = l2(d2)).start(y2), m2.update(lf.toDer(t7)), m2.finish(), a2 = m2.output.getBytes();
    var g2 = function(t8, e3, r3, n3) {
      var i3 = lf.create(lf.Class.UNIVERSAL, lf.Type.SEQUENCE, true, [lf.create(lf.Class.UNIVERSAL, lf.Type.OCTETSTRING, false, t8), lf.create(lf.Class.UNIVERSAL, lf.Type.INTEGER, false, e3.getBytes())]);
      n3 !== "hmacWithSHA1" && i3.value.push(lf.create(lf.Class.UNIVERSAL, lf.Type.INTEGER, false, xu.util.hexToBytes(r3.toString(16))), lf.create(lf.Class.UNIVERSAL, lf.Type.SEQUENCE, true, [lf.create(lf.Class.UNIVERSAL, lf.Type.OID, false, lf.oidToDer(hf.oids[n3]).getBytes()), lf.create(lf.Class.UNIVERSAL, lf.Type.NULL, false, "")]));
      return i3;
    }(o2, u2, n2, h2);
    i2 = lf.create(lf.Class.UNIVERSAL, lf.Type.SEQUENCE, true, [lf.create(lf.Class.UNIVERSAL, lf.Type.OID, false, lf.oidToDer(pf.pkcs5PBES2).getBytes()), lf.create(lf.Class.UNIVERSAL, lf.Type.SEQUENCE, true, [lf.create(lf.Class.UNIVERSAL, lf.Type.SEQUENCE, true, [lf.create(lf.Class.UNIVERSAL, lf.Type.OID, false, lf.oidToDer(pf.pkcs5PBKDF2).getBytes()), g2]), lf.create(lf.Class.UNIVERSAL, lf.Type.SEQUENCE, true, [lf.create(lf.Class.UNIVERSAL, lf.Type.OID, false, lf.oidToDer(f2).getBytes()), lf.create(lf.Class.UNIVERSAL, lf.Type.OCTETSTRING, false, y2)])])]);
  } else {
    var v2;
    if (r2.algorithm !== "3des")
      throw (v2 = new Error("Cannot encrypt private key. Unknown encryption algorithm.")).algorithm = r2.algorithm, v2;
    n2 = 24;
    var m2, C2 = new xu.util.ByteBuffer(o2);
    d2 = hf.pbe.generatePkcs12Key(e2, C2, 1, s2, n2), y2 = hf.pbe.generatePkcs12Key(e2, C2, 2, s2, n2);
    (m2 = xu.des.createEncryptionCipher(d2)).start(y2), m2.update(lf.toDer(t7)), m2.finish(), a2 = m2.output.getBytes(), i2 = lf.create(lf.Class.UNIVERSAL, lf.Type.SEQUENCE, true, [lf.create(lf.Class.UNIVERSAL, lf.Type.OID, false, lf.oidToDer(pf["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()), lf.create(lf.Class.UNIVERSAL, lf.Type.SEQUENCE, true, [lf.create(lf.Class.UNIVERSAL, lf.Type.OCTETSTRING, false, o2), lf.create(lf.Class.UNIVERSAL, lf.Type.INTEGER, false, u2.getBytes())])]);
  }
  return lf.create(lf.Class.UNIVERSAL, lf.Type.SEQUENCE, true, [i2, lf.create(lf.Class.UNIVERSAL, lf.Type.OCTETSTRING, false, a2)]);
}, hf.decryptPrivateKeyInfo = function(t7, e2) {
  var r2 = null, n2 = {}, i2 = [];
  if (!lf.validate(t7, df, n2, i2)) {
    var a2 = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
    throw a2.errors = i2, a2;
  }
  var o2 = lf.derToOid(n2.encryptionOid), s2 = hf.pbe.getCipher(o2, n2.encryptionParams, e2), u2 = xu.util.createBuffer(n2.encryptedData);
  return s2.update(u2), s2.finish() && (r2 = lf.fromDer(s2.output)), r2;
}, hf.encryptedPrivateKeyToPem = function(t7, e2) {
  var r2 = { type: "ENCRYPTED PRIVATE KEY", body: lf.toDer(t7).getBytes() };
  return xu.pem.encode(r2, { maxline: e2 });
}, hf.encryptedPrivateKeyFromPem = function(t7) {
  var e2 = xu.pem.decode(t7)[0];
  if (e2.type !== "ENCRYPTED PRIVATE KEY") {
    var r2 = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
    throw r2.headerType = e2.type, r2;
  }
  if (e2.procType && e2.procType.type === "ENCRYPTED")
    throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
  return lf.fromDer(e2.body);
}, hf.encryptRsaPrivateKey = function(t7, e2, r2) {
  if (!(r2 = r2 || {}).legacy) {
    var n2 = hf.wrapRsaPrivateKey(hf.privateKeyToAsn1(t7));
    return n2 = hf.encryptPrivateKeyInfo(n2, e2, r2), hf.encryptedPrivateKeyToPem(n2);
  }
  var i2, a2, o2, s2;
  switch (r2.algorithm) {
    case "aes128":
      i2 = "AES-128-CBC", o2 = 16, a2 = xu.random.getBytesSync(16), s2 = xu.aes.createEncryptionCipher;
      break;
    case "aes192":
      i2 = "AES-192-CBC", o2 = 24, a2 = xu.random.getBytesSync(16), s2 = xu.aes.createEncryptionCipher;
      break;
    case "aes256":
      i2 = "AES-256-CBC", o2 = 32, a2 = xu.random.getBytesSync(16), s2 = xu.aes.createEncryptionCipher;
      break;
    case "3des":
      i2 = "DES-EDE3-CBC", o2 = 24, a2 = xu.random.getBytesSync(8), s2 = xu.des.createEncryptionCipher;
      break;
    case "des":
      i2 = "DES-CBC", o2 = 8, a2 = xu.random.getBytesSync(8), s2 = xu.des.createEncryptionCipher;
      break;
    default:
      var u2 = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + r2.algorithm + '".');
      throw u2.algorithm = r2.algorithm, u2;
  }
  var c2 = s2(xu.pbe.opensslDeriveBytes(e2, a2.substr(0, 8), o2));
  c2.start(a2), c2.update(lf.toDer(hf.privateKeyToAsn1(t7))), c2.finish();
  var f2 = { type: "RSA PRIVATE KEY", procType: { version: "4", type: "ENCRYPTED" }, dekInfo: { algorithm: i2, parameters: xu.util.bytesToHex(a2).toUpperCase() }, body: c2.output.getBytes() };
  return xu.pem.encode(f2);
}, hf.decryptRsaPrivateKey = function(t7, e2) {
  var r2 = null, n2 = xu.pem.decode(t7)[0];
  if (n2.type !== "ENCRYPTED PRIVATE KEY" && n2.type !== "PRIVATE KEY" && n2.type !== "RSA PRIVATE KEY")
    throw (o2 = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".')).headerType = o2, o2;
  if (n2.procType && n2.procType.type === "ENCRYPTED") {
    var i2, a2;
    switch (n2.dekInfo.algorithm) {
      case "DES-CBC":
        i2 = 8, a2 = xu.des.createDecryptionCipher;
        break;
      case "DES-EDE3-CBC":
        i2 = 24, a2 = xu.des.createDecryptionCipher;
        break;
      case "AES-128-CBC":
        i2 = 16, a2 = xu.aes.createDecryptionCipher;
        break;
      case "AES-192-CBC":
        i2 = 24, a2 = xu.aes.createDecryptionCipher;
        break;
      case "AES-256-CBC":
        i2 = 32, a2 = xu.aes.createDecryptionCipher;
        break;
      case "RC2-40-CBC":
        i2 = 5, a2 = function(t8) {
          return xu.rc2.createDecryptionCipher(t8, 40);
        };
        break;
      case "RC2-64-CBC":
        i2 = 8, a2 = function(t8) {
          return xu.rc2.createDecryptionCipher(t8, 64);
        };
        break;
      case "RC2-128-CBC":
        i2 = 16, a2 = function(t8) {
          return xu.rc2.createDecryptionCipher(t8, 128);
        };
        break;
      default:
        var o2;
        throw (o2 = new Error('Could not decrypt private key; unsupported encryption algorithm "' + n2.dekInfo.algorithm + '".')).algorithm = n2.dekInfo.algorithm, o2;
    }
    var s2 = xu.util.hexToBytes(n2.dekInfo.parameters), u2 = a2(xu.pbe.opensslDeriveBytes(e2, s2.substr(0, 8), i2));
    if (u2.start(s2), u2.update(xu.util.createBuffer(n2.body)), !u2.finish())
      return r2;
    r2 = u2.output.getBytes();
  } else
    r2 = n2.body;
  return (r2 = n2.type === "ENCRYPTED PRIVATE KEY" ? hf.decryptPrivateKeyInfo(lf.fromDer(r2), e2) : lf.fromDer(r2)) !== null && (r2 = hf.privateKeyFromAsn1(r2)), r2;
}, hf.pbe.generatePkcs12Key = function(t7, e2, r2, n2, i2, a2) {
  var o2, s2;
  if (a2 == null) {
    if (!("sha1" in xu.md))
      throw new Error('"sha1" hash algorithm unavailable.');
    a2 = xu.md.sha1.create();
  }
  var u2 = a2.digestLength, c2 = a2.blockLength, f2 = new xu.util.ByteBuffer(), l2 = new xu.util.ByteBuffer();
  if (t7 != null) {
    for (s2 = 0; s2 < t7.length; s2++)
      l2.putInt16(t7.charCodeAt(s2));
    l2.putInt16(0);
  }
  var h2 = l2.length(), p2 = e2.length(), d2 = new xu.util.ByteBuffer();
  d2.fillWithByte(r2, c2);
  var y2 = c2 * Math.ceil(p2 / c2), g2 = new xu.util.ByteBuffer();
  for (s2 = 0; s2 < y2; s2++)
    g2.putByte(e2.at(s2 % p2));
  var v2 = c2 * Math.ceil(h2 / c2), m2 = new xu.util.ByteBuffer();
  for (s2 = 0; s2 < v2; s2++)
    m2.putByte(l2.at(s2 % h2));
  var C2 = g2;
  C2.putBuffer(m2);
  for (var E2 = Math.ceil(i2 / u2), S2 = 1; S2 <= E2; S2++) {
    var b2 = new xu.util.ByteBuffer();
    b2.putBytes(d2.bytes()), b2.putBytes(C2.bytes());
    for (var T2 = 0; T2 < n2; T2++)
      a2.start(), a2.update(b2.getBytes()), b2 = a2.digest();
    var I2 = new xu.util.ByteBuffer();
    for (s2 = 0; s2 < c2; s2++)
      I2.putByte(b2.at(s2 % u2));
    var A2 = Math.ceil(p2 / c2) + Math.ceil(h2 / c2), w2 = new xu.util.ByteBuffer();
    for (o2 = 0; o2 < A2; o2++) {
      var _2 = new xu.util.ByteBuffer(C2.getBytes(c2)), B2 = 511;
      for (s2 = I2.length() - 1; s2 >= 0; s2--)
        B2 >>= 8, B2 += I2.at(s2) + _2.at(s2), _2.setAt(s2, 255 & B2);
      w2.putBuffer(_2);
    }
    C2 = w2, f2.putBuffer(b2);
  }
  return f2.truncate(f2.length() - i2), f2;
}, hf.pbe.getCipher = function(t7, e2, r2) {
  switch (t7) {
    case hf.oids.pkcs5PBES2:
      return hf.pbe.getCipherForPBES2(t7, e2, r2);
    case hf.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
    case hf.oids["pbewithSHAAnd40BitRC2-CBC"]:
      return hf.pbe.getCipherForPKCS12PBE(t7, e2, r2);
    default:
      var n2 = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
      throw n2.oid = t7, n2.supportedOids = ["pkcs5PBES2", "pbeWithSHAAnd3-KeyTripleDES-CBC", "pbewithSHAAnd40BitRC2-CBC"], n2;
  }
}, hf.pbe.getCipherForPBES2 = function(t7, e2, r2) {
  var n2, i2 = {}, a2 = [];
  if (!lf.validate(e2, yf, i2, a2))
    throw (n2 = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.")).errors = a2, n2;
  if ((t7 = lf.derToOid(i2.kdfOid)) !== hf.oids.pkcs5PBKDF2)
    throw (n2 = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.")).oid = t7, n2.supportedOids = ["pkcs5PBKDF2"], n2;
  if ((t7 = lf.derToOid(i2.encOid)) !== hf.oids["aes128-CBC"] && t7 !== hf.oids["aes192-CBC"] && t7 !== hf.oids["aes256-CBC"] && t7 !== hf.oids["des-EDE3-CBC"] && t7 !== hf.oids.desCBC)
    throw (n2 = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.")).oid = t7, n2.supportedOids = ["aes128-CBC", "aes192-CBC", "aes256-CBC", "des-EDE3-CBC", "desCBC"], n2;
  var o2, s2, u2 = i2.kdfSalt, c2 = xu.util.createBuffer(i2.kdfIterationCount);
  switch (c2 = c2.getInt(c2.length() << 3), hf.oids[t7]) {
    case "aes128-CBC":
      o2 = 16, s2 = xu.aes.createDecryptionCipher;
      break;
    case "aes192-CBC":
      o2 = 24, s2 = xu.aes.createDecryptionCipher;
      break;
    case "aes256-CBC":
      o2 = 32, s2 = xu.aes.createDecryptionCipher;
      break;
    case "des-EDE3-CBC":
      o2 = 24, s2 = xu.des.createDecryptionCipher;
      break;
    case "desCBC":
      o2 = 8, s2 = xu.des.createDecryptionCipher;
  }
  var f2 = mf(i2.prfOid), l2 = xu.pkcs5.pbkdf2(r2, u2, c2, o2, f2), h2 = i2.encIv, p2 = s2(l2);
  return p2.start(h2), p2;
}, hf.pbe.getCipherForPKCS12PBE = function(t7, e2, r2) {
  var n2 = {}, i2 = [];
  if (!lf.validate(e2, gf, n2, i2))
    throw (f2 = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.")).errors = i2, f2;
  var a2, o2, s2, u2 = xu.util.createBuffer(n2.salt), c2 = xu.util.createBuffer(n2.iterations);
  switch (c2 = c2.getInt(c2.length() << 3), t7) {
    case hf.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
      a2 = 24, o2 = 8, s2 = xu.des.startDecrypting;
      break;
    case hf.oids["pbewithSHAAnd40BitRC2-CBC"]:
      a2 = 5, o2 = 8, s2 = function(t8, e3) {
        var r3 = xu.rc2.createDecryptionCipher(t8, 40);
        return r3.start(e3, null), r3;
      };
      break;
    default:
      var f2;
      throw (f2 = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.")).oid = t7, f2;
  }
  var l2 = mf(n2.prfOid), h2 = hf.pbe.generatePkcs12Key(r2, u2, 1, c2, a2, l2);
  return l2.start(), s2(h2, hf.pbe.generatePkcs12Key(r2, u2, 2, c2, o2, l2));
}, hf.pbe.opensslDeriveBytes = function(t7, e2, r2, n2) {
  if (n2 == null) {
    if (!("md5" in xu.md))
      throw new Error('"md5" hash algorithm unavailable.');
    n2 = xu.md.md5.create();
  }
  e2 === null && (e2 = "");
  for (var i2 = [vf(n2, t7 + e2)], a2 = 16, o2 = 1; a2 < r2; ++o2, a2 += 16)
    i2.push(vf(n2, i2[o2 - 1] + t7 + e2));
  return i2.join("").substr(0, r2);
}, w(function(t7) {
  var e2 = xu.asn1, r2 = t7.exports = xu.pkcs7asn1 = xu.pkcs7asn1 || {};
  xu.pkcs7 = xu.pkcs7 || {}, xu.pkcs7.asn1 = r2;
  var n2 = { name: "ContentInfo", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, value: [{ name: "ContentInfo.ContentType", tagClass: e2.Class.UNIVERSAL, type: e2.Type.OID, constructed: false, capture: "contentType" }, { name: "ContentInfo.content", tagClass: e2.Class.CONTEXT_SPECIFIC, type: 0, constructed: true, optional: true, captureAsn1: "content" }] };
  r2.contentInfoValidator = n2;
  var i2 = { name: "EncryptedContentInfo", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, value: [{ name: "EncryptedContentInfo.contentType", tagClass: e2.Class.UNIVERSAL, type: e2.Type.OID, constructed: false, capture: "contentType" }, { name: "EncryptedContentInfo.contentEncryptionAlgorithm", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, value: [{ name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm", tagClass: e2.Class.UNIVERSAL, type: e2.Type.OID, constructed: false, capture: "encAlgorithm" }, { name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter", tagClass: e2.Class.UNIVERSAL, captureAsn1: "encParameter" }] }, { name: "EncryptedContentInfo.encryptedContent", tagClass: e2.Class.CONTEXT_SPECIFIC, type: 0, capture: "encryptedContent", captureAsn1: "encryptedContentAsn1" }] };
  r2.envelopedDataValidator = { name: "EnvelopedData", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, value: [{ name: "EnvelopedData.Version", tagClass: e2.Class.UNIVERSAL, type: e2.Type.INTEGER, constructed: false, capture: "version" }, { name: "EnvelopedData.RecipientInfos", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SET, constructed: true, captureAsn1: "recipientInfos" }].concat(i2) }, r2.encryptedDataValidator = { name: "EncryptedData", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, value: [{ name: "EncryptedData.Version", tagClass: e2.Class.UNIVERSAL, type: e2.Type.INTEGER, constructed: false, capture: "version" }].concat(i2) };
  var a2 = { name: "SignerInfo", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, value: [{ name: "SignerInfo.version", tagClass: e2.Class.UNIVERSAL, type: e2.Type.INTEGER, constructed: false }, { name: "SignerInfo.issuerAndSerialNumber", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, value: [{ name: "SignerInfo.issuerAndSerialNumber.issuer", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, captureAsn1: "issuer" }, { name: "SignerInfo.issuerAndSerialNumber.serialNumber", tagClass: e2.Class.UNIVERSAL, type: e2.Type.INTEGER, constructed: false, capture: "serial" }] }, { name: "SignerInfo.digestAlgorithm", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, value: [{ name: "SignerInfo.digestAlgorithm.algorithm", tagClass: e2.Class.UNIVERSAL, type: e2.Type.OID, constructed: false, capture: "digestAlgorithm" }, { name: "SignerInfo.digestAlgorithm.parameter", tagClass: e2.Class.UNIVERSAL, constructed: false, captureAsn1: "digestParameter", optional: true }] }, { name: "SignerInfo.authenticatedAttributes", tagClass: e2.Class.CONTEXT_SPECIFIC, type: 0, constructed: true, optional: true, capture: "authenticatedAttributes" }, { name: "SignerInfo.digestEncryptionAlgorithm", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, capture: "signatureAlgorithm" }, { name: "SignerInfo.encryptedDigest", tagClass: e2.Class.UNIVERSAL, type: e2.Type.OCTETSTRING, constructed: false, capture: "signature" }, { name: "SignerInfo.unauthenticatedAttributes", tagClass: e2.Class.CONTEXT_SPECIFIC, type: 1, constructed: true, optional: true, capture: "unauthenticatedAttributes" }] };
  r2.signedDataValidator = { name: "SignedData", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, value: [{ name: "SignedData.Version", tagClass: e2.Class.UNIVERSAL, type: e2.Type.INTEGER, constructed: false, capture: "version" }, { name: "SignedData.DigestAlgorithms", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SET, constructed: true, captureAsn1: "digestAlgorithms" }, n2, { name: "SignedData.Certificates", tagClass: e2.Class.CONTEXT_SPECIFIC, type: 0, optional: true, captureAsn1: "certificates" }, { name: "SignedData.CertificateRevocationLists", tagClass: e2.Class.CONTEXT_SPECIFIC, type: 1, optional: true, captureAsn1: "crls" }, { name: "SignedData.SignerInfos", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SET, capture: "signerInfos", optional: true, value: [a2] }] }, r2.recipientInfoValidator = { name: "RecipientInfo", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, value: [{ name: "RecipientInfo.version", tagClass: e2.Class.UNIVERSAL, type: e2.Type.INTEGER, constructed: false, capture: "version" }, { name: "RecipientInfo.issuerAndSerial", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, value: [{ name: "RecipientInfo.issuerAndSerial.issuer", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, captureAsn1: "issuer" }, { name: "RecipientInfo.issuerAndSerial.serialNumber", tagClass: e2.Class.UNIVERSAL, type: e2.Type.INTEGER, constructed: false, capture: "serial" }] }, { name: "RecipientInfo.keyEncryptionAlgorithm", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, value: [{ name: "RecipientInfo.keyEncryptionAlgorithm.algorithm", tagClass: e2.Class.UNIVERSAL, type: e2.Type.OID, constructed: false, capture: "encAlgorithm" }, { name: "RecipientInfo.keyEncryptionAlgorithm.parameter", tagClass: e2.Class.UNIVERSAL, constructed: false, captureAsn1: "encParameter" }] }, { name: "RecipientInfo.encryptedKey", tagClass: e2.Class.UNIVERSAL, type: e2.Type.OCTETSTRING, constructed: false, capture: "encKey" }] };
}), w(function(t7) {
  xu.mgf = xu.mgf || {}, (t7.exports = xu.mgf.mgf1 = xu.mgf1 = xu.mgf1 || {}).create = function(t8) {
    return { generate: function(e2, r2) {
      for (var n2 = new xu.util.ByteBuffer(), i2 = Math.ceil(r2 / t8.digestLength), a2 = 0; a2 < i2; a2++) {
        var o2 = new xu.util.ByteBuffer();
        o2.putInt32(a2), t8.start(), t8.update(e2 + o2.getBytes()), n2.putBuffer(t8.digest());
      }
      return n2.truncate(n2.length() - r2), n2.getBytes();
    } };
  };
}), xu.mgf = xu.mgf || {}, xu.mgf.mgf1 = xu.mgf1, w(function(t7) {
  (t7.exports = xu.pss = xu.pss || {}).create = function(t8) {
    arguments.length === 3 && (t8 = { md: arguments[0], mgf: arguments[1], saltLength: arguments[2] });
    var e2, r2 = t8.md, n2 = t8.mgf, i2 = r2.digestLength, a2 = t8.salt || null;
    if (typeof a2 == "string" && (a2 = xu.util.createBuffer(a2)), "saltLength" in t8)
      e2 = t8.saltLength;
    else {
      if (a2 === null)
        throw new Error("Salt length not specified or specific salt not given.");
      e2 = a2.length();
    }
    if (a2 !== null && a2.length() !== e2)
      throw new Error("Given salt length does not match length of given salt.");
    var o2 = t8.prng || xu.random, s2 = { encode: function(t9, s3) {
      var u2, c2, f2 = s3 - 1, l2 = Math.ceil(f2 / 8), h2 = t9.digest().getBytes();
      if (l2 < i2 + e2 + 2)
        throw new Error("Message is too long to encrypt.");
      c2 = a2 === null ? o2.getBytesSync(e2) : a2.bytes();
      var p2 = new xu.util.ByteBuffer();
      p2.fillWithByte(0, 8), p2.putBytes(h2), p2.putBytes(c2), r2.start(), r2.update(p2.getBytes());
      var d2 = r2.digest().getBytes(), y2 = new xu.util.ByteBuffer();
      y2.fillWithByte(0, l2 - e2 - i2 - 2), y2.putByte(1), y2.putBytes(c2);
      var g2 = y2.getBytes(), v2 = l2 - i2 - 1, m2 = n2.generate(d2, v2), C2 = "";
      for (u2 = 0; u2 < v2; u2++)
        C2 += String.fromCharCode(g2.charCodeAt(u2) ^ m2.charCodeAt(u2));
      var E2 = 65280 >> 8 * l2 - f2 & 255;
      return (C2 = String.fromCharCode(C2.charCodeAt(0) & ~E2) + C2.substr(1)) + d2 + String.fromCharCode(188);
    }, verify: function(t9, a3, o3) {
      var s3, u2 = o3 - 1, c2 = Math.ceil(u2 / 8);
      if (a3 = a3.substr(-c2), c2 < i2 + e2 + 2)
        throw new Error("Inconsistent parameters to PSS signature verification.");
      if (a3.charCodeAt(c2 - 1) !== 188)
        throw new Error("Encoded message does not end in 0xBC.");
      var f2 = c2 - i2 - 1, l2 = a3.substr(0, f2), h2 = a3.substr(f2, i2), p2 = 65280 >> 8 * c2 - u2 & 255;
      if ((l2.charCodeAt(0) & p2) != 0)
        throw new Error("Bits beyond keysize not zero as expected.");
      var d2 = n2.generate(h2, f2), y2 = "";
      for (s3 = 0; s3 < f2; s3++)
        y2 += String.fromCharCode(l2.charCodeAt(s3) ^ d2.charCodeAt(s3));
      y2 = String.fromCharCode(y2.charCodeAt(0) & ~p2) + y2.substr(1);
      var g2 = c2 - i2 - e2 - 2;
      for (s3 = 0; s3 < g2; s3++)
        if (y2.charCodeAt(s3) !== 0)
          throw new Error("Leftmost octets not zero as expected");
      if (y2.charCodeAt(g2) !== 1)
        throw new Error("Inconsistent PSS signature, 0x01 marker not found");
      var v2 = y2.substr(-e2), m2 = new xu.util.ByteBuffer();
      return m2.fillWithByte(0, 8), m2.putBytes(t9), m2.putBytes(v2), r2.start(), r2.update(m2.getBytes()), h2 === r2.digest().getBytes();
    } };
    return s2;
  };
}), w(function(t7) {
  var e2 = xu.asn1, r2 = t7.exports = xu.pki = xu.pki || {}, n2 = r2.oids, i2 = {};
  i2.CN = n2.commonName, i2.commonName = "CN", i2.C = n2.countryName, i2.countryName = "C", i2.L = n2.localityName, i2.localityName = "L", i2.ST = n2.stateOrProvinceName, i2.stateOrProvinceName = "ST", i2.O = n2.organizationName, i2.organizationName = "O", i2.OU = n2.organizationalUnitName, i2.organizationalUnitName = "OU", i2.E = n2.emailAddress, i2.emailAddress = "E";
  var a2 = xu.pki.rsa.publicKeyValidator, o2 = { name: "Certificate", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, value: [{ name: "Certificate.TBSCertificate", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, captureAsn1: "tbsCertificate", value: [{ name: "Certificate.TBSCertificate.version", tagClass: e2.Class.CONTEXT_SPECIFIC, type: 0, constructed: true, optional: true, value: [{ name: "Certificate.TBSCertificate.version.integer", tagClass: e2.Class.UNIVERSAL, type: e2.Type.INTEGER, constructed: false, capture: "certVersion" }] }, { name: "Certificate.TBSCertificate.serialNumber", tagClass: e2.Class.UNIVERSAL, type: e2.Type.INTEGER, constructed: false, capture: "certSerialNumber" }, { name: "Certificate.TBSCertificate.signature", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, value: [{ name: "Certificate.TBSCertificate.signature.algorithm", tagClass: e2.Class.UNIVERSAL, type: e2.Type.OID, constructed: false, capture: "certinfoSignatureOid" }, { name: "Certificate.TBSCertificate.signature.parameters", tagClass: e2.Class.UNIVERSAL, optional: true, captureAsn1: "certinfoSignatureParams" }] }, { name: "Certificate.TBSCertificate.issuer", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, captureAsn1: "certIssuer" }, { name: "Certificate.TBSCertificate.validity", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, value: [{ name: "Certificate.TBSCertificate.validity.notBefore (utc)", tagClass: e2.Class.UNIVERSAL, type: e2.Type.UTCTIME, constructed: false, optional: true, capture: "certValidity1UTCTime" }, { name: "Certificate.TBSCertificate.validity.notBefore (generalized)", tagClass: e2.Class.UNIVERSAL, type: e2.Type.GENERALIZEDTIME, constructed: false, optional: true, capture: "certValidity2GeneralizedTime" }, { name: "Certificate.TBSCertificate.validity.notAfter (utc)", tagClass: e2.Class.UNIVERSAL, type: e2.Type.UTCTIME, constructed: false, optional: true, capture: "certValidity3UTCTime" }, { name: "Certificate.TBSCertificate.validity.notAfter (generalized)", tagClass: e2.Class.UNIVERSAL, type: e2.Type.GENERALIZEDTIME, constructed: false, optional: true, capture: "certValidity4GeneralizedTime" }] }, { name: "Certificate.TBSCertificate.subject", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, captureAsn1: "certSubject" }, a2, { name: "Certificate.TBSCertificate.issuerUniqueID", tagClass: e2.Class.CONTEXT_SPECIFIC, type: 1, constructed: true, optional: true, value: [{ name: "Certificate.TBSCertificate.issuerUniqueID.id", tagClass: e2.Class.UNIVERSAL, type: e2.Type.BITSTRING, constructed: false, captureBitStringValue: "certIssuerUniqueId" }] }, { name: "Certificate.TBSCertificate.subjectUniqueID", tagClass: e2.Class.CONTEXT_SPECIFIC, type: 2, constructed: true, optional: true, value: [{ name: "Certificate.TBSCertificate.subjectUniqueID.id", tagClass: e2.Class.UNIVERSAL, type: e2.Type.BITSTRING, constructed: false, captureBitStringValue: "certSubjectUniqueId" }] }, { name: "Certificate.TBSCertificate.extensions", tagClass: e2.Class.CONTEXT_SPECIFIC, type: 3, constructed: true, captureAsn1: "certExtensions", optional: true }] }, { name: "Certificate.signatureAlgorithm", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, value: [{ name: "Certificate.signatureAlgorithm.algorithm", tagClass: e2.Class.UNIVERSAL, type: e2.Type.OID, constructed: false, capture: "certSignatureOid" }, { name: "Certificate.TBSCertificate.signature.parameters", tagClass: e2.Class.UNIVERSAL, optional: true, captureAsn1: "certSignatureParams" }] }, { name: "Certificate.signatureValue", tagClass: e2.Class.UNIVERSAL, type: e2.Type.BITSTRING, constructed: false, captureBitStringValue: "certSignature" }] }, s2 = { name: "rsapss", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, value: [{ name: "rsapss.hashAlgorithm", tagClass: e2.Class.CONTEXT_SPECIFIC, type: 0, constructed: true, value: [{ name: "rsapss.hashAlgorithm.AlgorithmIdentifier", tagClass: e2.Class.UNIVERSAL, type: e2.Class.SEQUENCE, constructed: true, optional: true, value: [{ name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm", tagClass: e2.Class.UNIVERSAL, type: e2.Type.OID, constructed: false, capture: "hashOid" }] }] }, { name: "rsapss.maskGenAlgorithm", tagClass: e2.Class.CONTEXT_SPECIFIC, type: 1, constructed: true, value: [{ name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier", tagClass: e2.Class.UNIVERSAL, type: e2.Class.SEQUENCE, constructed: true, optional: true, value: [{ name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm", tagClass: e2.Class.UNIVERSAL, type: e2.Type.OID, constructed: false, capture: "maskGenOid" }, { name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, value: [{ name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm", tagClass: e2.Class.UNIVERSAL, type: e2.Type.OID, constructed: false, capture: "maskGenHashOid" }] }] }] }, { name: "rsapss.saltLength", tagClass: e2.Class.CONTEXT_SPECIFIC, type: 2, optional: true, value: [{ name: "rsapss.saltLength.saltLength", tagClass: e2.Class.UNIVERSAL, type: e2.Class.INTEGER, constructed: false, capture: "saltLength" }] }, { name: "rsapss.trailerField", tagClass: e2.Class.CONTEXT_SPECIFIC, type: 3, optional: true, value: [{ name: "rsapss.trailer.trailer", tagClass: e2.Class.UNIVERSAL, type: e2.Class.INTEGER, constructed: false, capture: "trailer" }] }] }, u2 = { name: "CertificationRequestInfo", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, captureAsn1: "certificationRequestInfo", value: [{ name: "CertificationRequestInfo.integer", tagClass: e2.Class.UNIVERSAL, type: e2.Type.INTEGER, constructed: false, capture: "certificationRequestInfoVersion" }, { name: "CertificationRequestInfo.subject", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, captureAsn1: "certificationRequestInfoSubject" }, a2, { name: "CertificationRequestInfo.attributes", tagClass: e2.Class.CONTEXT_SPECIFIC, type: 0, constructed: true, optional: true, capture: "certificationRequestInfoAttributes", value: [{ name: "CertificationRequestInfo.attributes", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, value: [{ name: "CertificationRequestInfo.attributes.type", tagClass: e2.Class.UNIVERSAL, type: e2.Type.OID, constructed: false }, { name: "CertificationRequestInfo.attributes.value", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SET, constructed: true }] }] }] }, c2 = { name: "CertificationRequest", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, captureAsn1: "csr", value: [u2, { name: "CertificationRequest.signatureAlgorithm", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, value: [{ name: "CertificationRequest.signatureAlgorithm.algorithm", tagClass: e2.Class.UNIVERSAL, type: e2.Type.OID, constructed: false, capture: "csrSignatureOid" }, { name: "CertificationRequest.signatureAlgorithm.parameters", tagClass: e2.Class.UNIVERSAL, optional: true, captureAsn1: "csrSignatureParams" }] }, { name: "CertificationRequest.signature", tagClass: e2.Class.UNIVERSAL, type: e2.Type.BITSTRING, constructed: false, captureBitStringValue: "csrSignature" }] };
  function f2(t8, e3) {
    typeof e3 == "string" && (e3 = { shortName: e3 });
    for (var r3, n3 = null, i3 = 0; n3 === null && i3 < t8.attributes.length; ++i3)
      r3 = t8.attributes[i3], (e3.type && e3.type === r3.type || e3.name && e3.name === r3.name || e3.shortName && e3.shortName === r3.shortName) && (n3 = r3);
    return n3;
  }
  r2.RDNAttributesAsArray = function(t8, r3) {
    for (var a3, o3, s3, u3 = [], c3 = 0; c3 < t8.value.length; ++c3) {
      a3 = t8.value[c3];
      for (var f3 = 0; f3 < a3.value.length; ++f3)
        s3 = {}, o3 = a3.value[f3], s3.type = e2.derToOid(o3.value[0].value), s3.value = o3.value[1].value, s3.valueTagClass = o3.value[1].type, s3.type in n2 && (s3.name = n2[s3.type], s3.name in i2 && (s3.shortName = i2[s3.name])), r3 && (r3.update(s3.type), r3.update(s3.value)), u3.push(s3);
    }
    return u3;
  }, r2.CRIAttributesAsArray = function(t8) {
    for (var a3 = [], o3 = 0; o3 < t8.length; ++o3)
      for (var s3 = t8[o3], u3 = e2.derToOid(s3.value[0].value), c3 = s3.value[1].value, f3 = 0; f3 < c3.length; ++f3) {
        var l3 = {};
        if (l3.type = u3, l3.value = c3[f3].value, l3.valueTagClass = c3[f3].type, l3.type in n2 && (l3.name = n2[l3.type], l3.name in i2 && (l3.shortName = i2[l3.name])), l3.type === n2.extensionRequest) {
          l3.extensions = [];
          for (var h3 = 0; h3 < l3.value.length; ++h3)
            l3.extensions.push(r2.certificateExtensionFromAsn1(l3.value[h3]));
        }
        a3.push(l3);
      }
    return a3;
  };
  var l2 = function(t8, r3, i3) {
    var a3 = {};
    if (t8 !== n2["RSASSA-PSS"])
      return a3;
    i3 && (a3 = { hash: { algorithmOid: n2.sha1 }, mgf: { algorithmOid: n2.mgf1, hash: { algorithmOid: n2.sha1 } }, saltLength: 20 });
    var o3 = {}, u3 = [];
    if (!e2.validate(r3, s2, o3, u3)) {
      var c3 = new Error("Cannot read RSASSA-PSS parameter block.");
      throw c3.errors = u3, c3;
    }
    return o3.hashOid !== void 0 && (a3.hash = a3.hash || {}, a3.hash.algorithmOid = e2.derToOid(o3.hashOid)), o3.maskGenOid !== void 0 && (a3.mgf = a3.mgf || {}, a3.mgf.algorithmOid = e2.derToOid(o3.maskGenOid), a3.mgf.hash = a3.mgf.hash || {}, a3.mgf.hash.algorithmOid = e2.derToOid(o3.maskGenHashOid)), o3.saltLength !== void 0 && (a3.saltLength = o3.saltLength.charCodeAt(0)), a3;
  };
  function h2(t8) {
    for (var r3, n3, i3 = e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, []), a3 = t8.attributes, o3 = 0; o3 < a3.length; ++o3) {
      var s3 = (r3 = a3[o3]).value, u3 = e2.Type.PRINTABLESTRING;
      "valueTagClass" in r3 && (u3 = r3.valueTagClass) === e2.Type.UTF8 && (s3 = xu.util.encodeUtf8(s3)), n3 = e2.create(e2.Class.UNIVERSAL, e2.Type.SET, true, [e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, [e2.create(e2.Class.UNIVERSAL, e2.Type.OID, false, e2.oidToDer(r3.type).getBytes()), e2.create(e2.Class.UNIVERSAL, u3, false, s3)])]), i3.value.push(n3);
    }
    return i3;
  }
  function p2(t8) {
    for (var a3, o3 = 0; o3 < t8.length; ++o3) {
      if ((a3 = t8[o3]).name === void 0 && (a3.type && a3.type in r2.oids ? a3.name = r2.oids[a3.type] : a3.shortName && a3.shortName in i2 && (a3.name = r2.oids[i2[a3.shortName]])), a3.type === void 0) {
        if (!a3.name || !(a3.name in r2.oids))
          throw (u3 = new Error("Attribute type not specified.")).attribute = a3, u3;
        a3.type = r2.oids[a3.name];
      }
      if (a3.shortName === void 0 && a3.name && a3.name in i2 && (a3.shortName = i2[a3.name]), a3.type === n2.extensionRequest && (a3.valueConstructed = true, a3.valueTagClass = e2.Type.SEQUENCE, !a3.value && a3.extensions)) {
        a3.value = [];
        for (var s3 = 0; s3 < a3.extensions.length; ++s3)
          a3.value.push(r2.certificateExtensionToAsn1(d2(a3.extensions[s3])));
      }
      var u3;
      if (a3.value === void 0)
        throw (u3 = new Error("Attribute value not specified.")).attribute = a3, u3;
    }
  }
  function d2(t8, i3) {
    if (i3 = i3 || {}, t8.name === void 0 && t8.id && t8.id in r2.oids && (t8.name = r2.oids[t8.id]), t8.id === void 0) {
      if (!t8.name || !(t8.name in r2.oids))
        throw (E2 = new Error("Extension ID not specified.")).extension = t8, E2;
      t8.id = r2.oids[t8.name];
    }
    if (t8.value !== void 0)
      return t8;
    if (t8.name === "keyUsage") {
      var a3 = 0, o3 = 0, s3 = 0;
      t8.digitalSignature && (o3 |= 128, a3 = 7), t8.nonRepudiation && (o3 |= 64, a3 = 6), t8.keyEncipherment && (o3 |= 32, a3 = 5), t8.dataEncipherment && (o3 |= 16, a3 = 4), t8.keyAgreement && (o3 |= 8, a3 = 3), t8.keyCertSign && (o3 |= 4, a3 = 2), t8.cRLSign && (o3 |= 2, a3 = 1), t8.encipherOnly && (o3 |= 1, a3 = 0), t8.decipherOnly && (s3 |= 128, a3 = 7);
      var u3 = String.fromCharCode(a3);
      s3 !== 0 ? u3 += String.fromCharCode(o3) + String.fromCharCode(s3) : o3 !== 0 && (u3 += String.fromCharCode(o3)), t8.value = e2.create(e2.Class.UNIVERSAL, e2.Type.BITSTRING, false, u3);
    } else if (t8.name === "basicConstraints")
      t8.value = e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, []), t8.cA && t8.value.value.push(e2.create(e2.Class.UNIVERSAL, e2.Type.BOOLEAN, false, String.fromCharCode(255))), "pathLenConstraint" in t8 && t8.value.value.push(e2.create(e2.Class.UNIVERSAL, e2.Type.INTEGER, false, e2.integerToDer(t8.pathLenConstraint).getBytes()));
    else if (t8.name === "extKeyUsage") {
      t8.value = e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, []);
      var c3 = t8.value.value;
      for (var f3 in t8)
        t8[f3] === true && (f3 in n2 ? c3.push(e2.create(e2.Class.UNIVERSAL, e2.Type.OID, false, e2.oidToDer(n2[f3]).getBytes())) : f3.indexOf(".") !== -1 && c3.push(e2.create(e2.Class.UNIVERSAL, e2.Type.OID, false, e2.oidToDer(f3).getBytes())));
    } else if (t8.name === "nsCertType") {
      a3 = 0, o3 = 0;
      t8.client && (o3 |= 128, a3 = 7), t8.server && (o3 |= 64, a3 = 6), t8.email && (o3 |= 32, a3 = 5), t8.objsign && (o3 |= 16, a3 = 4), t8.reserved && (o3 |= 8, a3 = 3), t8.sslCA && (o3 |= 4, a3 = 2), t8.emailCA && (o3 |= 2, a3 = 1), t8.objCA && (o3 |= 1, a3 = 0);
      u3 = String.fromCharCode(a3);
      o3 !== 0 && (u3 += String.fromCharCode(o3)), t8.value = e2.create(e2.Class.UNIVERSAL, e2.Type.BITSTRING, false, u3);
    } else if (t8.name === "subjectAltName" || t8.name === "issuerAltName") {
      t8.value = e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, []);
      for (var l3 = 0; l3 < t8.altNames.length; ++l3) {
        u3 = (v3 = t8.altNames[l3]).value;
        if (v3.type === 7 && v3.ip) {
          if ((u3 = xu.util.bytesFromIP(v3.ip)) === null)
            throw (E2 = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.')).extension = t8, E2;
        } else
          v3.type === 8 && (u3 = v3.oid ? e2.oidToDer(e2.oidToDer(v3.oid)) : e2.oidToDer(u3));
        t8.value.value.push(e2.create(e2.Class.CONTEXT_SPECIFIC, v3.type, false, u3));
      }
    } else if (t8.name === "nsComment" && i3.cert) {
      if (!/^[\x00-\x7F]*$/.test(t8.comment) || t8.comment.length < 1 || t8.comment.length > 128)
        throw new Error('Invalid "nsComment" content.');
      t8.value = e2.create(e2.Class.UNIVERSAL, e2.Type.IA5STRING, false, t8.comment);
    } else if (t8.name === "subjectKeyIdentifier" && i3.cert) {
      var p3 = i3.cert.generateSubjectKeyIdentifier();
      t8.subjectKeyIdentifier = p3.toHex(), t8.value = e2.create(e2.Class.UNIVERSAL, e2.Type.OCTETSTRING, false, p3.getBytes());
    } else if (t8.name === "authorityKeyIdentifier" && i3.cert) {
      t8.value = e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, []);
      c3 = t8.value.value;
      if (t8.keyIdentifier) {
        var d3 = t8.keyIdentifier === true ? i3.cert.generateSubjectKeyIdentifier().getBytes() : t8.keyIdentifier;
        c3.push(e2.create(e2.Class.CONTEXT_SPECIFIC, 0, false, d3));
      }
      if (t8.authorityCertIssuer) {
        var y3 = [e2.create(e2.Class.CONTEXT_SPECIFIC, 4, true, [h2(t8.authorityCertIssuer === true ? i3.cert.issuer : t8.authorityCertIssuer)])];
        c3.push(e2.create(e2.Class.CONTEXT_SPECIFIC, 1, true, y3));
      }
      if (t8.serialNumber) {
        var g3 = xu.util.hexToBytes(t8.serialNumber === true ? i3.cert.serialNumber : t8.serialNumber);
        c3.push(e2.create(e2.Class.CONTEXT_SPECIFIC, 2, false, g3));
      }
    } else if (t8.name === "cRLDistributionPoints") {
      t8.value = e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, []);
      c3 = t8.value.value;
      var v3, m3 = e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, []), C3 = e2.create(e2.Class.CONTEXT_SPECIFIC, 0, true, []);
      for (l3 = 0; l3 < t8.altNames.length; ++l3) {
        u3 = (v3 = t8.altNames[l3]).value;
        if (v3.type === 7 && v3.ip) {
          if ((u3 = xu.util.bytesFromIP(v3.ip)) === null)
            throw (E2 = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.')).extension = t8, E2;
        } else
          v3.type === 8 && (u3 = v3.oid ? e2.oidToDer(e2.oidToDer(v3.oid)) : e2.oidToDer(u3));
        C3.value.push(e2.create(e2.Class.CONTEXT_SPECIFIC, v3.type, false, u3));
      }
      m3.value.push(e2.create(e2.Class.CONTEXT_SPECIFIC, 0, true, [C3])), c3.push(m3);
    }
    var E2;
    if (t8.value === void 0)
      throw (E2 = new Error("Extension value not specified.")).extension = t8, E2;
    return t8;
  }
  function y2(t8, r3) {
    switch (t8) {
      case n2["RSASSA-PSS"]:
        var i3 = [];
        return r3.hash.algorithmOid !== void 0 && i3.push(e2.create(e2.Class.CONTEXT_SPECIFIC, 0, true, [e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, [e2.create(e2.Class.UNIVERSAL, e2.Type.OID, false, e2.oidToDer(r3.hash.algorithmOid).getBytes()), e2.create(e2.Class.UNIVERSAL, e2.Type.NULL, false, "")])])), r3.mgf.algorithmOid !== void 0 && i3.push(e2.create(e2.Class.CONTEXT_SPECIFIC, 1, true, [e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, [e2.create(e2.Class.UNIVERSAL, e2.Type.OID, false, e2.oidToDer(r3.mgf.algorithmOid).getBytes()), e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, [e2.create(e2.Class.UNIVERSAL, e2.Type.OID, false, e2.oidToDer(r3.mgf.hash.algorithmOid).getBytes()), e2.create(e2.Class.UNIVERSAL, e2.Type.NULL, false, "")])])])), r3.saltLength !== void 0 && i3.push(e2.create(e2.Class.CONTEXT_SPECIFIC, 2, true, [e2.create(e2.Class.UNIVERSAL, e2.Type.INTEGER, false, e2.integerToDer(r3.saltLength).getBytes())])), e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, i3);
      default:
        return e2.create(e2.Class.UNIVERSAL, e2.Type.NULL, false, "");
    }
  }
  function g2(t8) {
    var r3 = e2.create(e2.Class.CONTEXT_SPECIFIC, 0, true, []);
    if (t8.attributes.length === 0)
      return r3;
    for (var n3 = t8.attributes, i3 = 0; i3 < n3.length; ++i3) {
      var a3 = n3[i3], o3 = a3.value, s3 = e2.Type.UTF8;
      "valueTagClass" in a3 && (s3 = a3.valueTagClass), s3 === e2.Type.UTF8 && (o3 = xu.util.encodeUtf8(o3));
      var u3 = false;
      "valueConstructed" in a3 && (u3 = a3.valueConstructed);
      var c3 = e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, [e2.create(e2.Class.UNIVERSAL, e2.Type.OID, false, e2.oidToDer(a3.type).getBytes()), e2.create(e2.Class.UNIVERSAL, e2.Type.SET, true, [e2.create(e2.Class.UNIVERSAL, s3, u3, o3)])]);
      r3.value.push(c3);
    }
    return r3;
  }
  r2.certificateFromPem = function(t8, n3, i3) {
    var a3 = xu.pem.decode(t8)[0];
    if (a3.type !== "CERTIFICATE" && a3.type !== "X509 CERTIFICATE" && a3.type !== "TRUSTED CERTIFICATE") {
      var o3 = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
      throw o3.headerType = a3.type, o3;
    }
    if (a3.procType && a3.procType.type === "ENCRYPTED")
      throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
    var s3 = e2.fromDer(a3.body, i3);
    return r2.certificateFromAsn1(s3, n3);
  }, r2.certificateToPem = function(t8, n3) {
    var i3 = { type: "CERTIFICATE", body: e2.toDer(r2.certificateToAsn1(t8)).getBytes() };
    return xu.pem.encode(i3, { maxline: n3 });
  }, r2.publicKeyFromPem = function(t8) {
    var n3 = xu.pem.decode(t8)[0];
    if (n3.type !== "PUBLIC KEY" && n3.type !== "RSA PUBLIC KEY") {
      var i3 = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
      throw i3.headerType = n3.type, i3;
    }
    if (n3.procType && n3.procType.type === "ENCRYPTED")
      throw new Error("Could not convert public key from PEM; PEM is encrypted.");
    var a3 = e2.fromDer(n3.body);
    return r2.publicKeyFromAsn1(a3);
  }, r2.publicKeyToPem = function(t8, n3) {
    var i3 = { type: "PUBLIC KEY", body: e2.toDer(r2.publicKeyToAsn1(t8)).getBytes() };
    return xu.pem.encode(i3, { maxline: n3 });
  }, r2.publicKeyToRSAPublicKeyPem = function(t8, n3) {
    var i3 = { type: "RSA PUBLIC KEY", body: e2.toDer(r2.publicKeyToRSAPublicKey(t8)).getBytes() };
    return xu.pem.encode(i3, { maxline: n3 });
  }, r2.getPublicKeyFingerprint = function(t8, n3) {
    var i3, a3 = (n3 = n3 || {}).md || xu.md.sha1.create();
    switch (n3.type || "RSAPublicKey") {
      case "RSAPublicKey":
        i3 = e2.toDer(r2.publicKeyToRSAPublicKey(t8)).getBytes();
        break;
      case "SubjectPublicKeyInfo":
        i3 = e2.toDer(r2.publicKeyToAsn1(t8)).getBytes();
        break;
      default:
        throw new Error('Unknown fingerprint type "' + n3.type + '".');
    }
    a3.start(), a3.update(i3);
    var o3 = a3.digest();
    if (n3.encoding === "hex") {
      var s3 = o3.toHex();
      return n3.delimiter ? s3.match(/.{2}/g).join(n3.delimiter) : s3;
    }
    if (n3.encoding === "binary")
      return o3.getBytes();
    if (n3.encoding)
      throw new Error('Unknown encoding "' + n3.encoding + '".');
    return o3;
  }, r2.certificationRequestFromPem = function(t8, n3, i3) {
    var a3 = xu.pem.decode(t8)[0];
    if (a3.type !== "CERTIFICATE REQUEST") {
      var o3 = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
      throw o3.headerType = a3.type, o3;
    }
    if (a3.procType && a3.procType.type === "ENCRYPTED")
      throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
    var s3 = e2.fromDer(a3.body, i3);
    return r2.certificationRequestFromAsn1(s3, n3);
  }, r2.certificationRequestToPem = function(t8, n3) {
    var i3 = { type: "CERTIFICATE REQUEST", body: e2.toDer(r2.certificationRequestToAsn1(t8)).getBytes() };
    return xu.pem.encode(i3, { maxline: n3 });
  }, r2.createCertificate = function() {
    var t8 = { version: 2, serialNumber: "00", signatureOid: null, signature: null, siginfo: {} };
    return t8.siginfo.algorithmOid = null, t8.validity = {}, t8.validity.notBefore = new Date(), t8.validity.notAfter = new Date(), t8.issuer = {}, t8.issuer.getField = function(e3) {
      return f2(t8.issuer, e3);
    }, t8.issuer.addField = function(e3) {
      p2([e3]), t8.issuer.attributes.push(e3);
    }, t8.issuer.attributes = [], t8.issuer.hash = null, t8.subject = {}, t8.subject.getField = function(e3) {
      return f2(t8.subject, e3);
    }, t8.subject.addField = function(e3) {
      p2([e3]), t8.subject.attributes.push(e3);
    }, t8.subject.attributes = [], t8.subject.hash = null, t8.extensions = [], t8.publicKey = null, t8.md = null, t8.setSubject = function(e3, r3) {
      p2(e3), t8.subject.attributes = e3, delete t8.subject.uniqueId, r3 && (t8.subject.uniqueId = r3), t8.subject.hash = null;
    }, t8.setIssuer = function(e3, r3) {
      p2(e3), t8.issuer.attributes = e3, delete t8.issuer.uniqueId, r3 && (t8.issuer.uniqueId = r3), t8.issuer.hash = null;
    }, t8.setExtensions = function(e3) {
      for (var r3 = 0; r3 < e3.length; ++r3)
        d2(e3[r3], { cert: t8 });
      t8.extensions = e3;
    }, t8.getExtension = function(e3) {
      typeof e3 == "string" && (e3 = { name: e3 });
      for (var r3, n3 = null, i3 = 0; n3 === null && i3 < t8.extensions.length; ++i3)
        r3 = t8.extensions[i3], (e3.id && r3.id === e3.id || e3.name && r3.name === e3.name) && (n3 = r3);
      return n3;
    }, t8.sign = function(i3, a3) {
      t8.md = a3 || xu.md.sha1.create();
      var o3 = n2[t8.md.algorithm + "WithRSAEncryption"];
      if (!o3) {
        var s3 = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
        throw s3.algorithm = t8.md.algorithm, s3;
      }
      t8.signatureOid = t8.siginfo.algorithmOid = o3, t8.tbsCertificate = r2.getTBSCertificate(t8);
      var u3 = e2.toDer(t8.tbsCertificate);
      t8.md.update(u3.getBytes()), t8.signature = i3.sign(t8.md);
    }, t8.verify = function(i3) {
      var a3 = false;
      if (!t8.issued(i3)) {
        var o3 = i3.issuer, s3 = t8.subject;
        throw (d3 = new Error("The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject.")).expectedIssuer = o3.attributes, d3.actualIssuer = s3.attributes, d3;
      }
      var u3 = i3.md;
      if (u3 === null) {
        if (i3.signatureOid in n2)
          switch (n2[i3.signatureOid]) {
            case "sha1WithRSAEncryption":
              u3 = xu.md.sha1.create();
              break;
            case "md5WithRSAEncryption":
              u3 = xu.md.md5.create();
              break;
            case "sha256WithRSAEncryption":
              u3 = xu.md.sha256.create();
              break;
            case "sha384WithRSAEncryption":
              u3 = xu.md.sha384.create();
              break;
            case "sha512WithRSAEncryption":
              u3 = xu.md.sha512.create();
              break;
            case "RSASSA-PSS":
              u3 = xu.md.sha256.create();
          }
        if (u3 === null)
          throw (d3 = new Error("Could not compute certificate digest. Unknown signature OID.")).signatureOid = i3.signatureOid, d3;
        var c3 = i3.tbsCertificate || r2.getTBSCertificate(i3), f3 = e2.toDer(c3);
        u3.update(f3.getBytes());
      }
      if (u3 !== null) {
        var l3;
        switch (i3.signatureOid) {
          case n2.sha1WithRSAEncryption:
            l3 = void 0;
            break;
          case n2["RSASSA-PSS"]:
            var h3, p3, d3;
            if ((h3 = n2[i3.signatureParameters.mgf.hash.algorithmOid]) === void 0 || xu.md[h3] === void 0)
              throw (d3 = new Error("Unsupported MGF hash function.")).oid = i3.signatureParameters.mgf.hash.algorithmOid, d3.name = h3, d3;
            if ((p3 = n2[i3.signatureParameters.mgf.algorithmOid]) === void 0 || xu.mgf[p3] === void 0)
              throw (d3 = new Error("Unsupported MGF function.")).oid = i3.signatureParameters.mgf.algorithmOid, d3.name = p3, d3;
            if (p3 = xu.mgf[p3].create(xu.md[h3].create()), (h3 = n2[i3.signatureParameters.hash.algorithmOid]) === void 0 || xu.md[h3] === void 0)
              throw { message: "Unsupported RSASSA-PSS hash function.", oid: i3.signatureParameters.hash.algorithmOid, name: h3 };
            l3 = xu.pss.create(xu.md[h3].create(), p3, i3.signatureParameters.saltLength);
        }
        a3 = t8.publicKey.verify(u3.digest().getBytes(), i3.signature, l3);
      }
      return a3;
    }, t8.isIssuer = function(e3) {
      var r3 = false, n3 = t8.issuer, i3 = e3.subject;
      if (n3.hash && i3.hash)
        r3 = n3.hash === i3.hash;
      else if (n3.attributes.length === i3.attributes.length) {
        var a3, o3;
        r3 = true;
        for (var s3 = 0; r3 && s3 < n3.attributes.length; ++s3)
          a3 = n3.attributes[s3], o3 = i3.attributes[s3], a3.type === o3.type && a3.value === o3.value || (r3 = false);
      }
      return r3;
    }, t8.issued = function(e3) {
      return e3.isIssuer(t8);
    }, t8.generateSubjectKeyIdentifier = function() {
      return r2.getPublicKeyFingerprint(t8.publicKey, { type: "RSAPublicKey" });
    }, t8.verifySubjectKeyIdentifier = function() {
      for (var e3 = n2.subjectKeyIdentifier, r3 = 0; r3 < t8.extensions.length; ++r3) {
        var i3 = t8.extensions[r3];
        if (i3.id === e3) {
          var a3 = t8.generateSubjectKeyIdentifier().getBytes();
          return xu.util.hexToBytes(i3.subjectKeyIdentifier) === a3;
        }
      }
      return false;
    }, t8;
  }, r2.certificateFromAsn1 = function(t8, i3) {
    var a3 = {}, s3 = [];
    if (!e2.validate(t8, o2, a3, s3))
      throw (d3 = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.")).errors = s3, d3;
    if (e2.derToOid(a3.publicKeyOid) !== r2.oids.rsaEncryption)
      throw new Error("Cannot read public key. OID is not RSA.");
    var u3 = r2.createCertificate();
    u3.version = a3.certVersion ? a3.certVersion.charCodeAt(0) : 0;
    var c3 = xu.util.createBuffer(a3.certSerialNumber);
    u3.serialNumber = c3.toHex(), u3.signatureOid = xu.asn1.derToOid(a3.certSignatureOid), u3.signatureParameters = l2(u3.signatureOid, a3.certSignatureParams, true), u3.siginfo.algorithmOid = xu.asn1.derToOid(a3.certinfoSignatureOid), u3.siginfo.parameters = l2(u3.siginfo.algorithmOid, a3.certinfoSignatureParams, false), u3.signature = a3.certSignature;
    var h3 = [];
    if (a3.certValidity1UTCTime !== void 0 && h3.push(e2.utcTimeToDate(a3.certValidity1UTCTime)), a3.certValidity2GeneralizedTime !== void 0 && h3.push(e2.generalizedTimeToDate(a3.certValidity2GeneralizedTime)), a3.certValidity3UTCTime !== void 0 && h3.push(e2.utcTimeToDate(a3.certValidity3UTCTime)), a3.certValidity4GeneralizedTime !== void 0 && h3.push(e2.generalizedTimeToDate(a3.certValidity4GeneralizedTime)), h3.length > 2)
      throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
    if (h3.length < 2)
      throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
    if (u3.validity.notBefore = h3[0], u3.validity.notAfter = h3[1], u3.tbsCertificate = a3.tbsCertificate, i3) {
      var d3;
      if (u3.md = null, u3.signatureOid in n2)
        switch (n2[u3.signatureOid]) {
          case "sha1WithRSAEncryption":
            u3.md = xu.md.sha1.create();
            break;
          case "md5WithRSAEncryption":
            u3.md = xu.md.md5.create();
            break;
          case "sha256WithRSAEncryption":
            u3.md = xu.md.sha256.create();
            break;
          case "sha384WithRSAEncryption":
            u3.md = xu.md.sha384.create();
            break;
          case "sha512WithRSAEncryption":
            u3.md = xu.md.sha512.create();
            break;
          case "RSASSA-PSS":
            u3.md = xu.md.sha256.create();
        }
      if (u3.md === null)
        throw (d3 = new Error("Could not compute certificate digest. Unknown signature OID.")).signatureOid = u3.signatureOid, d3;
      var y3 = e2.toDer(u3.tbsCertificate);
      u3.md.update(y3.getBytes());
    }
    var g3 = xu.md.sha1.create();
    u3.issuer.getField = function(t9) {
      return f2(u3.issuer, t9);
    }, u3.issuer.addField = function(t9) {
      p2([t9]), u3.issuer.attributes.push(t9);
    }, u3.issuer.attributes = r2.RDNAttributesAsArray(a3.certIssuer, g3), a3.certIssuerUniqueId && (u3.issuer.uniqueId = a3.certIssuerUniqueId), u3.issuer.hash = g3.digest().toHex();
    var v3 = xu.md.sha1.create();
    return u3.subject.getField = function(t9) {
      return f2(u3.subject, t9);
    }, u3.subject.addField = function(t9) {
      p2([t9]), u3.subject.attributes.push(t9);
    }, u3.subject.attributes = r2.RDNAttributesAsArray(a3.certSubject, v3), a3.certSubjectUniqueId && (u3.subject.uniqueId = a3.certSubjectUniqueId), u3.subject.hash = v3.digest().toHex(), a3.certExtensions ? u3.extensions = r2.certificateExtensionsFromAsn1(a3.certExtensions) : u3.extensions = [], u3.publicKey = r2.publicKeyFromAsn1(a3.subjectPublicKeyInfo), u3;
  }, r2.certificateExtensionsFromAsn1 = function(t8) {
    for (var e3 = [], n3 = 0; n3 < t8.value.length; ++n3)
      for (var i3 = t8.value[n3], a3 = 0; a3 < i3.value.length; ++a3)
        e3.push(r2.certificateExtensionFromAsn1(i3.value[a3]));
    return e3;
  }, r2.certificateExtensionFromAsn1 = function(t8) {
    var r3 = {};
    if (r3.id = e2.derToOid(t8.value[0].value), r3.critical = false, t8.value[1].type === e2.Type.BOOLEAN ? (r3.critical = t8.value[1].value.charCodeAt(0) !== 0, r3.value = t8.value[2].value) : r3.value = t8.value[1].value, r3.id in n2) {
      if (r3.name = n2[r3.id], r3.name === "keyUsage") {
        var i3 = 0, a3 = 0;
        (s3 = e2.fromDer(r3.value)).value.length > 1 && (i3 = s3.value.charCodeAt(1), a3 = s3.value.length > 2 ? s3.value.charCodeAt(2) : 0), r3.digitalSignature = (128 & i3) == 128, r3.nonRepudiation = (64 & i3) == 64, r3.keyEncipherment = (32 & i3) == 32, r3.dataEncipherment = (16 & i3) == 16, r3.keyAgreement = (8 & i3) == 8, r3.keyCertSign = (4 & i3) == 4, r3.cRLSign = (2 & i3) == 2, r3.encipherOnly = (1 & i3) == 1, r3.decipherOnly = (128 & a3) == 128;
      } else if (r3.name === "basicConstraints") {
        (s3 = e2.fromDer(r3.value)).value.length > 0 && s3.value[0].type === e2.Type.BOOLEAN ? r3.cA = s3.value[0].value.charCodeAt(0) !== 0 : r3.cA = false;
        var o3 = null;
        s3.value.length > 0 && s3.value[0].type === e2.Type.INTEGER ? o3 = s3.value[0].value : s3.value.length > 1 && (o3 = s3.value[1].value), o3 !== null && (r3.pathLenConstraint = e2.derToInteger(o3));
      } else if (r3.name === "extKeyUsage")
        for (var s3 = e2.fromDer(r3.value), u3 = 0; u3 < s3.value.length; ++u3) {
          var c3 = e2.derToOid(s3.value[u3].value);
          c3 in n2 ? r3[n2[c3]] = true : r3[c3] = true;
        }
      else if (r3.name === "nsCertType") {
        i3 = 0;
        (s3 = e2.fromDer(r3.value)).value.length > 1 && (i3 = s3.value.charCodeAt(1)), r3.client = (128 & i3) == 128, r3.server = (64 & i3) == 64, r3.email = (32 & i3) == 32, r3.objsign = (16 & i3) == 16, r3.reserved = (8 & i3) == 8, r3.sslCA = (4 & i3) == 4, r3.emailCA = (2 & i3) == 2, r3.objCA = (1 & i3) == 1;
      } else if (r3.name === "subjectAltName" || r3.name === "issuerAltName") {
        var f3;
        r3.altNames = [];
        s3 = e2.fromDer(r3.value);
        for (var l3 = 0; l3 < s3.value.length; ++l3) {
          var h3 = { type: (f3 = s3.value[l3]).type, value: f3.value };
          switch (r3.altNames.push(h3), f3.type) {
            case 1:
            case 2:
            case 6:
              break;
            case 7:
              h3.ip = xu.util.bytesToIP(f3.value);
              break;
            case 8:
              h3.oid = e2.derToOid(f3.value);
          }
        }
      } else if (r3.name === "subjectKeyIdentifier") {
        s3 = e2.fromDer(r3.value);
        r3.subjectKeyIdentifier = xu.util.bytesToHex(s3.value);
      }
    }
    return r3;
  }, r2.certificationRequestFromAsn1 = function(t8, i3) {
    var a3 = {}, o3 = [];
    if (!e2.validate(t8, c2, a3, o3))
      throw (u3 = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.")).errors = o3, u3;
    if (e2.derToOid(a3.publicKeyOid) !== r2.oids.rsaEncryption)
      throw new Error("Cannot read public key. OID is not RSA.");
    var s3 = r2.createCertificationRequest();
    if (s3.version = a3.csrVersion ? a3.csrVersion.charCodeAt(0) : 0, s3.signatureOid = xu.asn1.derToOid(a3.csrSignatureOid), s3.signatureParameters = l2(s3.signatureOid, a3.csrSignatureParams, true), s3.siginfo.algorithmOid = xu.asn1.derToOid(a3.csrSignatureOid), s3.siginfo.parameters = l2(s3.siginfo.algorithmOid, a3.csrSignatureParams, false), s3.signature = a3.csrSignature, s3.certificationRequestInfo = a3.certificationRequestInfo, i3) {
      var u3;
      if (s3.md = null, s3.signatureOid in n2)
        switch (n2[s3.signatureOid]) {
          case "sha1WithRSAEncryption":
            s3.md = xu.md.sha1.create();
            break;
          case "md5WithRSAEncryption":
            s3.md = xu.md.md5.create();
            break;
          case "sha256WithRSAEncryption":
            s3.md = xu.md.sha256.create();
            break;
          case "sha384WithRSAEncryption":
            s3.md = xu.md.sha384.create();
            break;
          case "sha512WithRSAEncryption":
            s3.md = xu.md.sha512.create();
            break;
          case "RSASSA-PSS":
            s3.md = xu.md.sha256.create();
        }
      if (s3.md === null)
        throw (u3 = new Error("Could not compute certification request digest. Unknown signature OID.")).signatureOid = s3.signatureOid, u3;
      var h3 = e2.toDer(s3.certificationRequestInfo);
      s3.md.update(h3.getBytes());
    }
    var d3 = xu.md.sha1.create();
    return s3.subject.getField = function(t9) {
      return f2(s3.subject, t9);
    }, s3.subject.addField = function(t9) {
      p2([t9]), s3.subject.attributes.push(t9);
    }, s3.subject.attributes = r2.RDNAttributesAsArray(a3.certificationRequestInfoSubject, d3), s3.subject.hash = d3.digest().toHex(), s3.publicKey = r2.publicKeyFromAsn1(a3.subjectPublicKeyInfo), s3.getAttribute = function(t9) {
      return f2(s3, t9);
    }, s3.addAttribute = function(t9) {
      p2([t9]), s3.attributes.push(t9);
    }, s3.attributes = r2.CRIAttributesAsArray(a3.certificationRequestInfoAttributes || []), s3;
  }, r2.createCertificationRequest = function() {
    var t8 = { version: 0, signatureOid: null, signature: null, siginfo: {} };
    return t8.siginfo.algorithmOid = null, t8.subject = {}, t8.subject.getField = function(e3) {
      return f2(t8.subject, e3);
    }, t8.subject.addField = function(e3) {
      p2([e3]), t8.subject.attributes.push(e3);
    }, t8.subject.attributes = [], t8.subject.hash = null, t8.publicKey = null, t8.attributes = [], t8.getAttribute = function(e3) {
      return f2(t8, e3);
    }, t8.addAttribute = function(e3) {
      p2([e3]), t8.attributes.push(e3);
    }, t8.md = null, t8.setSubject = function(e3) {
      p2(e3), t8.subject.attributes = e3, t8.subject.hash = null;
    }, t8.setAttributes = function(e3) {
      p2(e3), t8.attributes = e3;
    }, t8.sign = function(i3, a3) {
      t8.md = a3 || xu.md.sha1.create();
      var o3 = n2[t8.md.algorithm + "WithRSAEncryption"];
      if (!o3) {
        var s3 = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
        throw s3.algorithm = t8.md.algorithm, s3;
      }
      t8.signatureOid = t8.siginfo.algorithmOid = o3, t8.certificationRequestInfo = r2.getCertificationRequestInfo(t8);
      var u3 = e2.toDer(t8.certificationRequestInfo);
      t8.md.update(u3.getBytes()), t8.signature = i3.sign(t8.md);
    }, t8.verify = function() {
      var i3 = false, a3 = t8.md;
      if (a3 === null) {
        if (t8.signatureOid in n2)
          switch (n2[t8.signatureOid]) {
            case "sha1WithRSAEncryption":
              a3 = xu.md.sha1.create();
              break;
            case "md5WithRSAEncryption":
              a3 = xu.md.md5.create();
              break;
            case "sha256WithRSAEncryption":
              a3 = xu.md.sha256.create();
              break;
            case "sha384WithRSAEncryption":
              a3 = xu.md.sha384.create();
              break;
            case "sha512WithRSAEncryption":
              a3 = xu.md.sha512.create();
              break;
            case "RSASSA-PSS":
              a3 = xu.md.sha256.create();
          }
        if (a3 === null)
          throw (l3 = new Error("Could not compute certification request digest. Unknown signature OID.")).signatureOid = t8.signatureOid, l3;
        var o3 = t8.certificationRequestInfo || r2.getCertificationRequestInfo(t8), s3 = e2.toDer(o3);
        a3.update(s3.getBytes());
      }
      if (a3 !== null) {
        var u3;
        switch (t8.signatureOid) {
          case n2.sha1WithRSAEncryption:
            break;
          case n2["RSASSA-PSS"]:
            var c3, f3, l3;
            if ((c3 = n2[t8.signatureParameters.mgf.hash.algorithmOid]) === void 0 || xu.md[c3] === void 0)
              throw (l3 = new Error("Unsupported MGF hash function.")).oid = t8.signatureParameters.mgf.hash.algorithmOid, l3.name = c3, l3;
            if ((f3 = n2[t8.signatureParameters.mgf.algorithmOid]) === void 0 || xu.mgf[f3] === void 0)
              throw (l3 = new Error("Unsupported MGF function.")).oid = t8.signatureParameters.mgf.algorithmOid, l3.name = f3, l3;
            if (f3 = xu.mgf[f3].create(xu.md[c3].create()), (c3 = n2[t8.signatureParameters.hash.algorithmOid]) === void 0 || xu.md[c3] === void 0)
              throw (l3 = new Error("Unsupported RSASSA-PSS hash function.")).oid = t8.signatureParameters.hash.algorithmOid, l3.name = c3, l3;
            u3 = xu.pss.create(xu.md[c3].create(), f3, t8.signatureParameters.saltLength);
        }
        i3 = t8.publicKey.verify(a3.digest().getBytes(), t8.signature, u3);
      }
      return i3;
    }, t8;
  };
  var v2 = new Date("1950-01-01T00:00:00Z"), m2 = new Date("2050-01-01T00:00:00Z");
  function C2(t8) {
    return t8 >= v2 && t8 < m2 ? e2.create(e2.Class.UNIVERSAL, e2.Type.UTCTIME, false, e2.dateToUtcTime(t8)) : e2.create(e2.Class.UNIVERSAL, e2.Type.GENERALIZEDTIME, false, e2.dateToGeneralizedTime(t8));
  }
  r2.getTBSCertificate = function(t8) {
    var n3 = C2(t8.validity.notBefore), i3 = C2(t8.validity.notAfter), a3 = e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, [e2.create(e2.Class.CONTEXT_SPECIFIC, 0, true, [e2.create(e2.Class.UNIVERSAL, e2.Type.INTEGER, false, e2.integerToDer(t8.version).getBytes())]), e2.create(e2.Class.UNIVERSAL, e2.Type.INTEGER, false, xu.util.hexToBytes(t8.serialNumber)), e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, [e2.create(e2.Class.UNIVERSAL, e2.Type.OID, false, e2.oidToDer(t8.siginfo.algorithmOid).getBytes()), y2(t8.siginfo.algorithmOid, t8.siginfo.parameters)]), h2(t8.issuer), e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, [n3, i3]), h2(t8.subject), r2.publicKeyToAsn1(t8.publicKey)]);
    return t8.issuer.uniqueId && a3.value.push(e2.create(e2.Class.CONTEXT_SPECIFIC, 1, true, [e2.create(e2.Class.UNIVERSAL, e2.Type.BITSTRING, false, String.fromCharCode(0) + t8.issuer.uniqueId)])), t8.subject.uniqueId && a3.value.push(e2.create(e2.Class.CONTEXT_SPECIFIC, 2, true, [e2.create(e2.Class.UNIVERSAL, e2.Type.BITSTRING, false, String.fromCharCode(0) + t8.subject.uniqueId)])), t8.extensions.length > 0 && a3.value.push(r2.certificateExtensionsToAsn1(t8.extensions)), a3;
  }, r2.getCertificationRequestInfo = function(t8) {
    return e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, [e2.create(e2.Class.UNIVERSAL, e2.Type.INTEGER, false, e2.integerToDer(t8.version).getBytes()), h2(t8.subject), r2.publicKeyToAsn1(t8.publicKey), g2(t8)]);
  }, r2.distinguishedNameToAsn1 = function(t8) {
    return h2(t8);
  }, r2.certificateToAsn1 = function(t8) {
    var n3 = t8.tbsCertificate || r2.getTBSCertificate(t8);
    return e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, [n3, e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, [e2.create(e2.Class.UNIVERSAL, e2.Type.OID, false, e2.oidToDer(t8.signatureOid).getBytes()), y2(t8.signatureOid, t8.signatureParameters)]), e2.create(e2.Class.UNIVERSAL, e2.Type.BITSTRING, false, String.fromCharCode(0) + t8.signature)]);
  }, r2.certificateExtensionsToAsn1 = function(t8) {
    var n3 = e2.create(e2.Class.CONTEXT_SPECIFIC, 3, true, []), i3 = e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, []);
    n3.value.push(i3);
    for (var a3 = 0; a3 < t8.length; ++a3)
      i3.value.push(r2.certificateExtensionToAsn1(t8[a3]));
    return n3;
  }, r2.certificateExtensionToAsn1 = function(t8) {
    var r3 = e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, []);
    r3.value.push(e2.create(e2.Class.UNIVERSAL, e2.Type.OID, false, e2.oidToDer(t8.id).getBytes())), t8.critical && r3.value.push(e2.create(e2.Class.UNIVERSAL, e2.Type.BOOLEAN, false, String.fromCharCode(255)));
    var n3 = t8.value;
    return typeof t8.value != "string" && (n3 = e2.toDer(n3).getBytes()), r3.value.push(e2.create(e2.Class.UNIVERSAL, e2.Type.OCTETSTRING, false, n3)), r3;
  }, r2.certificationRequestToAsn1 = function(t8) {
    var n3 = t8.certificationRequestInfo || r2.getCertificationRequestInfo(t8);
    return e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, [n3, e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, [e2.create(e2.Class.UNIVERSAL, e2.Type.OID, false, e2.oidToDer(t8.signatureOid).getBytes()), y2(t8.signatureOid, t8.signatureParameters)]), e2.create(e2.Class.UNIVERSAL, e2.Type.BITSTRING, false, String.fromCharCode(0) + t8.signature)]);
  }, r2.createCaStore = function(t8) {
    var n3 = { certs: {} };
    function i3(t9) {
      return a3(t9), n3.certs[t9.hash] || null;
    }
    function a3(t9) {
      if (!t9.hash) {
        var e3 = xu.md.sha1.create();
        t9.attributes = r2.RDNAttributesAsArray(h2(t9), e3), t9.hash = e3.digest().toHex();
      }
    }
    if (n3.getIssuer = function(t9) {
      return i3(t9.issuer);
    }, n3.addCertificate = function(t9) {
      if (typeof t9 == "string" && (t9 = xu.pki.certificateFromPem(t9)), a3(t9.subject), !n3.hasCertificate(t9))
        if (t9.subject.hash in n3.certs) {
          var e3 = n3.certs[t9.subject.hash];
          xu.util.isArray(e3) || (e3 = [e3]), e3.push(t9), n3.certs[t9.subject.hash] = e3;
        } else
          n3.certs[t9.subject.hash] = t9;
    }, n3.hasCertificate = function(t9) {
      typeof t9 == "string" && (t9 = xu.pki.certificateFromPem(t9));
      var n4 = i3(t9.subject);
      if (!n4)
        return false;
      xu.util.isArray(n4) || (n4 = [n4]);
      for (var a4 = e2.toDer(r2.certificateToAsn1(t9)).getBytes(), o4 = 0; o4 < n4.length; ++o4) {
        if (a4 === e2.toDer(r2.certificateToAsn1(n4[o4])).getBytes())
          return true;
      }
      return false;
    }, n3.listAllCertificates = function() {
      var t9 = [];
      for (var e3 in n3.certs)
        if (n3.certs.hasOwnProperty(e3)) {
          var r3 = n3.certs[e3];
          if (xu.util.isArray(r3))
            for (var i4 = 0; i4 < r3.length; ++i4)
              t9.push(r3[i4]);
          else
            t9.push(r3);
        }
      return t9;
    }, n3.removeCertificate = function(t9) {
      var o4;
      if (typeof t9 == "string" && (t9 = xu.pki.certificateFromPem(t9)), a3(t9.subject), !n3.hasCertificate(t9))
        return null;
      var s4 = i3(t9.subject);
      if (!xu.util.isArray(s4))
        return o4 = n3.certs[t9.subject.hash], delete n3.certs[t9.subject.hash], o4;
      for (var u3 = e2.toDer(r2.certificateToAsn1(t9)).getBytes(), c3 = 0; c3 < s4.length; ++c3) {
        u3 === e2.toDer(r2.certificateToAsn1(s4[c3])).getBytes() && (o4 = s4[c3], s4.splice(c3, 1));
      }
      return s4.length === 0 && delete n3.certs[t9.subject.hash], o4;
    }, t8)
      for (var o3 = 0; o3 < t8.length; ++o3) {
        var s3 = t8[o3];
        n3.addCertificate(s3);
      }
    return n3;
  }, r2.certificateError = { bad_certificate: "forge.pki.BadCertificate", unsupported_certificate: "forge.pki.UnsupportedCertificate", certificate_revoked: "forge.pki.CertificateRevoked", certificate_expired: "forge.pki.CertificateExpired", certificate_unknown: "forge.pki.CertificateUnknown", unknown_ca: "forge.pki.UnknownCertificateAuthority" }, r2.verifyCertificateChain = function(t8, e3, n3) {
    typeof n3 == "function" && (n3 = { verify: n3 }), n3 = n3 || {};
    var i3 = (e3 = e3.slice(0)).slice(0), a3 = n3.validityCheckDate;
    a3 === void 0 && (a3 = new Date());
    var o3 = true, s3 = null, u3 = 0;
    do {
      var c3 = e3.shift(), f3 = null, l3 = false;
      if (a3 && (a3 < c3.validity.notBefore || a3 > c3.validity.notAfter) && (s3 = { message: "Certificate is not valid yet or has expired.", error: r2.certificateError.certificate_expired, notBefore: c3.validity.notBefore, notAfter: c3.validity.notAfter, now: a3 }), s3 === null) {
        if ((f3 = e3[0] || t8.getIssuer(c3)) === null && c3.isIssuer(c3) && (l3 = true, f3 = c3), f3) {
          var h3 = f3;
          xu.util.isArray(h3) || (h3 = [h3]);
          for (var p3 = false; !p3 && h3.length > 0; ) {
            f3 = h3.shift();
            try {
              p3 = f3.verify(c3);
            } catch (t9) {
            }
          }
          p3 || (s3 = { message: "Certificate signature is invalid.", error: r2.certificateError.bad_certificate });
        }
        s3 !== null || f3 && !l3 || t8.hasCertificate(c3) || (s3 = { message: "Certificate is not trusted.", error: r2.certificateError.unknown_ca });
      }
      if (s3 === null && f3 && !c3.isIssuer(f3) && (s3 = { message: "Certificate issuer is invalid.", error: r2.certificateError.bad_certificate }), s3 === null)
        for (var d3 = { keyUsage: true, basicConstraints: true }, y3 = 0; s3 === null && y3 < c3.extensions.length; ++y3) {
          var g3 = c3.extensions[y3];
          g3.critical && !(g3.name in d3) && (s3 = { message: "Certificate has an unsupported critical extension.", error: r2.certificateError.unsupported_certificate });
        }
      if (s3 === null && (!o3 || e3.length === 0 && (!f3 || l3))) {
        var v3 = c3.getExtension("basicConstraints"), m3 = c3.getExtension("keyUsage");
        if (m3 !== null && (m3.keyCertSign && v3 !== null || (s3 = { message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.", error: r2.certificateError.bad_certificate })), s3 !== null || v3 === null || v3.cA || (s3 = { message: "Certificate basicConstraints indicates the certificate is not a CA.", error: r2.certificateError.bad_certificate }), s3 === null && m3 !== null && "pathLenConstraint" in v3)
          u3 - 1 > v3.pathLenConstraint && (s3 = { message: "Certificate basicConstraints pathLenConstraint violated.", error: r2.certificateError.bad_certificate });
      }
      var C3 = s3 === null || s3.error, E2 = n3.verify ? n3.verify(C3, u3, i3) : C3;
      if (E2 !== true)
        throw C3 === true && (s3 = { message: "The application rejected the certificate.", error: r2.certificateError.bad_certificate }), (E2 || E2 === 0) && (typeof E2 != "object" || xu.util.isArray(E2) ? typeof E2 == "string" && (s3.error = E2) : (E2.message && (s3.message = E2.message), E2.error && (s3.error = E2.error))), s3;
      s3 = null, o3 = false, ++u3;
    } while (e3.length > 0);
    return true;
  };
}), w(function(t7) {
  var e2 = xu.asn1, r2 = xu.pki, n2 = t7.exports = xu.pkcs12 = xu.pkcs12 || {}, i2 = { name: "ContentInfo", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, value: [{ name: "ContentInfo.contentType", tagClass: e2.Class.UNIVERSAL, type: e2.Type.OID, constructed: false, capture: "contentType" }, { name: "ContentInfo.content", tagClass: e2.Class.CONTEXT_SPECIFIC, constructed: true, captureAsn1: "content" }] }, a2 = { name: "PFX", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, value: [{ name: "PFX.version", tagClass: e2.Class.UNIVERSAL, type: e2.Type.INTEGER, constructed: false, capture: "version" }, i2, { name: "PFX.macData", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, optional: true, captureAsn1: "mac", value: [{ name: "PFX.macData.mac", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, value: [{ name: "PFX.macData.mac.digestAlgorithm", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, value: [{ name: "PFX.macData.mac.digestAlgorithm.algorithm", tagClass: e2.Class.UNIVERSAL, type: e2.Type.OID, constructed: false, capture: "macAlgorithm" }, { name: "PFX.macData.mac.digestAlgorithm.parameters", tagClass: e2.Class.UNIVERSAL, captureAsn1: "macAlgorithmParameters" }] }, { name: "PFX.macData.mac.digest", tagClass: e2.Class.UNIVERSAL, type: e2.Type.OCTETSTRING, constructed: false, capture: "macDigest" }] }, { name: "PFX.macData.macSalt", tagClass: e2.Class.UNIVERSAL, type: e2.Type.OCTETSTRING, constructed: false, capture: "macSalt" }, { name: "PFX.macData.iterations", tagClass: e2.Class.UNIVERSAL, type: e2.Type.INTEGER, constructed: false, optional: true, capture: "macIterations" }] }] }, o2 = { name: "SafeBag", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, value: [{ name: "SafeBag.bagId", tagClass: e2.Class.UNIVERSAL, type: e2.Type.OID, constructed: false, capture: "bagId" }, { name: "SafeBag.bagValue", tagClass: e2.Class.CONTEXT_SPECIFIC, constructed: true, captureAsn1: "bagValue" }, { name: "SafeBag.bagAttributes", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SET, constructed: true, optional: true, capture: "bagAttributes" }] }, s2 = { name: "Attribute", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, value: [{ name: "Attribute.attrId", tagClass: e2.Class.UNIVERSAL, type: e2.Type.OID, constructed: false, capture: "oid" }, { name: "Attribute.attrValues", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SET, constructed: true, capture: "values" }] }, u2 = { name: "CertBag", tagClass: e2.Class.UNIVERSAL, type: e2.Type.SEQUENCE, constructed: true, value: [{ name: "CertBag.certId", tagClass: e2.Class.UNIVERSAL, type: e2.Type.OID, constructed: false, capture: "certId" }, { name: "CertBag.certValue", tagClass: e2.Class.CONTEXT_SPECIFIC, constructed: true, value: [{ name: "CertBag.certValue[0]", tagClass: e2.Class.UNIVERSAL, type: e2.Class.OCTETSTRING, constructed: false, capture: "cert" }] }] };
  function c2(t8, e3, r3, n3) {
    for (var i3 = [], a3 = 0; a3 < t8.length; a3++)
      for (var o3 = 0; o3 < t8[a3].safeBags.length; o3++) {
        var s3 = t8[a3].safeBags[o3];
        n3 !== void 0 && s3.type !== n3 || (e3 !== null ? s3.attributes[e3] !== void 0 && s3.attributes[e3].indexOf(r3) >= 0 && i3.push(s3) : i3.push(s3));
      }
    return i3;
  }
  function f2(t8) {
    if (t8.composed || t8.constructed) {
      for (var e3 = xu.util.createBuffer(), r3 = 0; r3 < t8.value.length; ++r3)
        e3.putBytes(t8.value[r3].value);
      t8.composed = t8.constructed = false, t8.value = e3.getBytes();
    }
    return t8;
  }
  function l2(t8, n3) {
    var i3 = {}, a3 = [];
    if (!e2.validate(t8, xu.pkcs7.asn1.encryptedDataValidator, i3, a3))
      throw (o3 = new Error("Cannot read EncryptedContentInfo.")).errors = a3, o3;
    var o3, s3 = e2.derToOid(i3.contentType);
    if (s3 !== r2.oids.data)
      throw (o3 = new Error("PKCS#12 EncryptedContentInfo ContentType is not Data.")).oid = s3, o3;
    s3 = e2.derToOid(i3.encAlgorithm);
    var u3 = r2.pbe.getCipher(s3, i3.encParameter, n3), c3 = f2(i3.encryptedContentAsn1), l3 = xu.util.createBuffer(c3.value);
    if (u3.update(l3), !u3.finish())
      throw new Error("Failed to decrypt PKCS#12 SafeContents.");
    return u3.output.getBytes();
  }
  function h2(t8, n3, i3) {
    if (!n3 && t8.length === 0)
      return [];
    if ((t8 = e2.fromDer(t8, n3)).tagClass !== e2.Class.UNIVERSAL || t8.type !== e2.Type.SEQUENCE || t8.constructed !== true)
      throw new Error("PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.");
    for (var a3 = [], s3 = 0; s3 < t8.value.length; s3++) {
      var c3 = t8.value[s3], f3 = {}, l3 = [];
      if (!e2.validate(c3, o2, f3, l3))
        throw (v2 = new Error("Cannot read SafeBag.")).errors = l3, v2;
      var h3, d2, y2 = { type: e2.derToOid(f3.bagId), attributes: p2(f3.bagAttributes) };
      a3.push(y2);
      var g2 = f3.bagValue.value[0];
      switch (y2.type) {
        case r2.oids.pkcs8ShroudedKeyBag:
          if ((g2 = r2.decryptPrivateKeyInfo(g2, i3)) === null)
            throw new Error("Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?");
        case r2.oids.keyBag:
          try {
            y2.key = r2.privateKeyFromAsn1(g2);
          } catch (t9) {
            y2.key = null, y2.asn1 = g2;
          }
          continue;
        case r2.oids.certBag:
          h3 = u2, d2 = function() {
            if (e2.derToOid(f3.certId) !== r2.oids.x509Certificate) {
              var t9 = new Error("Unsupported certificate type, only X.509 supported.");
              throw t9.oid = e2.derToOid(f3.certId), t9;
            }
            var i4 = e2.fromDer(f3.cert, n3);
            try {
              y2.cert = r2.certificateFromAsn1(i4, true);
            } catch (t10) {
              y2.cert = null, y2.asn1 = i4;
            }
          };
          break;
        default:
          var v2;
          throw (v2 = new Error("Unsupported PKCS#12 SafeBag type.")).oid = y2.type, v2;
      }
      if (h3 !== void 0 && !e2.validate(g2, h3, f3, l3))
        throw (v2 = new Error("Cannot read PKCS#12 " + h3.name)).errors = l3, v2;
      d2();
    }
    return a3;
  }
  function p2(t8) {
    var n3 = {};
    if (t8 !== void 0)
      for (var i3 = 0; i3 < t8.length; ++i3) {
        var a3 = {}, o3 = [];
        if (!e2.validate(t8[i3], s2, a3, o3)) {
          var u3 = new Error("Cannot read PKCS#12 BagAttribute.");
          throw u3.errors = o3, u3;
        }
        var c3 = e2.derToOid(a3.oid);
        if (r2.oids[c3] !== void 0) {
          n3[r2.oids[c3]] = [];
          for (var f3 = 0; f3 < a3.values.length; ++f3)
            n3[r2.oids[c3]].push(a3.values[f3].value);
        }
      }
    return n3;
  }
  n2.pkcs12FromAsn1 = function(t8, o3, s3) {
    typeof o3 == "string" ? (s3 = o3, o3 = true) : o3 === void 0 && (o3 = true);
    var u3 = {};
    if (!e2.validate(t8, a2, u3, []))
      throw (p3 = new Error("Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.")).errors = p3, p3;
    var p3, d2 = { version: u3.version.charCodeAt(0), safeContents: [], getBags: function(t9) {
      var e3, r3 = {};
      return "localKeyId" in t9 ? e3 = t9.localKeyId : "localKeyIdHex" in t9 && (e3 = xu.util.hexToBytes(t9.localKeyIdHex)), e3 === void 0 && !("friendlyName" in t9) && "bagType" in t9 && (r3[t9.bagType] = c2(d2.safeContents, null, null, t9.bagType)), e3 !== void 0 && (r3.localKeyId = c2(d2.safeContents, "localKeyId", e3, t9.bagType)), "friendlyName" in t9 && (r3.friendlyName = c2(d2.safeContents, "friendlyName", t9.friendlyName, t9.bagType)), r3;
    }, getBagsByFriendlyName: function(t9, e3) {
      return c2(d2.safeContents, "friendlyName", t9, e3);
    }, getBagsByLocalKeyId: function(t9, e3) {
      return c2(d2.safeContents, "localKeyId", t9, e3);
    } };
    if (u3.version.charCodeAt(0) !== 3)
      throw (p3 = new Error("PKCS#12 PFX of version other than 3 not supported.")).version = u3.version.charCodeAt(0), p3;
    if (e2.derToOid(u3.contentType) !== r2.oids.data)
      throw (p3 = new Error("Only PKCS#12 PFX in password integrity mode supported.")).oid = e2.derToOid(u3.contentType), p3;
    var y2 = u3.content.value[0];
    if (y2.tagClass !== e2.Class.UNIVERSAL || y2.type !== e2.Type.OCTETSTRING)
      throw new Error("PKCS#12 authSafe content data is not an OCTET STRING.");
    if (y2 = f2(y2), u3.mac) {
      var g2 = null, v2 = 0, m2 = e2.derToOid(u3.macAlgorithm);
      switch (m2) {
        case r2.oids.sha1:
          g2 = xu.md.sha1.create(), v2 = 20;
          break;
        case r2.oids.sha256:
          g2 = xu.md.sha256.create(), v2 = 32;
          break;
        case r2.oids.sha384:
          g2 = xu.md.sha384.create(), v2 = 48;
          break;
        case r2.oids.sha512:
          g2 = xu.md.sha512.create(), v2 = 64;
          break;
        case r2.oids.md5:
          g2 = xu.md.md5.create(), v2 = 16;
      }
      if (g2 === null)
        throw new Error("PKCS#12 uses unsupported MAC algorithm: " + m2);
      var C2 = new xu.util.ByteBuffer(u3.macSalt), E2 = "macIterations" in u3 ? parseInt(xu.util.bytesToHex(u3.macIterations), 16) : 1, S2 = n2.generateKey(s3, C2, 3, E2, v2, g2), b2 = xu.hmac.create();
      if (b2.start(g2, S2), b2.update(y2.value), b2.getMac().getBytes() !== u3.macDigest)
        throw new Error("PKCS#12 MAC could not be verified. Invalid password?");
    }
    return function(t9, n3, a3, o4) {
      if ((n3 = e2.fromDer(n3, a3)).tagClass !== e2.Class.UNIVERSAL || n3.type !== e2.Type.SEQUENCE || n3.constructed !== true)
        throw new Error("PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo");
      for (var s4 = 0; s4 < n3.value.length; s4++) {
        var u4 = n3.value[s4], c3 = {}, p4 = [];
        if (!e2.validate(u4, i2, c3, p4))
          throw (v3 = new Error("Cannot read ContentInfo.")).errors = p4, v3;
        var d3 = { encrypted: false }, y3 = null, g3 = c3.content.value[0];
        switch (e2.derToOid(c3.contentType)) {
          case r2.oids.data:
            if (g3.tagClass !== e2.Class.UNIVERSAL || g3.type !== e2.Type.OCTETSTRING)
              throw new Error("PKCS#12 SafeContents Data is not an OCTET STRING.");
            y3 = f2(g3).value;
            break;
          case r2.oids.encryptedData:
            y3 = l2(g3, o4), d3.encrypted = true;
            break;
          default:
            var v3;
            throw (v3 = new Error("Unsupported PKCS#12 contentType.")).contentType = e2.derToOid(c3.contentType), v3;
        }
        d3.safeBags = h2(y3, a3, o4), t9.safeContents.push(d3);
      }
    }(d2, y2.value, o3, s3), d2;
  }, n2.toPkcs12Asn1 = function(t8, i3, a3, o3) {
    (o3 = o3 || {}).saltSize = o3.saltSize || 8, o3.count = o3.count || 2048, o3.algorithm = o3.algorithm || o3.encAlgorithm || "aes128", "useMac" in o3 || (o3.useMac = true), "localKeyId" in o3 || (o3.localKeyId = null), "generateLocalKeyId" in o3 || (o3.generateLocalKeyId = true);
    var s3, u3 = o3.localKeyId;
    if (u3 !== null)
      u3 = xu.util.hexToBytes(u3);
    else if (o3.generateLocalKeyId)
      if (i3) {
        var c3 = xu.util.isArray(i3) ? i3[0] : i3;
        typeof c3 == "string" && (c3 = r2.certificateFromPem(c3)), (w2 = xu.md.sha1.create()).update(e2.toDer(r2.certificateToAsn1(c3)).getBytes()), u3 = w2.digest().getBytes();
      } else
        u3 = xu.random.getBytes(20);
    var f3 = [];
    u3 !== null && f3.push(e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, [e2.create(e2.Class.UNIVERSAL, e2.Type.OID, false, e2.oidToDer(r2.oids.localKeyId).getBytes()), e2.create(e2.Class.UNIVERSAL, e2.Type.SET, true, [e2.create(e2.Class.UNIVERSAL, e2.Type.OCTETSTRING, false, u3)])])), "friendlyName" in o3 && f3.push(e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, [e2.create(e2.Class.UNIVERSAL, e2.Type.OID, false, e2.oidToDer(r2.oids.friendlyName).getBytes()), e2.create(e2.Class.UNIVERSAL, e2.Type.SET, true, [e2.create(e2.Class.UNIVERSAL, e2.Type.BMPSTRING, false, o3.friendlyName)])])), f3.length > 0 && (s3 = e2.create(e2.Class.UNIVERSAL, e2.Type.SET, true, f3));
    var l3 = [], h3 = [];
    i3 !== null && (h3 = xu.util.isArray(i3) ? i3 : [i3]);
    for (var p3 = [], d2 = 0; d2 < h3.length; ++d2) {
      typeof (i3 = h3[d2]) == "string" && (i3 = r2.certificateFromPem(i3));
      var y2 = d2 === 0 ? s3 : void 0, g2 = r2.certificateToAsn1(i3), v2 = e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, [e2.create(e2.Class.UNIVERSAL, e2.Type.OID, false, e2.oidToDer(r2.oids.certBag).getBytes()), e2.create(e2.Class.CONTEXT_SPECIFIC, 0, true, [e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, [e2.create(e2.Class.UNIVERSAL, e2.Type.OID, false, e2.oidToDer(r2.oids.x509Certificate).getBytes()), e2.create(e2.Class.CONTEXT_SPECIFIC, 0, true, [e2.create(e2.Class.UNIVERSAL, e2.Type.OCTETSTRING, false, e2.toDer(g2).getBytes())])])]), y2]);
      p3.push(v2);
    }
    if (p3.length > 0) {
      var m2 = e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, p3), C2 = e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, [e2.create(e2.Class.UNIVERSAL, e2.Type.OID, false, e2.oidToDer(r2.oids.data).getBytes()), e2.create(e2.Class.CONTEXT_SPECIFIC, 0, true, [e2.create(e2.Class.UNIVERSAL, e2.Type.OCTETSTRING, false, e2.toDer(m2).getBytes())])]);
      l3.push(C2);
    }
    var E2 = null;
    if (t8 !== null) {
      var S2 = r2.wrapRsaPrivateKey(r2.privateKeyToAsn1(t8));
      E2 = a3 === null ? e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, [e2.create(e2.Class.UNIVERSAL, e2.Type.OID, false, e2.oidToDer(r2.oids.keyBag).getBytes()), e2.create(e2.Class.CONTEXT_SPECIFIC, 0, true, [S2]), s3]) : e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, [e2.create(e2.Class.UNIVERSAL, e2.Type.OID, false, e2.oidToDer(r2.oids.pkcs8ShroudedKeyBag).getBytes()), e2.create(e2.Class.CONTEXT_SPECIFIC, 0, true, [r2.encryptPrivateKeyInfo(S2, a3, o3)]), s3]);
      var b2 = e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, [E2]), T2 = e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, [e2.create(e2.Class.UNIVERSAL, e2.Type.OID, false, e2.oidToDer(r2.oids.data).getBytes()), e2.create(e2.Class.CONTEXT_SPECIFIC, 0, true, [e2.create(e2.Class.UNIVERSAL, e2.Type.OCTETSTRING, false, e2.toDer(b2).getBytes())])]);
      l3.push(T2);
    }
    var I2, A2 = e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, l3);
    if (o3.useMac) {
      var w2 = xu.md.sha1.create(), _2 = new xu.util.ByteBuffer(xu.random.getBytes(o3.saltSize)), B2 = o3.count, N2 = (t8 = n2.generateKey(a3, _2, 3, B2, 20), xu.hmac.create());
      N2.start(w2, t8), N2.update(e2.toDer(A2).getBytes());
      var k2 = N2.getMac();
      I2 = e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, [e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, [e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, [e2.create(e2.Class.UNIVERSAL, e2.Type.OID, false, e2.oidToDer(r2.oids.sha1).getBytes()), e2.create(e2.Class.UNIVERSAL, e2.Type.NULL, false, "")]), e2.create(e2.Class.UNIVERSAL, e2.Type.OCTETSTRING, false, k2.getBytes())]), e2.create(e2.Class.UNIVERSAL, e2.Type.OCTETSTRING, false, _2.getBytes()), e2.create(e2.Class.UNIVERSAL, e2.Type.INTEGER, false, e2.integerToDer(B2).getBytes())]);
    }
    return e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, [e2.create(e2.Class.UNIVERSAL, e2.Type.INTEGER, false, e2.integerToDer(3).getBytes()), e2.create(e2.Class.UNIVERSAL, e2.Type.SEQUENCE, true, [e2.create(e2.Class.UNIVERSAL, e2.Type.OID, false, e2.oidToDer(r2.oids.data).getBytes()), e2.create(e2.Class.CONTEXT_SPECIFIC, 0, true, [e2.create(e2.Class.UNIVERSAL, e2.Type.OCTETSTRING, false, e2.toDer(A2).getBytes())])]), I2]);
  }, n2.generateKey = xu.pbe.generatePkcs12Key;
});
var Ef = w(function(t7) {
  var e2 = xu.asn1, r2 = t7.exports = xu.pki = xu.pki || {};
  r2.pemToDer = function(t8) {
    var e3 = xu.pem.decode(t8)[0];
    if (e3.procType && e3.procType.type === "ENCRYPTED")
      throw new Error("Could not convert PEM to DER; PEM is encrypted.");
    return xu.util.createBuffer(e3.body);
  }, r2.privateKeyFromPem = function(t8) {
    var n2 = xu.pem.decode(t8)[0];
    if (n2.type !== "PRIVATE KEY" && n2.type !== "RSA PRIVATE KEY") {
      var i2 = new Error('Could not convert private key from PEM; PEM header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".');
      throw i2.headerType = n2.type, i2;
    }
    if (n2.procType && n2.procType.type === "ENCRYPTED")
      throw new Error("Could not convert private key from PEM; PEM is encrypted.");
    var a2 = e2.fromDer(n2.body);
    return r2.privateKeyFromAsn1(a2);
  }, r2.privateKeyToPem = function(t8, n2) {
    var i2 = { type: "RSA PRIVATE KEY", body: e2.toDer(r2.privateKeyToAsn1(t8)).getBytes() };
    return xu.pem.encode(i2, { maxline: n2 });
  }, r2.privateKeyInfoToPem = function(t8, r3) {
    var n2 = { type: "PRIVATE KEY", body: e2.toDer(t8).getBytes() };
    return xu.pem.encode(n2, { maxline: r3 });
  };
}), Sf = w(function(t7, e2) {
  var r2 = e2;
  r2.createCA = function(t8) {
    var e3 = Ef.rsa.generateKeyPair(2046), r3 = Ef.createCertificate();
    r3.publicKey = e3.publicKey, r3.serialNumber = new Date().getTime() + "", r3.validity.notBefore = new Date(), r3.validity.notBefore.setFullYear(r3.validity.notBefore.getFullYear() - 5), r3.validity.notAfter = new Date(), r3.validity.notAfter.setFullYear(r3.validity.notAfter.getFullYear() + 20);
    var n2 = [{ name: "commonName", value: t8 }, { name: "countryName", value: "CN" }, { shortName: "ST", value: "GuangDong" }, { name: "localityName", value: "ShenZhen" }, { name: "organizationName", value: "node-mitmproxy" }, { shortName: "OU", value: "https://github.com/wuchangming/node-mitmproxy" }];
    return r3.setSubject(n2), r3.setIssuer(n2), r3.setExtensions([{ name: "basicConstraints", critical: true, cA: true }, { name: "keyUsage", critical: true, keyCertSign: true }, { name: "subjectKeyIdentifier" }]), r3.sign(e3.privateKey, fc.sha256.create()), { key: e3.privateKey, cert: r3 };
  }, r2.covertNodeCertToForgeCert = function(t8) {
    var e3 = ju.fromDer(t8.raw.toString("binary"));
    return Ef.certificateFromAsn1(e3);
  }, r2.createFakeCertificateByDomain = function(t8, e3, r3) {
    var n2 = Ef.rsa.generateKeyPair(2046), i2 = Ef.createCertificate();
    i2.publicKey = n2.publicKey, i2.serialNumber = new Date().getTime() + "", i2.validity.notBefore = new Date(), i2.validity.notBefore.setFullYear(i2.validity.notBefore.getFullYear() - 1), i2.validity.notAfter = new Date(), i2.validity.notAfter.setFullYear(i2.validity.notAfter.getFullYear() + 1);
    var a2 = [{ name: "commonName", value: r3 }, { name: "countryName", value: "CN" }, { shortName: "ST", value: "GuangDong" }, { name: "localityName", value: "ShengZhen" }, { name: "organizationName", value: "node-mitmproxy" }, { shortName: "OU", value: "https://github.com/wuchangming/node-mitmproxy" }];
    return i2.setIssuer(e3.subject.attributes), i2.setSubject(a2), i2.setExtensions([{ name: "basicConstraints", critical: true, cA: false }, { name: "keyUsage", critical: true, digitalSignature: true, contentCommitment: true, keyEncipherment: true, dataEncipherment: true, keyAgreement: true, keyCertSign: true, cRLSign: true, encipherOnly: true, decipherOnly: true }, { name: "subjectAltName", altNames: [{ type: 2, value: r3 }] }, { name: "subjectKeyIdentifier" }, { name: "extKeyUsage", serverAuth: true, clientAuth: true, codeSigning: true, emailProtection: true, timeStamping: true }, { name: "authorityKeyIdentifier" }]), i2.sign(t8, fc.sha256.create()), { key: n2.privateKey, cert: i2 };
  }, r2.createFakeCertificateByCA = function(t8, e3, n2) {
    var i2 = r2.covertNodeCertToForgeCert(n2), a2 = Ef.rsa.generateKeyPair(2046), o2 = Ef.createCertificate();
    o2.publicKey = a2.publicKey, o2.serialNumber = i2.serialNumber, o2.validity.notBefore = new Date(), o2.validity.notBefore.setFullYear(o2.validity.notBefore.getFullYear() - 1), o2.validity.notAfter = new Date(), o2.validity.notAfter.setFullYear(o2.validity.notAfter.getFullYear() + 1), o2.setSubject(i2.subject.attributes), o2.setIssuer(e3.subject.attributes), i2.subjectaltname && (o2.subjectaltname = i2.subjectaltname);
    var s2 = Ou.find(i2.extensions, { name: "subjectAltName" });
    return o2.setExtensions([{ name: "basicConstraints", critical: true, cA: false }, { name: "keyUsage", critical: true, digitalSignature: true, contentCommitment: true, keyEncipherment: true, dataEncipherment: true, keyAgreement: true, keyCertSign: true, cRLSign: true, encipherOnly: true, decipherOnly: true }, { name: "subjectAltName", altNames: s2.altNames }, { name: "subjectKeyIdentifier" }, { name: "extKeyUsage", serverAuth: true, clientAuth: true, codeSigning: true, emailProtection: true, timeStamping: true }, { name: "authorityKeyIdentifier" }]), o2.sign(t8, fc.sha256.create()), { key: a2.privateKey, cert: o2 };
  }, r2.isBrowserRequest = function() {
    return /Mozilla/i.test(userAgent);
  }, r2.isMappingHostName = function(t8, e3) {
    var r3 = t8.replace(/\./g, "\\.").replace(/\*/g, "[^.]+");
    return r3 = "^" + r3 + "$", new RegExp(r3).test(e3);
  }, r2.getMappingHostNamesFormCert = function(t8) {
    var e3 = [];
    e3.push(t8.subject.getField("CN") ? t8.subject.getField("CN").value : "");
    var r3 = t8.getExtension("subjectAltName") ? t8.getExtension("subjectAltName").altNames : [];
    return e3 = e3.concat(Ou.map(r3, "value"));
  }, r2.initCA = function() {
    var t8 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Ru.getDefaultCABasePath(), e3 = d.default.resolve(t8, Ru.caCertFileName), n2 = d.default.resolve(t8, Ru.caKeyFileName);
    try {
      return p.default.accessSync(e3, p.default.F_OK), p.default.accessSync(n2, p.default.F_OK), { caCertPath: e3, caKeyPath: n2, create: false };
    } catch (t9) {
      var i2 = r2.createCA(Ru.caName), a2 = i2.cert, o2 = i2.key, s2 = Ef.certificateToPem(a2), u2 = Ef.privateKeyToPem(o2);
      Pu.sync(d.default.dirname(e3)), p.default.writeFileSync(e3, s2), p.default.writeFileSync(n2, u2);
    }
    return { caCertPath: e3, caKeyPath: n2, create: true };
  };
}), bf = w(function(t7) {
  var e2 = {};
  t7.exports = e2;
  var r2 = { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29], black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], gray: [90, 39], grey: [90, 39], brightRed: [91, 39], brightGreen: [92, 39], brightYellow: [93, 39], brightBlue: [94, 39], brightMagenta: [95, 39], brightCyan: [96, 39], brightWhite: [97, 39], bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgGray: [100, 49], bgGrey: [100, 49], bgBrightRed: [101, 49], bgBrightGreen: [102, 49], bgBrightYellow: [103, 49], bgBrightBlue: [104, 49], bgBrightMagenta: [105, 49], bgBrightCyan: [106, 49], bgBrightWhite: [107, 49], blackBG: [40, 49], redBG: [41, 49], greenBG: [42, 49], yellowBG: [43, 49], blueBG: [44, 49], magentaBG: [45, 49], cyanBG: [46, 49], whiteBG: [47, 49] };
  Object.keys(r2).forEach(function(t8) {
    var n2 = r2[t8], i2 = e2[t8] = [];
    i2.open = "[" + n2[0] + "m", i2.close = "[" + n2[1] + "m";
  });
}), Tf = function(t7, e2) {
  var r2 = (e2 = e2 || process.argv).indexOf("--"), n2 = /^-{1,2}/.test(t7) ? "" : "--", i2 = e2.indexOf(n2 + t7);
  return i2 !== -1 && (r2 === -1 || i2 < r2);
}, If = process.env, Af = void 0;
function wf(t7) {
  return function(t8) {
    return t8 !== 0 && { level: t8, hasBasic: true, has256: t8 >= 2, has16m: t8 >= 3 };
  }(function(t8) {
    if (Af === false)
      return 0;
    if (Tf("color=16m") || Tf("color=full") || Tf("color=truecolor"))
      return 3;
    if (Tf("color=256"))
      return 2;
    if (t8 && !t8.isTTY && Af !== true)
      return 0;
    var e2 = Af ? 1 : 0;
    if (process.platform === "win32") {
      var r2 = m.default.release().split(".");
      return Number(process.versions.node.split(".")[0]) >= 8 && Number(r2[0]) >= 10 && Number(r2[2]) >= 10586 ? Number(r2[2]) >= 14931 ? 3 : 2 : 1;
    }
    if ("CI" in If)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some(function(t9) {
        return t9 in If;
      }) || If.CI_NAME === "codeship" ? 1 : e2;
    if ("TEAMCITY_VERSION" in If)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(If.TEAMCITY_VERSION) ? 1 : 0;
    if ("TERM_PROGRAM" in If) {
      var n2 = parseInt((If.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (If.TERM_PROGRAM) {
        case "iTerm.app":
          return n2 >= 3 ? 3 : 2;
        case "Hyper":
          return 3;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(If.TERM) ? 2 : /^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(If.TERM) || "COLORTERM" in If ? 1 : (If.TERM, e2);
  }(t7));
}
Tf("no-color") || Tf("no-colors") || Tf("color=false") ? Af = false : (Tf("color") || Tf("colors") || Tf("color=true") || Tf("color=always")) && (Af = true), "FORCE_COLOR" in If && (Af = If.FORCE_COLOR.length === 0 || parseInt(If.FORCE_COLOR, 10) !== 0);
var _f = wf, Bf = (wf(process.stdout), wf(process.stderr), w(function(t7) {
  t7.exports = function(t8, e2) {
    var r2 = "";
    t8 = (t8 = t8 || "Run the trap, drop the bass").split("");
    var n2 = { a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"], b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"], c: ["\xA9", "\u023B", "\u03FE"], d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"], e: ["\xCB", "\u0115", "\u018E", "\u0258", "\u03A3", "\u03BE", "\u04BC", "\u0A6C"], f: ["\u04FA"], g: ["\u0262"], h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"], i: ["\u0F0F"], j: ["\u0134"], k: ["\u0138", "\u04A0", "\u04C3", "\u051E"], l: ["\u0139"], m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"], n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"], o: ["\xD8", "\xF5", "\xF8", "\u01FE", "\u0298", "\u047A", "\u05DD", "\u06DD", "\u0E4F"], p: ["\u01F7", "\u048E"], q: ["\u09CD"], r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"], s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"], t: ["\u0141", "\u0166", "\u0373"], u: ["\u01B1", "\u054D"], v: ["\u05D8"], w: ["\u0428", "\u0460", "\u047C", "\u0D70"], x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"], y: ["\xA5", "\u04B0", "\u04CB"], z: ["\u01B5", "\u0240"] };
    return t8.forEach(function(t9) {
      t9 = t9.toLowerCase();
      var e3 = n2[t9] || [" "], i2 = Math.floor(Math.random() * e3.length);
      r2 += n2[t9] !== void 0 ? n2[t9][i2] : t9;
    }), r2;
  };
})), Nf = w(function(t7) {
  t7.exports = function(t8, e2) {
    t8 = t8 || "   he is here   ";
    var r2 = { up: ["\u030D", "\u030E", "\u0304", "\u0305", "\u033F", "\u0311", "\u0306", "\u0310", "\u0352", "\u0357", "\u0351", "\u0307", "\u0308", "\u030A", "\u0342", "\u0313", "\u0308", "\u034A", "\u034B", "\u034C", "\u0303", "\u0302", "\u030C", "\u0350", "\u0300", "\u0301", "\u030B", "\u030F", "\u0312", "\u0313", "\u0314", "\u033D", "\u0309", "\u0363", "\u0364", "\u0365", "\u0366", "\u0367", "\u0368", "\u0369", "\u036A", "\u036B", "\u036C", "\u036D", "\u036E", "\u036F", "\u033E", "\u035B", "\u0346", "\u031A"], down: ["\u0316", "\u0317", "\u0318", "\u0319", "\u031C", "\u031D", "\u031E", "\u031F", "\u0320", "\u0324", "\u0325", "\u0326", "\u0329", "\u032A", "\u032B", "\u032C", "\u032D", "\u032E", "\u032F", "\u0330", "\u0331", "\u0332", "\u0333", "\u0339", "\u033A", "\u033B", "\u033C", "\u0345", "\u0347", "\u0348", "\u0349", "\u034D", "\u034E", "\u0353", "\u0354", "\u0355", "\u0356", "\u0359", "\u035A", "\u0323"], mid: ["\u0315", "\u031B", "\u0300", "\u0301", "\u0358", "\u0321", "\u0322", "\u0327", "\u0328", "\u0334", "\u0335", "\u0336", "\u035C", "\u035D", "\u035E", "\u035F", "\u0360", "\u0362", "\u0338", "\u0337", "\u0361", " \u0489"] }, n2 = [].concat(r2.up, r2.down, r2.mid);
    function i2(t9) {
      return Math.floor(Math.random() * t9);
    }
    function a2(t9) {
      var e3 = false;
      return n2.filter(function(r3) {
        e3 = r3 === t9;
      }), e3;
    }
    return function(t9, e3) {
      var n3, o2, s2 = "";
      for (o2 in (e3 = e3 || {}).up = e3.up === void 0 || e3.up, e3.mid = e3.mid === void 0 || e3.mid, e3.down = e3.down === void 0 || e3.down, e3.size = e3.size !== void 0 ? e3.size : "maxi", t9 = t9.split(""))
        if (!a2(o2)) {
          switch (s2 += t9[o2], n3 = { up: 0, down: 0, mid: 0 }, e3.size) {
            case "mini":
              n3.up = i2(8), n3.mid = i2(2), n3.down = i2(8);
              break;
            case "maxi":
              n3.up = i2(16) + 3, n3.mid = i2(4) + 1, n3.down = i2(64) + 3;
              break;
            default:
              n3.up = i2(8) + 1, n3.mid = i2(6) / 2, n3.down = i2(8) + 1;
          }
          var u2 = ["up", "mid", "down"];
          for (var c2 in u2)
            for (var f2 = u2[c2], l2 = 0; l2 <= n3[f2]; l2++)
              e3[f2] && (s2 += r2[f2][i2(r2[f2].length)]);
        }
      return s2;
    }(t8, e2);
  };
}), kf = w(function(t7) {
  t7.exports = function(t8) {
    return function(e2, r2, n2) {
      if (e2 === " ")
        return e2;
      switch (r2 % 3) {
        case 0:
          return t8.red(e2);
        case 1:
          return t8.white(e2);
        case 2:
          return t8.blue(e2);
      }
    };
  };
}), Rf = w(function(t7) {
  t7.exports = function(t8) {
    return function(e2, r2, n2) {
      return r2 % 2 == 0 ? e2 : t8.inverse(e2);
    };
  };
}), Of = w(function(t7) {
  t7.exports = function(t8) {
    var e2 = ["red", "yellow", "green", "blue", "magenta"];
    return function(r2, n2, i2) {
      return r2 === " " ? r2 : t8[e2[n2++ % e2.length]](r2);
    };
  };
}), Lf = w(function(t7) {
  t7.exports = function(t8) {
    var e2 = ["underline", "inverse", "grey", "yellow", "red", "green", "blue", "white", "cyan", "magenta", "brightYellow", "brightRed", "brightGreen", "brightBlue", "brightWhite", "brightCyan", "brightMagenta"];
    return function(r2, n2, i2) {
      return r2 === " " ? r2 : t8[e2[Math.round(Math.random() * (e2.length - 2))]](r2);
    };
  };
}), Pf = w(function(t7) {
  var e2 = {};
  t7.exports = e2, e2.themes = {};
  var r2 = e2.styles = bf, n2 = Object.defineProperties, i2 = new RegExp(/[\r\n]+/g);
  e2.supportsColor = _f, e2.enabled === void 0 && (e2.enabled = e2.supportsColor() !== false), e2.enable = function() {
    e2.enabled = true;
  }, e2.disable = function() {
    e2.enabled = false;
  }, e2.stripColors = e2.strip = function(t8) {
    return ("" + t8).replace(/\x1B\[\d+m/g, "");
  }, e2.stylize = function(t8, n3) {
    if (!e2.enabled)
      return t8 + "";
    var i3 = r2[n3];
    return !i3 && n3 in e2 ? e2[n3](t8) : i3.open + t8 + i3.close;
  };
  var a2 = /[|\\{}()[\]^$+*?.]/g;
  function o2(t8) {
    var e3 = function t9() {
      return f2.apply(t9, arguments);
    };
    return e3._styles = t8, e3.__proto__ = c2, e3;
  }
  var s2, u2 = (s2 = {}, r2.grey = r2.gray, Object.keys(r2).forEach(function(t8) {
    r2[t8].closeRe = new RegExp(function(t9) {
      if (typeof t9 != "string")
        throw new TypeError("Expected a string");
      return t9.replace(a2, "\\$&");
    }(r2[t8].close), "g"), s2[t8] = { get: function() {
      return o2(this._styles.concat(t8));
    } };
  }), s2), c2 = n2(function() {
  }, u2);
  function f2() {
    var t8 = Array.prototype.slice.call(arguments), n3 = t8.map(function(t9) {
      return t9 != null && t9.constructor === String ? t9 : v.default.inspect(t9);
    }).join(" ");
    if (!e2.enabled || !n3)
      return n3;
    for (var a3 = n3.indexOf("\n") != -1, o3 = this._styles, s3 = o3.length; s3--; ) {
      var u3 = r2[o3[s3]];
      n3 = u3.open + n3.replace(u3.closeRe, u3.open) + u3.close, a3 && (n3 = n3.replace(i2, function(t9) {
        return u3.close + t9 + u3.open;
      }));
    }
    return n3;
  }
  e2.setTheme = function(t8) {
    if (typeof t8 != "string")
      for (var r3 in t8)
        !function(r4) {
          e2[r4] = function(n3) {
            if (typeof t8[r4] == "object") {
              var i3 = n3;
              for (var a3 in t8[r4])
                i3 = e2[t8[r4][a3]](i3);
              return i3;
            }
            return e2[t8[r4]](n3);
          };
        }(r3);
    else
      console.log("colors.setTheme now only accepts an object, not a string.  If you are trying to set a theme from a file, it is now your (the caller's) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + '/../themes/generic-logging.js'); The new syntax looks like colors.setTheme(require(__dirname + '/../themes/generic-logging.js'));");
  };
  var l2 = function(t8, e3) {
    var r3 = e3.split("");
    return (r3 = r3.map(t8)).join("");
  };
  for (var h2 in e2.trap = Bf, e2.zalgo = Nf, e2.maps = {}, e2.maps.america = kf(e2), e2.maps.zebra = Rf(e2), e2.maps.rainbow = Of(e2), e2.maps.random = Lf(e2), e2.maps)
    !function(t8) {
      e2[t8] = function(r3) {
        return l2(e2.maps[t8], r3);
      };
    }(h2);
  n2(e2, function() {
    var t8 = {};
    return Object.keys(u2).forEach(function(e3) {
      t8[e3] = { get: function() {
        return o2([e3]);
      } };
    }), t8;
  }());
}), Uf = w(function(t7) {
  t7.exports = function() {
    var t8 = function(t9, e2) {
      String.prototype.__defineGetter__(t9, e2);
    };
    t8("strip", function() {
      return Pf.strip(this);
    }), t8("stripColors", function() {
      return Pf.strip(this);
    }), t8("trap", function() {
      return Pf.trap(this);
    }), t8("zalgo", function() {
      return Pf.zalgo(this);
    }), t8("zebra", function() {
      return Pf.zebra(this);
    }), t8("rainbow", function() {
      return Pf.rainbow(this);
    }), t8("random", function() {
      return Pf.random(this);
    }), t8("america", function() {
      return Pf.america(this);
    }), Object.keys(Pf.styles).forEach(function(e2) {
      t8(e2, function() {
        return Pf.stylize(this, e2);
      });
    }), Pf.setTheme = function(e2) {
      typeof e2 != "string" ? function(e3) {
        var r2 = ["__defineGetter__", "__defineSetter__", "__lookupGetter__", "__lookupSetter__", "charAt", "constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf", "charCodeAt", "indexOf", "lastIndexOf", "length", "localeCompare", "match", "repeat", "replace", "search", "slice", "split", "substring", "toLocaleLowerCase", "toLocaleUpperCase", "toLowerCase", "toUpperCase", "trim", "trimLeft", "trimRight"];
        Object.keys(e3).forEach(function(n2) {
          if (r2.indexOf(n2) !== -1)
            console.log("warn: ".red + ("String.prototype" + n2).magenta + " is probably something you don't want to override.  Ignoring style name");
          else if (typeof e3[n2] == "string")
            Pf[n2] = Pf[e3[n2]], t8(n2, function() {
              return Pf[n2](this);
            });
          else {
            var i2 = function(t9) {
              for (var r3 = t9 || this, i3 = 0; i3 < e3[n2].length; i3++)
                r3 = Pf[e3[n2][i3]](r3);
              return r3;
            };
            t8(n2, i2), Pf[n2] = function(t9) {
              return i2(t9);
            };
          }
        });
      }(e2) : console.log("colors.setTheme now only accepts an object, not a string. If you are trying to set a theme from a file, it is now your (the caller's) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + '/../themes/generic-logging.js'); The new syntax looks like colors.setTheme(require(__dirname + '/../themes/generic-logging.js'));");
    };
  };
}), xf = w(function(t7) {
  t7.exports = Pf, Uf();
}), Df = process.version.indexOf("v0.10.") === 0, Vf = { debug: Df ? function() {
  process.env.NODE_DEBUG && /agentkeepalive/.test(process.env.NODE_DEBUG) && console.log.apply(console.log, arguments);
} : v.default.debuglog("agentkeepalive"), isNode10: Df, inherits: v.default.inherits }, Mf = b.default.EventEmitter, jf = Vf.debug;
function Ff(t7) {
  if (!(this instanceof Ff))
    return new Ff(t7);
  Mf.call(this);
  var e2 = this;
  e2.defaultPort = 80, e2.protocol = "http:", e2.options = v.default._extend({}, t7), e2.options.path = null, e2.requests = {}, e2.sockets = {}, e2.freeSockets = {}, e2.keepAliveMsecs = e2.options.keepAliveMsecs || 1e3, e2.keepAlive = e2.options.keepAlive || false, e2.keepAliveTimeout = e2.options.keepAliveTimeout || 0, e2.timeout = e2.options.timeout || 0, e2.maxSockets = e2.options.maxSockets || Ff.defaultMaxSockets, e2.maxFreeSockets = e2.options.maxFreeSockets || 256, e2.on("free", function(t8, r2) {
    var n2 = e2.getName(r2);
    if (jf("agent.on(free)", n2), !t8.destroyed && e2.requests[n2] && e2.requests[n2].length)
      e2.requests[n2].shift().onSocket(t8), e2.requests[n2].length === 0 && delete e2.requests[n2], jf("continue handle next request");
    else {
      var i2 = t8._httpMessage;
      if (i2 && i2.shouldKeepAlive && !t8.destroyed && e2.options.keepAlive) {
        var a2 = e2.freeSockets[n2], o2 = a2 ? a2.length : 0, s2 = o2;
        e2.sockets[n2] && (s2 += e2.sockets[n2].length), s2 > e2.maxSockets || o2 >= e2.maxFreeSockets ? (e2.removeSocket(t8, r2), t8.destroy()) : (a2 = a2 || [], e2.freeSockets[n2] = a2, t8.setKeepAlive(true, e2.keepAliveMsecs), t8.unref && t8.unref(), t8._httpMessage = null, e2.removeSocket(t8, r2), a2.push(t8), t8.listeners("error").length === 0 && t8.once("error", qf), t8.setTimeout(e2.keepAliveTimeout));
      } else
        e2.removeSocket(t8, r2), t8.destroy();
    }
  });
}
v.default.inherits(Ff, Mf);
var Kf = Ff;
function qf(t7) {
  jf("SOCKET ERROR on FREE socket:", t7.message, t7.stack), this.destroy(), this.emit("agentRemove");
}
Ff.defaultMaxSockets = 1 / 0, Ff.prototype.createConnection = S.default.createConnection, Ff.prototype.getName = function(t7) {
  var e2 = "";
  return t7.host ? e2 += t7.host : e2 += "localhost", e2 += ":", t7.port && (e2 += t7.port), e2 += ":", t7.localAddress && (e2 += t7.localAddress), e2 += ":";
}, Ff.prototype.addRequest = function(t7, e2) {
  typeof e2 == "string" && (e2 = { host: e2, port: arguments[2], path: arguments[3] }), e2 = v.default._extend({}, e2), e2 = v.default._extend(e2, this.options);
  var r2 = this.getName(e2);
  this.sockets[r2] || (this.sockets[r2] = []);
  var n2 = this.freeSockets[r2] ? this.freeSockets[r2].length : 0, i2 = n2 + this.sockets[r2].length;
  if (n2) {
    var a2 = this.freeSockets[r2].shift();
    jf("have free socket"), a2.removeListener("error", qf), a2.setTimeout(this.timeout), this.freeSockets[r2].length || delete this.freeSockets[r2], a2.ref && a2.ref(), t7.onSocket(a2), this.sockets[r2].push(a2);
  } else
    i2 < this.maxSockets ? (jf("call onSocket", i2, n2), t7.onSocket(this.createSocket(t7, e2))) : (jf("wait for socket"), this.requests[r2] || (this.requests[r2] = []), this.requests[r2].push(t7));
}, Ff.prototype.createSocket = function(t7, e2) {
  var r2 = this;
  if (e2 = v.default._extend({}, e2), !(e2 = v.default._extend(e2, r2.options)).servername && (e2.servername = e2.host, t7)) {
    var n2 = t7.getHeader("host");
    n2 && (e2.servername = n2.replace(/:.*$/, ""));
  }
  var i2 = r2.getName(e2);
  jf("createConnection", i2, e2), e2.encoding = null;
  var a2 = r2.createConnection(e2);
  function o2() {
    r2.emit("free", a2, e2);
  }
  function s2(t8) {
    jf("CLIENT socket onClose"), typeof a2.destroyed != "boolean" && (a2.destroyed = true), r2.removeSocket(a2, e2), r2.emit("close");
  }
  function u2() {
    jf("CLIENT socket onTimeout"), a2.destroy(), r2.removeSocket(a2, e2), r2.emit("timeout");
  }
  return r2.sockets[i2] || (r2.sockets[i2] = []), this.sockets[i2].push(a2), jf("sockets", i2, this.sockets[i2].length), a2.on("free", o2), a2.on("close", s2), a2.on("timeout", u2), a2.setTimeout(r2.timeout), a2.on("agentRemove", function t8() {
    jf("CLIENT socket onRemove"), r2.removeSocket(a2, e2), a2.removeListener("close", s2), a2.removeListener("free", o2), a2.removeListener("agentRemove", t8), a2.setTimeout(0, u2);
  }), a2;
}, Ff.prototype.removeSocket = function(t7, e2) {
  var r2, n2 = this.getName(e2);
  jf("removeSocket", n2, "destroyed:", t7.destroyed);
  var i2 = [this.sockets];
  t7.destroyed && i2.push(this.freeSockets);
  for (var a2 = 0; a2 < i2.length; a2++) {
    var o2 = i2[a2];
    if (o2[n2]) {
      var s2 = o2[n2].indexOf(t7);
      s2 !== -1 && (o2[n2].splice(s2, 1), o2[n2].length === 0 && delete o2[n2]);
    }
  }
  if (r2 = (this.freeSockets[n2] ? this.freeSockets[n2].length : 0) + this.sockets[n2] ? this.sockets[n2].length : 0, this.requests[n2] && this.requests[n2].length && r2 < this.maxSockets) {
    jf("removeSocket, have a request, make a socket");
    var u2 = this.requests[n2][0];
    this.createSocket(u2, e2).emit("free");
  }
}, Ff.prototype.destroy = function() {
  for (var t7 = [this.freeSockets, this.sockets], e2 = 0; e2 < t7.length; e2++)
    for (var r2 = t7[e2], n2 = Object.keys(r2), i2 = 0; i2 < n2.length; i2++)
      for (var a2 = r2[n2[i2]], o2 = 0; o2 < a2.length; o2++)
        a2[o2].destroy();
};
var Gf = { Agent: Kf, globalAgent: new Ff() }.Agent;
C.default.Agent;
var zf = Wf;
function Wf(t7) {
  if (!(this instanceof Wf))
    return new Wf(t7);
  (t7 = t7 || {}).keepAlive = t7.keepAlive !== false, t7.keepAliveTimeout === void 0 && (t7.keepAliveTimeout = 15e3), t7.timeout === void 0 && (t7.timeout = 2 * t7.keepAliveTimeout), Gf.call(this, t7);
  var e2 = this;
  e2.createSocketCount = 0, e2.closeSocketCount = 0, e2.errorSocketCount = 0, e2.requestCount = 0, e2.timeoutSocketCount = 0, e2.on("free", function() {
    e2.requestCount++;
  }), e2.on("timeout", function() {
    e2.timeoutSocketCount++;
  }), e2.on("close", function() {
    e2.closeSocketCount++;
  }), e2.on("error", function() {
    e2.errorSocketCount++;
  });
}
function Hf(t7) {
  var e2 = {};
  for (var r2 in t7)
    e2[r2] = t7[r2].length;
  return e2;
}
Vf.inherits(Wf, Gf), Wf.prototype.createSocket = function(t7, e2) {
  var r2 = Gf.prototype.createSocket.call(this, t7, e2);
  return this.keepAlive && r2.setNoDelay(true), this.createSocketCount++, r2;
}, Wf.prototype.getCurrentStatus = function() {
  return { createSocketCount: this.createSocketCount, closeSocketCount: this.closeSocketCount, errorSocketCount: this.errorSocketCount, timeoutSocketCount: this.timeoutSocketCount, requestCount: this.requestCount, freeSockets: Hf(this.freeSockets), sockets: Hf(this.sockets), requests: Hf(this.requests) };
};
var Qf, Yf = C.default.Agent;
Vf.isNode10 ? (Qf = function(t7) {
  zf.call(this, t7), this.defaultPort = 443, this.protocol = "https:";
}, Vf.inherits(Qf, zf), Qf.prototype.createConnection = C.default.globalAgent.createConnection, Qf.prototype.getName = function(t7) {
  var e2 = zf.prototype.getName.call(this, t7);
  return e2 += ":", t7.ca && (e2 += t7.ca), e2 += ":", t7.cert && (e2 += t7.cert), e2 += ":", t7.ciphers && (e2 += t7.ciphers), e2 += ":", t7.key && (e2 += t7.key), e2 += ":", t7.pfx && (e2 += t7.pfx), e2 += ":", t7.rejectUnauthorized !== void 0 && (e2 += t7.rejectUnauthorized), e2;
}) : (Qf = function(t7) {
  zf.call(this, t7), this.defaultPort = 443, this.protocol = "https:", this.maxCachedSessions = this.options.maxCachedSessions, this.maxCachedSessions === void 0 && (this.maxCachedSessions = 100), this._sessionCache = { map: {}, list: [] };
}, Vf.inherits(Qf, zf), ["createConnection", "getName", "_getSession", "_cacheSession", "_evictSession"].forEach(function(t7) {
  typeof Yf.prototype[t7] == "function" && (Qf.prototype[t7] = Yf.prototype[t7]);
}));
var Xf = zf, $f = Qf;
Xf.HttpsAgent = $f;
var Zf = function() {
  function t7(t8, e2) {
    for (var r2 = 0; r2 < e2.length; r2++) {
      var n2 = e2[r2];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t8, n2.key, n2);
    }
  }
  return function(e2, r2, n2) {
    return r2 && t7(e2.prototype, r2), n2 && t7(e2, n2), e2;
  };
}();
function Jf(t7, e2) {
  if (!(t7 instanceof e2))
    throw new TypeError("Cannot call a class as a function");
}
function tl(t7, e2) {
  if (!t7)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return !e2 || typeof e2 != "object" && typeof e2 != "function" ? t7 : e2;
}
var el = function(t7) {
  function e2() {
    return Jf(this, e2), tl(this, (e2.__proto__ || Object.getPrototypeOf(e2)).apply(this, arguments));
  }
  return function(t8, e3) {
    if (typeof e3 != "function" && e3 !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
    t8.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t8, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t8, e3) : t8.__proto__ = e3);
  }(e2, Xf), Zf(e2, [{ key: "getName", value: function(t8) {
    var e3 = Xf.prototype.getName.call(this, t8);
    return e3 += ":", t8.customSocketId && (e3 += t8.customSocketId), e3;
  } }]), e2;
}(), rl = function() {
  function t7(t8, e2) {
    for (var r2 = 0; r2 < e2.length; r2++) {
      var n2 = e2[r2];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t8, n2.key, n2);
    }
  }
  return function(e2, r2, n2) {
    return r2 && t7(e2.prototype, r2), n2 && t7(e2, n2), e2;
  };
}();
function nl(t7, e2) {
  if (!(t7 instanceof e2))
    throw new TypeError("Cannot call a class as a function");
}
function il(t7, e2) {
  if (!t7)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return !e2 || typeof e2 != "object" && typeof e2 != "function" ? t7 : e2;
}
var al, ol = Xf.HttpsAgent, sl = function(t7) {
  function e2() {
    return nl(this, e2), il(this, (e2.__proto__ || Object.getPrototypeOf(e2)).apply(this, arguments));
  }
  return function(t8, e3) {
    if (typeof e3 != "function" && e3 !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
    t8.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t8, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t8, e3) : t8.__proto__ = e3);
  }(e2, ol), rl(e2, [{ key: "getName", value: function(t8) {
    var e3 = ol.prototype.getName.call(this, t8);
    return e3 += ":", t8.customSocketId && (e3 += t8.customSocketId), e3;
  } }]), e2;
}(), ul = function(t7) {
  var e2 = new hl(t7);
  return e2.request = g.default.request, e2;
}, cl = function(t7) {
  var e2 = new hl(t7);
  return e2.request = g.default.request, e2.createSocket = pl, e2.defaultPort = 443, e2;
}, fl = function(t7) {
  var e2 = new hl(t7);
  return e2.request = C.default.request, e2;
}, ll = function(t7) {
  var e2 = new hl(t7);
  return e2.request = C.default.request, e2.createSocket = pl, e2.defaultPort = 443, e2;
};
function hl(t7) {
  var e2 = this;
  e2.options = t7 || {}, e2.proxyOptions = e2.options.proxy || {}, e2.maxSockets = e2.options.maxSockets || g.default.Agent.defaultMaxSockets, e2.requests = [], e2.sockets = [], e2.on("free", function(t8, r2, n2) {
    for (var i2 = 0, a2 = e2.requests.length; i2 < a2; ++i2) {
      var o2 = e2.requests[i2];
      if (o2.host === r2 && o2.port === n2)
        return e2.requests.splice(i2, 1), void o2.request.onSocket(t8);
    }
    t8.destroy(), e2.removeSocket(t8);
  });
}
function pl(t7, e2) {
  var r2 = this;
  hl.prototype.createSocket.call(r2, t7, function(n2) {
    var i2 = T.default.connect(0, dl({}, r2.options, { servername: t7.host, socket: n2 }));
    r2.sockets[r2.sockets.indexOf(n2)] = i2, e2(i2);
  });
}
function dl(t7) {
  for (var e2 = 1, r2 = arguments.length; e2 < r2; ++e2) {
    var n2 = arguments[e2];
    if (typeof n2 == "object")
      for (var i2 = Object.keys(n2), a2 = 0, o2 = i2.length; a2 < o2; ++a2) {
        var s2 = i2[a2];
        n2[s2] !== void 0 && (t7[s2] = n2[s2]);
      }
  }
  return t7;
}
v.default.inherits(hl, b.default.EventEmitter), hl.prototype.addRequest = function(t7, e2) {
  var r2 = this;
  typeof e2 == "string" && (e2 = { host: e2, port: arguments[2], path: arguments[3] }), r2.sockets.length >= this.maxSockets ? r2.requests.push({ host: e2.host, port: e2.port, request: t7 }) : r2.createConnection({ host: e2.host, port: e2.port, request: t7 });
}, hl.prototype.createConnection = function(t7) {
  var e2 = this;
  e2.createSocket(t7, function(r2) {
    function n2() {
      e2.emit("free", r2, t7.host, t7.port);
    }
    function i2(t8) {
      e2.removeSocket(r2), r2.removeListener("free", n2), r2.removeListener("close", i2), r2.removeListener("agentRemove", i2);
    }
    r2.on("free", n2), r2.on("close", i2), r2.on("agentRemove", i2), t7.request.onSocket(r2);
  });
}, hl.prototype.createSocket = function(t7, e2) {
  var r2 = this, n2 = {};
  r2.sockets.push(n2);
  var i2 = dl({}, r2.proxyOptions, { method: "CONNECT", path: t7.host + ":" + t7.port, agent: false });
  i2.proxyAuth && (i2.headers = i2.headers || {}, i2.headers["Proxy-Authorization"] = "Basic " + new Buffer(i2.proxyAuth).toString("base64")), al("making CONNECT request");
  var a2 = r2.request(i2);
  function o2(i3, o3, s2) {
    if (a2.removeAllListeners(), o3.removeAllListeners(), i3.statusCode === 200)
      I.default.equal(s2.length, 0), al("tunneling connection has established"), r2.sockets[r2.sockets.indexOf(n2)] = o3, e2(o3);
    else {
      al("tunneling socket could not be established, statusCode=%d", i3.statusCode);
      var u2 = new Error("tunneling socket could not be established, statusCode=" + i3.statusCode);
      u2.code = "ECONNRESET", t7.request.emit("error", u2), r2.removeSocket(n2);
    }
  }
  a2.useChunkedEncodingByDefault = false, a2.once("response", function(t8) {
    t8.upgrade = true;
  }), a2.once("upgrade", function(t8, e3, r3) {
    process.nextTick(function() {
      o2(t8, e3, r3);
    });
  }), a2.once("connect", o2), a2.once("error", function(e3) {
    a2.removeAllListeners(), al("tunneling socket could not be established, cause=%s\n", e3.message, e3.stack);
    var i3 = new Error("tunneling socket could not be established, cause=" + e3.message);
    i3.code = "ECONNRESET", t7.request.emit("error", i3), r2.removeSocket(n2);
  }), a2.end();
}, hl.prototype.removeSocket = function(t7) {
  var e2 = this.sockets.indexOf(t7);
  if (e2 !== -1) {
    this.sockets.splice(e2, 1);
    var r2 = this.requests.shift();
    r2 && this.createConnection(r2);
  }
};
var yl = { httpOverHttp: ul, httpsOverHttp: cl, httpOverHttps: fl, httpsOverHttps: ll, debug: al = process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG) ? function() {
  var t7 = Array.prototype.slice.call(arguments);
  typeof t7[0] == "string" ? t7[0] = "TUNNEL: " + t7[0] : t7.unshift("TUNNEL:"), console.error.apply(console, t7);
} : function() {
} }, gl = w(function(t7, e2) {
  var r2, n2, i2, a2 = e2, o2 = new sl({ keepAlive: true, timeout: 6e4, keepAliveTimeout: 3e4, rejectUnauthorized: false }), s2 = new el({ keepAlive: true, timeout: 6e4, keepAliveTimeout: 3e4 }), u2 = 0;
  a2.getOptionsFormRequest = function(t8, e3) {
    var r3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, n3 = E.default.parse(t8.url), i3 = e3 ? 443 : 80, c2 = e3 ? "https:" : "http:", f2 = Object.assign({}, t8.headers), l2 = null;
    if (r3) {
      if (typeof r3 == "string")
        l2 = r3;
      else if (typeof r3 == "function")
        try {
          l2 = r3(t8, e3);
        } catch (t9) {
          console.error(t9);
        }
    }
    delete f2["proxy-connection"];
    var h2 = false;
    l2 ? h2 = a2.getTunnelAgent(c2 === "https:", l2) : f2.connection !== "close" && (h2 = c2 == "https:" ? o2 : s2, f2.connection = "keep-alive");
    var p2 = { protocol: c2, hostname: t8.headers.host.split(":")[0], method: t8.method, port: t8.headers.host.split(":")[1] || i3, path: n3.path, headers: t8.headers, agent: h2 };
    if (c2 === "http:" && l2 && E.default.parse(l2).protocol === "http:") {
      var d2 = E.default.parse(l2);
      p2.hostname = d2.hostname, p2.port = d2.port, p2.path = "http://" + n3.host + n3.path;
    }
    return t8.socket.customSocketId ? p2.customSocketId = t8.socket.customSocketId : f2.authorization && (p2.customSocketId = t8.socket.customSocketId = u2++), p2;
  }, a2.getTunnelAgent = function(t8, e3) {
    var a3 = E.default.parse(e3), o3 = a3.protocol || "http:", s3 = a3.port;
    s3 || (s3 = o3 === "http:" ? 80 : 443);
    var u3 = a3.hostname || "localhost";
    return t8 ? o3 === "http:" ? (r2 || (r2 = yl.httpsOverHttp({ proxy: { host: u3, port: s3 } })), r2) : (i2 || (i2 = yl.httpsOverHttps({ proxy: { host: u3, port: s3 } })), i2) : o3 !== "http:" && (n2 || (n2 = yl.httpOverHttps({ proxy: { host: u3, port: s3 } })), n2);
  };
});
var vl = function(t7, e2, r2, n2) {
  return function(r3, i2, a2) {
    var o2, s2 = this, u2 = gl.getOptionsFormRequest(r3, a2, n2);
    u2.headers.connection === "close" ? r3.socket.setKeepAlive(false) : u2.customSocketId != null ? r3.socket.setKeepAlive(true, 36e5) : r3.socket.setKeepAlive(true, 3e4);
    var c2;
    (c2 = regeneratorRuntime.mark(function n3() {
      var c3, f2;
      return regeneratorRuntime.wrap(function(n4) {
        for (; ; )
          switch (n4.prev = n4.next) {
            case 0:
              return n4.next = 2, new Promise(function(e3, n5) {
                try {
                  typeof t7 == "function" ? t7.call(null, u2, r3, i2, a2, function() {
                    e3();
                  }) : e3();
                } catch (t8) {
                  n5(t8);
                }
              });
            case 2:
              if (!i2.finished) {
                n4.next = 4;
                break;
              }
              return n4.abrupt("return", false);
            case 4:
              return n4.next = 6, new Promise(function(t8, e3) {
                if (u2.host = u2.hostname || u2.host || "localhost", u2.agent && u2.customSocketId != null && u2.agent.getName) {
                  var n5 = u2.agent.getName(u2), i3 = u2.agent.sockets[n5];
                  if (i3 && i3.length > 0)
                    return void i3[0].once("free", a3);
                }
                function a3() {
                  (o2 = (u2.protocol == "https:" ? C.default : g.default).request(u2, function(e4) {
                    t8(e4);
                  })).on("timeout", function() {
                    e3(u2.host + ":" + u2.port + ", request timeout");
                  }), o2.on("error", function(t9) {
                    e3(t9);
                  }), o2.on("aborted", function() {
                    e3("server aborted reqest"), r3.abort();
                  }), r3.on("aborted", function() {
                    o2.abort();
                  }), r3.pipe(o2);
                }
                a3();
              });
            case 6:
              return c3 = n4.sent, f2 = new Promise(function(t8, n5) {
                try {
                  typeof e2 == "function" ? e2.call(null, r3, i2, o2, c3, a2, function() {
                    t8();
                  }) : t8();
                } catch (t9) {
                  n5(t9);
                }
              }), n4.next = 10, f2;
            case 10:
              if (!i2.finished) {
                n4.next = 12;
                break;
              }
              return n4.abrupt("return", false);
            case 12:
              n4.prev = 12, i2.headersSent || (Object.keys(c3.headers).forEach(function(t8) {
                c3.headers[t8] != null && (/^www-authenticate$/i.test(t8) && (c3.headers[t8] && (c3.headers[t8] = c3.headers[t8] && c3.headers[t8].split(",")), t8 = "www-authenticate"), i2.setHeader(t8, c3.headers[t8]));
              }), i2.writeHead(c3.statusCode), c3.pipe(i2)), n4.next = 19;
              break;
            case 16:
              throw n4.prev = 16, n4.t0 = n4.catch(12), n4.t0;
            case 19:
            case "end":
              return n4.stop();
          }
      }, n3, s2, [[12, 16]]);
    }), function() {
      var t8 = c2.apply(this, arguments);
      return new Promise(function(e3, r4) {
        return function n3(i3, a3) {
          try {
            var o3 = t8[i3](a3), s3 = o3.value;
          } catch (t9) {
            return void r4(t9);
          }
          if (!o3.done)
            return Promise.resolve(s3).then(function(t9) {
              n3("next", t9);
            }, function(t9) {
              n3("throw", t9);
            });
          e3(s3);
        }("next");
      });
    })().then(function(t8) {
    }, function(t8) {
      i2.finished || (i2.writeHead(500), i2.write("Node-MitmProxy Warning:\n\n " + t8.toString()), i2.end()), console.error(t8);
    });
  };
};
const ml = m.default.networkInterfaces();
var Cl = (() => {
  for (var t7 in ml)
    for (var e2 = ml[t7], r2 = 0; r2 < e2.length; r2++) {
      var n2 = e2[r2];
      if (n2.family === "IPv4" && n2.address !== "127.0.0.1" && !n2.internal)
        return n2.address;
    }
  return "127.0.0.1";
})();
function El(t7, e2, r2, n2, i2) {
  var a2 = S.default.connect(i2, n2, function() {
    e2.write("HTTP/1.1 200 Connection Established\r\nProxy-agent: node-mitmproxy\r\n\r\n"), a2.write(r2), a2.pipe(e2), e2.pipe(a2);
  });
  return a2.on("error", function(t8) {
    console.log(xf.red(t8));
  }), a2;
}
var Sl = function() {
  function t7(t8, e2) {
    for (var r2 = 0; r2 < e2.length; r2++) {
      var n2 = e2[r2];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t8, n2.key, n2);
    }
  }
  return function(e2, r2, n2) {
    return r2 && t7(e2.prototype, r2), n2 && t7(e2, n2), e2;
  };
}();
var bl = function() {
  function t7(e2) {
    var r2 = e2.maxLength, n2 = r2 === void 0 ? 1e3 : r2, i2 = e2.getCertSocketTimeout, a2 = i2 === void 0 ? 2e3 : i2, o2 = e2.caCert, s2 = e2.caKey;
    !function(t8, e3) {
      if (!(t8 instanceof e3))
        throw new TypeError("Cannot call a class as a function");
    }(this, t7), this.queue = [], this.maxLength = n2, this.getCertSocketTimeout = a2, this.caCert = o2, this.caKey = s2;
  }
  return Sl(t7, [{ key: "addCertPromise", value: function(t8) {
    return this.queue.length >= this.maxLength && this.queue.shift(), this.queue.push(t8), t8;
  } }, { key: "getCertPromise", value: function(t8, e2) {
    for (var r2 = this, n2 = 0; n2 < this.queue.length; n2++)
      for (var i2 = this.queue[n2], a2 = i2.mappingHostNames, o2 = 0; o2 < a2.length; o2++) {
        var s2 = a2[o2];
        if (Sf.isMappingHostName(s2, t8))
          return this.reRankCert(n2), i2.promise;
      }
    var u2 = { mappingHostNames: [t8] }, c2 = new Promise(function(n3, i3) {
      var a3 = true, o3 = function(t9) {
        if (a3) {
          a3 = false;
          var e3 = Sf.getMappingHostNamesFormCert(t9.cert);
          u2.mappingHostNames = e3, n3(t9);
        }
      }, s3 = void 0, c3 = C.default.request({ port: e2, hostname: t8, path: "/", method: "HEAD" }, function(e3) {
        try {
          var n4 = e3.socket.getPeerCertificate();
          if (n4)
            try {
              s3 = Sf.createFakeCertificateByCA(r2.caKey, r2.caCert, n4);
            } catch (e4) {
              s3 = Sf.createFakeCertificateByDomain(r2.caKey, r2.caCert, t8);
            }
          else
            s3 = Sf.createFakeCertificateByDomain(r2.caKey, r2.caCert, t8);
          o3(s3);
        } catch (t9) {
          i3(t9);
        }
      });
      c3.setTimeout(~~r2.getCertSocketTimeout, function() {
        s3 || (s3 = Sf.createFakeCertificateByDomain(r2.caKey, r2.caCert, t8), o3(s3));
      }), c3.on("error", function(e3) {
        s3 || (s3 = Sf.createFakeCertificateByDomain(r2.caKey, r2.caCert, t8), o3(s3));
      }), c3.end();
    });
    return u2.promise = c2, this.addCertPromise(u2).promise;
  } }, { key: "reRankCert", value: function(t8) {
    this.queue.push(this.queue.splice(t8, 1)[0]);
  } }]), t7;
}(), Tl = function() {
  function t7(t8, e2) {
    for (var r2 = 0; r2 < e2.length; r2++) {
      var n2 = e2[r2];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t8, n2.key, n2);
    }
  }
  return function(e2, r2, n2) {
    return r2 && t7(e2.prototype, r2), n2 && t7(e2, n2), e2;
  };
}();
function Il(t7) {
  return function() {
    var e2 = t7.apply(this, arguments);
    return new Promise(function(t8, r2) {
      return function n2(i2, a2) {
        try {
          var o2 = e2[i2](a2), s2 = o2.value;
        } catch (t9) {
          return void r2(t9);
        }
        if (!o2.done)
          return Promise.resolve(s2).then(function(t9) {
            n2("next", t9);
          }, function(t9) {
            n2("throw", t9);
          });
        t8(s2);
      }("next");
    });
  };
}
var Al = function() {
  function t7(e2) {
    var r2 = e2.maxLength, n2 = r2 === void 0 ? 100 : r2, i2 = e2.requestHandler, a2 = e2.upgradeHandler, o2 = e2.caCert, s2 = e2.caKey, u2 = e2.getCertSocketTimeout;
    !function(t8, e3) {
      if (!(t8 instanceof e3))
        throw new TypeError("Cannot call a class as a function");
    }(this, t7), this.queue = [], this.maxLength = n2, this.requestHandler = i2, this.upgradeHandler = a2, this.certAndKeyContainer = new bl({ getCertSocketTimeout: u2, caCert: o2, caKey: s2 });
  }
  return Tl(t7, [{ key: "addServerPromise", value: function(t8) {
    if (this.queue.length >= this.maxLength) {
      var e2 = this.queue.shift();
      try {
        e2.serverObj.server.close();
      } catch (t9) {
        console.log(t9);
      }
    }
    return this.queue.push(t8), t8;
  } }, { key: "getServerPromise", value: function(t8, e2) {
    for (var r2 = this, n2 = 0; n2 < this.queue.length; n2++)
      for (var i2 = this.queue[n2], a2 = i2.mappingHostNames, o2 = 0; o2 < a2.length; o2++) {
        var s2 = a2[o2];
        if (Sf.isMappingHostName(s2, t8))
          return this.reRankServer(n2), i2.promise;
      }
    var u2 = { mappingHostNames: [t8] }, c2 = new Promise(function(n3, i3) {
      Il(regeneratorRuntime.mark(function i4() {
        var a3, o3, s3, c3, f2, l2, h2;
        return regeneratorRuntime.wrap(function(i5) {
          for (; ; )
            switch (i5.prev = i5.next) {
              case 0:
                return i5.next = 2, r2.certAndKeyContainer.getCertPromise(t8, e2);
              case 2:
                a3 = i5.sent, o3 = a3.cert, s3 = a3.key, c3 = Ef.certificateToPem(o3), f2 = Ef.privateKeyToPem(s3), l2 = new C.default.Server({ key: f2, cert: c3, SNICallback: function(t9, n4) {
                  Il(regeneratorRuntime.mark(function i6() {
                    var a4;
                    return regeneratorRuntime.wrap(function(i7) {
                      for (; ; )
                        switch (i7.prev = i7.next) {
                          case 0:
                            return i7.next = 2, r2.certAndKeyContainer.getCertPromise(t9, e2);
                          case 2:
                            a4 = i7.sent, n4(null, T.default.createSecureContext({ key: Ef.privateKeyToPem(a4.key), cert: Ef.certificateToPem(a4.cert) }));
                          case 4:
                          case "end":
                            return i7.stop();
                        }
                    }, i6, r2);
                  }))();
                } }), h2 = { cert: o3, key: s3, server: l2, port: 0 }, u2.serverObj = h2, l2.listen(0, function() {
                  var t9 = l2.address();
                  h2.port = t9.port;
                }), l2.on("request", function(t9, e3) {
                  r2.requestHandler(t9, e3, true);
                }), l2.on("error", function(t9) {
                  console.error(t9);
                }), l2.on("listening", function() {
                  var t9 = Sf.getMappingHostNamesFormCert(a3.cert);
                  u2.mappingHostNames = t9, n3(h2);
                }), l2.on("upgrade", function(t9, e3, n4) {
                  r2.upgradeHandler(t9, e3, n4, true);
                });
              case 15:
              case "end":
                return i5.stop();
            }
        }, i4, r2);
      }))();
    });
    return u2.promise = c2, this.addServerPromise(u2).promise;
  } }, { key: "reRankServer", value: function(t8) {
    this.queue.push(this.queue.splice(t8, 1)[0]);
  } }]), t7;
}(), wl = { createProxy: function(t7) {
  var e2 = t7.port, r2 = e2 === void 0 ? Ru.defaultPort : e2, n2 = t7.caCertPath, i2 = t7.caKeyPath, a2 = t7.sslConnectInterceptor, o2 = t7.requestInterceptor, s2 = t7.responseInterceptor, u2 = t7.getCertSocketTimeout, c2 = u2 === void 0 ? 1e3 : u2, f2 = (t7.middlewares, t7.externalProxy);
  if (t7.getPath && (Ru.getDefaultCABasePath = t7.getPath), process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0", !n2 && !i2) {
    var l2 = this.createCA();
    n2 = l2.caCertPath, i2 = l2.caKeyPath, l2.create && (console.log(xf.cyan("CA Cert saved in: " + n2)), console.log(xf.cyan("CA private key saved in: " + i2)));
  }
  r2 = ~~r2;
  var h2 = vl(o2, s2, 0, f2), d2 = function(t8, e3, r3, n3) {
    var i3 = gl.getOptionsFormRequest(t8, n3), a3 = (n3 ? C.default : g.default).request(i3);
    a3.on("error", function(t9) {
      console.error(t9);
    }), a3.on("response", function(t9) {
      t9.upgrade || e3.end();
    }), a3.on("upgrade", function(t9, r4, n4) {
      r4.on("error", function(t10) {
        console.error(t10);
      }), e3.on("error", function() {
        r4.end();
      }), r4.setTimeout(0), r4.setNoDelay(true), r4.setKeepAlive(true, 0), n4 && n4.length && r4.unshift(n4), e3.write(Object.keys(t9.headers).reduce(function(e4, r5) {
        var n5 = t9.headers[r5];
        if (!Array.isArray(n5))
          return e4.push(r5 + ": " + n5), e4;
        for (var i4 = 0; i4 < n5.length; i4++)
          e4.push(r5 + ": " + n5[i4]);
        return e4;
      }, ["HTTP/1.1 101 Switching Protocols"]).join("\r\n") + "\r\n\r\n"), r4.pipe(e3).pipe(r4);
    }), a3.end();
  }, y2 = function(t8, e3) {
    return function(r3, n3, i3) {
      var a3 = E.default.parse("https://" + r3.url);
      typeof t8 == "function" && t8.call(null, r3, n3, i3) ? e3.getServerPromise(a3.hostname, a3.port).then(function(t9) {
        El(0, n3, i3, Cl, t9.port);
      }, function(t9) {
        console.error(t9);
      }) : El(0, n3, i3, a3.hostname, a3.port);
    };
  }(a2, function(t8) {
    var e3, r3, n3 = t8.caCertPath, i3 = t8.caKeyPath, a3 = t8.requestHandler, o3 = t8.upgradeHandler, s3 = t8.getCertSocketTimeout;
    try {
      p.default.accessSync(n3, p.default.F_OK), p.default.accessSync(i3, p.default.F_OK);
      var u3 = p.default.readFileSync(n3), c3 = p.default.readFileSync(i3);
      e3 = Ef.certificateFromPem(u3), r3 = Ef.privateKeyFromPem(c3);
    } catch (t9) {
      console.log(xf.red("Can not find `CA certificate` or `CA key`."), t9), process.exit(1);
    }
    return new Al({ caCert: e3, caKey: r3, maxLength: 100, requestHandler: a3, upgradeHandler: o3, getCertSocketTimeout: s3 });
  }({ caCertPath: n2, caKeyPath: i2, requestHandler: h2, upgradeHandler: d2, getCertSocketTimeout: c2 })), v2 = new g.default.Server();
  v2.listen(r2, function() {
    console.log(xf.green("node-mitmproxy\u542F\u52A8\u7AEF\u53E3: " + r2)), v2.on("error", function(t8) {
      console.error(xf.red(t8));
    }), v2.on("request", function(t8, e3) {
      h2(t8, e3, false);
    }), v2.on("connect", function(t8, e3, r3) {
      y2(t8, e3, r3);
    }), v2.on("upgrade", function(t8, e3, r3) {
      d2(t8, e3, r3, false);
    });
  });
}, createCA: function() {
  var t7 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Ru.getDefaultCABasePath();
  return Sf.initCA(t7);
} };
var nodeMitmproxy = wl;

const fs$6 = lib$1;
const path$4 = require$$1__default["default"];
const { URL: URL$2 } = require$$2__default$1["default"];
const { app: app$4, ipcMain: ipcMain$3, shell, clipboard } = require$$0__default$4["default"];
const { readdir, sleep, request, sendMsg: sendMsg$1, readJSON: readJSON$1, saveJSON: saveJSON$1, userDataPath: userDataPath$1, userPath, localIp, langMap, getCacheText } = utils;
const config$2 = config_1;
const getItemTypeNameMap$1 = gachaTypeMap.getItemTypeNameMap;
const i18n$2 = i18n_1;
const { enableProxy, disableProxy: disableProxy$1 } = systemProxy;
const mitmproxy = nodeMitmproxy;
const dataMap = new Map();
let apiDomain = "https://public-operation-hk4e.mihoyo.com";
const saveData$1 = async (data, url) => {
  const obj = Object.assign({}, data);
  obj.result = [...obj.result];
  obj.typeMap = [...obj.typeMap];
  if (url) {
    config$2.urls.set(data.uid, url);
    await config$2.save();
  }
  await saveJSON$1(`gacha-list-${data.uid}.json`, obj);
};
const defaultTypeMap = new Map([
  ["301", "\u89D2\u8272\u6D3B\u52A8\u7948\u613F"],
  ["302", "\u6B66\u5668\u6D3B\u52A8\u7948\u613F"],
  ["500", "\u96C6\u5F55\u7948\u613F"],
  ["200", "\u5E38\u9A7B\u7948\u613F"],
  ["100", "\u65B0\u624B\u7948\u613F"]
]);
let localDataReaded = false;
const readData = async (force = false) => {
  if (localDataReaded && !force)
    return;
  localDataReaded = true;
  await fs$6.ensureDir(userDataPath$1);
  const files = await readdir(userDataPath$1);
  for (let name of files) {
    if (/^gacha-list-\d+\.json$/.test(name)) {
      try {
        const data = await readJSON$1(name);
        data.typeMap = new Map(data.typeMap) || defaultTypeMap;
        data.result = new Map(data.result);
        if (data.uid) {
          dataMap.set(data.uid, data);
        }
      } catch (e) {
        sendMsg$1(e, "ERROR");
      }
    }
  }
  if (!config$2.current && dataMap.size || config$2.current && dataMap.size && !dataMap.has(config$2.current)) {
    await changeCurrent$1(dataMap.keys().next().value);
  }
};
const changeCurrent$1 = async (uid) => {
  config$2.current = uid;
  await config$2.save();
};
const compareList = (b, a) => {
  if (!b.length)
    return false;
  if (b.length < a.length) {
    a = a.slice(0, b.length);
  }
  const strA = a.map((item) => item.slice(0, 4).join("-")).join(",");
  const strB = b.map((item) => item.slice(0, 4).join("-")).join(",");
  return strA === strB;
};
const mergeList = (a, b) => {
  if (!a || !a.length)
    return b || [];
  if (!b || !b.length)
    return a;
  const minA = new Date(a[0][0]).getTime();
  const idA = a[0][5];
  let pos = b.length;
  let idFounded = false;
  for (let i = b.length - 1; i >= 0; i--) {
    let idB = b[i][5];
    if (idB && idB === idA) {
      pos = i;
      idFounded = true;
      break;
    }
  }
  if (!idFounded) {
    let width = Math.min(11, a.length, b.length);
    for (let i = 0; i < b.length; i++) {
      const time = new Date(b[i][0]).getTime();
      if (time >= minA) {
        if (compareList(b.slice(i, width + i), a.slice(0, width))) {
          pos = i;
          break;
        }
      }
    }
  }
  return b.slice(0, pos).concat(a);
};
const mergeData = (local, origin) => {
  if (local && local.result) {
    const localResult = local.result;
    const localUid = local.uid;
    const originUid = origin.uid;
    if (localUid !== originUid)
      return origin.result;
    const originResult = new Map();
    for (let [key, value] of origin.result) {
      const newVal = mergeList(value, localResult.get(key));
      originResult.set(key, newVal);
    }
    return originResult;
  }
  return origin.result;
};
const detectGameType = async (userPath2) => {
  let list = [];
  const lang = app$4.getLocale();
  try {
    await fs$6.access(path$4.join(userPath2, "/AppData/LocalLow/miHoYo/", "\u539F\u795E/output_log.txt"), fs$6.constants.F_OK);
    list.push("\u539F\u795E");
  } catch (e) {
  }
  try {
    await fs$6.access(path$4.join(userPath2, "/AppData/LocalLow/miHoYo/", "Genshin Impact/output_log.txt"), fs$6.constants.F_OK);
    list.push("Genshin Impact");
  } catch (e) {
  }
  if (config$2.logType) {
    if (config$2.logType === 2) {
      list.reverse();
    } else if (config$2.logType === 3) {
      list = [];
    }
    list = list.slice(0, 1);
  } else if (lang !== "zh-CN") {
    list.reverse();
  }
  try {
    await fs$6.access(path$4.join(userPath2, "/AppData/Local/", "miHoYo/GenshinImpactCloudGame/config/logs/MiHoYoSDK.log"), fs$6.constants.F_OK);
    list.push("cloud");
  } catch (e) {
  }
  return list;
};
let cacheFolder = null;
const readLog = async () => {
  const text = i18n$2.log;
  try {
    let userPath2;
    if (!process.env.WINEPREFIX) {
      userPath2 = app$4.getPath("home");
    } else {
      userPath2 = path$4.join(process.env.WINEPREFIX, "drive_c/users", process.env.USER);
    }
    const gameNames = await detectGameType(userPath2);
    if (!gameNames.length) {
      sendMsg$1(text.file.notFound);
      return false;
    }
    const promises = gameNames.map(async (name) => {
      if (name === "cloud") {
        const cacheText = await fs$6.readFile(path$4.join(userPath2, "/AppData/Local/", "miHoYo/GenshinImpactCloudGame/config/logs/MiHoYoSDK.log"), "utf8");
        const urlMch = cacheText.match(/https.+?auth_appid=webview_gacha.+?authkey=.+?game_biz=hk4e_\w+/g);
        if (urlMch) {
          return urlMch[urlMch.length - 1];
        }
      } else {
        const logText = await fs$6.readFile(`${userPath2}/AppData/LocalLow/miHoYo/${name}/output_log.txt`, "utf8");
        const gamePathMch = logText.match(/\w:\/.+(GenshinImpact_Data|YuanShen_Data)/);
        if (gamePathMch) {
          const [cacheText, cacheFile] = await getCacheText(gamePathMch[0]);
          const urlMch = cacheText.match(/https.+?auth_appid=webview_gacha.+?authkey=.+?game_biz=hk4e_\w+/g);
          if (urlMch) {
            cacheFolder = cacheFile.replace(/Cache_Data[/\\]data_2$/, "");
            return urlMch[urlMch.length - 1];
          }
        }
      }
    });
    const result = await Promise.all(promises);
    for (let url of result) {
      if (url) {
        return url;
      }
    }
    sendMsg$1(text.url.notFound);
    return false;
  } catch (e) {
    sendMsg$1(text.file.readFailed);
    return false;
  }
};
const getGachaLog = async ({ key, page, name, retryCount, url, endId }) => {
  const text = i18n$2.log;
  try {
    const res = await request(`${url}&gacha_type=${key}&page=${page}&size=${20}${endId ? "&end_id=" + endId : ""}`);
    return res.data.list;
  } catch (e) {
    if (retryCount) {
      sendMsg$1(i18n$2.parse(text.fetch.retry, { name, page, count: 6 - retryCount }));
      await sleep(5);
      retryCount--;
      return await getGachaLog({ key, page, name, retryCount, url, endId });
    } else {
      sendMsg$1(i18n$2.parse(text.fetch.retryFailed, { name, page }));
      throw e;
    }
  }
};
const getGachaLogs = async ([key, name], queryString) => {
  const text = i18n$2.log;
  let page = 1;
  let list = [];
  let res = [];
  let uid = 0;
  let endId = 0;
  const url = `${apiDomain}/gacha_info/api/getGachaLog?${queryString}`;
  do {
    if (page % 10 === 0) {
      sendMsg$1(i18n$2.parse(text.fetch.interval, { name, page }));
      await sleep(1);
    }
    sendMsg$1(i18n$2.parse(text.fetch.current, { name, page }));
    res = await getGachaLog({ key, page, name, url, endId, retryCount: 5 });
    await sleep(0.3);
    if (!uid && res.length) {
      uid = res[0].uid;
    }
    list.push(...res);
    page += 1;
    if (res.length) {
      endId = BigInt(res[res.length - 1].id);
    }
    if (!config$2.fetchFullHistory && res.length && uid && dataMap.has(uid)) {
      const result = dataMap.get(uid).result;
      if (result.has(key)) {
        const arr = result.get(key);
        if (arr.length) {
          const localLatestId = arr[arr.length - 1][5];
          if (localLatestId) {
            let shouldBreak = false;
            res.forEach((item) => {
              if (item.id === localLatestId) {
                shouldBreak = true;
              }
            });
            if (shouldBreak) {
              break;
            }
          }
        }
      }
    }
  } while (res.length > 0);
  return { list, uid };
};
const checkResStatus = (res) => {
  const text = i18n$2.log;
  if (res.retcode !== 0) {
    let message = res.message;
    if (res.message === "authkey timeout") {
      message = text.fetch.authTimeout;
      sendMsg$1(true, "AUTHKEY_TIMEOUT");
    }
    sendMsg$1(message);
    throw new Error(message);
  }
  sendMsg$1(false, "AUTHKEY_TIMEOUT");
  return res;
};
const tryGetUid = async (queryString) => {
  const url = `${apiDomain}/gacha_info/api/getGachaLog?${queryString}`;
  try {
    for (let [key] of defaultTypeMap) {
      const res = await request(`${url}&gacha_type=${key}&page=1&size=6`);
      checkResStatus(res);
      if (res.data.list && res.data.list.length) {
        return res.data.list[0].uid;
      }
    }
  } catch (e) {
  }
  return config$2.current;
};
const fixAuthkey = (url) => {
  const mr = url.match(/authkey=([^&]+)/);
  if (mr && mr[1] && mr[1].includes("=") && !mr[1].includes("%")) {
    return url.replace(/authkey=([^&]+)/, `authkey=${encodeURIComponent(mr[1])}`);
  }
  return url;
};
const getQuerystring = (url) => {
  const text = i18n$2.log;
  const { searchParams, host } = new URL$2(fixAuthkey(url));
  if (host.includes("webstatic-sea") || host.includes("hk4e-api-os") || host.includes("hoyoverse.com")) {
    apiDomain = "https://public-operation-hk4e-sg.hoyoverse.com";
  } else {
    apiDomain = "https://public-operation-hk4e.mihoyo.com";
  }
  const authkey = searchParams.get("authkey");
  if (!authkey) {
    sendMsg$1(text.url.lackAuth);
    return false;
  }
  searchParams.delete("page");
  searchParams.delete("size");
  searchParams.delete("gacha_type");
  searchParams.delete("end_id");
  return searchParams;
};
const proxyServer = (port) => {
  return new Promise((rev) => {
    mitmproxy.createProxy({
      sslConnectInterceptor: (req, cltSocket, head) => {
        if (/webstatic([^\.]{2,10})?\.(mihoyo|hoyoverse)\.com/.test(req.url)) {
          return true;
        }
      },
      requestInterceptor: (rOptions, req, res, ssl, next) => {
        next();
        if (/webstatic([^\.]{2,10})?\.(mihoyo|hoyoverse)\.com/.test(rOptions.hostname)) {
          if (/authkey=[^&]+/.test(rOptions.path)) {
            rev(`${rOptions.protocol}//${rOptions.hostname}${rOptions.path}`);
          }
        }
      },
      responseInterceptor: (req, res, proxyReq, proxyRes, ssl, next) => {
        next();
      },
      getPath: () => path$4.join(userPath, "node-mitmproxy"),
      port
    });
  });
};
let proxyServerPromise;
const useProxy = async () => {
  const text = i18n$2.log;
  const ip = localIp();
  const port = config$2.proxyPort;
  sendMsg$1(i18n$2.parse(text.proxy.hint, { ip, port }));
  await enableProxy("127.0.0.1", port);
  if (!proxyServerPromise) {
    proxyServerPromise = proxyServer(port);
  }
  const url = await proxyServerPromise;
  await disableProxy$1();
  return url;
};
const tryRequest = async (url, retry = false) => {
  const queryString = getQuerystring(url);
  if (!queryString)
    return false;
  const gachaTypeUrl = `${apiDomain}/gacha_info/api/getConfigList?${queryString}`;
  const res = await request(gachaTypeUrl);
  checkResStatus(res);
};
const getUrl = async () => {
  let url = await readLog();
  await tryRequest(url);
  return url;
};
const fetchData = async (urlOverride) => {
  const text = i18n$2.log;
  await readData();
  let url = urlOverride;
  if (!url) {
    url = await getUrl();
  }
  if (!url) {
    const message = text.url.notFound2;
    sendMsg$1(message);
    throw new Error(message);
  }
  const searchParams = getQuerystring(url);
  if (!searchParams) {
    const message = text.url.incorrect;
    sendMsg$1(message);
    throw new Error(message);
  }
  let queryString = searchParams.toString();
  const vUid = await tryGetUid(queryString);
  let localLang = dataMap.has(vUid) ? dataMap.get(vUid).lang : "";
  if (localLang) {
    if (!localLang.startsWith("zh-")) {
      localLang = localLang.replace(/-\w+$/, "");
    }
    searchParams.set("lang", localLang);
  }
  queryString = searchParams.toString();
  const result = new Map();
  const typeMap = new Map();
  const lang = searchParams.get("lang");
  console.log(lang);
  const gachaType = getItemTypeNameMap$1(lang);
  let originUid = 0;
  for (const type of gachaType) {
    const { list, uid } = await getGachaLogs(type, queryString);
    const logs = list.map((item) => {
      return [item.time, item.name, item.item_type, parseInt(item.rank_type), item.gacha_type, item.id];
    });
    logs.reverse();
    typeMap.set(type[0], type[1]);
    result.set(type[0], logs);
    if (!originUid) {
      originUid = uid;
    }
  }
  const data = { result, time: Date.now(), typeMap, uid: originUid, lang };
  const localData = dataMap.get(originUid);
  const mergedResult = mergeData(localData, data);
  data.result = mergedResult;
  dataMap.set(originUid, data);
  await changeCurrent$1(originUid);
  await saveData$1(data, url);
};
let proxyStarted = false;
const fetchDataByProxy = async () => {
  if (proxyStarted)
    return;
  proxyStarted = true;
  const url = await useProxy();
  await fetchData(url);
};
ipcMain$3.handle("FETCH_DATA", async (event, param) => {
  try {
    if (param === "proxy") {
      await fetchDataByProxy();
    } else {
      await fetchData(param);
    }
    return {
      dataMap,
      current: config$2.current
    };
  } catch (e) {
    sendMsg$1(e, "ERROR");
    console.error(e);
  }
  return false;
});
ipcMain$3.handle("READ_DATA", async () => {
  await readData();
  return {
    dataMap,
    current: config$2.current
  };
});
ipcMain$3.handle("FORCE_READ_DATA", async () => {
  await readData(true);
  return {
    dataMap,
    current: config$2.current
  };
});
ipcMain$3.handle("CHANGE_UID", (event, uid) => {
  config$2.current = uid;
});
ipcMain$3.handle("GET_CONFIG", () => {
  return config$2.value();
});
ipcMain$3.handle("LANG_MAP", () => {
  return langMap;
});
ipcMain$3.handle("SAVE_CONFIG", (event, [key, value]) => {
  config$2[key] = value;
  config$2.save();
});
ipcMain$3.handle("DISABLE_PROXY", async () => {
  await disableProxy$1();
});
ipcMain$3.handle("I18N_DATA", () => {
  return i18n$2.data;
});
ipcMain$3.handle("OPEN_CACHE_FOLDER", () => {
  if (cacheFolder) {
    shell.openPath(cacheFolder);
  }
});
ipcMain$3.handle("COPY_URL", async () => {
  const url = await getUrl();
  if (url) {
    clipboard.writeText(url);
    return true;
  }
  return false;
});
getData$3.getData = () => {
  return {
    dataMap,
    current: config$2.current
  };
};
getData$3.saveData = saveData$1;
getData$3.changeCurrent = changeCurrent$1;

var exceljs_min = {exports: {}};

/*! ExcelJS 27-10-2020 */
(function(module, exports) {
  !function(t) {
    module.exports = t();
  }(function() {
    return function t(e, r, n) {
      function i(a2, s) {
        if (!r[a2]) {
          if (!e[a2]) {
            var u = typeof commonjsRequire == "function" && commonjsRequire;
            if (!s && u)
              return u(a2, true);
            if (o)
              return o(a2, true);
            var c = new Error("Cannot find module '" + a2 + "'");
            throw c.code = "MODULE_NOT_FOUND", c;
          }
          var f = r[a2] = { exports: {} };
          e[a2][0].call(f.exports, function(t2) {
            return i(e[a2][1][t2] || t2);
          }, f, f.exports, t, e, r, n);
        }
        return r[a2].exports;
      }
      for (var o = typeof commonjsRequire == "function" && commonjsRequire, a = 0; a < n.length; a++)
        i(n[a]);
      return i;
    }({ 1: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2, r2, n2, i2, o2, a2) {
        try {
          var s2 = t2[o2](a2), u2 = s2.value;
        } catch (t3) {
          return void r2(t3);
        }
        s2.done ? e2(u2) : Promise.resolve(u2).then(n2, i2);
      }
      function o(t2) {
        return function() {
          var e2 = this, r2 = arguments;
          return new Promise(function(n2, o2) {
            var a2 = t2.apply(e2, r2);
            function s2(t3) {
              i(a2, n2, o2, s2, u2, "next", t3);
            }
            function u2(t3) {
              i(a2, n2, o2, s2, u2, "throw", t3);
            }
            s2(void 0);
          });
        };
      }
      function a(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      var s = t("fs"), u = t("fast-csv"), c = t("dayjs/plugin/customParseFormat"), f = t("dayjs/plugin/utc"), l = t("dayjs").extend(c).extend(f), h = t("../utils/stream-buf"), d = t("../utils/utils").fs.exists, p = { true: true, false: false, "#N/A": { error: "#N/A" }, "#REF!": { error: "#REF!" }, "#NAME?": { error: "#NAME?" }, "#DIV/0!": { error: "#DIV/0!" }, "#NULL!": { error: "#NULL!" }, "#VALUE!": { error: "#VALUE!" }, "#NUM!": { error: "#NUM!" } }, m = function() {
        function t2(e3) {
          !function(t3, e4) {
            if (!(t3 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, t2), this.workbook = e3, this.worksheet = null;
        }
        var e2, r2, c2, f2;
        return e2 = t2, (r2 = [{ key: "readFile", value: (f2 = o(regeneratorRuntime.mark(function t3(e3, r3) {
          var n2, i3;
          return regeneratorRuntime.wrap(function(t4) {
            for (; ; )
              switch (t4.prev = t4.next) {
                case 0:
                  return r3 = r3 || {}, t4.next = 3, d(e3);
                case 3:
                  if (t4.sent) {
                    t4.next = 5;
                    break;
                  }
                  throw new Error("File not found: ".concat(e3));
                case 5:
                  return n2 = s.createReadStream(e3), t4.next = 8, this.read(n2, r3);
                case 8:
                  return i3 = t4.sent, n2.close(), t4.abrupt("return", i3);
                case 11:
                case "end":
                  return t4.stop();
              }
          }, t3, this);
        })), function(t3, e3) {
          return f2.apply(this, arguments);
        }) }, { key: "read", value: function(t3, e3) {
          var r3 = this;
          return e3 = e3 || {}, new Promise(function(n2, i3) {
            var o2 = r3.workbook.addWorksheet(e3.sheetName), a2 = e3.dateFormats || ["YYYY-MM-DD[T]HH:mm:ssZ", "YYYY-MM-DD[T]HH:mm:ss", "MM-DD-YYYY", "YYYY-MM-DD"], s2 = e3.map || function(t4) {
              if (t4 === "")
                return null;
              var e4 = Number(t4);
              if (!Number.isNaN(e4) && e4 !== 1 / 0)
                return e4;
              var r4 = a2.reduce(function(e5, r5) {
                if (e5)
                  return e5;
                var n4 = l(t4, r5, true);
                return n4.isValid() ? n4 : null;
              }, null);
              if (r4)
                return new Date(r4.valueOf());
              var n3 = p[t4];
              return n3 !== void 0 ? n3 : t4;
            }, c3 = u.parse(e3.parserOptions).on("data", function(t4) {
              o2.addRow(t4.map(s2));
            }).on("end", function() {
              c3.emit("worksheet", o2);
            });
            c3.on("worksheet", n2).on("error", i3), t3.pipe(c3);
          });
        } }, { key: "createInputStream", value: function() {
          throw new Error("`CSV#createInputStream` is deprecated. You should use `CSV#read` instead. This method will be removed in version 5.0. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md");
        } }, { key: "write", value: function(t3, e3) {
          var r3 = this;
          return new Promise(function(i3, o2) {
            e3 = e3 || {};
            var a2 = r3.workbook.getWorksheet(e3.sheetName || e3.sheetId), s2 = u.format(e3.formatterOptions);
            t3.on("finish", function() {
              i3();
            }), s2.on("error", o2), s2.pipe(t3);
            var c3 = e3, f3 = c3.dateFormat, h2 = c3.dateUTC, d2 = e3.map || function(t4) {
              if (t4) {
                if (t4.text || t4.hyperlink)
                  return t4.hyperlink || t4.text || "";
                if (t4.formula || t4.result)
                  return t4.result || "";
                if (t4 instanceof Date)
                  return f3 ? h2 ? l.utc(t4).format(f3) : l(t4).format(f3) : h2 ? l.utc(t4).format() : l(t4).format();
                if (t4.error)
                  return t4.error;
                if (n(t4) === "object")
                  return JSON.stringify(t4);
              }
              return t4;
            }, p2 = e3.includeEmptyRows === void 0 || e3.includeEmptyRows, m2 = 1;
            a2 && a2.eachRow(function(t4, e4) {
              if (p2)
                for (; m2++ < e4 - 1; )
                  s2.write([]);
              var r4 = t4.values;
              r4.shift(), s2.write(r4.map(d2)), m2 = e4;
            }), s2.end();
          });
        } }, { key: "writeFile", value: function(t3, e3) {
          var r3 = { encoding: (e3 = e3 || {}).encoding || "utf8" }, n2 = s.createWriteStream(t3, r3);
          return this.write(n2, e3);
        } }, { key: "writeBuffer", value: (c2 = o(regeneratorRuntime.mark(function t3(e3) {
          var r3;
          return regeneratorRuntime.wrap(function(t4) {
            for (; ; )
              switch (t4.prev = t4.next) {
                case 0:
                  return r3 = new h(), t4.next = 3, this.write(r3, e3);
                case 3:
                  return t4.abrupt("return", r3.read());
                case 4:
                case "end":
                  return t4.stop();
              }
          }, t3, this);
        })), function(t3) {
          return c2.apply(this, arguments);
        }) }]) && a(e2.prototype, r2), t2;
      }();
      e.exports = m;
    }, { "../utils/stream-buf": 23, "../utils/utils": 26, dayjs: 336, "dayjs/plugin/customParseFormat": 337, "dayjs/plugin/utc": 338, "fast-csv": 369, fs: 215 }], 2: [function(t, e, r) {
      function n(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      var o = t("../utils/col-cache"), a = function() {
        function t2(e3, r3) {
          var i2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
          if (n(this, t2), r3)
            if (typeof r3 == "string") {
              var a3 = o.decodeAddress(r3);
              this.nativeCol = a3.col + i2, this.nativeColOff = 0, this.nativeRow = a3.row + i2, this.nativeRowOff = 0;
            } else
              r3.nativeCol !== void 0 ? (this.nativeCol = r3.nativeCol || 0, this.nativeColOff = r3.nativeColOff || 0, this.nativeRow = r3.nativeRow || 0, this.nativeRowOff = r3.nativeRowOff || 0) : r3.col !== void 0 ? (this.col = r3.col + i2, this.row = r3.row + i2) : (this.nativeCol = 0, this.nativeColOff = 0, this.nativeRow = 0, this.nativeRowOff = 0);
          else
            this.nativeCol = 0, this.nativeColOff = 0, this.nativeRow = 0, this.nativeRowOff = 0;
          this.worksheet = e3;
        }
        var e2, r2, a2;
        return e2 = t2, a2 = [{ key: "asInstance", value: function(e3) {
          return e3 instanceof t2 || e3 == null ? e3 : new t2(e3);
        } }], (r2 = [{ key: "col", get: function() {
          return this.nativeCol + Math.min(this.colWidth - 1, this.nativeColOff) / this.colWidth;
        }, set: function(t3) {
          this.nativeCol = Math.floor(t3), this.nativeColOff = Math.floor((t3 - this.nativeCol) * this.colWidth);
        } }, { key: "row", get: function() {
          return this.nativeRow + Math.min(this.rowHeight - 1, this.nativeRowOff) / this.rowHeight;
        }, set: function(t3) {
          this.nativeRow = Math.floor(t3), this.nativeRowOff = Math.floor((t3 - this.nativeRow) * this.rowHeight);
        } }, { key: "colWidth", get: function() {
          return this.worksheet && this.worksheet.getColumn(this.nativeCol + 1) && this.worksheet.getColumn(this.nativeCol + 1).isCustomWidth ? Math.floor(1e4 * this.worksheet.getColumn(this.nativeCol + 1).width) : 64e4;
        } }, { key: "rowHeight", get: function() {
          return this.worksheet && this.worksheet.getRow(this.nativeRow + 1) && this.worksheet.getRow(this.nativeRow + 1).height ? Math.floor(1e4 * this.worksheet.getRow(this.nativeRow + 1).height) : 18e4;
        } }, { key: "model", get: function() {
          return { nativeCol: this.nativeCol, nativeColOff: this.nativeColOff, nativeRow: this.nativeRow, nativeRowOff: this.nativeRowOff };
        }, set: function(t3) {
          this.nativeCol = t3.nativeCol, this.nativeColOff = t3.nativeColOff, this.nativeRow = t3.nativeRow, this.nativeRowOff = t3.nativeRowOff;
        } }]) && i(e2.prototype, r2), a2 && i(e2, a2), t2;
      }();
      e.exports = a;
    }, { "../utils/col-cache": 19 }], 3: [function(t, e, r) {
      function n(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2, r2) {
        return e2 && i(t2.prototype, e2), r2 && i(t2, r2), t2;
      }
      var a = t("../utils/col-cache"), s = t("../utils/under-dash"), u = t("./enums"), c = t("../utils/shared-formula").slideFormula, f = t("./note"), l = function() {
        function t2(e2, r2, i2) {
          if (n(this, t2), !e2 || !r2)
            throw new Error("A Cell needs a Row");
          this._row = e2, this._column = r2, a.validateAddress(i2), this._address = i2, this._value = S.create(t2.Types.Null, this), this.style = this._mergeStyle(e2.style, r2.style, {}), this._mergeCount = 0;
        }
        return o(t2, [{ key: "destroy", value: function() {
          delete this.style, delete this._value, delete this._row, delete this._column, delete this._address;
        } }, { key: "_mergeStyle", value: function(t3, e2, r2) {
          var n2 = t3 && t3.numFmt || e2 && e2.numFmt;
          n2 && (r2.numFmt = n2);
          var i2 = t3 && t3.font || e2 && e2.font;
          i2 && (r2.font = i2);
          var o2 = t3 && t3.alignment || e2 && e2.alignment;
          o2 && (r2.alignment = o2);
          var a2 = t3 && t3.border || e2 && e2.border;
          a2 && (r2.border = a2);
          var s2 = t3 && t3.fill || e2 && e2.fill;
          s2 && (r2.fill = s2);
          var u2 = t3 && t3.protection || e2 && e2.protection;
          return u2 && (r2.protection = u2), r2;
        } }, { key: "toCsvString", value: function() {
          return this._value.toCsvString();
        } }, { key: "addMergeRef", value: function() {
          this._mergeCount++;
        } }, { key: "releaseMergeRef", value: function() {
          this._mergeCount--;
        } }, { key: "merge", value: function(e2, r2) {
          this._value.release(), this._value = S.create(t2.Types.Merge, this, e2), r2 || (this.style = e2.style);
        } }, { key: "unmerge", value: function() {
          this.type === t2.Types.Merge && (this._value.release(), this._value = S.create(t2.Types.Null, this), this.style = this._mergeStyle(this._row.style, this._column.style, {}));
        } }, { key: "isMergedTo", value: function(e2) {
          return this._value.type === t2.Types.Merge && this._value.isMergedTo(e2);
        } }, { key: "toString", value: function() {
          return this.text;
        } }, { key: "_upgradeToHyperlink", value: function(e2) {
          this.type === t2.Types.String && (this._value = S.create(t2.Types.Hyperlink, this, { text: this._value.value, hyperlink: e2 }));
        } }, { key: "addName", value: function(t3) {
          this.workbook.definedNames.addEx(this.fullAddress, t3);
        } }, { key: "removeName", value: function(t3) {
          this.workbook.definedNames.removeEx(this.fullAddress, t3);
        } }, { key: "removeAllNames", value: function() {
          this.workbook.definedNames.removeAllNames(this.fullAddress);
        } }, { key: "worksheet", get: function() {
          return this._row.worksheet;
        } }, { key: "workbook", get: function() {
          return this._row.worksheet.workbook;
        } }, { key: "numFmt", get: function() {
          return this.style.numFmt;
        }, set: function(t3) {
          this.style.numFmt = t3;
        } }, { key: "font", get: function() {
          return this.style.font;
        }, set: function(t3) {
          this.style.font = t3;
        } }, { key: "alignment", get: function() {
          return this.style.alignment;
        }, set: function(t3) {
          this.style.alignment = t3;
        } }, { key: "border", get: function() {
          return this.style.border;
        }, set: function(t3) {
          this.style.border = t3;
        } }, { key: "fill", get: function() {
          return this.style.fill;
        }, set: function(t3) {
          this.style.fill = t3;
        } }, { key: "protection", get: function() {
          return this.style.protection;
        }, set: function(t3) {
          this.style.protection = t3;
        } }, { key: "address", get: function() {
          return this._address;
        } }, { key: "row", get: function() {
          return this._row.number;
        } }, { key: "col", get: function() {
          return this._column.number;
        } }, { key: "$col$row", get: function() {
          return "$".concat(this._column.letter, "$").concat(this.row);
        } }, { key: "type", get: function() {
          return this._value.type;
        } }, { key: "effectiveType", get: function() {
          return this._value.effectiveType;
        } }, { key: "isMerged", get: function() {
          return this._mergeCount > 0 || this.type === t2.Types.Merge;
        } }, { key: "master", get: function() {
          return this.type === t2.Types.Merge ? this._value.master : this;
        } }, { key: "isHyperlink", get: function() {
          return this._value.type === t2.Types.Hyperlink;
        } }, { key: "hyperlink", get: function() {
          return this._value.hyperlink;
        } }, { key: "value", get: function() {
          return this._value.value;
        }, set: function(e2) {
          this.type !== t2.Types.Merge ? (this._value.release(), this._value = S.create(S.getType(e2), this, e2)) : this._value.master.value = e2;
        } }, { key: "note", get: function() {
          return this._comment && this._comment.note;
        }, set: function(t3) {
          this._comment = new f(t3);
        } }, { key: "text", get: function() {
          return this._value.toString();
        } }, { key: "html", get: function() {
          return s.escapeHtml(this.text);
        } }, { key: "formula", get: function() {
          return this._value.formula;
        } }, { key: "result", get: function() {
          return this._value.result;
        } }, { key: "formulaType", get: function() {
          return this._value.formulaType;
        } }, { key: "fullAddress", get: function() {
          return { sheetName: this._row.worksheet.name, address: this.address, row: this.row, col: this.col };
        } }, { key: "name", get: function() {
          return this.names[0];
        }, set: function(t3) {
          this.names = [t3];
        } }, { key: "names", get: function() {
          return this.workbook.definedNames.getNamesEx(this.fullAddress);
        }, set: function(t3) {
          var e2 = this, r2 = this.workbook.definedNames;
          r2.removeAllNames(this.fullAddress), t3.forEach(function(t4) {
            r2.addEx(e2.fullAddress, t4);
          });
        } }, { key: "_dataValidations", get: function() {
          return this.worksheet.dataValidations;
        } }, { key: "dataValidation", get: function() {
          return this._dataValidations.find(this.address);
        }, set: function(t3) {
          this._dataValidations.add(this.address, t3);
        } }, { key: "model", get: function() {
          var t3 = this._value.model;
          return t3.style = this.style, this._comment && (t3.comment = this._comment.model), t3;
        }, set: function(t3) {
          if (this._value.release(), this._value = S.create(t3.type, this), this._value.model = t3, t3.comment)
            switch (t3.comment.type) {
              case "note":
                this._comment = f.fromModel(t3.comment);
            }
          t3.style ? this.style = t3.style : this.style = {};
        } }]), t2;
      }();
      l.Types = u.ValueType;
      var h = function() {
        function t2(e2) {
          n(this, t2), this.model = { address: e2.address, type: l.Types.Null };
        }
        return o(t2, [{ key: "toCsvString", value: function() {
          return "";
        } }, { key: "release", value: function() {
        } }, { key: "toString", value: function() {
          return "";
        } }, { key: "value", get: function() {
          return null;
        }, set: function(t3) {
        } }, { key: "type", get: function() {
          return l.Types.Null;
        } }, { key: "effectiveType", get: function() {
          return l.Types.Null;
        } }, { key: "address", get: function() {
          return this.model.address;
        }, set: function(t3) {
          this.model.address = t3;
        } }]), t2;
      }(), d = function() {
        function t2(e2, r2) {
          n(this, t2), this.model = { address: e2.address, type: l.Types.Number, value: r2 };
        }
        return o(t2, [{ key: "toCsvString", value: function() {
          return this.model.value.toString();
        } }, { key: "release", value: function() {
        } }, { key: "toString", value: function() {
          return this.model.value.toString();
        } }, { key: "value", get: function() {
          return this.model.value;
        }, set: function(t3) {
          this.model.value = t3;
        } }, { key: "type", get: function() {
          return l.Types.Number;
        } }, { key: "effectiveType", get: function() {
          return l.Types.Number;
        } }, { key: "address", get: function() {
          return this.model.address;
        }, set: function(t3) {
          this.model.address = t3;
        } }]), t2;
      }(), p = function() {
        function t2(e2, r2) {
          n(this, t2), this.model = { address: e2.address, type: l.Types.String, value: r2 };
        }
        return o(t2, [{ key: "toCsvString", value: function() {
          return '"'.concat(this.model.value.replace(/"/g, '""'), '"');
        } }, { key: "release", value: function() {
        } }, { key: "toString", value: function() {
          return this.model.value;
        } }, { key: "value", get: function() {
          return this.model.value;
        }, set: function(t3) {
          this.model.value = t3;
        } }, { key: "type", get: function() {
          return l.Types.String;
        } }, { key: "effectiveType", get: function() {
          return l.Types.String;
        } }, { key: "address", get: function() {
          return this.model.address;
        }, set: function(t3) {
          this.model.address = t3;
        } }]), t2;
      }(), m = function() {
        function t2(e2, r2) {
          n(this, t2), this.model = { address: e2.address, type: l.Types.String, value: r2 };
        }
        return o(t2, [{ key: "toString", value: function() {
          return this.model.value.richText.map(function(t3) {
            return t3.text;
          }).join("");
        } }, { key: "toCsvString", value: function() {
          return '"'.concat(this.text.replace(/"/g, '""'), '"');
        } }, { key: "release", value: function() {
        } }, { key: "value", get: function() {
          return this.model.value;
        }, set: function(t3) {
          this.model.value = t3;
        } }, { key: "type", get: function() {
          return l.Types.RichText;
        } }, { key: "effectiveType", get: function() {
          return l.Types.RichText;
        } }, { key: "address", get: function() {
          return this.model.address;
        }, set: function(t3) {
          this.model.address = t3;
        } }]), t2;
      }(), y = function() {
        function t2(e2, r2) {
          n(this, t2), this.model = { address: e2.address, type: l.Types.Date, value: r2 };
        }
        return o(t2, [{ key: "toCsvString", value: function() {
          return this.model.value.toISOString();
        } }, { key: "release", value: function() {
        } }, { key: "toString", value: function() {
          return this.model.value.toString();
        } }, { key: "value", get: function() {
          return this.model.value;
        }, set: function(t3) {
          this.model.value = t3;
        } }, { key: "type", get: function() {
          return l.Types.Date;
        } }, { key: "effectiveType", get: function() {
          return l.Types.Date;
        } }, { key: "address", get: function() {
          return this.model.address;
        }, set: function(t3) {
          this.model.address = t3;
        } }]), t2;
      }(), b = function() {
        function t2(e2, r2) {
          n(this, t2), this.model = { address: e2.address, type: l.Types.Hyperlink, text: r2 ? r2.text : void 0, hyperlink: r2 ? r2.hyperlink : void 0 }, r2 && r2.tooltip && (this.model.tooltip = r2.tooltip);
        }
        return o(t2, [{ key: "toCsvString", value: function() {
          return this.model.hyperlink;
        } }, { key: "release", value: function() {
        } }, { key: "toString", value: function() {
          return this.model.text;
        } }, { key: "value", get: function() {
          var t3 = { text: this.model.text, hyperlink: this.model.hyperlink };
          return this.model.tooltip && (t3.tooltip = this.model.tooltip), t3;
        }, set: function(t3) {
          this.model = { text: t3.text, hyperlink: t3.hyperlink }, t3.tooltip && (this.model.tooltip = t3.tooltip);
        } }, { key: "text", get: function() {
          return this.model.text;
        }, set: function(t3) {
          this.model.text = t3;
        } }, { key: "hyperlink", get: function() {
          return this.model.hyperlink;
        }, set: function(t3) {
          this.model.hyperlink = t3;
        } }, { key: "type", get: function() {
          return l.Types.Hyperlink;
        } }, { key: "effectiveType", get: function() {
          return l.Types.Hyperlink;
        } }, { key: "address", get: function() {
          return this.model.address;
        }, set: function(t3) {
          this.model.address = t3;
        } }]), t2;
      }(), v = function() {
        function t2(e2, r2) {
          n(this, t2), this.model = { address: e2.address, type: l.Types.Merge, master: r2 ? r2.address : void 0 }, this._master = r2, r2 && r2.addMergeRef();
        }
        return o(t2, [{ key: "isMergedTo", value: function(t3) {
          return t3 === this._master;
        } }, { key: "toCsvString", value: function() {
          return "";
        } }, { key: "release", value: function() {
          this._master.releaseMergeRef();
        } }, { key: "toString", value: function() {
          return this.value.toString();
        } }, { key: "value", get: function() {
          return this._master.value;
        }, set: function(t3) {
          t3 instanceof l ? (this._master && this._master.releaseMergeRef(), t3.addMergeRef(), this._master = t3) : this._master.value = t3;
        } }, { key: "master", get: function() {
          return this._master;
        } }, { key: "type", get: function() {
          return l.Types.Merge;
        } }, { key: "effectiveType", get: function() {
          return this._master.effectiveType;
        } }, { key: "address", get: function() {
          return this.model.address;
        }, set: function(t3) {
          this.model.address = t3;
        } }]), t2;
      }(), g = function() {
        function t2(e2, r2) {
          n(this, t2), this.cell = e2, this.model = { address: e2.address, type: l.Types.Formula, shareType: r2 ? r2.shareType : void 0, ref: r2 ? r2.ref : void 0, formula: r2 ? r2.formula : void 0, sharedFormula: r2 ? r2.sharedFormula : void 0, result: r2 ? r2.result : void 0 };
        }
        return o(t2, [{ key: "_copyModel", value: function(t3) {
          var e2 = {}, r2 = function(r3) {
            var n2 = t3[r3];
            n2 && (e2[r3] = n2);
          };
          return r2("formula"), r2("result"), r2("ref"), r2("shareType"), r2("sharedFormula"), e2;
        } }, { key: "validate", value: function(t3) {
          switch (S.getType(t3)) {
            case l.Types.Null:
            case l.Types.String:
            case l.Types.Number:
            case l.Types.Date:
              break;
            case l.Types.Hyperlink:
            case l.Types.Formula:
            default:
              throw new Error("Cannot process that type of result value");
          }
        } }, { key: "_getTranslatedFormula", value: function() {
          if (!this._translatedFormula && this.model.sharedFormula) {
            var t3 = this.cell.worksheet.findCell(this.model.sharedFormula);
            this._translatedFormula = t3 && c(t3.formula, t3.address, this.model.address);
          }
          return this._translatedFormula;
        } }, { key: "toCsvString", value: function() {
          return "".concat(this.model.result || "");
        } }, { key: "release", value: function() {
        } }, { key: "toString", value: function() {
          return this.model.result ? this.model.result.toString() : "";
        } }, { key: "value", get: function() {
          return this._copyModel(this.model);
        }, set: function(t3) {
          this.model = this._copyModel(t3);
        } }, { key: "dependencies", get: function() {
          return { ranges: this.formula.match(/([a-zA-Z0-9]+!)?[A-Z]{1,3}\d{1,4}:[A-Z]{1,3}\d{1,4}/g), cells: this.formula.replace(/([a-zA-Z0-9]+!)?[A-Z]{1,3}\d{1,4}:[A-Z]{1,3}\d{1,4}/g, "").match(/([a-zA-Z0-9]+!)?[A-Z]{1,3}\d{1,4}/g) };
        } }, { key: "formula", get: function() {
          return this.model.formula || this._getTranslatedFormula();
        }, set: function(t3) {
          this.model.formula = t3;
        } }, { key: "formulaType", get: function() {
          return this.model.formula ? u.FormulaType.Master : this.model.sharedFormula ? u.FormulaType.Shared : u.FormulaType.None;
        } }, { key: "result", get: function() {
          return this.model.result;
        }, set: function(t3) {
          this.model.result = t3;
        } }, { key: "type", get: function() {
          return l.Types.Formula;
        } }, { key: "effectiveType", get: function() {
          var t3 = this.model.result;
          return t3 == null ? u.ValueType.Null : t3 instanceof String || typeof t3 == "string" ? u.ValueType.String : typeof t3 == "number" ? u.ValueType.Number : t3 instanceof Date ? u.ValueType.Date : t3.text && t3.hyperlink ? u.ValueType.Hyperlink : t3.formula ? u.ValueType.Formula : u.ValueType.Null;
        } }, { key: "address", get: function() {
          return this.model.address;
        }, set: function(t3) {
          this.model.address = t3;
        } }]), t2;
      }(), w = function() {
        function t2(e2, r2) {
          n(this, t2), this.model = { address: e2.address, type: l.Types.SharedString, value: r2 };
        }
        return o(t2, [{ key: "toCsvString", value: function() {
          return this.model.value.toString();
        } }, { key: "release", value: function() {
        } }, { key: "toString", value: function() {
          return this.model.value.toString();
        } }, { key: "value", get: function() {
          return this.model.value;
        }, set: function(t3) {
          this.model.value = t3;
        } }, { key: "type", get: function() {
          return l.Types.SharedString;
        } }, { key: "effectiveType", get: function() {
          return l.Types.SharedString;
        } }, { key: "address", get: function() {
          return this.model.address;
        }, set: function(t3) {
          this.model.address = t3;
        } }]), t2;
      }(), _ = function() {
        function t2(e2, r2) {
          n(this, t2), this.model = { address: e2.address, type: l.Types.Boolean, value: r2 };
        }
        return o(t2, [{ key: "toCsvString", value: function() {
          return this.model.value ? 1 : 0;
        } }, { key: "release", value: function() {
        } }, { key: "toString", value: function() {
          return this.model.value.toString();
        } }, { key: "value", get: function() {
          return this.model.value;
        }, set: function(t3) {
          this.model.value = t3;
        } }, { key: "type", get: function() {
          return l.Types.Boolean;
        } }, { key: "effectiveType", get: function() {
          return l.Types.Boolean;
        } }, { key: "address", get: function() {
          return this.model.address;
        }, set: function(t3) {
          this.model.address = t3;
        } }]), t2;
      }(), k = function() {
        function t2(e2, r2) {
          n(this, t2), this.model = { address: e2.address, type: l.Types.Error, value: r2 };
        }
        return o(t2, [{ key: "toCsvString", value: function() {
          return this.toString();
        } }, { key: "release", value: function() {
        } }, { key: "toString", value: function() {
          return this.model.value.error.toString();
        } }, { key: "value", get: function() {
          return this.model.value;
        }, set: function(t3) {
          this.model.value = t3;
        } }, { key: "type", get: function() {
          return l.Types.Error;
        } }, { key: "effectiveType", get: function() {
          return l.Types.Error;
        } }, { key: "address", get: function() {
          return this.model.address;
        }, set: function(t3) {
          this.model.address = t3;
        } }]), t2;
      }(), x = function() {
        function t2(e2, r2) {
          n(this, t2), this.model = { address: e2.address, type: l.Types.String, value: JSON.stringify(r2), rawValue: r2 };
        }
        return o(t2, [{ key: "toCsvString", value: function() {
          return this.model.value;
        } }, { key: "release", value: function() {
        } }, { key: "toString", value: function() {
          return this.model.value;
        } }, { key: "value", get: function() {
          return this.model.rawValue;
        }, set: function(t3) {
          this.model.rawValue = t3, this.model.value = JSON.stringify(t3);
        } }, { key: "type", get: function() {
          return l.Types.String;
        } }, { key: "effectiveType", get: function() {
          return l.Types.String;
        } }, { key: "address", get: function() {
          return this.model.address;
        }, set: function(t3) {
          this.model.address = t3;
        } }]), t2;
      }(), S = { getType: function(t2) {
        return t2 == null ? l.Types.Null : t2 instanceof String || typeof t2 == "string" ? l.Types.String : typeof t2 == "number" ? l.Types.Number : typeof t2 == "boolean" ? l.Types.Boolean : t2 instanceof Date ? l.Types.Date : t2.text && t2.hyperlink ? l.Types.Hyperlink : t2.formula || t2.sharedFormula ? l.Types.Formula : t2.richText ? l.Types.RichText : t2.sharedString ? l.Types.SharedString : t2.error ? l.Types.Error : l.Types.JSON;
      }, types: [{ t: l.Types.Null, f: h }, { t: l.Types.Number, f: d }, { t: l.Types.String, f: p }, { t: l.Types.Date, f: y }, { t: l.Types.Hyperlink, f: b }, { t: l.Types.Formula, f: g }, { t: l.Types.Merge, f: v }, { t: l.Types.JSON, f: x }, { t: l.Types.SharedString, f: w }, { t: l.Types.RichText, f: m }, { t: l.Types.Boolean, f: _ }, { t: l.Types.Error, f: k }].reduce(function(t2, e2) {
        return t2[e2.t] = e2.f, t2;
      }, []), create: function(t2, e2, r2) {
        var n2 = this.types[t2];
        if (!n2)
          throw new Error("Could not create Value of type ".concat(t2));
        return new n2(e2, r2);
      } };
      e.exports = l;
    }, { "../utils/col-cache": 19, "../utils/shared-formula": 22, "../utils/under-dash": 25, "./enums": 7, "./note": 9 }], 4: [function(t, e, r) {
      function n(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      var i = t("../utils/under-dash"), o = t("./enums"), a = t("../utils/col-cache"), s = function() {
        function t2(e3, r3, n2) {
          !function(t3, e4) {
            if (!(t3 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, t2), this._worksheet = e3, this._number = r3, n2 !== false && (this.defn = n2);
        }
        var e2, r2, s2;
        return e2 = t2, s2 = [{ key: "toModel", value: function(t3) {
          var e3 = [], r3 = null;
          return t3 && t3.forEach(function(t4, n2) {
            t4.isDefault ? r3 && (r3 = null) : r3 && t4.equivalentTo(r3) ? r3.max = n2 + 1 : (r3 = { min: n2 + 1, max: n2 + 1, width: t4.width !== void 0 ? t4.width : 9, style: t4.style, isCustomWidth: t4.isCustomWidth, hidden: t4.hidden, outlineLevel: t4.outlineLevel, collapsed: t4.collapsed }, e3.push(r3));
          }), e3.length ? e3 : void 0;
        } }, { key: "fromModel", value: function(e3, r3) {
          r3 = r3 || [];
          for (var n2 = [], i2 = 1, o2 = 0; o2 < r3.length; ) {
            for (var a2 = r3[o2++]; i2 < a2.min; )
              n2.push(new t2(e3, i2++));
            for (; i2 <= a2.max; )
              n2.push(new t2(e3, i2++, a2));
          }
          return n2.length ? n2 : null;
        } }], (r2 = [{ key: "toString", value: function() {
          return JSON.stringify({ key: this.key, width: this.width, headers: this.headers.length ? this.headers : void 0 });
        } }, { key: "equivalentTo", value: function(t3) {
          return this.width === t3.width && this.hidden === t3.hidden && this.outlineLevel === t3.outlineLevel && i.isEqual(this.style, t3.style);
        } }, { key: "eachCell", value: function(t3, e3) {
          var r3 = this.number;
          e3 || (e3 = t3, t3 = null), this._worksheet.eachRow(t3, function(t4, n2) {
            e3(t4.getCell(r3), n2);
          });
        } }, { key: "_applyStyle", value: function(t3, e3) {
          return this.style[t3] = e3, this.eachCell(function(r3) {
            r3[t3] = e3;
          }), e3;
        } }, { key: "number", get: function() {
          return this._number;
        } }, { key: "worksheet", get: function() {
          return this._worksheet;
        } }, { key: "letter", get: function() {
          return a.n2l(this._number);
        } }, { key: "isCustomWidth", get: function() {
          return this.width !== void 0 && this.width !== 9;
        } }, { key: "defn", get: function() {
          return { header: this._header, key: this.key, width: this.width, style: this.style, hidden: this.hidden, outlineLevel: this.outlineLevel };
        }, set: function(t3) {
          t3 ? (this.key = t3.key, this.width = t3.width !== void 0 ? t3.width : 9, this.outlineLevel = t3.outlineLevel, t3.style ? this.style = t3.style : this.style = {}, this.header = t3.header, this._hidden = !!t3.hidden) : (delete this._header, delete this._key, delete this.width, this.style = {}, this.outlineLevel = 0);
        } }, { key: "headers", get: function() {
          return this._header && this._header instanceof Array ? this._header : [this._header];
        } }, { key: "header", get: function() {
          return this._header;
        }, set: function(t3) {
          var e3 = this;
          t3 !== void 0 ? (this._header = t3, this.headers.forEach(function(t4, r3) {
            e3._worksheet.getCell(r3 + 1, e3.number).value = t4;
          })) : this._header = void 0;
        } }, { key: "key", get: function() {
          return this._key;
        }, set: function(t3) {
          (this._key && this._worksheet.getColumnKey(this._key)) === this && this._worksheet.deleteColumnKey(this._key), this._key = t3, t3 && this._worksheet.setColumnKey(this._key, this);
        } }, { key: "hidden", get: function() {
          return !!this._hidden;
        }, set: function(t3) {
          this._hidden = t3;
        } }, { key: "outlineLevel", get: function() {
          return this._outlineLevel || 0;
        }, set: function(t3) {
          this._outlineLevel = t3;
        } }, { key: "collapsed", get: function() {
          return !!(this._outlineLevel && this._outlineLevel >= this._worksheet.properties.outlineLevelCol);
        } }, { key: "isDefault", get: function() {
          if (this.isCustomWidth)
            return false;
          if (this.hidden)
            return false;
          if (this.outlineLevel)
            return false;
          var t3 = this.style;
          return !t3 || !(t3.font || t3.numFmt || t3.alignment || t3.border || t3.fill || t3.protection);
        } }, { key: "headerCount", get: function() {
          return this.headers.length;
        } }, { key: "values", get: function() {
          var t3 = [];
          return this.eachCell(function(e3, r3) {
            e3 && e3.type !== o.ValueType.Null && (t3[r3] = e3.value);
          }), t3;
        }, set: function(t3) {
          var e3 = this;
          if (t3) {
            var r3 = this.number, n2 = 0;
            t3.hasOwnProperty("0") && (n2 = 1), t3.forEach(function(t4, i2) {
              e3._worksheet.getCell(i2 + n2, r3).value = t4;
            });
          }
        } }, { key: "numFmt", get: function() {
          return this.style.numFmt;
        }, set: function(t3) {
          this._applyStyle("numFmt", t3);
        } }, { key: "font", get: function() {
          return this.style.font;
        }, set: function(t3) {
          this._applyStyle("font", t3);
        } }, { key: "alignment", get: function() {
          return this.style.alignment;
        }, set: function(t3) {
          this._applyStyle("alignment", t3);
        } }, { key: "protection", get: function() {
          return this.style.protection;
        }, set: function(t3) {
          this._applyStyle("protection", t3);
        } }, { key: "border", get: function() {
          return this.style.border;
        }, set: function(t3) {
          this._applyStyle("border", t3);
        } }, { key: "fill", get: function() {
          return this.style.fill;
        }, set: function(t3) {
          this._applyStyle("fill", t3);
        } }]) && n(e2.prototype, r2), s2 && n(e2, s2), t2;
      }();
      e.exports = s;
    }, { "../utils/col-cache": 19, "../utils/under-dash": 25, "./enums": 7 }], 5: [function(t, e, r) {
      function n(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      var i = function() {
        function t2(e3) {
          !function(t3, e4) {
            if (!(t3 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, t2), this.model = e3 || {};
        }
        var e2, r2;
        return e2 = t2, (r2 = [{ key: "add", value: function(t3, e3) {
          return this.model[t3] = e3;
        } }, { key: "find", value: function(t3) {
          return this.model[t3];
        } }, { key: "remove", value: function(t3) {
          this.model[t3] = void 0;
        } }]) && n(e2.prototype, r2), t2;
      }();
      e.exports = i;
    }, {}], 6: [function(t, e, r) {
      function n(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      var i = t("../utils/under-dash"), o = t("../utils/col-cache"), a = t("../utils/cell-matrix"), s = t("./range"), u = /[$](\w+)[$](\d+)(:[$](\w+)[$](\d+))?/, c = function() {
        function t2() {
          !function(t3, e3) {
            if (!(t3 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, t2), this.matrixMap = {};
        }
        var e2, r2;
        return e2 = t2, (r2 = [{ key: "getMatrix", value: function(t3) {
          return this.matrixMap[t3] || (this.matrixMap[t3] = new a());
        } }, { key: "add", value: function(t3, e3) {
          var r3 = o.decodeEx(t3);
          this.addEx(r3, e3);
        } }, { key: "addEx", value: function(t3, e3) {
          var r3 = this.getMatrix(e3);
          if (t3.top)
            for (var n2 = t3.left; n2 <= t3.right; n2++)
              for (var i2 = t3.top; i2 <= t3.bottom; i2++) {
                var a2 = { sheetName: t3.sheetName, address: o.n2l(n2) + i2, row: i2, col: n2 };
                r3.addCellEx(a2);
              }
          else
            r3.addCellEx(t3);
        } }, { key: "remove", value: function(t3, e3) {
          var r3 = o.decodeEx(t3);
          this.removeEx(r3, e3);
        } }, { key: "removeEx", value: function(t3, e3) {
          this.getMatrix(e3).removeCellEx(t3);
        } }, { key: "removeAllNames", value: function(t3) {
          i.each(this.matrixMap, function(e3) {
            e3.removeCellEx(t3);
          });
        } }, { key: "forEach", value: function(t3) {
          i.each(this.matrixMap, function(e3, r3) {
            e3.forEach(function(e4) {
              t3(r3, e4);
            });
          });
        } }, { key: "getNames", value: function(t3) {
          return this.getNamesEx(o.decodeEx(t3));
        } }, { key: "getNamesEx", value: function(t3) {
          return i.map(this.matrixMap, function(e3, r3) {
            return e3.findCellEx(t3) && r3;
          }).filter(Boolean);
        } }, { key: "_explore", value: function(t3, e3) {
          e3.mark = false;
          var r3, n2, i2 = e3.sheetName, o2 = new s(e3.row, e3.col, e3.row, e3.col, i2);
          function a2(r4, n3) {
            var a3 = t3.findCellAt(i2, r4, e3.col);
            return !(!a3 || !a3.mark || (o2[n3] = r4, a3.mark = false, 0));
          }
          for (n2 = e3.row - 1; a2(n2, "top"); n2--)
            ;
          for (n2 = e3.row + 1; a2(n2, "bottom"); n2++)
            ;
          function u2(e4, r4) {
            var a3 = [];
            for (n2 = o2.top; n2 <= o2.bottom; n2++) {
              var s2 = t3.findCellAt(i2, n2, e4);
              if (!s2 || !s2.mark)
                return false;
              a3.push(s2);
            }
            o2[r4] = e4;
            for (var u3 = 0; u3 < a3.length; u3++)
              a3[u3].mark = false;
            return true;
          }
          for (r3 = e3.col - 1; u2(r3, "left"); r3--)
            ;
          for (r3 = e3.col + 1; u2(r3, "right"); r3++)
            ;
          return o2;
        } }, { key: "getRanges", value: function(t3, e3) {
          var r3 = this;
          return (e3 = e3 || this.matrixMap[t3]) ? (e3.forEach(function(t4) {
            t4.mark = true;
          }), { name: t3, ranges: e3.map(function(t4) {
            return t4.mark && r3._explore(e3, t4);
          }).filter(Boolean).map(function(t4) {
            return t4.$shortRange;
          }) }) : { name: t3, ranges: [] };
        } }, { key: "normaliseMatrix", value: function(t3, e3) {
          t3.forEachInSheet(e3, function(t4, e4, r3) {
            t4 && (t4.row === e4 && t4.col === r3 || (t4.row = e4, t4.col = r3, t4.address = o.n2l(r3) + e4));
          });
        } }, { key: "spliceRows", value: function(t3, e3, r3, n2) {
          var o2 = this;
          i.each(this.matrixMap, function(i2) {
            i2.spliceRows(t3, e3, r3, n2), o2.normaliseMatrix(i2, t3);
          });
        } }, { key: "spliceColumns", value: function(t3, e3, r3, n2) {
          var o2 = this;
          i.each(this.matrixMap, function(i2) {
            i2.spliceColumns(t3, e3, r3, n2), o2.normaliseMatrix(i2, t3);
          });
        } }, { key: "model", get: function() {
          var t3 = this;
          return i.map(this.matrixMap, function(e3, r3) {
            return t3.getRanges(r3, e3);
          }).filter(function(t4) {
            return t4.ranges.length;
          });
        }, set: function(t3) {
          var e3 = this.matrixMap = {};
          t3.forEach(function(t4) {
            var r3 = e3[t4.name] = new a();
            t4.ranges.forEach(function(t5) {
              u.test(t5.split("!").pop() || "") && r3.addCell(t5);
            });
          });
        } }]) && n(e2.prototype, r2), t2;
      }();
      e.exports = c;
    }, { "../utils/cell-matrix": 18, "../utils/col-cache": 19, "../utils/under-dash": 25, "./range": 10 }], 7: [function(t, e, r) {
      e.exports = { ValueType: { Null: 0, Merge: 1, Number: 2, String: 3, Date: 4, Hyperlink: 5, Formula: 6, SharedString: 7, RichText: 8, Boolean: 9, Error: 10 }, FormulaType: { None: 0, Master: 1, Shared: 2 }, RelationshipType: { None: 0, OfficeDocument: 1, Worksheet: 2, CalcChain: 3, SharedStrings: 4, Styles: 5, Theme: 6, Hyperlink: 7 }, DocumentType: { Xlsx: 1 }, ReadingOrder: { LeftToRight: 1, RightToLeft: 2 }, ErrorValue: { NotApplicable: "#N/A", Ref: "#REF!", Name: "#NAME?", DivZero: "#DIV/0!", Null: "#NULL!", Value: "#VALUE!", Num: "#NUM!" } };
    }, {}], 8: [function(t, e, r) {
      function n(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      var i = t("../utils/col-cache"), o = t("./anchor"), a = function() {
        function t2(e3, r3) {
          !function(t3, e4) {
            if (!(t3 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, t2), this.worksheet = e3, this.model = r3;
        }
        var e2, r2;
        return e2 = t2, (r2 = [{ key: "model", get: function() {
          switch (this.type) {
            case "background":
              return { type: this.type, imageId: this.imageId };
            case "image":
              return { type: this.type, imageId: this.imageId, hyperlinks: this.range.hyperlinks, range: { tl: this.range.tl.model, br: this.range.br && this.range.br.model, ext: this.range.ext, editAs: this.range.editAs } };
            default:
              throw new Error("Invalid Image Type");
          }
        }, set: function(t3) {
          var e3 = t3.type, r3 = t3.imageId, n2 = t3.range, a3 = t3.hyperlinks;
          if (this.type = e3, this.imageId = r3, e3 === "image")
            if (typeof n2 == "string") {
              var s = i.decode(n2);
              this.range = { tl: new o(this.worksheet, { col: s.left, row: s.top }, -1), br: new o(this.worksheet, { col: s.right, row: s.bottom }, 0), editAs: "oneCell" };
            } else
              this.range = { tl: new o(this.worksheet, n2.tl, 0), br: n2.br && new o(this.worksheet, n2.br, 0), ext: n2.ext, editAs: n2.editAs, hyperlinks: a3 || n2.hyperlinks };
        } }]) && n(e2.prototype, r2), t2;
      }();
      e.exports = a;
    }, { "../utils/col-cache": 19, "./anchor": 2 }], 9: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      var o = t("../utils/under-dash"), a = function() {
        function t2(e3) {
          !function(t3, e4) {
            if (!(t3 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, t2), this.note = e3;
        }
        var e2, r2, a2;
        return e2 = t2, a2 = [{ key: "fromModel", value: function(e3) {
          var r3 = new t2();
          return r3.model = e3, r3;
        } }], (r2 = [{ key: "model", get: function() {
          var e3 = null;
          switch (n(this.note)) {
            case "string":
              e3 = { type: "note", note: { texts: [{ text: this.note }] } };
              break;
            default:
              e3 = { type: "note", note: this.note };
          }
          return o.deepMerge({}, t2.DEFAULT_CONFIGS, e3);
        }, set: function(t3) {
          var e3 = t3.note, r3 = e3.texts;
          r3.length === 1 && Object.keys(r3[0]).length === 1 ? this.note = r3[0].text : this.note = e3;
        } }]) && i(e2.prototype, r2), a2 && i(e2, a2), t2;
      }();
      a.DEFAULT_CONFIGS = { note: { margins: { insetmode: "auto", inset: [0.13, 0.13, 0.25, 0.25] }, protection: { locked: "True", lockText: "True" }, editAs: "absolute" } }, e.exports = a;
    }, { "../utils/under-dash": 25 }], 10: [function(t, e, r) {
      function n(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      var o = t("../utils/col-cache"), a = function() {
        function t2() {
          n(this, t2), this.decode(arguments);
        }
        var e2, r2;
        return e2 = t2, (r2 = [{ key: "setTLBR", value: function(t3, e3, r3, n2, i2) {
          if (arguments.length < 4) {
            var a3 = o.decodeAddress(t3), s = o.decodeAddress(e3);
            this.model = { top: Math.min(a3.row, s.row), left: Math.min(a3.col, s.col), bottom: Math.max(a3.row, s.row), right: Math.max(a3.col, s.col), sheetName: r3 }, this.setTLBR(a3.row, a3.col, s.row, s.col, i2);
          } else
            this.model = { top: Math.min(t3, r3), left: Math.min(e3, n2), bottom: Math.max(t3, r3), right: Math.max(e3, n2), sheetName: i2 };
        } }, { key: "decode", value: function(e3) {
          switch (e3.length) {
            case 5:
              this.setTLBR(e3[0], e3[1], e3[2], e3[3], e3[4]);
              break;
            case 4:
              this.setTLBR(e3[0], e3[1], e3[2], e3[3]);
              break;
            case 3:
              this.setTLBR(e3[0], e3[1], e3[2]);
              break;
            case 2:
              this.setTLBR(e3[0], e3[1]);
              break;
            case 1:
              var r3 = e3[0];
              if (r3 instanceof t2)
                this.model = { top: r3.model.top, left: r3.model.left, bottom: r3.model.bottom, right: r3.model.right, sheetName: r3.sheetName };
              else if (r3 instanceof Array)
                this.decode(r3);
              else if (r3.top && r3.left && r3.bottom && r3.right)
                this.model = { top: r3.top, left: r3.left, bottom: r3.bottom, right: r3.right, sheetName: r3.sheetName };
              else {
                var n2 = o.decodeEx(r3);
                n2.top ? this.model = { top: n2.top, left: n2.left, bottom: n2.bottom, right: n2.right, sheetName: n2.sheetName } : this.model = { top: n2.row, left: n2.col, bottom: n2.row, right: n2.col, sheetName: n2.sheetName };
              }
              break;
            case 0:
              this.model = { top: 0, left: 0, bottom: 0, right: 0 };
              break;
            default:
              throw new Error("Invalid number of arguments to _getDimensions() - ".concat(e3.length));
          }
        } }, { key: "expand", value: function(t3, e3, r3, n2) {
          (!this.model.top || t3 < this.top) && (this.top = t3), (!this.model.left || e3 < this.left) && (this.left = e3), (!this.model.bottom || r3 > this.bottom) && (this.bottom = r3), (!this.model.right || n2 > this.right) && (this.right = n2);
        } }, { key: "expandRow", value: function(t3) {
          if (t3) {
            var e3 = t3.dimensions, r3 = t3.number;
            e3 && this.expand(r3, e3.min, r3, e3.max);
          }
        } }, { key: "expandToAddress", value: function(t3) {
          var e3 = o.decodeEx(t3);
          this.expand(e3.row, e3.col, e3.row, e3.col);
        } }, { key: "toString", value: function() {
          return this.range;
        } }, { key: "intersects", value: function(t3) {
          return !(t3.sheetName && this.sheetName && t3.sheetName !== this.sheetName || t3.bottom < this.top || t3.top > this.bottom || t3.right < this.left || t3.left > this.right);
        } }, { key: "contains", value: function(t3) {
          var e3 = o.decodeEx(t3);
          return this.containsEx(e3);
        } }, { key: "containsEx", value: function(t3) {
          return (!t3.sheetName || !this.sheetName || t3.sheetName === this.sheetName) && t3.row >= this.top && t3.row <= this.bottom && t3.col >= this.left && t3.col <= this.right;
        } }, { key: "forEachAddress", value: function(t3) {
          for (var e3 = this.left; e3 <= this.right; e3++)
            for (var r3 = this.top; r3 <= this.bottom; r3++)
              t3(o.encodeAddress(r3, e3), r3, e3);
        } }, { key: "top", get: function() {
          return this.model.top || 1;
        }, set: function(t3) {
          this.model.top = t3;
        } }, { key: "left", get: function() {
          return this.model.left || 1;
        }, set: function(t3) {
          this.model.left = t3;
        } }, { key: "bottom", get: function() {
          return this.model.bottom || 1;
        }, set: function(t3) {
          this.model.bottom = t3;
        } }, { key: "right", get: function() {
          return this.model.right || 1;
        }, set: function(t3) {
          this.model.right = t3;
        } }, { key: "sheetName", get: function() {
          return this.model.sheetName;
        }, set: function(t3) {
          this.model.sheetName = t3;
        } }, { key: "_serialisedSheetName", get: function() {
          var t3 = this.model.sheetName;
          return t3 ? /^[a-zA-Z0-9]*$/.test(t3) ? "".concat(t3, "!") : "'".concat(t3, "'!") : "";
        } }, { key: "tl", get: function() {
          return o.n2l(this.left) + this.top;
        } }, { key: "$t$l", get: function() {
          return "$".concat(o.n2l(this.left), "$").concat(this.top);
        } }, { key: "br", get: function() {
          return o.n2l(this.right) + this.bottom;
        } }, { key: "$b$r", get: function() {
          return "$".concat(o.n2l(this.right), "$").concat(this.bottom);
        } }, { key: "range", get: function() {
          return "".concat(this._serialisedSheetName + this.tl, ":").concat(this.br);
        } }, { key: "$range", get: function() {
          return "".concat(this._serialisedSheetName + this.$t$l, ":").concat(this.$b$r);
        } }, { key: "shortRange", get: function() {
          return this.count > 1 ? this.range : this._serialisedSheetName + this.tl;
        } }, { key: "$shortRange", get: function() {
          return this.count > 1 ? this.$range : this._serialisedSheetName + this.$t$l;
        } }, { key: "count", get: function() {
          return (1 + this.bottom - this.top) * (1 + this.right - this.left);
        } }]) && i(e2.prototype, r2), t2;
      }();
      e.exports = a;
    }, { "../utils/col-cache": 19 }], 11: [function(t, e, r) {
      function n(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      var i = t("../utils/under-dash"), o = t("./enums"), a = t("../utils/col-cache"), s = t("./cell"), u = function() {
        function t2(e3, r3) {
          !function(t3, e4) {
            if (!(t3 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, t2), this._worksheet = e3, this._number = r3, this._cells = [], this.style = {}, this.outlineLevel = 0;
        }
        var e2, r2;
        return e2 = t2, (r2 = [{ key: "commit", value: function() {
          this._worksheet._commitRow(this);
        } }, { key: "destroy", value: function() {
          delete this._worksheet, delete this._cells, delete this.style;
        } }, { key: "findCell", value: function(t3) {
          return this._cells[t3 - 1];
        } }, { key: "getCellEx", value: function(t3) {
          var e3 = this._cells[t3.col - 1];
          if (!e3) {
            var r3 = this._worksheet.getColumn(t3.col);
            e3 = new s(this, r3, t3.address), this._cells[t3.col - 1] = e3;
          }
          return e3;
        } }, { key: "getCell", value: function(t3) {
          if (typeof t3 == "string") {
            var e3 = this._worksheet.getColumnKey(t3);
            t3 = e3 ? e3.number : a.l2n(t3);
          }
          return this._cells[t3 - 1] || this.getCellEx({ address: a.encodeAddress(this._number, t3), row: this._number, col: t3 });
        } }, { key: "splice", value: function(t3, e3) {
          for (var r3 = t3 + e3, n2 = arguments.length, i2 = new Array(n2 > 2 ? n2 - 2 : 0), o2 = 2; o2 < n2; o2++)
            i2[o2 - 2] = arguments[o2];
          var a2, s2, u3, c = i2.length - e3, f = this._cells.length;
          if (c < 0)
            for (a2 = t3 + i2.length; a2 <= f; a2++)
              u3 = this._cells[a2 - 1], (s2 = this._cells[a2 - c - 1]) ? ((u3 = this.getCell(a2)).value = s2.value, u3.style = s2.style, u3._comment = s2._comment) : u3 && (u3.value = null, u3.style = {}, u3._comment = void 0);
          else if (c > 0)
            for (a2 = f; a2 >= r3; a2--)
              (s2 = this._cells[a2 - 1]) ? ((u3 = this.getCell(a2 + c)).value = s2.value, u3.style = s2.style, u3._comment = s2._comment) : this._cells[a2 + c - 1] = void 0;
          for (a2 = 0; a2 < i2.length; a2++)
            (u3 = this.getCell(t3 + a2)).value = i2[a2], u3.style = {}, u3._comment = void 0;
        } }, { key: "eachCell", value: function(t3, e3) {
          if (e3 || (e3 = t3, t3 = null), t3 && t3.includeEmpty)
            for (var r3 = this._cells.length, n2 = 1; n2 <= r3; n2++)
              e3(this.getCell(n2), n2);
          else
            this._cells.forEach(function(t4, r4) {
              t4 && t4.type !== o.ValueType.Null && e3(t4, r4 + 1);
            });
        } }, { key: "addPageBreak", value: function(t3, e3) {
          var r3 = this._worksheet, n2 = Math.max(0, t3 - 1) || 0, i2 = Math.max(0, e3 - 1) || 16838, o2 = { id: this._number, max: i2, man: 1 };
          n2 && (o2.min = n2), r3.rowBreaks.push(o2);
        } }, { key: "_applyStyle", value: function(t3, e3) {
          return this.style[t3] = e3, this._cells.forEach(function(r3) {
            r3 && (r3[t3] = e3);
          }), e3;
        } }, { key: "number", get: function() {
          return this._number;
        } }, { key: "worksheet", get: function() {
          return this._worksheet;
        } }, { key: "values", get: function() {
          var t3 = [];
          return this._cells.forEach(function(e3) {
            e3 && e3.type !== o.ValueType.Null && (t3[e3.col] = e3.value);
          }), t3;
        }, set: function(t3) {
          var e3 = this;
          if (this._cells = [], t3)
            if (t3 instanceof Array) {
              var r3 = 0;
              t3.hasOwnProperty("0") && (r3 = 1), t3.forEach(function(t4, n2) {
                t4 !== void 0 && (e3.getCellEx({ address: a.encodeAddress(e3._number, n2 + r3), row: e3._number, col: n2 + r3 }).value = t4);
              });
            } else
              this._worksheet.eachColumnKey(function(r4, n2) {
                t3[n2] !== void 0 && (e3.getCellEx({ address: a.encodeAddress(e3._number, r4.number), row: e3._number, col: r4.number }).value = t3[n2]);
              });
        } }, { key: "hasValues", get: function() {
          return i.some(this._cells, function(t3) {
            return t3 && t3.type !== o.ValueType.Null;
          });
        } }, { key: "cellCount", get: function() {
          return this._cells.length;
        } }, { key: "actualCellCount", get: function() {
          var t3 = 0;
          return this.eachCell(function() {
            t3++;
          }), t3;
        } }, { key: "dimensions", get: function() {
          var t3 = 0, e3 = 0;
          return this._cells.forEach(function(r3) {
            r3 && r3.type !== o.ValueType.Null && ((!t3 || t3 > r3.col) && (t3 = r3.col), e3 < r3.col && (e3 = r3.col));
          }), t3 > 0 ? { min: t3, max: e3 } : null;
        } }, { key: "numFmt", get: function() {
          return this.style.numFmt;
        }, set: function(t3) {
          this._applyStyle("numFmt", t3);
        } }, { key: "font", get: function() {
          return this.style.font;
        }, set: function(t3) {
          this._applyStyle("font", t3);
        } }, { key: "alignment", get: function() {
          return this.style.alignment;
        }, set: function(t3) {
          this._applyStyle("alignment", t3);
        } }, { key: "protection", get: function() {
          return this.style.protection;
        }, set: function(t3) {
          this._applyStyle("protection", t3);
        } }, { key: "border", get: function() {
          return this.style.border;
        }, set: function(t3) {
          this._applyStyle("border", t3);
        } }, { key: "fill", get: function() {
          return this.style.fill;
        }, set: function(t3) {
          this._applyStyle("fill", t3);
        } }, { key: "hidden", get: function() {
          return !!this._hidden;
        }, set: function(t3) {
          this._hidden = t3;
        } }, { key: "outlineLevel", get: function() {
          return this._outlineLevel || 0;
        }, set: function(t3) {
          this._outlineLevel = t3;
        } }, { key: "collapsed", get: function() {
          return !!(this._outlineLevel && this._outlineLevel >= this._worksheet.properties.outlineLevelRow);
        } }, { key: "model", get: function() {
          var t3 = [], e3 = 0, r3 = 0;
          return this._cells.forEach(function(n2) {
            if (n2) {
              var i2 = n2.model;
              i2 && ((!e3 || e3 > n2.col) && (e3 = n2.col), r3 < n2.col && (r3 = n2.col), t3.push(i2));
            }
          }), this.height || t3.length ? { cells: t3, number: this.number, min: e3, max: r3, height: this.height, style: this.style, hidden: this.hidden, outlineLevel: this.outlineLevel, collapsed: this.collapsed } : null;
        }, set: function(t3) {
          var e3, r3 = this;
          if (t3.number !== this._number)
            throw new Error("Invalid row number in model");
          this._cells = [], t3.cells.forEach(function(t4) {
            switch (t4.type) {
              case s.Types.Merge:
                break;
              default:
                var n2;
                if (t4.address)
                  n2 = a.decodeAddress(t4.address);
                else if (e3) {
                  var i2 = e3.row, o2 = e3.col + 1;
                  n2 = { row: i2, col: o2, address: a.encodeAddress(i2, o2), $col$row: "$".concat(a.n2l(o2), "$").concat(i2) };
                }
                e3 = n2, r3.getCellEx(n2).model = t4;
            }
          }), t3.height ? this.height = t3.height : delete this.height, this.hidden = t3.hidden, this.outlineLevel = t3.outlineLevel || 0, this.style = t3.style && JSON.parse(JSON.stringify(t3.style)) || {};
        } }]) && n(e2.prototype, r2), t2;
      }();
      e.exports = u;
    }, { "../utils/col-cache": 19, "../utils/under-dash": 25, "./cell": 3, "./enums": 7 }], 12: [function(t, e, r) {
      function n(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2, r2) {
        return e2 && i(t2.prototype, e2), r2 && i(t2, r2), t2;
      }
      var a = t("../utils/col-cache"), s = function() {
        function t2(e2, r2, i2) {
          n(this, t2), this.table = e2, this.column = r2, this.index = i2;
        }
        return o(t2, [{ key: "_set", value: function(t3, e2) {
          this.table.cacheState(), this.column[t3] = e2;
        } }, { key: "name", get: function() {
          return this.column.name;
        }, set: function(t3) {
          this._set("name", t3);
        } }, { key: "filterButton", get: function() {
          return this.column.filterButton;
        }, set: function(t3) {
          this.column.filterButton = t3;
        } }, { key: "style", get: function() {
          return this.column.style;
        }, set: function(t3) {
          this.column.style = t3;
        } }, { key: "totalsRowLabel", get: function() {
          return this.column.totalsRowLabel;
        }, set: function(t3) {
          this._set("totalsRowLabel", t3);
        } }, { key: "totalsRowFunction", get: function() {
          return this.column.totalsRowFunction;
        }, set: function(t3) {
          this._set("totalsRowFunction", t3);
        } }, { key: "totalsRowResult", get: function() {
          return this.column.totalsRowResult;
        }, set: function(t3) {
          this._set("totalsRowResult", t3);
        } }, { key: "totalsRowFormula", get: function() {
          return this.column.totalsRowFormula;
        }, set: function(t3) {
          this._set("totalsRowFormula", t3);
        } }]), t2;
      }(), u = function() {
        function t2(e2, r2) {
          n(this, t2), this.worksheet = e2, r2 && (this.table = r2, this.validate(), this.store());
        }
        return o(t2, [{ key: "getFormula", value: function(t3) {
          switch (t3.totalsRowFunction) {
            case "none":
              return null;
            case "average":
              return "SUBTOTAL(101,".concat(this.table.name, "[").concat(t3.name, "])");
            case "countNums":
              return "SUBTOTAL(102,".concat(this.table.name, "[").concat(t3.name, "])");
            case "count":
              return "SUBTOTAL(103,".concat(this.table.name, "[").concat(t3.name, "])");
            case "max":
              return "SUBTOTAL(104,".concat(this.table.name, "[").concat(t3.name, "])");
            case "min":
              return "SUBTOTAL(105,".concat(this.table.name, "[").concat(t3.name, "])");
            case "stdDev":
              return "SUBTOTAL(106,".concat(this.table.name, "[").concat(t3.name, "])");
            case "var":
              return "SUBTOTAL(107,".concat(this.table.name, "[").concat(t3.name, "])");
            case "sum":
              return "SUBTOTAL(109,".concat(this.table.name, "[").concat(t3.name, "])");
            case "custom":
              return t3.totalsRowFormula;
            default:
              throw new Error("Invalid Totals Row Function: ".concat(t3.totalsRowFunction));
          }
        } }, { key: "validate", value: function() {
          var t3 = this, e2 = this.table, r2 = function(t4, e3, r3) {
            t4[e3] === void 0 && (t4[e3] = r3);
          };
          r2(e2, "headerRow", true), r2(e2, "totalsRow", false), r2(e2, "style", {}), r2(e2.style, "theme", "TableStyleMedium2"), r2(e2.style, "showFirstColumn", false), r2(e2.style, "showLastColumn", false), r2(e2.style, "showRowStripes", false), r2(e2.style, "showColumnStripes", false);
          var n2 = function(t4, e3) {
            if (!t4)
              throw new Error(e3);
          };
          n2(e2.ref, "Table must have ref"), n2(e2.columns, "Table must have column definitions"), n2(e2.rows, "Table must have row definitions"), e2.tl = a.decodeAddress(e2.ref);
          var i2 = e2.tl, o2 = i2.row, s2 = i2.col;
          n2(o2 > 0, "Table must be on valid row"), n2(s2 > 0, "Table must be on valid col");
          var u2 = this.width, c = this.filterHeight, f = this.tableHeight;
          e2.autoFilterRef = a.encode(o2, s2, o2 + c - 1, s2 + u2 - 1), e2.tableRef = a.encode(o2, s2, o2 + f - 1, s2 + u2 - 1), e2.columns.forEach(function(e3, i3) {
            n2(e3.name, "Column ".concat(i3, " must have a name")), i3 === 0 ? r2(e3, "totalsRowLabel", "Total") : (r2(e3, "totalsRowFunction", "none"), e3.totalsRowFormula = t3.getFormula(e3));
          });
        } }, { key: "store", value: function() {
          var t3 = this, e2 = function(t4, e3) {
            e3 && Object.keys(e3).forEach(function(r3) {
              t4[r3] = e3[r3];
            });
          }, r2 = this.worksheet, n2 = this.table, i2 = n2.tl, o2 = i2.row, a2 = i2.col, s2 = 0;
          if (n2.headerRow) {
            var u2 = r2.getRow(o2 + s2++);
            n2.columns.forEach(function(t4, r3) {
              var n3 = t4.style, i3 = t4.name, o3 = u2.getCell(a2 + r3);
              o3.value = i3, e2(o3, n3);
            });
          }
          if (n2.rows.forEach(function(t4) {
            var i3 = r2.getRow(o2 + s2++);
            t4.forEach(function(t5, r3) {
              var o3 = i3.getCell(a2 + r3);
              o3.value = t5, e2(o3, n2.columns[r3].style);
            });
          }), n2.totalsRow) {
            var c = r2.getRow(o2 + s2++);
            n2.columns.forEach(function(r3, n3) {
              var i3 = c.getCell(a2 + n3);
              if (n3 === 0)
                i3.value = r3.totalsRowLabel;
              else {
                var o3 = t3.getFormula(r3);
                i3.value = o3 ? { formula: r3.totalsRowFormula, result: r3.totalsRowResult } : null;
              }
              e2(i3, r3.style);
            });
          }
        } }, { key: "load", value: function(t3) {
          var e2 = this, r2 = this.table, n2 = r2.tl, i2 = n2.row, o2 = n2.col, a2 = 0;
          if (r2.headerRow) {
            var s2 = t3.getRow(i2 + a2++);
            r2.columns.forEach(function(t4, e3) {
              s2.getCell(o2 + e3).value = t4.name;
            });
          }
          if (r2.rows.forEach(function(e3) {
            var r3 = t3.getRow(i2 + a2++);
            e3.forEach(function(t4, e4) {
              r3.getCell(o2 + e4).value = t4;
            });
          }), r2.totalsRow) {
            var u2 = t3.getRow(i2 + a2++);
            r2.columns.forEach(function(t4, r3) {
              var n3 = u2.getCell(o2 + r3);
              r3 === 0 ? n3.value = t4.totalsRowLabel : e2.getFormula(t4) && (n3.value = { formula: t4.totalsRowFormula, result: t4.totalsRowResult });
            });
          }
        } }, { key: "cacheState", value: function() {
          this._cache || (this._cache = { ref: this.ref, width: this.width, tableHeight: this.tableHeight });
        } }, { key: "commit", value: function() {
          if (this._cache) {
            this.validate();
            var t3 = a.decodeAddress(this._cache.ref);
            if (this.ref !== this._cache.ref)
              for (var e2 = 0; e2 < this._cache.tableHeight; e2++)
                for (var r2 = this.worksheet.getRow(t3.row + e2), n2 = 0; n2 < this._cache.width; n2++) {
                  r2.getCell(t3.col + n2).value = null;
                }
            else {
              for (var i2 = this.tableHeight; i2 < this._cache.tableHeight; i2++)
                for (var o2 = this.worksheet.getRow(t3.row + i2), s2 = 0; s2 < this._cache.width; s2++) {
                  o2.getCell(t3.col + s2).value = null;
                }
              for (var u2 = 0; u2 < this.tableHeight; u2++)
                for (var c = this.worksheet.getRow(t3.row + u2), f = this.width; f < this._cache.width; f++) {
                  c.getCell(t3.col + f).value = null;
                }
            }
            this.store();
          }
        } }, { key: "addRow", value: function(t3, e2) {
          this.cacheState(), e2 === void 0 ? this.table.rows.push(t3) : this.table.rows.splice(e2, 0, t3);
        } }, { key: "removeRows", value: function(t3) {
          var e2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          this.cacheState(), this.table.rows.splice(t3, e2);
        } }, { key: "getColumn", value: function(t3) {
          var e2 = this.table.columns[t3];
          return new s(this, e2, t3);
        } }, { key: "addColumn", value: function(t3, e2, r2) {
          this.cacheState(), r2 === void 0 ? (this.table.columns.push(t3), this.table.rows.forEach(function(t4, r3) {
            t4.push(e2[r3]);
          })) : (this.table.columns.splice(r2, 0, t3), this.table.rows.forEach(function(t4, n2) {
            t4.splice(r2, 0, e2[n2]);
          }));
        } }, { key: "removeColumns", value: function(t3) {
          var e2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          this.cacheState(), this.table.columns.splice(t3, e2), this.table.rows.forEach(function(r2) {
            r2.splice(t3, e2);
          });
        } }, { key: "_assign", value: function(t3, e2, r2) {
          this.cacheState(), t3[e2] = r2;
        } }, { key: "width", get: function() {
          return this.table.columns.length;
        } }, { key: "height", get: function() {
          return this.table.rows.length;
        } }, { key: "filterHeight", get: function() {
          return this.height + (this.table.headerRow ? 1 : 0);
        } }, { key: "tableHeight", get: function() {
          return this.filterHeight + (this.table.totalsRow ? 1 : 0);
        } }, { key: "model", get: function() {
          return this.table;
        }, set: function(t3) {
          this.table = t3;
        } }, { key: "ref", get: function() {
          return this.table.ref;
        }, set: function(t3) {
          this._assign(this.table, "ref", t3);
        } }, { key: "name", get: function() {
          return this.table.name;
        }, set: function(t3) {
          this.table.name = t3;
        } }, { key: "displayName", get: function() {
          return this.table.displyName || this.table.name;
        } }, { key: "displayNamename", set: function(t3) {
          this.table.displayName = t3;
        } }, { key: "headerRow", get: function() {
          return this.table.headerRow;
        }, set: function(t3) {
          this._assign(this.table, "headerRow", t3);
        } }, { key: "totalsRow", get: function() {
          return this.table.totalsRow;
        }, set: function(t3) {
          this._assign(this.table, "totalsRow", t3);
        } }, { key: "theme", get: function() {
          return this.table.style.name;
        }, set: function(t3) {
          this.table.style.name = t3;
        } }, { key: "showFirstColumn", get: function() {
          return this.table.style.showFirstColumn;
        }, set: function(t3) {
          this.table.style.showFirstColumn = t3;
        } }, { key: "showLastColumn", get: function() {
          return this.table.style.showLastColumn;
        }, set: function(t3) {
          this.table.style.showLastColumn = t3;
        } }, { key: "showRowStripes", get: function() {
          return this.table.style.showRowStripes;
        }, set: function(t3) {
          this.table.style.showRowStripes = t3;
        } }, { key: "showColumnStripes", get: function() {
          return this.table.style.showColumnStripes;
        }, set: function(t3) {
          this.table.style.showColumnStripes = t3;
        } }]), t2;
      }();
      e.exports = u;
    }, { "../utils/col-cache": 19 }], 13: [function(t, e, r) {
      function n(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      var i = t("./worksheet"), o = t("./defined-names"), a = t("../xlsx/xlsx"), s = t("../csv/csv"), u = function() {
        function t2() {
          !function(t3, e3) {
            if (!(t3 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, t2), this.created = new Date(), this.modified = this.created, this.properties = {}, this.calcProperties = {}, this._worksheets = [], this.views = [], this.media = [], this._definedNames = new o();
        }
        var e2, r2;
        return e2 = t2, (r2 = [{ key: "addWorksheet", value: function(t3, e3) {
          var r3 = this.nextId;
          if (t3 && t3.length > 31 && console.warn("Worksheet name ".concat(t3, " exceeds 31 chars. This will be truncated")), /[*?:/\\[\]]/.test(t3))
            throw new Error("Worksheet name ".concat(t3, " cannot include any of the following characters: * ? : \\ / [ ]"));
          if (/(^')|('$)/.test(t3))
            throw new Error("The first or last character of worksheet name cannot be a single quotation mark: ".concat(t3));
          if (t3 = (t3 || "sheet".concat(r3)).substring(0, 31), this._worksheets.find(function(e4) {
            return e4 && e4.name.toLowerCase() === t3.toLowerCase();
          }))
            throw new Error("Worksheet name already exists: ".concat(t3));
          e3 && (typeof e3 == "string" ? (console.trace('tabColor argument is now deprecated. Please use workbook.addWorksheet(name, {properties: { tabColor: { argb: "rbg value" } }'), e3 = { properties: { tabColor: { argb: e3 } } }) : (e3.argb || e3.theme || e3.indexed) && (console.trace("tabColor argument is now deprecated. Please use workbook.addWorksheet(name, {properties: { tabColor: { ... } }"), e3 = { properties: { tabColor: e3 } }));
          var n2 = this._worksheets.reduce(function(t4, e4) {
            return (e4 && e4.orderNo) > t4 ? e4.orderNo : t4;
          }, 0), o2 = Object.assign({}, e3, { id: r3, name: t3, orderNo: n2 + 1, workbook: this }), a2 = new i(o2);
          return this._worksheets[r3] = a2, a2;
        } }, { key: "removeWorksheetEx", value: function(t3) {
          delete this._worksheets[t3.id];
        } }, { key: "removeWorksheet", value: function(t3) {
          var e3 = this.getWorksheet(t3);
          e3 && e3.destroy();
        } }, { key: "getWorksheet", value: function(t3) {
          return t3 === void 0 ? this._worksheets.find(Boolean) : typeof t3 == "number" ? this._worksheets[t3] : typeof t3 == "string" ? this._worksheets.find(function(e3) {
            return e3 && e3.name === t3;
          }) : void 0;
        } }, { key: "eachSheet", value: function(t3) {
          this.worksheets.forEach(function(e3) {
            t3(e3, e3.id);
          });
        } }, { key: "clearThemes", value: function() {
          this._themes = void 0;
        } }, { key: "addImage", value: function(t3) {
          var e3 = this.media.length;
          return this.media.push(Object.assign({}, t3, { type: "image" })), e3;
        } }, { key: "getImage", value: function(t3) {
          return this.media[t3];
        } }, { key: "xlsx", get: function() {
          return this._xlsx || (this._xlsx = new a(this)), this._xlsx;
        } }, { key: "csv", get: function() {
          return this._csv || (this._csv = new s(this)), this._csv;
        } }, { key: "nextId", get: function() {
          for (var t3 = 1; t3 < this._worksheets.length; t3++)
            if (!this._worksheets[t3])
              return t3;
          return this._worksheets.length || 1;
        } }, { key: "worksheets", get: function() {
          return this._worksheets.slice(1).sort(function(t3, e3) {
            return t3.orderNo - e3.orderNo;
          }).filter(Boolean);
        } }, { key: "definedNames", get: function() {
          return this._definedNames;
        } }, { key: "model", get: function() {
          return { creator: this.creator || "Unknown", lastModifiedBy: this.lastModifiedBy || "Unknown", lastPrinted: this.lastPrinted, created: this.created, modified: this.modified, properties: this.properties, worksheets: this.worksheets.map(function(t3) {
            return t3.model;
          }), sheets: this.worksheets.map(function(t3) {
            return t3.model;
          }).filter(Boolean), definedNames: this._definedNames.model, views: this.views, company: this.company, manager: this.manager, title: this.title, subject: this.subject, keywords: this.keywords, category: this.category, description: this.description, language: this.language, revision: this.revision, contentStatus: this.contentStatus, themes: this._themes, media: this.media, calcProperties: this.calcProperties };
        }, set: function(t3) {
          var e3 = this;
          this.creator = t3.creator, this.lastModifiedBy = t3.lastModifiedBy, this.lastPrinted = t3.lastPrinted, this.created = t3.created, this.modified = t3.modified, this.company = t3.company, this.manager = t3.manager, this.title = t3.title, this.subject = t3.subject, this.keywords = t3.keywords, this.category = t3.category, this.description = t3.description, this.language = t3.language, this.revision = t3.revision, this.contentStatus = t3.contentStatus, this.properties = t3.properties, this.calcProperties = t3.calcProperties, this._worksheets = [], t3.worksheets.forEach(function(r3) {
            var n2 = r3.id, o2 = r3.name, a2 = r3.state, s2 = t3.sheets && t3.sheets.findIndex(function(t4) {
              return t4.id === n2;
            });
            (e3._worksheets[n2] = new i({ id: n2, name: o2, orderNo: s2, state: a2, workbook: e3 })).model = r3;
          }), this._definedNames.model = t3.definedNames, this.views = t3.views, this._themes = t3.themes, this.media = t3.media || [];
        } }]) && n(e2.prototype, r2), t2;
      }();
      e.exports = u;
    }, { "../csv/csv": 1, "../xlsx/xlsx": 141, "./defined-names": 6, "./worksheet": 14 }], 14: [function(t, e, r) {
      function n(t2, e2) {
        var r2 = Object.keys(t2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t2);
          e2 && (n2 = n2.filter(function(e3) {
            return Object.getOwnPropertyDescriptor(t2, e3).enumerable;
          })), r2.push.apply(r2, n2);
        }
        return r2;
      }
      function i(t2) {
        for (var e2 = 1; e2 < arguments.length; e2++) {
          var r2 = arguments[e2] != null ? arguments[e2] : {};
          e2 % 2 ? n(Object(r2), true).forEach(function(e3) {
            o(t2, e3, r2[e3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(r2)) : n(Object(r2)).forEach(function(e3) {
            Object.defineProperty(t2, e3, Object.getOwnPropertyDescriptor(r2, e3));
          });
        }
        return t2;
      }
      function o(t2, e2, r2) {
        return e2 in t2 ? Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }) : t2[e2] = r2, t2;
      }
      function a(t2) {
        return function(t3) {
          if (Array.isArray(t3))
            return s(t3);
        }(t2) || function(t3) {
          if (typeof Symbol != "undefined" && Symbol.iterator in Object(t3))
            return Array.from(t3);
        }(t2) || function(t3, e2) {
          if (!t3)
            return;
          if (typeof t3 == "string")
            return s(t3, e2);
          var r2 = Object.prototype.toString.call(t3).slice(8, -1);
          r2 === "Object" && t3.constructor && (r2 = t3.constructor.name);
          if (r2 === "Map" || r2 === "Set")
            return Array.from(t3);
          if (r2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
            return s(t3, e2);
        }(t2) || function() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function s(t2, e2) {
        (e2 == null || e2 > t2.length) && (e2 = t2.length);
        for (var r2 = 0, n2 = new Array(e2); r2 < e2; r2++)
          n2[r2] = t2[r2];
        return n2;
      }
      function u(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      var c = t("../utils/under-dash"), f = t("../utils/col-cache"), l = t("./range"), h = t("./row"), d = t("./column"), p = t("./enums"), m = t("./image"), y = t("./table"), b = t("./data-validations"), v = t("../utils/encryptor"), g = function() {
        function t2(e3) {
          !function(t3, e4) {
            if (!(t3 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, t2), e3 = e3 || {}, this.id = e3.id, this.orderNo = e3.orderNo, this.name = e3.name || "Sheet".concat(this.id), this.state = e3.state || "visible", this._rows = [], this._columns = null, this._keys = {}, this._merges = {}, this.rowBreaks = [], this._workbook = e3.workbook, this.properties = Object.assign({}, { defaultRowHeight: 15, dyDescent: 55, outlineLevelCol: 0, outlineLevelRow: 0 }, e3.properties), this.pageSetup = Object.assign({}, { margins: { left: 0.7, right: 0.7, top: 0.75, bottom: 0.75, header: 0.3, footer: 0.3 }, orientation: "portrait", horizontalDpi: 4294967295, verticalDpi: 4294967295, fitToPage: !(!e3.pageSetup || !e3.pageSetup.fitToWidth && !e3.pageSetup.fitToHeight || e3.pageSetup.scale), pageOrder: "downThenOver", blackAndWhite: false, draft: false, cellComments: "None", errors: "displayed", scale: 100, fitToWidth: 1, fitToHeight: 1, paperSize: void 0, showRowColHeaders: false, showGridLines: false, firstPageNumber: void 0, horizontalCentered: false, verticalCentered: false, rowBreaks: null, colBreaks: null }, e3.pageSetup), this.headerFooter = Object.assign({}, { differentFirst: false, differentOddEven: false, oddHeader: null, oddFooter: null, evenHeader: null, evenFooter: null, firstHeader: null, firstFooter: null }, e3.headerFooter), this.dataValidations = new b(), this.views = e3.views || [], this.autoFilter = e3.autoFilter || null, this._media = [], this.sheetProtection = null, this.tables = {}, this.conditionalFormattings = [];
        }
        var e2, r2;
        return e2 = t2, (r2 = [{ key: "destroy", value: function() {
          this._workbook.removeWorksheetEx(this);
        } }, { key: "getColumnKey", value: function(t3) {
          return this._keys[t3];
        } }, { key: "setColumnKey", value: function(t3, e3) {
          this._keys[t3] = e3;
        } }, { key: "deleteColumnKey", value: function(t3) {
          delete this._keys[t3];
        } }, { key: "eachColumnKey", value: function(t3) {
          c.each(this._keys, t3);
        } }, { key: "getColumn", value: function(t3) {
          if (typeof t3 == "string") {
            var e3 = this._keys[t3];
            if (e3)
              return e3;
            t3 = f.l2n(t3);
          }
          if (this._columns || (this._columns = []), t3 > this._columns.length)
            for (var r3 = this._columns.length + 1; r3 <= t3; )
              this._columns.push(new d(this, r3++));
          return this._columns[t3 - 1];
        } }, { key: "spliceColumns", value: function(t3, e3) {
          for (var r3 = this, n3 = this._rows, i2 = n3.length, o2 = arguments.length, a2 = new Array(o2 > 2 ? o2 - 2 : 0), s2 = 2; s2 < o2; s2++)
            a2[s2 - 2] = arguments[s2];
          if (a2.length > 0)
            for (var u2 = function(n4) {
              var i3 = [t3, e3];
              a2.forEach(function(t4) {
                i3.push(t4[n4] || null);
              });
              var o3 = r3.getRow(n4 + 1);
              o3.splice.apply(o3, i3);
            }, c2 = 0; c2 < i2; c2++)
              u2(c2);
          else
            this._rows.forEach(function(r4) {
              r4 && r4.splice(t3, e3);
            });
          var f2 = a2.length - e3, l2 = t3 + e3, h2 = this._columns.length;
          if (f2 < 0)
            for (var d2 = t3 + a2.length; d2 <= h2; d2++)
              this.getColumn(d2).defn = this.getColumn(d2 - f2).defn;
          else if (f2 > 0)
            for (var p2 = h2; p2 >= l2; p2--)
              this.getColumn(p2 + f2).defn = this.getColumn(p2).defn;
          for (var m2 = t3; m2 < t3 + a2.length; m2++)
            this.getColumn(m2).defn = null;
          this.workbook.definedNames.spliceColumns(this.name, t3, e3, a2.length);
        } }, { key: "_commitRow", value: function() {
        } }, { key: "findRow", value: function(t3) {
          return this._rows[t3 - 1];
        } }, { key: "findRows", value: function(t3, e3) {
          return this._rows.slice(t3 - 1, t3 - 1 + e3);
        } }, { key: "getRow", value: function(t3) {
          var e3 = this._rows[t3 - 1];
          return e3 || (e3 = this._rows[t3 - 1] = new h(this, t3)), e3;
        } }, { key: "getRows", value: function(t3, e3) {
          if (!(e3 < 1)) {
            for (var r3 = [], n3 = t3; n3 < t3 + e3; n3++)
              r3.push(this.getRow(n3));
            return r3;
          }
        } }, { key: "addRow", value: function(t3) {
          var e3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "n", r3 = this._nextRow, n3 = this.getRow(r3);
          return n3.values = t3, this._setStyleOption(r3, e3[0] === "i" ? e3 : "n"), n3;
        } }, { key: "addRows", value: function(t3) {
          var e3 = this, r3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "n", n3 = [];
          return t3.forEach(function(t4) {
            n3.push(e3.addRow(t4, r3));
          }), n3;
        } }, { key: "insertRow", value: function(t3, e3) {
          var r3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "n";
          return this.spliceRows(t3, 0, e3), this._setStyleOption(t3, r3), this.getRow(t3);
        } }, { key: "insertRows", value: function(t3, e3) {
          var r3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "n";
          if (this.spliceRows.apply(this, [t3, 0].concat(a(e3))), r3 !== "n")
            for (var n3 = 0; n3 < e3.length; n3++)
              r3[0] === "o" && this.findRow(e3.length + t3 + n3) !== void 0 ? this._copyStyle(e3.length + t3 + n3, t3 + n3, r3[1] === "+") : r3[0] === "i" && this.findRow(t3 - 1) !== void 0 && this._copyStyle(t3 - 1, t3 + n3, r3[1] === "+");
          return this.getRows(t3, e3.length);
        } }, { key: "_setStyleOption", value: function(t3) {
          var e3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "n";
          e3[0] === "o" && this.findRow(t3 + 1) !== void 0 ? this._copyStyle(t3 + 1, t3, e3[1] === "+") : e3[0] === "i" && this.findRow(t3 - 1) !== void 0 && this._copyStyle(t3 - 1, t3, e3[1] === "+");
        } }, { key: "_copyStyle", value: function(t3, e3) {
          var r3 = arguments.length > 2 && arguments[2] !== void 0 && arguments[2], n3 = this.getRow(t3), o2 = this.getRow(e3);
          o2.style = Object.freeze(i({}, n3.style)), n3.eachCell({ includeEmpty: r3 }, function(t4, e4) {
            o2.getCell(e4).style = Object.freeze(i({}, t4.style));
          }), o2.height = n3.height;
        } }, { key: "duplicateRow", value: function(t3, e3) {
          var r3 = this, n3 = arguments.length > 2 && arguments[2] !== void 0 && arguments[2], i2 = this._rows[t3 - 1], o2 = new Array(e3).fill(i2.values);
          this.spliceRows.apply(this, [t3 + 1, n3 ? 0 : e3].concat(a(o2)));
          for (var s2 = function(e4) {
            var n4 = r3._rows[t3 + e4];
            n4.style = i2.style, n4.height = i2.height, i2.eachCell({ includeEmpty: true }, function(t4, e5) {
              n4.getCell(e5).style = t4.style;
            });
          }, u2 = 0; u2 < e3; u2++)
            s2(u2);
        } }, { key: "spliceRows", value: function(t3, e3) {
          for (var r3 = this, n3 = t3 + e3, i2 = arguments.length, o2 = new Array(i2 > 2 ? i2 - 2 : 0), a2 = 2; a2 < i2; a2++)
            o2[a2 - 2] = arguments[a2];
          var s2, u2, c2 = o2.length, f2 = c2 - e3, l2 = this._rows.length;
          if (f2 < 0)
            for (s2 = n3; s2 <= l2; s2++)
              (u2 = this._rows[s2 - 1]) ? function() {
                var t4 = r3.getRow(s2 + f2);
                t4.values = u2.values, t4.style = u2.style, t4.height = u2.height, u2.eachCell({ includeEmpty: true }, function(e4, r4) {
                  t4.getCell(r4).style = e4.style;
                }), r3._rows[s2 - 1] = void 0;
              }() : this._rows[s2 + f2 - 1] = void 0;
          else if (f2 > 0)
            for (s2 = l2; s2 >= n3; s2--)
              (u2 = this._rows[s2 - 1]) ? function() {
                var t4 = r3.getRow(s2 + f2);
                t4.values = u2.values, t4.style = u2.style, t4.height = u2.height, u2.eachCell({ includeEmpty: true }, function(e4, n4) {
                  if (t4.getCell(n4).style = e4.style, e4._value.constructor.name === "MergeValue") {
                    var i3 = r3.getRow(e4._row._number + c2).getCell(n4), o3 = e4._value._master, a3 = r3.getRow(o3._row._number + c2).getCell(o3._column._number);
                    i3.merge(a3);
                  }
                });
              }() : this._rows[s2 + f2 - 1] = void 0;
          for (s2 = 0; s2 < c2; s2++) {
            var h2 = this.getRow(t3 + s2);
            h2.style = {}, h2.values = o2[s2];
          }
          this.workbook.definedNames.spliceRows(this.name, t3, e3, c2);
        } }, { key: "eachRow", value: function(t3, e3) {
          if (e3 || (e3 = t3, t3 = void 0), t3 && t3.includeEmpty)
            for (var r3 = this._rows.length, n3 = 1; n3 <= r3; n3++)
              e3(this.getRow(n3), n3);
          else
            this._rows.forEach(function(t4) {
              t4 && t4.hasValues && e3(t4, t4.number);
            });
        } }, { key: "getSheetValues", value: function() {
          var t3 = [];
          return this._rows.forEach(function(e3) {
            e3 && (t3[e3.number] = e3.values);
          }), t3;
        } }, { key: "findCell", value: function(t3, e3) {
          var r3 = f.getAddress(t3, e3), n3 = this._rows[r3.row - 1];
          return n3 ? n3.findCell(r3.col) : void 0;
        } }, { key: "getCell", value: function(t3, e3) {
          var r3 = f.getAddress(t3, e3);
          return this.getRow(r3.row).getCellEx(r3);
        } }, { key: "mergeCells", value: function() {
          for (var t3 = arguments.length, e3 = new Array(t3), r3 = 0; r3 < t3; r3++)
            e3[r3] = arguments[r3];
          var n3 = new l(e3);
          this._mergeCellsInternal(n3);
        } }, { key: "mergeCellsWithoutStyle", value: function() {
          for (var t3 = arguments.length, e3 = new Array(t3), r3 = 0; r3 < t3; r3++)
            e3[r3] = arguments[r3];
          var n3 = new l(e3);
          this._mergeCellsInternal(n3, true);
        } }, { key: "_mergeCellsInternal", value: function(t3, e3) {
          c.each(this._merges, function(e4) {
            if (e4.intersects(t3))
              throw new Error("Cannot merge already merged cells");
          });
          for (var r3 = this.getCell(t3.top, t3.left), n3 = t3.top; n3 <= t3.bottom; n3++)
            for (var i2 = t3.left; i2 <= t3.right; i2++)
              (n3 > t3.top || i2 > t3.left) && this.getCell(n3, i2).merge(r3, e3);
          this._merges[r3.address] = t3;
        } }, { key: "_unMergeMaster", value: function(t3) {
          var e3 = this._merges[t3.address];
          if (e3) {
            for (var r3 = e3.top; r3 <= e3.bottom; r3++)
              for (var n3 = e3.left; n3 <= e3.right; n3++)
                this.getCell(r3, n3).unmerge();
            delete this._merges[t3.address];
          }
        } }, { key: "unMergeCells", value: function() {
          for (var t3 = arguments.length, e3 = new Array(t3), r3 = 0; r3 < t3; r3++)
            e3[r3] = arguments[r3];
          for (var n3 = new l(e3), i2 = n3.top; i2 <= n3.bottom; i2++)
            for (var o2 = n3.left; o2 <= n3.right; o2++) {
              var a2 = this.findCell(i2, o2);
              a2 && (a2.type === p.ValueType.Merge ? this._unMergeMaster(a2.master) : this._merges[a2.address] && this._unMergeMaster(a2));
            }
        } }, { key: "fillFormula", value: function(t3, e3, r3) {
          var n3, i2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "shared", o2 = f.decode(t3), a2 = o2.top, s2 = o2.left, u2 = o2.bottom, c2 = o2.right, l2 = c2 - s2 + 1, h2 = f.encodeAddress(a2, s2), d2 = i2 === "shared";
          n3 = typeof r3 == "function" ? r3 : Array.isArray(r3) ? Array.isArray(r3[0]) ? function(t4, e4) {
            return r3[t4 - a2][e4 - s2];
          } : function(t4, e4) {
            return r3[(t4 - a2) * l2 + (e4 - s2)];
          } : function() {
          };
          for (var p2 = true, m2 = a2; m2 <= u2; m2++)
            for (var y2 = s2; y2 <= c2; y2++)
              p2 ? (this.getCell(m2, y2).value = { shareType: i2, formula: e3, ref: t3, result: n3(m2, y2) }, p2 = false) : this.getCell(m2, y2).value = d2 ? { sharedFormula: h2, result: n3(m2, y2) } : n3(m2, y2);
        } }, { key: "addImage", value: function(t3, e3) {
          var r3 = { type: "image", imageId: t3, range: e3 };
          this._media.push(new m(this, r3));
        } }, { key: "getImages", value: function() {
          return this._media.filter(function(t3) {
            return t3.type === "image";
          });
        } }, { key: "addBackgroundImage", value: function(t3) {
          var e3 = { type: "background", imageId: t3 };
          this._media.push(new m(this, e3));
        } }, { key: "getBackgroundImageId", value: function() {
          var t3 = this._media.find(function(t4) {
            return t4.type === "background";
          });
          return t3 && t3.imageId;
        } }, { key: "protect", value: function(t3, e3) {
          var r3 = this;
          return new Promise(function(n3) {
            r3.sheetProtection = { sheet: true }, e3 && "spinCount" in e3 && (e3.spinCount = Number.isFinite(e3.spinCount) ? Math.round(Math.max(0, e3.spinCount)) : 1e5), t3 && (r3.sheetProtection.algorithmName = "SHA-512", r3.sheetProtection.saltValue = v.randomBytes(16).toString("base64"), r3.sheetProtection.spinCount = e3 && "spinCount" in e3 ? e3.spinCount : 1e5, r3.sheetProtection.hashValue = v.convertPasswordToHash(t3, "SHA512", r3.sheetProtection.saltValue, r3.sheetProtection.spinCount)), e3 && (r3.sheetProtection = Object.assign(r3.sheetProtection, e3), !t3 && "spinCount" in e3 && delete r3.sheetProtection.spinCount), n3();
          });
        } }, { key: "unprotect", value: function() {
          this.sheetProtection = null;
        } }, { key: "addTable", value: function(t3) {
          var e3 = new y(this, t3);
          return this.tables[t3.name] = e3, e3;
        } }, { key: "getTable", value: function(t3) {
          return this.tables[t3];
        } }, { key: "removeTable", value: function(t3) {
          delete this.tables[t3];
        } }, { key: "getTables", value: function() {
          return Object.values(this.tables);
        } }, { key: "addConditionalFormatting", value: function(t3) {
          this.conditionalFormattings.push(t3);
        } }, { key: "removeConditionalFormatting", value: function(t3) {
          typeof t3 == "number" ? this.conditionalFormattings.splice(t3, 1) : this.conditionalFormattings = t3 instanceof Function ? this.conditionalFormattings.filter(t3) : [];
        } }, { key: "_parseRows", value: function(t3) {
          var e3 = this;
          this._rows = [], t3.rows.forEach(function(t4) {
            var r3 = new h(e3, t4.number);
            e3._rows[r3.number - 1] = r3, r3.model = t4;
          });
        } }, { key: "_parseMergeCells", value: function(t3) {
          var e3 = this;
          c.each(t3.mergeCells, function(t4) {
            e3.mergeCellsWithoutStyle(t4);
          });
        } }, { key: "workbook", get: function() {
          return this._workbook;
        } }, { key: "dimensions", get: function() {
          var t3 = new l();
          return this._rows.forEach(function(e3) {
            if (e3) {
              var r3 = e3.dimensions;
              r3 && t3.expand(e3.number, r3.min, e3.number, r3.max);
            }
          }), t3;
        } }, { key: "columns", get: function() {
          return this._columns;
        }, set: function(t3) {
          var e3 = this;
          this._headerRowCount = t3.reduce(function(t4, e4) {
            var r4 = (e4.header ? 1 : e4.headers && e4.headers.length) || 0;
            return Math.max(t4, r4);
          }, 0);
          var r3 = 1, n3 = this._columns = [];
          t3.forEach(function(t4) {
            var i2 = new d(e3, r3++, false);
            n3.push(i2), i2.defn = t4;
          });
        } }, { key: "lastColumn", get: function() {
          return this.getColumn(this.columnCount);
        } }, { key: "columnCount", get: function() {
          var t3 = 0;
          return this.eachRow(function(e3) {
            t3 = Math.max(t3, e3.cellCount);
          }), t3;
        } }, { key: "actualColumnCount", get: function() {
          var t3 = [], e3 = 0;
          return this.eachRow(function(r3) {
            r3.eachCell(function(r4) {
              var n3 = r4.col;
              t3[n3] || (t3[n3] = true, e3++);
            });
          }), e3;
        } }, { key: "_lastRowNumber", get: function() {
          for (var t3 = this._rows, e3 = t3.length; e3 > 0 && t3[e3 - 1] === void 0; )
            e3--;
          return e3;
        } }, { key: "_nextRow", get: function() {
          return this._lastRowNumber + 1;
        } }, { key: "lastRow", get: function() {
          if (this._rows.length)
            return this._rows[this._rows.length - 1];
        } }, { key: "rowCount", get: function() {
          return this._lastRowNumber;
        } }, { key: "actualRowCount", get: function() {
          var t3 = 0;
          return this.eachRow(function() {
            t3++;
          }), t3;
        } }, { key: "hasMerges", get: function() {
          return c.some(this._merges, Boolean);
        } }, { key: "tabColor", get: function() {
          return console.trace("worksheet.tabColor property is now deprecated. Please use worksheet.properties.tabColor"), this.properties.tabColor;
        }, set: function(t3) {
          console.trace("worksheet.tabColor property is now deprecated. Please use worksheet.properties.tabColor"), this.properties.tabColor = t3;
        } }, { key: "model", get: function() {
          var t3 = { id: this.id, name: this.name, dataValidations: this.dataValidations.model, properties: this.properties, state: this.state, pageSetup: this.pageSetup, headerFooter: this.headerFooter, rowBreaks: this.rowBreaks, views: this.views, autoFilter: this.autoFilter, media: this._media.map(function(t4) {
            return t4.model;
          }), sheetProtection: this.sheetProtection, tables: Object.values(this.tables).map(function(t4) {
            return t4.model;
          }), conditionalFormattings: this.conditionalFormattings };
          t3.cols = d.toModel(this.columns);
          var e3 = t3.rows = [], r3 = t3.dimensions = new l();
          return this._rows.forEach(function(t4) {
            var n3 = t4 && t4.model;
            n3 && (r3.expand(n3.number, n3.min, n3.number, n3.max), e3.push(n3));
          }), t3.merges = [], c.each(this._merges, function(e4) {
            t3.merges.push(e4.range);
          }), t3;
        }, set: function(t3) {
          var e3 = this;
          this.name = t3.name, this._columns = d.fromModel(this, t3.cols), this._parseRows(t3), this._parseMergeCells(t3), this.dataValidations = new b(t3.dataValidations), this.properties = t3.properties, this.pageSetup = t3.pageSetup, this.headerFooter = t3.headerFooter, this.views = t3.views, this.autoFilter = t3.autoFilter, this._media = t3.media.map(function(t4) {
            return new m(e3, t4);
          }), this.sheetProtection = t3.sheetProtection, this.tables = t3.tables.reduce(function(t4, e4) {
            var r3 = new y();
            return r3.model = e4, t4[e4.name] = r3, t4;
          }, {}), this.conditionalFormattings = t3.conditionalFormattings;
        } }]) && u(e2.prototype, r2), t2;
      }();
      e.exports = g;
    }, { "../utils/col-cache": 19, "../utils/encryptor": 20, "../utils/under-dash": 25, "./column": 4, "./data-validations": 5, "./enums": 7, "./image": 8, "./range": 10, "./row": 11, "./table": 12 }], 15: [function(t, e, r) {
      t("core-js/modules/es.promise"), t("core-js/modules/es.object.assign"), t("core-js/modules/es.object.keys"), t("core-js/modules/es.object.values"), t("core-js/modules/es.symbol"), t("core-js/modules/es.symbol.async-iterator"), t("core-js/modules/es.array.iterator"), t("core-js/modules/es.array.includes"), t("core-js/modules/es.array.find-index"), t("core-js/modules/es.array.find"), t("core-js/modules/es.string.from-code-point"), t("core-js/modules/es.string.includes"), t("core-js/modules/es.number.is-nan"), t("regenerator-runtime/runtime");
      var n = { Workbook: t("./doc/workbook") }, i = t("./doc/enums");
      Object.keys(i).forEach(function(t2) {
        n[t2] = i[t2];
      }), e.exports = n;
    }, { "./doc/enums": 7, "./doc/workbook": 13, "core-js/modules/es.array.find": 316, "core-js/modules/es.array.find-index": 315, "core-js/modules/es.array.includes": 317, "core-js/modules/es.array.iterator": 318, "core-js/modules/es.number.is-nan": 319, "core-js/modules/es.object.assign": 320, "core-js/modules/es.object.keys": 321, "core-js/modules/es.object.values": 322, "core-js/modules/es.promise": 323, "core-js/modules/es.string.from-code-point": 324, "core-js/modules/es.string.includes": 325, "core-js/modules/es.symbol": 327, "core-js/modules/es.symbol.async-iterator": 326, "regenerator-runtime/runtime": 492 }], 16: [function(t, e, r) {
      var n = typeof TextDecoder == "undefined" ? null : new TextDecoder("utf-8");
      r.bufferToString = function(t2) {
        return typeof t2 == "string" ? t2 : n ? n.decode(t2) : t2.toString();
      };
    }, {}], 17: [function(t, e, r) {
      var n = typeof TextEncoder == "undefined" ? null : new TextEncoder("utf-8"), i = t("buffer").Buffer;
      r.stringToBuffer = function(t2) {
        return typeof t2 != "string" ? t2 : n ? i.from(n.encode(t2).buffer) : i.from(t2);
      };
    }, { buffer: 216 }], 18: [function(t, e, r) {
      function n(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      var i = t("./under-dash"), o = t("./col-cache"), a = function() {
        function t2(e3) {
          !function(t3, e4) {
            if (!(t3 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, t2), this.template = e3, this.sheets = {};
        }
        var e2, r2;
        return e2 = t2, (r2 = [{ key: "addCell", value: function(t3) {
          this.addCellEx(o.decodeEx(t3));
        } }, { key: "getCell", value: function(t3) {
          return this.findCellEx(o.decodeEx(t3), true);
        } }, { key: "findCell", value: function(t3) {
          return this.findCellEx(o.decodeEx(t3), false);
        } }, { key: "findCellAt", value: function(t3, e3, r3) {
          var n2 = this.sheets[t3], i2 = n2 && n2[e3];
          return i2 && i2[r3];
        } }, { key: "addCellEx", value: function(t3) {
          if (t3.top)
            for (var e3 = t3.top; e3 <= t3.bottom; e3++)
              for (var r3 = t3.left; r3 <= t3.right; r3++)
                this.getCellAt(t3.sheetName, e3, r3);
          else
            this.findCellEx(t3, true);
        } }, { key: "getCellEx", value: function(t3) {
          return this.findCellEx(t3, true);
        } }, { key: "findCellEx", value: function(t3, e3) {
          var r3 = this.findSheet(t3, e3), n2 = this.findSheetRow(r3, t3, e3);
          return this.findRowCell(n2, t3, e3);
        } }, { key: "getCellAt", value: function(t3, e3, r3) {
          var n2 = this.sheets[t3] || (this.sheets[t3] = []), i2 = n2[e3] || (n2[e3] = []);
          return i2[r3] || (i2[r3] = { sheetName: t3, address: o.n2l(r3) + e3, row: e3, col: r3 });
        } }, { key: "removeCellEx", value: function(t3) {
          var e3 = this.findSheet(t3);
          if (e3) {
            var r3 = this.findSheetRow(e3, t3);
            r3 && delete r3[t3.col];
          }
        } }, { key: "forEachInSheet", value: function(t3, e3) {
          var r3 = this.sheets[t3];
          r3 && r3.forEach(function(t4, r4) {
            t4 && t4.forEach(function(t5, n2) {
              t5 && e3(t5, r4, n2);
            });
          });
        } }, { key: "forEach", value: function(t3) {
          var e3 = this;
          i.each(this.sheets, function(r3, n2) {
            e3.forEachInSheet(n2, t3);
          });
        } }, { key: "map", value: function(t3) {
          var e3 = [];
          return this.forEach(function(r3) {
            e3.push(t3(r3));
          }), e3;
        } }, { key: "findSheet", value: function(t3, e3) {
          var r3 = t3.sheetName;
          return this.sheets[r3] ? this.sheets[r3] : e3 ? this.sheets[r3] = [] : void 0;
        } }, { key: "findSheetRow", value: function(t3, e3, r3) {
          var n2 = e3.row;
          return t3 && t3[n2] ? t3[n2] : r3 ? t3[n2] = [] : void 0;
        } }, { key: "findRowCell", value: function(t3, e3, r3) {
          var n2 = e3.col;
          return t3 && t3[n2] ? t3[n2] : r3 ? t3[n2] = this.template ? Object.assign(e3, JSON.parse(JSON.stringify(this.template))) : e3 : void 0;
        } }, { key: "spliceRows", value: function(t3, e3, r3, n2) {
          var i2 = this.sheets[t3];
          if (i2) {
            for (var o2 = [], a3 = 0; a3 < n2; a3++)
              o2.push([]);
            i2.splice.apply(i2, [e3, r3].concat(o2));
          }
        } }, { key: "spliceColumns", value: function(t3, e3, r3, n2) {
          var o2 = this.sheets[t3];
          if (o2) {
            for (var a3 = [], s = 0; s < n2; s++)
              a3.push(null);
            i.each(o2, function(t4) {
              t4.splice.apply(t4, [e3, r3].concat(a3));
            });
          }
        } }]) && n(e2.prototype, r2), t2;
      }();
      e.exports = a;
    }, { "./col-cache": 19, "./under-dash": 25 }], 19: [function(t, e, r) {
      function n(t2, e2) {
        return function(t3) {
          if (Array.isArray(t3))
            return t3;
        }(t2) || function(t3, e3) {
          if (typeof Symbol == "undefined" || !(Symbol.iterator in Object(t3)))
            return;
          var r2 = [], n2 = true, i2 = false, o2 = void 0;
          try {
            for (var a2, s2 = t3[Symbol.iterator](); !(n2 = (a2 = s2.next()).done) && (r2.push(a2.value), !e3 || r2.length !== e3); n2 = true)
              ;
          } catch (t4) {
            i2 = true, o2 = t4;
          } finally {
            try {
              n2 || s2.return == null || s2.return();
            } finally {
              if (i2)
                throw o2;
            }
          }
          return r2;
        }(t2, e2) || function(t3, e3) {
          if (!t3)
            return;
          if (typeof t3 == "string")
            return i(t3, e3);
          var r2 = Object.prototype.toString.call(t3).slice(8, -1);
          r2 === "Object" && t3.constructor && (r2 = t3.constructor.name);
          if (r2 === "Map" || r2 === "Set")
            return Array.from(t3);
          if (r2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
            return i(t3, e3);
        }(t2, e2) || function() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function i(t2, e2) {
        (e2 == null || e2 > t2.length) && (e2 = t2.length);
        for (var r2 = 0, n2 = new Array(e2); r2 < e2; r2++)
          n2[r2] = t2[r2];
        return n2;
      }
      function o(t2, e2) {
        var r2 = Object.keys(t2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t2);
          e2 && (n2 = n2.filter(function(e3) {
            return Object.getOwnPropertyDescriptor(t2, e3).enumerable;
          })), r2.push.apply(r2, n2);
        }
        return r2;
      }
      function a(t2, e2, r2) {
        return e2 in t2 ? Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }) : t2[e2] = r2, t2;
      }
      var s = /^[A-Z]+\d+$/, u = { _dictionary: ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"], _l2nFill: 0, _l2n: {}, _n2l: [], _level: function(t2) {
        return t2 <= 26 ? 1 : t2 <= 676 ? 2 : 3;
      }, _fill: function(t2) {
        var e2, r2, n2, i2, o2, a2 = 1;
        if (t2 >= 4)
          throw new Error("Out of bounds. Excel supports columns from 1 to 16384");
        if (this._l2nFill < 1 && t2 >= 1) {
          for (; a2 <= 26; )
            e2 = this._dictionary[a2 - 1], this._n2l[a2] = e2, this._l2n[e2] = a2, a2++;
          this._l2nFill = 1;
        }
        if (this._l2nFill < 2 && t2 >= 2) {
          for (a2 = 27; a2 <= 702; )
            n2 = (r2 = a2 - 27) % 26, i2 = Math.floor(r2 / 26), e2 = this._dictionary[i2] + this._dictionary[n2], this._n2l[a2] = e2, this._l2n[e2] = a2, a2++;
          this._l2nFill = 2;
        }
        if (this._l2nFill < 3 && t2 >= 3) {
          for (a2 = 703; a2 <= 16384; )
            n2 = (r2 = a2 - 703) % 26, i2 = Math.floor(r2 / 26) % 26, o2 = Math.floor(r2 / 676), e2 = this._dictionary[o2] + this._dictionary[i2] + this._dictionary[n2], this._n2l[a2] = e2, this._l2n[e2] = a2, a2++;
          this._l2nFill = 3;
        }
      }, l2n: function(t2) {
        if (this._l2n[t2] || this._fill(t2.length), !this._l2n[t2])
          throw new Error("Out of bounds. Invalid column letter: ".concat(t2));
        return this._l2n[t2];
      }, n2l: function(t2) {
        if (t2 < 1 || t2 > 16384)
          throw new Error("".concat(t2, " is out of bounds. Excel supports columns from 1 to 16384"));
        return this._n2l[t2] || this._fill(this._level(t2)), this._n2l[t2];
      }, _hash: {}, validateAddress: function(t2) {
        if (!s.test(t2))
          throw new Error("Invalid Address: ".concat(t2));
        return true;
      }, decodeAddress: function(t2) {
        var e2 = t2.length < 5 && this._hash[t2];
        if (e2)
          return e2;
        for (var r2, n2 = false, i2 = "", o2 = 0, a2 = false, s2 = "", u2 = 0, c = 0; c < t2.length; c++)
          if (r2 = t2.charCodeAt(c), !a2 && r2 >= 65 && r2 <= 90)
            n2 = true, i2 += t2[c], o2 = 26 * o2 + r2 - 64;
          else if (r2 >= 48 && r2 <= 57)
            a2 = true, s2 += t2[c], u2 = 10 * u2 + r2 - 48;
          else if (a2 && n2 && r2 !== 36)
            break;
        if (n2) {
          if (o2 > 16384)
            throw new Error("Out of bounds. Invalid column letter: ".concat(i2));
        } else
          o2 = void 0;
        a2 || (u2 = void 0);
        var f = { address: t2 = i2 + s2, col: o2, row: u2, $col$row: "$".concat(i2, "$").concat(s2) };
        return o2 <= 100 && u2 <= 100 && (this._hash[t2] = f, this._hash[f.$col$row] = f), f;
      }, getAddress: function(t2, e2) {
        if (e2) {
          var r2 = this.n2l(e2) + t2;
          return this.decodeAddress(r2);
        }
        return this.decodeAddress(t2);
      }, decode: function(t2) {
        var e2 = t2.split(":");
        if (e2.length === 2) {
          var r2 = this.decodeAddress(e2[0]), n2 = this.decodeAddress(e2[1]), i2 = { top: Math.min(r2.row, n2.row), left: Math.min(r2.col, n2.col), bottom: Math.max(r2.row, n2.row), right: Math.max(r2.col, n2.col) };
          return i2.tl = this.n2l(i2.left) + i2.top, i2.br = this.n2l(i2.right) + i2.bottom, i2.dimensions = "".concat(i2.tl, ":").concat(i2.br), i2;
        }
        return this.decodeAddress(t2);
      }, decodeEx: function(t2) {
        var e2 = t2.match(/(?:(?:(?:'((?:[^']|'')*)')|([^'^ !]*))!)?(.*)/), r2 = e2[1] || e2[2], n2 = e2[3], i2 = n2.split(":");
        if (i2.length > 1) {
          var s2 = this.decodeAddress(i2[0]), u2 = this.decodeAddress(i2[1]), c = Math.min(s2.row, u2.row), f = Math.min(s2.col, u2.col), l = Math.max(s2.row, u2.row), h = Math.max(s2.col, u2.col);
          return s2 = this.n2l(f) + c, u2 = this.n2l(h) + l, { top: c, left: f, bottom: l, right: h, sheetName: r2, tl: { address: s2, col: f, row: c, $col$row: "$".concat(this.n2l(f), "$").concat(c), sheetName: r2 }, br: { address: u2, col: h, row: l, $col$row: "$".concat(this.n2l(h), "$").concat(l), sheetName: r2 }, dimensions: "".concat(s2, ":").concat(u2) };
        }
        if (n2.startsWith("#"))
          return r2 ? { sheetName: r2, error: n2 } : { error: n2 };
        var d = this.decodeAddress(n2);
        return r2 ? function(t3) {
          for (var e3 = 1; e3 < arguments.length; e3++) {
            var r3 = arguments[e3] != null ? arguments[e3] : {};
            e3 % 2 ? o(Object(r3), true).forEach(function(e4) {
              a(t3, e4, r3[e4]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t3, Object.getOwnPropertyDescriptors(r3)) : o(Object(r3)).forEach(function(e4) {
              Object.defineProperty(t3, e4, Object.getOwnPropertyDescriptor(r3, e4));
            });
          }
          return t3;
        }({ sheetName: r2 }, d) : d;
      }, encodeAddress: function(t2, e2) {
        return u.n2l(e2) + t2;
      }, encode: function() {
        switch (arguments.length) {
          case 2:
            return u.encodeAddress(arguments[0], arguments[1]);
          case 4:
            return "".concat(u.encodeAddress(arguments[0], arguments[1]), ":").concat(u.encodeAddress(arguments[2], arguments[3]));
          default:
            throw new Error("Can only encode with 2 or 4 arguments");
        }
      }, inRange: function(t2, e2) {
        var r2 = n(t2, 5), i2 = r2[0], o2 = r2[1], a2 = r2[3], s2 = r2[4], u2 = n(e2, 2), c = u2[0], f = u2[1];
        return c >= i2 && c <= a2 && f >= o2 && f <= s2;
      } };
      e.exports = u;
    }, {}], 20: [function(t, e, r) {
      (function(r2) {
        var n = t("crypto"), i = { hash: function(t2) {
          for (var e2 = n.createHash(t2), i2 = arguments.length, o = new Array(i2 > 1 ? i2 - 1 : 0), a = 1; a < i2; a++)
            o[a - 1] = arguments[a];
          return e2.update(r2.concat(o)), e2.digest();
        }, convertPasswordToHash: function(t2, e2, i2, o) {
          if (e2 = e2.toLowerCase(), n.getHashes().indexOf(e2) < 0)
            throw new Error("Hash algorithm '".concat(e2, "' not supported!"));
          for (var a = r2.from(t2, "utf16le"), s = this.hash(e2, r2.from(i2, "base64"), a), u = 0; u < o; u++) {
            var c = r2.alloc(4);
            c.writeUInt32LE(u, 0), s = this.hash(e2, s, c);
          }
          return s.toString("base64");
        }, randomBytes: function(t2) {
          return n.randomBytes(t2);
        } };
        e.exports = i;
      }).call(this, t("buffer").Buffer);
    }, { buffer: 216, crypto: 335 }], 21: [function(t, e, r) {
      function n(t2) {
        return new o(t2);
      }
      function i(t2) {
        var e2, r2;
        function n2(e3, r3) {
          try {
            var a2 = t2[e3](r3), s2 = a2.value, u2 = s2 instanceof o;
            Promise.resolve(u2 ? s2.wrapped : s2).then(function(t3) {
              u2 ? n2(e3 === "return" ? "return" : "next", t3) : i2(a2.done ? "return" : "normal", t3);
            }, function(t3) {
              n2("throw", t3);
            });
          } catch (t3) {
            i2("throw", t3);
          }
        }
        function i2(t3, i3) {
          switch (t3) {
            case "return":
              e2.resolve({ value: i3, done: true });
              break;
            case "throw":
              e2.reject(i3);
              break;
            default:
              e2.resolve({ value: i3, done: false });
          }
          (e2 = e2.next) ? n2(e2.key, e2.arg) : r2 = null;
        }
        this._invoke = function(t3, i3) {
          return new Promise(function(o2, a2) {
            var s2 = { key: t3, arg: i3, resolve: o2, reject: a2, next: null };
            r2 ? r2 = r2.next = s2 : (e2 = r2 = s2, n2(t3, i3));
          });
        }, typeof t2.return != "function" && (this.return = void 0);
      }
      function o(t2) {
        this.wrapped = t2;
      }
      function a(t2) {
        var e2;
        if (typeof Symbol != "undefined") {
          if (Symbol.asyncIterator && (e2 = t2[Symbol.asyncIterator]) != null)
            return e2.call(t2);
          if (Symbol.iterator && (e2 = t2[Symbol.iterator]) != null)
            return e2.call(t2);
        }
        throw new TypeError("Object is not async iterable");
      }
      typeof Symbol == "function" && Symbol.asyncIterator && (i.prototype[Symbol.asyncIterator] = function() {
        return this;
      }), i.prototype.next = function(t2) {
        return this._invoke("next", t2);
      }, i.prototype.throw = function(t2) {
        return this._invoke("throw", t2);
      }, i.prototype.return = function(t2) {
        return this._invoke("return", t2);
      };
      var s = t("saxes").SaxesParser, u = t("readable-stream").PassThrough, c = t("./browser-buffer-decode").bufferToString;
      e.exports = function() {
        var t2, e2 = (t2 = regeneratorRuntime.mark(function t3(e3) {
          var r2, i2, o2, f, l, h, d, p, m, y;
          return regeneratorRuntime.wrap(function(t4) {
            for (; ; )
              switch (t4.prev = t4.next) {
                case 0:
                  e3.pipe && !e3[Symbol.asyncIterator] && (e3 = e3.pipe(new u())), (r2 = new s()).on("error", function(t5) {
                    i2 = t5;
                  }), o2 = [], r2.on("opentag", function(t5) {
                    return o2.push({ eventType: "opentag", value: t5 });
                  }), r2.on("text", function(t5) {
                    return o2.push({ eventType: "text", value: t5 });
                  }), r2.on("closetag", function(t5) {
                    return o2.push({ eventType: "closetag", value: t5 });
                  }), f = true, l = false, t4.prev = 9, d = a(e3);
                case 11:
                  return t4.next = 13, n(d.next());
                case 13:
                  return p = t4.sent, f = p.done, t4.next = 17, n(p.value);
                case 17:
                  if (m = t4.sent, f) {
                    t4.next = 29;
                    break;
                  }
                  if (y = m, r2.write(c(y)), !i2) {
                    t4.next = 23;
                    break;
                  }
                  throw i2;
                case 23:
                  return t4.next = 25, o2;
                case 25:
                  o2 = [];
                case 26:
                  f = true, t4.next = 11;
                  break;
                case 29:
                  t4.next = 35;
                  break;
                case 31:
                  t4.prev = 31, t4.t0 = t4.catch(9), l = true, h = t4.t0;
                case 35:
                  if (t4.prev = 35, t4.prev = 36, f || d.return == null) {
                    t4.next = 40;
                    break;
                  }
                  return t4.next = 40, n(d.return());
                case 40:
                  if (t4.prev = 40, !l) {
                    t4.next = 43;
                    break;
                  }
                  throw h;
                case 43:
                  return t4.finish(40);
                case 44:
                  return t4.finish(35);
                case 45:
                case "end":
                  return t4.stop();
              }
          }, t3, null, [[9, 31, 35, 45], [36, , 40, 44]]);
        }), function() {
          return new i(t2.apply(this, arguments));
        });
        return function(t3) {
          return e2.apply(this, arguments);
        };
      }();
    }, { "./browser-buffer-decode": 16, "readable-stream": 491, saxes: 496 }], 22: [function(t, e, r) {
      var n = t("./col-cache"), i = /(([a-z_\-0-9]*)!)?([a-z0-9_$]{2,})([(])?/gi, o = /^([$])?([a-z]+)([$])?([1-9][0-9]*)$/i;
      e.exports = { slideFormula: function(t2, e2, r2) {
        var a = n.decode(e2), s = n.decode(r2);
        return t2.replace(i, function(t3, e3, r3, i2, u) {
          if (u)
            return t3;
          var c = o.exec(i2);
          if (c) {
            var f = c[1], l = c[2].toUpperCase(), h = c[3], d = c[4];
            if (l.length > 3 || l.length === 3 && l > "XFD")
              return t3;
            var p = n.l2n(l), m = parseInt(d, 10);
            return f || (p += s.col - a.col), h || (m += s.row - a.row), (e3 || "") + (f || "") + n.n2l(p) + (h || "") + m;
          }
          return t3;
        });
      } };
    }, { "./col-cache": 19 }], 23: [function(t, e, r) {
      (function(r2, n) {
        function i(t2, e2, r3, n2, i2, o2, a2) {
          try {
            var s2 = t2[o2](a2), u2 = s2.value;
          } catch (t3) {
            return void r3(t3);
          }
          s2.done ? e2(u2) : Promise.resolve(u2).then(n2, i2);
        }
        function o(t2) {
          return function() {
            var e2 = this, r3 = arguments;
            return new Promise(function(n2, o2) {
              var a2 = t2.apply(e2, r3);
              function s2(t3) {
                i(a2, n2, o2, s2, u2, "next", t3);
              }
              function u2(t3) {
                i(a2, n2, o2, s2, u2, "throw", t3);
              }
              s2(void 0);
            });
          };
        }
        function a(t2, e2) {
          if (!(t2 instanceof e2))
            throw new TypeError("Cannot call a class as a function");
        }
        function s(t2, e2) {
          for (var r3 = 0; r3 < e2.length; r3++) {
            var n2 = e2[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
          }
        }
        function u(t2, e2, r3) {
          return e2 && s(t2.prototype, e2), r3 && s(t2, r3), t2;
        }
        var c = t("readable-stream"), f = t("./utils"), l = t("./string-buf"), h = function() {
          function t2(e2, r3) {
            a(this, t2), this._data = e2, this._encoding = r3;
          }
          return u(t2, [{ key: "copy", value: function(t3, e2, r3, n2) {
            return this.toBuffer().copy(t3, e2, r3, n2);
          } }, { key: "toBuffer", value: function() {
            return this._buffer || (this._buffer = n.from(this._data, this._encoding)), this._buffer;
          } }, { key: "length", get: function() {
            return this.toBuffer().length;
          } }]), t2;
        }(), d = function() {
          function t2(e2) {
            a(this, t2), this._data = e2;
          }
          return u(t2, [{ key: "copy", value: function(t3, e2, r3, n2) {
            return this._data._buf.copy(t3, e2, r3, n2);
          } }, { key: "toBuffer", value: function() {
            return this._data.toBuffer();
          } }, { key: "length", get: function() {
            return this._data.length;
          } }]), t2;
        }(), p = function() {
          function t2(e2) {
            a(this, t2), this._data = e2;
          }
          return u(t2, [{ key: "copy", value: function(t3, e2, r3, n2) {
            this._data.copy(t3, e2, r3, n2);
          } }, { key: "toBuffer", value: function() {
            return this._data;
          } }, { key: "length", get: function() {
            return this._data.length;
          } }]), t2;
        }(), m = function() {
          function t2(e2) {
            a(this, t2), this.size = e2, this.buffer = n.alloc(e2), this.iRead = 0, this.iWrite = 0;
          }
          return u(t2, [{ key: "toBuffer", value: function() {
            if (this.iRead === 0 && this.iWrite === this.size)
              return this.buffer;
            var t3 = n.alloc(this.iWrite - this.iRead);
            return this.buffer.copy(t3, 0, this.iRead, this.iWrite), t3;
          } }, { key: "read", value: function(t3) {
            var e2;
            return t3 === 0 ? null : t3 === void 0 || t3 >= this.length ? (e2 = this.toBuffer(), this.iRead = this.iWrite, e2) : (e2 = n.alloc(t3), this.buffer.copy(e2, 0, this.iRead, t3), this.iRead += t3, e2);
          } }, { key: "write", value: function(t3, e2, r3) {
            var n2 = Math.min(r3, this.size - this.iWrite);
            return t3.copy(this.buffer, this.iWrite, e2, e2 + n2), this.iWrite += n2, n2;
          } }, { key: "length", get: function() {
            return this.iWrite - this.iRead;
          } }, { key: "eod", get: function() {
            return this.iRead === this.iWrite;
          } }, { key: "full", get: function() {
            return this.iWrite === this.size;
          } }]), t2;
        }(), y = function(t2) {
          t2 = t2 || {}, this.bufSize = t2.bufSize || 1048576, this.buffers = [], this.batch = t2.batch || false, this.corked = false, this.inPos = 0, this.outPos = 0, this.pipes = [], this.paused = false, this.encoding = null;
        };
        f.inherits(y, c.Duplex, { toBuffer: function() {
          switch (this.buffers.length) {
            case 0:
              return null;
            case 1:
              return this.buffers[0].toBuffer();
            default:
              return n.concat(this.buffers.map(function(t2) {
                return t2.toBuffer();
              }));
          }
        }, _getWritableBuffer: function() {
          if (this.buffers.length) {
            var t2 = this.buffers[this.buffers.length - 1];
            if (!t2.full)
              return t2;
          }
          var e2 = new m(this.bufSize);
          return this.buffers.push(e2), e2;
        }, _pipe: function(t2) {
          var e2 = this;
          return o(regeneratorRuntime.mark(function r3() {
            var n2;
            return regeneratorRuntime.wrap(function(r4) {
              for (; ; )
                switch (r4.prev = r4.next) {
                  case 0:
                    return n2 = function(e3) {
                      return new Promise(function(r5) {
                        e3.write(t2.toBuffer(), function() {
                          r5();
                        });
                      });
                    }, r4.next = 3, Promise.all(e2.pipes.map(n2));
                  case 3:
                  case "end":
                    return r4.stop();
                }
            }, r3);
          }))();
        }, _writeToBuffers: function(t2) {
          for (var e2 = 0, r3 = t2.length; e2 < r3; ) {
            e2 += this._getWritableBuffer().write(t2, e2, r3 - e2);
          }
        }, write: function(t2, e2, i2) {
          var a2 = this;
          return o(regeneratorRuntime.mark(function o2() {
            var s2;
            return regeneratorRuntime.wrap(function(o3) {
              for (; ; )
                switch (o3.prev = o3.next) {
                  case 0:
                    if (e2 instanceof Function && (i2 = e2, e2 = "utf8"), i2 = i2 || f.nop, !(t2 instanceof l)) {
                      o3.next = 6;
                      break;
                    }
                    s2 = new d(t2), o3.next = 15;
                    break;
                  case 6:
                    if (!(t2 instanceof n)) {
                      o3.next = 10;
                      break;
                    }
                    s2 = new p(t2), o3.next = 15;
                    break;
                  case 10:
                    if (!(typeof t2 == "string" || t2 instanceof String || t2 instanceof ArrayBuffer)) {
                      o3.next = 14;
                      break;
                    }
                    s2 = new h(t2, e2), o3.next = 15;
                    break;
                  case 14:
                    throw new Error("Chunk must be one of type String, Buffer or StringBuf.");
                  case 15:
                    if (!a2.pipes.length) {
                      o3.next = 31;
                      break;
                    }
                    if (!a2.batch) {
                      o3.next = 21;
                      break;
                    }
                    for (a2._writeToBuffers(s2); !a2.corked && a2.buffers.length > 1; )
                      a2._pipe(a2.buffers.shift());
                    o3.next = 29;
                    break;
                  case 21:
                    if (a2.corked) {
                      o3.next = 27;
                      break;
                    }
                    return o3.next = 24, a2._pipe(s2);
                  case 24:
                    i2(), o3.next = 29;
                    break;
                  case 27:
                    a2._writeToBuffers(s2), r2.nextTick(i2);
                  case 29:
                    o3.next = 34;
                    break;
                  case 31:
                    a2.paused || a2.emit("data", s2.toBuffer()), a2._writeToBuffers(s2), a2.emit("readable");
                  case 34:
                    return o3.abrupt("return", true);
                  case 35:
                  case "end":
                    return o3.stop();
                }
            }, o2);
          }))();
        }, cork: function() {
          this.corked = true;
        }, _flush: function() {
          if (this.pipes.length)
            for (; this.buffers.length; )
              this._pipe(this.buffers.shift());
        }, uncork: function() {
          this.corked = false, this._flush();
        }, end: function(t2, e2, r3) {
          var n2 = this, i2 = function(t3) {
            t3 ? r3(t3) : (n2._flush(), n2.pipes.forEach(function(t4) {
              t4.end();
            }), n2.emit("finish"));
          };
          t2 ? this.write(t2, e2, i2) : i2();
        }, read: function(t2) {
          var e2;
          if (t2) {
            for (e2 = []; t2 && this.buffers.length && !this.buffers[0].eod; ) {
              var r3 = this.buffers[0], i2 = r3.read(t2);
              t2 -= i2.length, e2.push(i2), r3.eod && r3.full && this.buffers.shift();
            }
            return n.concat(e2);
          }
          return e2 = this.buffers.map(function(t3) {
            return t3.toBuffer();
          }).filter(Boolean), this.buffers = [], n.concat(e2);
        }, setEncoding: function(t2) {
          this.encoding = t2;
        }, pause: function() {
          this.paused = true;
        }, resume: function() {
          this.paused = false;
        }, isPaused: function() {
          return !!this.paused;
        }, pipe: function(t2) {
          this.pipes.push(t2), !this.paused && this.buffers.length && this.end();
        }, unpipe: function(t2) {
          this.pipes = this.pipes.filter(function(e2) {
            return e2 !== t2;
          });
        }, unshift: function() {
          throw new Error("Not Implemented");
        }, wrap: function() {
          throw new Error("Not Implemented");
        } }), e.exports = y;
      }).call(this, t("_process"), t("buffer").Buffer);
    }, { "./string-buf": 24, "./utils": 26, _process: 467, buffer: 216, "readable-stream": 491 }], 24: [function(t, e, r) {
      (function(t2) {
        function r2(t3, e2) {
          for (var r3 = 0; r3 < e2.length; r3++) {
            var n2 = e2[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, n2.key, n2);
          }
        }
        var n = function() {
          function e2(r3) {
            !function(t3, e3) {
              if (!(t3 instanceof e3))
                throw new TypeError("Cannot call a class as a function");
            }(this, e2), this._buf = t2.alloc(r3 && r3.size || 16384), this._encoding = r3 && r3.encoding || "utf8", this._inPos = 0, this._buffer = void 0;
          }
          var n2, i;
          return n2 = e2, (i = [{ key: "toBuffer", value: function() {
            return this._buffer || (this._buffer = t2.alloc(this.length), this._buf.copy(this._buffer, 0, 0, this.length)), this._buffer;
          } }, { key: "reset", value: function(t3) {
            t3 = t3 || 0, this._buffer = void 0, this._inPos = t3;
          } }, { key: "_grow", value: function(e3) {
            for (var r3 = 2 * this._buf.length; r3 < e3; )
              r3 *= 2;
            var n3 = t2.alloc(r3);
            this._buf.copy(n3, 0), this._buf = n3;
          } }, { key: "addText", value: function(t3) {
            this._buffer = void 0;
            for (var e3 = this._inPos + this._buf.write(t3, this._inPos, this._encoding); e3 >= this._buf.length - 4; )
              this._grow(this._inPos + t3.length), e3 = this._inPos + this._buf.write(t3, this._inPos, this._encoding);
            this._inPos = e3;
          } }, { key: "addStringBuf", value: function(t3) {
            t3.length && (this._buffer = void 0, this.length + t3.length > this.capacity && this._grow(this.length + t3.length), t3._buf.copy(this._buf, this._inPos, 0, t3.length), this._inPos += t3.length);
          } }, { key: "length", get: function() {
            return this._inPos;
          } }, { key: "capacity", get: function() {
            return this._buf.length;
          } }, { key: "buffer", get: function() {
            return this._buf;
          } }]) && r2(n2.prototype, i), e2;
        }();
        e.exports = n;
      }).call(this, t("buffer").Buffer);
    }, { buffer: 216 }], 25: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      var i = Object.prototype.toString, o = /["&<>]/, a = { each: function(t2, e2) {
        t2 && (Array.isArray(t2) ? t2.forEach(e2) : Object.keys(t2).forEach(function(r2) {
          e2(t2[r2], r2);
        }));
      }, some: function(t2, e2) {
        return !!t2 && (Array.isArray(t2) ? t2.some(e2) : Object.keys(t2).some(function(r2) {
          return e2(t2[r2], r2);
        }));
      }, every: function(t2, e2) {
        return !t2 || (Array.isArray(t2) ? t2.every(e2) : Object.keys(t2).every(function(r2) {
          return e2(t2[r2], r2);
        }));
      }, map: function(t2, e2) {
        return t2 ? Array.isArray(t2) ? t2.map(e2) : Object.keys(t2).map(function(r2) {
          return e2(t2[r2], r2);
        }) : [];
      }, keyBy: function(t2, e2) {
        return t2.reduce(function(t3, r2) {
          return t3[r2[e2]] = r2, t3;
        }, {});
      }, isEqual: function(t2, e2) {
        var r2 = n(t2), i2 = n(e2), o2 = Array.isArray(t2), s = Array.isArray(e2);
        if (r2 !== i2)
          return false;
        switch (n(t2)) {
          case "object":
            return o2 || s ? !(!o2 || !s) && (t2.length === e2.length && t2.every(function(t3, r3) {
              var n2 = e2[r3];
              return a.isEqual(t3, n2);
            })) : a.every(t2, function(t3, r3) {
              var n2 = e2[r3];
              return a.isEqual(t3, n2);
            });
          default:
            return t2 === e2;
        }
      }, escapeHtml: function(t2) {
        var e2 = o.exec(t2);
        if (!e2)
          return t2;
        for (var r2 = "", n2 = "", i2 = 0, a2 = e2.index; a2 < t2.length; a2++) {
          switch (t2.charAt(a2)) {
            case '"':
              n2 = "&quot;";
              break;
            case "&":
              n2 = "&amp;";
              break;
            case "'":
              n2 = "&apos;";
              break;
            case "<":
              n2 = "&lt;";
              break;
            case ">":
              n2 = "&gt;";
              break;
            default:
              continue;
          }
          i2 !== a2 && (r2 += t2.substring(i2, a2)), i2 = a2 + 1, r2 += n2;
        }
        return i2 !== a2 ? r2 + t2.substring(i2, a2) : r2;
      }, strcmp: function(t2, e2) {
        return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
      }, isUndefined: function(t2) {
        return i.call(t2) === "[object Undefined]";
      }, isObject: function(t2) {
        return i.call(t2) === "[object Object]";
      }, deepMerge: function() {
        var t2, e2, r2, n2 = arguments[0] || {}, i2 = arguments.length;
        function o2(i3, o3) {
          t2 = n2[o3], r2 = Array.isArray(i3), a.isObject(i3) || r2 ? (r2 ? (r2 = false, e2 = t2 && Array.isArray(t2) ? t2 : []) : e2 = t2 && a.isObject(t2) ? t2 : {}, n2[o3] = a.deepMerge(e2, i3)) : a.isUndefined(i3) || (n2[o3] = i3);
        }
        for (var s = 0; s < i2; s++)
          a.each(arguments[s], o2);
        return n2;
      } };
      e.exports = a;
    }, {}], 26: [function(t, e, r) {
      (function(r2, n) {
        var i = t("fs"), o = /[<>&'"\x7F\x00-\x08\x0B-\x0C\x0E-\x1F]/, a = { nop: function() {
        }, promiseImmediate: function(t2) {
          return new Promise(function(e2) {
            r2.setImmediate ? n(function() {
              e2(t2);
            }) : setTimeout(function() {
              e2(t2);
            }, 1);
          });
        }, inherits: function(t2, e2, r3, n2) {
          t2.super_ = e2, n2 || (n2 = r3, r3 = null), r3 && Object.keys(r3).forEach(function(e3) {
            Object.defineProperty(t2, e3, Object.getOwnPropertyDescriptor(r3, e3));
          });
          var i2 = { constructor: { value: t2, enumerable: false, writable: false, configurable: true } };
          n2 && Object.keys(n2).forEach(function(t3) {
            i2[t3] = Object.getOwnPropertyDescriptor(n2, t3);
          }), t2.prototype = Object.create(e2.prototype, i2);
        }, dateToExcel: function(t2, e2) {
          return 25569 + t2.getTime() / 864e5 - (e2 ? 1462 : 0);
        }, excelToDate: function(t2, e2) {
          var r3 = Math.round(24 * (t2 - 25569 + (e2 ? 1462 : 0)) * 3600 * 1e3);
          return new Date(r3);
        }, parsePath: function(t2) {
          var e2 = t2.lastIndexOf("/");
          return { path: t2.substring(0, e2), name: t2.substring(e2 + 1) };
        }, getRelsPath: function(t2) {
          var e2 = a.parsePath(t2);
          return "".concat(e2.path, "/_rels/").concat(e2.name, ".rels");
        }, xmlEncode: function(t2) {
          var e2 = o.exec(t2);
          if (!e2)
            return t2;
          for (var r3 = "", n2 = "", i2 = 0, a2 = e2.index; a2 < t2.length; a2++) {
            var s = t2.charCodeAt(a2);
            switch (s) {
              case 34:
                n2 = "&quot;";
                break;
              case 38:
                n2 = "&amp;";
                break;
              case 39:
                n2 = "&apos;";
                break;
              case 60:
                n2 = "&lt;";
                break;
              case 62:
                n2 = "&gt;";
                break;
              case 127:
                n2 = "";
                break;
              default:
                if (s <= 31 && (s <= 8 || s >= 11 && s !== 13)) {
                  n2 = "";
                  break;
                }
                continue;
            }
            i2 !== a2 && (r3 += t2.substring(i2, a2)), i2 = a2 + 1, n2 && (r3 += n2);
          }
          return i2 !== a2 ? r3 + t2.substring(i2, a2) : r3;
        }, xmlDecode: function(t2) {
          return t2.replace(/&([a-z]*);/g, function(t3) {
            switch (t3) {
              case "&lt;":
                return "<";
              case "&gt;":
                return ">";
              case "&amp;":
                return "&";
              case "&apos;":
                return "'";
              case "&quot;":
                return '"';
              default:
                return t3;
            }
          });
        }, validInt: function(t2) {
          var e2 = parseInt(t2, 10);
          return Number.isNaN(e2) ? 0 : e2;
        }, isDateFmt: function(t2) {
          return !!t2 && (t2 = (t2 = t2.replace(/\[[^\]]*]/g, "")).replace(/"[^"]*"/g, "")).match(/[ymdhMsb]+/) !== null;
        }, fs: { exists: function(t2) {
          return new Promise(function(e2) {
            i.access(t2, i.constants.F_OK, function(t3) {
              e2(!t3);
            });
          });
        } }, toIsoDateString: function(t2) {
          return t2.toIsoString().subsstr(0, 10);
        } };
        e.exports = a;
      }).call(this, typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {}, t("timers").setImmediate);
    }, { fs: 215, timers: 521 }], 27: [function(t, e, r) {
      function n(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      var i = t("./under-dash"), o = t("./utils");
      function a(t2, e2, r2) {
        t2.push(" "), t2.push(e2), t2.push('="'), t2.push(o.xmlEncode(r2.toString())), t2.push('"');
      }
      function s(t2, e2) {
        e2 && i.each(e2, function(e3, r2) {
          e3 !== void 0 && a(t2, r2, e3);
        });
      }
      var u = function() {
        function t2() {
          !function(t3, e3) {
            if (!(t3 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, t2), this._xml = [], this._stack = [], this._rollbacks = [];
        }
        var e2, r2;
        return e2 = t2, (r2 = [{ key: "openXml", value: function(t3) {
          var e3 = this._xml;
          e3.push("<?xml"), s(e3, t3), e3.push("?>\n");
        } }, { key: "openNode", value: function(t3, e3) {
          var r3 = this.tos, n2 = this._xml;
          r3 && this.open && n2.push(">"), this._stack.push(t3), n2.push("<"), n2.push(t3), s(n2, e3), this.leaf = true, this.open = true;
        } }, { key: "addAttribute", value: function(t3, e3) {
          if (!this.open)
            throw new Error("Cannot write attributes to node if it is not open");
          e3 !== void 0 && a(this._xml, t3, e3);
        } }, { key: "addAttributes", value: function(t3) {
          if (!this.open)
            throw new Error("Cannot write attributes to node if it is not open");
          s(this._xml, t3);
        } }, { key: "writeText", value: function(t3) {
          var e3 = this._xml;
          this.open && (e3.push(">"), this.open = false), this.leaf = false, e3.push(o.xmlEncode(t3.toString()));
        } }, { key: "writeXml", value: function(t3) {
          this.open && (this._xml.push(">"), this.open = false), this.leaf = false, this._xml.push(t3);
        } }, { key: "closeNode", value: function() {
          var t3 = this._stack.pop(), e3 = this._xml;
          this.leaf ? e3.push("/>") : (e3.push("</"), e3.push(t3), e3.push(">")), this.open = false, this.leaf = false;
        } }, { key: "leafNode", value: function(t3, e3, r3) {
          this.openNode(t3, e3), r3 !== void 0 && this.writeText(r3), this.closeNode();
        } }, { key: "closeAll", value: function() {
          for (; this._stack.length; )
            this.closeNode();
        } }, { key: "addRollback", value: function() {
          return this._rollbacks.push({ xml: this._xml.length, stack: this._stack.length, leaf: this.leaf, open: this.open }), this.cursor;
        } }, { key: "commit", value: function() {
          this._rollbacks.pop();
        } }, { key: "rollback", value: function() {
          var t3 = this._rollbacks.pop();
          this._xml.length > t3.xml && this._xml.splice(t3.xml, this._xml.length - t3.xml), this._stack.length > t3.stack && this._stack.splice(t3.stack, this._stack.length - t3.stack), this.leaf = t3.leaf, this.open = t3.open;
        } }, { key: "tos", get: function() {
          return this._stack.length ? this._stack[this._stack.length - 1] : void 0;
        } }, { key: "cursor", get: function() {
          return this._xml.length;
        } }, { key: "xml", get: function() {
          return this.closeAll(), this._xml.join("");
        } }]) && n(e2.prototype, r2), t2;
      }();
      u.StdDocAttributes = { version: "1.0", encoding: "UTF-8", standalone: "yes" }, e.exports = u;
    }, { "./under-dash": 25, "./utils": 26 }], 28: [function(t, e, r) {
      (function(r2) {
        function n(t2) {
          return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
            return typeof t3;
          } : function(t3) {
            return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
          })(t2);
        }
        function i(t2, e2, r3, n2, i2, o2, a2) {
          try {
            var s2 = t2[o2](a2), u2 = s2.value;
          } catch (t3) {
            return void r3(t3);
          }
          s2.done ? e2(u2) : Promise.resolve(u2).then(n2, i2);
        }
        function o(t2, e2) {
          for (var r3 = 0; r3 < e2.length; r3++) {
            var n2 = e2[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
          }
        }
        function a(t2, e2) {
          return (a = Object.setPrototypeOf || function(t3, e3) {
            return t3.__proto__ = e3, t3;
          })(t2, e2);
        }
        function s(t2) {
          var e2 = function() {
            if (typeof Reflect == "undefined" || !Reflect.construct)
              return false;
            if (Reflect.construct.sham)
              return false;
            if (typeof Proxy == "function")
              return true;
            try {
              return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
              })), true;
            } catch (t3) {
              return false;
            }
          }();
          return function() {
            var r3, n2 = c(t2);
            if (e2) {
              var i2 = c(this).constructor;
              r3 = Reflect.construct(n2, arguments, i2);
            } else
              r3 = n2.apply(this, arguments);
            return u(this, r3);
          };
        }
        function u(t2, e2) {
          return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
            if (t3 === void 0)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t3;
          }(t2) : e2;
        }
        function c(t2) {
          return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
            return t3.__proto__ || Object.getPrototypeOf(t3);
          })(t2);
        }
        var f = t("events"), l = t("jszip"), h = t("./stream-buf"), d = t("./browser-buffer-encode").stringToBuffer, p = function(t2) {
          !function(t3, e3) {
            if (typeof e3 != "function" && e3 !== null)
              throw new TypeError("Super expression must either be null or a function");
            t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
          }(m, t2);
          var e2, n2, c2, f2, p2 = s(m);
          function m(t3) {
            var e3;
            return function(t4, e4) {
              if (!(t4 instanceof e4))
                throw new TypeError("Cannot call a class as a function");
            }(this, m), (e3 = p2.call(this)).options = Object.assign({ type: "nodebuffer", compression: "DEFLATE" }, t3), e3.zip = new l(), e3.stream = new h(), e3;
          }
          return e2 = m, (n2 = [{ key: "append", value: function(t3, e3) {
            e3.hasOwnProperty("base64") && e3.base64 ? this.zip.file(e3.name, t3, { base64: true }) : (r2.browser && typeof t3 == "string" && (t3 = d(t3)), this.zip.file(e3.name, t3));
          } }, { key: "finalize", value: (c2 = regeneratorRuntime.mark(function t3() {
            var e3;
            return regeneratorRuntime.wrap(function(t4) {
              for (; ; )
                switch (t4.prev = t4.next) {
                  case 0:
                    return t4.next = 2, this.zip.generateAsync(this.options);
                  case 2:
                    e3 = t4.sent, this.stream.end(e3), this.emit("finish");
                  case 5:
                  case "end":
                    return t4.stop();
                }
            }, t3, this);
          }), f2 = function() {
            var t3 = this, e3 = arguments;
            return new Promise(function(r3, n3) {
              var o2 = c2.apply(t3, e3);
              function a2(t4) {
                i(o2, r3, n3, a2, s2, "next", t4);
              }
              function s2(t4) {
                i(o2, r3, n3, a2, s2, "throw", t4);
              }
              a2(void 0);
            });
          }, function() {
            return f2.apply(this, arguments);
          }) }, { key: "read", value: function(t3) {
            return this.stream.read(t3);
          } }, { key: "setEncoding", value: function(t3) {
            return this.stream.setEncoding(t3);
          } }, { key: "pause", value: function() {
            return this.stream.pause();
          } }, { key: "resume", value: function() {
            return this.stream.resume();
          } }, { key: "isPaused", value: function() {
            return this.stream.isPaused();
          } }, { key: "pipe", value: function(t3, e3) {
            return this.stream.pipe(t3, e3);
          } }, { key: "unpipe", value: function(t3) {
            return this.stream.unpipe(t3);
          } }, { key: "unshift", value: function(t3) {
            return this.stream.unshift(t3);
          } }, { key: "wrap", value: function(t3) {
            return this.stream.wrap(t3);
          } }]) && o(e2.prototype, n2), m;
        }(f.EventEmitter);
        e.exports = { ZipWriter: p };
      }).call(this, t("_process"));
    }, { "./browser-buffer-encode": 17, "./stream-buf": 23, _process: 467, events: 367, jszip: 399 }], 29: [function(t, e, r) {
      e.exports = { 0: { f: "General" }, 1: { f: "0" }, 2: { f: "0.00" }, 3: { f: "#,##0" }, 4: { f: "#,##0.00" }, 9: { f: "0%" }, 10: { f: "0.00%" }, 11: { f: "0.00E+00" }, 12: { f: "# ?/?" }, 13: { f: "# ??/??" }, 14: { f: "mm-dd-yy" }, 15: { f: "d-mmm-yy" }, 16: { f: "d-mmm" }, 17: { f: "mmm-yy" }, 18: { f: "h:mm AM/PM" }, 19: { f: "h:mm:ss AM/PM" }, 20: { f: "h:mm" }, 21: { f: "h:mm:ss" }, 22: { f: 'm/d/yy "h":mm' }, 27: { "zh-tw": "[$-404]e/m/d", "zh-cn": 'yyyy"\u5E74"m"\u6708"', "ja-jp": "[$-411]ge.m.d", "ko-kr": 'yyyy"\u5E74" mm"\u6708" dd"\u65E5"' }, 28: { "zh-tw": '[$-404]e"\u5E74"m"\u6708"d"\u65E5"', "zh-cn": 'm"\u6708"d"\u65E5"', "ja-jp": '[$-411]ggge"\u5E74"m"\u6708"d"\u65E5"', "ko-kr": "mm-dd" }, 29: { "zh-tw": '[$-404]e"\u5E74"m"\u6708"d"\u65E5"', "zh-cn": 'm"\u6708"d"\u65E5"', "ja-jp": '[$-411]ggge"\u5E74"m"\u6708"d"\u65E5"', "ko-kr": "mm-dd" }, 30: { "zh-tw": "m/d/yy ", "zh-cn": "m-d-yy", "ja-jp": "m/d/yy", "ko-kr": "mm-dd-yy" }, 31: { "zh-tw": 'yyyy"\u5E74"m"\u6708"d"\u65E5"', "zh-cn": 'yyyy"\u5E74"m"\u6708"d"\u65E5"', "ja-jp": 'yyyy"\u5E74"m"\u6708"d"\u65E5"', "ko-kr": 'yyyy"\uB144" mm"\uC6D4" dd"\uC77C"' }, 32: { "zh-tw": 'hh"\u6642"mm"\u5206"', "zh-cn": 'h"\u65F6"mm"\u5206"', "ja-jp": 'h"\u6642"mm"\u5206"', "ko-kr": 'h"\uC2DC" mm"\uBD84"' }, 33: { "zh-tw": 'hh"\u6642"mm"\u5206"ss"\u79D2"', "zh-cn": 'h"\u65F6"mm"\u5206"ss"\u79D2"', "ja-jp": 'h"\u6642"mm"\u5206"ss"\u79D2"', "ko-kr": 'h"\uC2DC" mm"\uBD84" ss"\uCD08"' }, 34: { "zh-tw": '\u4E0A\u5348/\u4E0B\u5348 hh"\u6642"mm"\u5206"', "zh-cn": '\u4E0A\u5348/\u4E0B\u5348 h"\u65F6"mm"\u5206"', "ja-jp": 'yyyy"\u5E74"m"\u6708"', "ko-kr": "yyyy-mm-dd" }, 35: { "zh-tw": '\u4E0A\u5348/\u4E0B\u5348 hh"\u6642"mm"\u5206"ss"\u79D2"', "zh-cn": '\u4E0A\u5348/\u4E0B\u5348 h"\u65F6"mm"\u5206"ss"\u79D2"', "ja-jp": 'm"\u6708"d"\u65E5"', "ko-kr": "yyyy-mm-dd" }, 36: { "zh-tw": "[$-404]e/m/d", "zh-cn": 'yyyy"\u5E74"m"\u6708"', "ja-jp": "[$-411]ge.m.d", "ko-kr": 'yyyy"\u5E74" mm"\u6708" dd"\u65E5"' }, 37: { f: "#,##0 ;(#,##0)" }, 38: { f: "#,##0 ;[Red](#,##0)" }, 39: { f: "#,##0.00 ;(#,##0.00)" }, 40: { f: "#,##0.00 ;[Red](#,##0.00)" }, 45: { f: "mm:ss" }, 46: { f: "[h]:mm:ss" }, 47: { f: "mmss.0" }, 48: { f: "##0.0E+0" }, 49: { f: "@" }, 50: { "zh-tw": "[$-404]e/m/d", "zh-cn": 'yyyy"\u5E74"m"\u6708"', "ja-jp": "[$-411]ge.m.d", "ko-kr": 'yyyy"\u5E74" mm"\u6708" dd"\u65E5"' }, 51: { "zh-tw": '[$-404]e"\u5E74"m"\u6708"d"\u65E5"', "zh-cn": 'm"\u6708"d"\u65E5"', "ja-jp": '[$-411]ggge"\u5E74"m"\u6708"d"\u65E5"', "ko-kr": "mm-dd" }, 52: { "zh-tw": '\u4E0A\u5348/\u4E0B\u5348 hh"\u6642"mm"\u5206"', "zh-cn": 'yyyy"\u5E74"m"\u6708"', "ja-jp": 'yyyy"\u5E74"m"\u6708"', "ko-kr": "yyyy-mm-dd" }, 53: { "zh-tw": '\u4E0A\u5348/\u4E0B\u5348 hh"\u6642"mm"\u5206"ss"\u79D2"', "zh-cn": 'm"\u6708"d"\u65E5"', "ja-jp": 'm"\u6708"d"\u65E5"', "ko-kr": "yyyy-mm-dd" }, 54: { "zh-tw": '[$-404]e"\u5E74"m"\u6708"d"\u65E5"', "zh-cn": 'm"\u6708"d"\u65E5"', "ja-jp": '[$-411]ggge"\u5E74"m"\u6708"d"\u65E5"', "ko-kr": "mm-dd" }, 55: { "zh-tw": '\u4E0A\u5348/\u4E0B\u5348 hh"\u6642"mm"\u5206"', "zh-cn": '\u4E0A\u5348/\u4E0B\u5348 h"\u65F6"mm"\u5206"', "ja-jp": 'yyyy"\u5E74"m"\u6708"', "ko-kr": "yyyy-mm-dd" }, 56: { "zh-tw": '\u4E0A\u5348/\u4E0B\u5348 hh"\u6642"mm"\u5206"ss"\u79D2"', "zh-cn": '\u4E0A\u5348/\u4E0B\u5348 h"\u65F6"mm"\u5206"ss"\u79D2"', "ja-jp": 'm"\u6708"d"\u65E5"', "ko-kr": "yyyy-mm-dd" }, 57: { "zh-tw": "[$-404]e/m/d", "zh-cn": 'yyyy"\u5E74"m"\u6708"', "ja-jp": "[$-411]ge.m.d", "ko-kr": 'yyyy"\u5E74" mm"\u6708" dd"\u65E5"' }, 58: { "zh-tw": '[$-404]e"\u5E74"m"\u6708"d"\u65E5"', "zh-cn": 'm"\u6708"d"\u65E5"', "ja-jp": '[$-411]ggge"\u5E74"m"\u6708"d"\u65E5"', "ko-kr": "mm-dd" }, 59: { "th-th": "t0" }, 60: { "th-th": "t0.00" }, 61: { "th-th": "t#,##0" }, 62: { "th-th": "t#,##0.00" }, 67: { "th-th": "t0%" }, 68: { "th-th": "t0.00%" }, 69: { "th-th": "t# ?/?" }, 70: { "th-th": "t# ??/??" }, 81: { "th-th": "d/m/bb" } };
    }, {}], 30: [function(t, e, r) {
      e.exports = { OfficeDocument: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument", Worksheet: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet", CalcChain: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/calcChain", SharedStrings: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings", Styles: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles", Theme: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme", Hyperlink: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink", Image: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image", CoreProperties: "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties", ExtenderProperties: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties", Comments: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments", VmlDrawing: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing", Table: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/table" };
    }, {}], 31: [function(t, e, r) {
      function n(t2, e2) {
        var r2;
        if (typeof Symbol == "undefined" || t2[Symbol.iterator] == null) {
          if (Array.isArray(t2) || (r2 = function(t3, e3) {
            if (!t3)
              return;
            if (typeof t3 == "string")
              return i(t3, e3);
            var r3 = Object.prototype.toString.call(t3).slice(8, -1);
            r3 === "Object" && t3.constructor && (r3 = t3.constructor.name);
            if (r3 === "Map" || r3 === "Set")
              return Array.from(t3);
            if (r3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3))
              return i(t3, e3);
          }(t2)) || e2 && t2 && typeof t2.length == "number") {
            r2 && (t2 = r2);
            var n2 = 0, o2 = function() {
            };
            return { s: o2, n: function() {
              return n2 >= t2.length ? { done: true } : { done: false, value: t2[n2++] };
            }, e: function(t3) {
              throw t3;
            }, f: o2 };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var a2, s2 = true, u2 = false;
        return { s: function() {
          r2 = t2[Symbol.iterator]();
        }, n: function() {
          var t3 = r2.next();
          return s2 = t3.done, t3;
        }, e: function(t3) {
          u2 = true, a2 = t3;
        }, f: function() {
          try {
            s2 || r2.return == null || r2.return();
          } finally {
            if (u2)
              throw a2;
          }
        } };
      }
      function i(t2, e2) {
        (e2 == null || e2 > t2.length) && (e2 = t2.length);
        for (var r2 = 0, n2 = new Array(e2); r2 < e2; r2++)
          n2[r2] = t2[r2];
        return n2;
      }
      function o(t2, e2, r2, n2, i2, o2, a2) {
        try {
          var s2 = t2[o2](a2), u2 = s2.value;
        } catch (t3) {
          return void r2(t3);
        }
        s2.done ? e2(u2) : Promise.resolve(u2).then(n2, i2);
      }
      function a(t2) {
        return function() {
          var e2 = this, r2 = arguments;
          return new Promise(function(n2, i2) {
            var a2 = t2.apply(e2, r2);
            function s2(t3) {
              o(a2, n2, i2, s2, u2, "next", t3);
            }
            function u2(t3) {
              o(a2, n2, i2, s2, u2, "throw", t3);
            }
            s2(void 0);
          });
        };
      }
      function s(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function u(t2) {
        var e2;
        if (typeof Symbol != "undefined") {
          if (Symbol.asyncIterator && (e2 = t2[Symbol.asyncIterator]) != null)
            return e2.call(t2);
          if (Symbol.iterator && (e2 = t2[Symbol.iterator]) != null)
            return e2.call(t2);
        }
        throw new TypeError("Object is not async iterable");
      }
      var c = t("../../utils/parse-sax"), f = t("../../utils/xml-stream"), l = function() {
        function t2() {
          !function(t3, e3) {
            if (!(t3 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, t2);
        }
        var e2, r2, i2, o2, l2;
        return e2 = t2, r2 = [{ key: "prepare", value: function() {
        } }, { key: "render", value: function() {
        } }, { key: "parseOpen", value: function(t3) {
        } }, { key: "parseText", value: function(t3) {
        } }, { key: "parseClose", value: function(t3) {
        } }, { key: "reconcile", value: function(t3, e3) {
        } }, { key: "reset", value: function() {
          this.model = null, this.map && Object.values(this.map).forEach(function(e3) {
            e3 instanceof t2 ? e3.reset() : e3.xform && e3.xform.reset();
          });
        } }, { key: "mergeModel", value: function(t3) {
          this.model = Object.assign(this.model || {}, t3);
        } }, { key: "parse", value: (l2 = a(regeneratorRuntime.mark(function t3(e3) {
          var r3, i3, o3, a2, s2, c2, f2, l3, h, d, p;
          return regeneratorRuntime.wrap(function(t4) {
            for (; ; )
              switch (t4.prev = t4.next) {
                case 0:
                  r3 = true, i3 = false, t4.prev = 2, a2 = u(e3);
                case 4:
                  return t4.next = 6, a2.next();
                case 6:
                  return s2 = t4.sent, r3 = s2.done, t4.next = 10, s2.value;
                case 10:
                  if (c2 = t4.sent, r3) {
                    t4.next = 42;
                    break;
                  }
                  f2 = n(c2), t4.prev = 14, f2.s();
                case 16:
                  if ((l3 = f2.n()).done) {
                    t4.next = 31;
                    break;
                  }
                  if (h = l3.value, d = h.eventType, p = h.value, d !== "opentag") {
                    t4.next = 22;
                    break;
                  }
                  this.parseOpen(p), t4.next = 29;
                  break;
                case 22:
                  if (d !== "text") {
                    t4.next = 26;
                    break;
                  }
                  this.parseText(p), t4.next = 29;
                  break;
                case 26:
                  if (d !== "closetag") {
                    t4.next = 29;
                    break;
                  }
                  if (this.parseClose(p.name)) {
                    t4.next = 29;
                    break;
                  }
                  return t4.abrupt("return", this.model);
                case 29:
                  t4.next = 16;
                  break;
                case 31:
                  t4.next = 36;
                  break;
                case 33:
                  t4.prev = 33, t4.t0 = t4.catch(14), f2.e(t4.t0);
                case 36:
                  return t4.prev = 36, f2.f(), t4.finish(36);
                case 39:
                  r3 = true, t4.next = 4;
                  break;
                case 42:
                  t4.next = 48;
                  break;
                case 44:
                  t4.prev = 44, t4.t1 = t4.catch(2), i3 = true, o3 = t4.t1;
                case 48:
                  if (t4.prev = 48, t4.prev = 49, r3 || a2.return == null) {
                    t4.next = 53;
                    break;
                  }
                  return t4.next = 53, a2.return();
                case 53:
                  if (t4.prev = 53, !i3) {
                    t4.next = 56;
                    break;
                  }
                  throw o3;
                case 56:
                  return t4.finish(53);
                case 57:
                  return t4.finish(48);
                case 58:
                  return t4.abrupt("return", this.model);
                case 59:
                case "end":
                  return t4.stop();
              }
          }, t3, this, [[2, 44, 48, 58], [14, 33, 36, 39], [49, , 53, 57]]);
        })), function(t3) {
          return l2.apply(this, arguments);
        }) }, { key: "parseStream", value: (o2 = a(regeneratorRuntime.mark(function t3(e3) {
          return regeneratorRuntime.wrap(function(t4) {
            for (; ; )
              switch (t4.prev = t4.next) {
                case 0:
                  return t4.abrupt("return", this.parse(c(e3)));
                case 1:
                case "end":
                  return t4.stop();
              }
          }, t3, this);
        })), function(t3) {
          return o2.apply(this, arguments);
        }) }, { key: "toXml", value: function(t3) {
          var e3 = new f();
          return this.render(e3, t3), e3.xml;
        } }, { key: "xml", get: function() {
          return this.toXml(this.model);
        } }], i2 = [{ key: "toAttribute", value: function(t3, e3) {
          var r3 = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
          if (t3 === void 0) {
            if (r3)
              return e3;
          } else if (r3 || t3 !== e3)
            return t3.toString();
        } }, { key: "toStringAttribute", value: function(e3, r3) {
          var n2 = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
          return t2.toAttribute(e3, r3, n2);
        } }, { key: "toStringValue", value: function(t3, e3) {
          return t3 === void 0 ? e3 : t3;
        } }, { key: "toBoolAttribute", value: function(t3, e3) {
          var r3 = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
          if (t3 === void 0) {
            if (r3)
              return e3;
          } else if (r3 || t3 !== e3)
            return t3 ? "1" : "0";
        } }, { key: "toBoolValue", value: function(t3, e3) {
          return t3 === void 0 ? e3 : t3 === "1";
        } }, { key: "toIntAttribute", value: function(e3, r3) {
          var n2 = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
          return t2.toAttribute(e3, r3, n2);
        } }, { key: "toIntValue", value: function(t3, e3) {
          return t3 === void 0 ? e3 : parseInt(t3, 10);
        } }, { key: "toFloatAttribute", value: function(e3, r3) {
          var n2 = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
          return t2.toAttribute(e3, r3, n2);
        } }, { key: "toFloatValue", value: function(t3, e3) {
          return t3 === void 0 ? e3 : parseFloat(t3);
        } }], r2 && s(e2.prototype, r2), i2 && s(e2, i2), t2;
      }();
      e.exports = l;
    }, { "../../utils/parse-sax": 21, "../../utils/xml-stream": 27 }], 32: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = t("../base-xform"), l = t("../../../utils/col-cache"), h = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          t3.openNode("definedName", { name: e3.name, localSheetId: e3.localSheetId }), t3.writeText(e3.ranges.join(",")), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          switch (t3.name) {
            case "definedName":
              return this._parsedName = t3.attributes.name, this._parsedLocalSheetId = t3.attributes.localSheetId, this._parsedText = [], true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function(t3) {
          this._parsedText.push(t3);
        } }, { key: "parseClose", value: function() {
          return this.model = { name: this._parsedName, ranges: p(this._parsedText.join("")) }, this._parsedLocalSheetId !== void 0 && (this.model.localSheetId = parseInt(this._parsedLocalSheetId, 10)), false;
        } }]) && o(e2.prototype, r2), c2;
      }(f);
      function d(t2) {
        try {
          return l.decodeEx(t2), true;
        } catch (t3) {
          return false;
        }
      }
      function p(t2) {
        var e2 = [], r2 = false, n2 = "";
        return t2.split(",").forEach(function(t3) {
          if (t3) {
            var i2 = (t3.match(/'/g) || []).length;
            if (i2) {
              var o2 = i2 % 2 == 0;
              !r2 && o2 && d(t3) ? e2.push(t3) : r2 && !o2 ? (r2 = false, d(n2 + t3) && e2.push(n2 + t3), n2 = "") : (r2 = true, n2 += "".concat(t3, ","));
            } else
              r2 ? n2 += "".concat(t3, ",") : d(t3) && e2.push(t3);
          }
        }), e2;
      }
      e.exports = h;
    }, { "../../../utils/col-cache": 19, "../base-xform": 31 }], 33: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = t("../../../utils/utils"), l = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          t3.leafNode("sheet", { sheetId: e3.id, name: e3.name, state: e3.state, "r:id": e3.rId });
        } }, { key: "parseOpen", value: function(t3) {
          return t3.name === "sheet" && (this.model = { name: f.xmlDecode(t3.attributes.name), id: parseInt(t3.attributes.sheetId, 10), state: t3.attributes.state, rId: t3.attributes["r:id"] }, true);
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function() {
          return false;
        } }]) && o(e2.prototype, r2), c2;
      }(t("../base-xform"));
      e.exports = l;
    }, { "../../../utils/utils": 26, "../base-xform": 31 }], 34: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          t3.leafNode("calcPr", { calcId: 171027, fullCalcOnLoad: e3.fullCalcOnLoad ? 1 : void 0 });
        } }, { key: "parseOpen", value: function(t3) {
          return t3.name === "calcPr" && (this.model = {}, true);
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function() {
          return false;
        } }]) && o(e2.prototype, r2), c2;
      }(t("../base-xform"));
      e.exports = f;
    }, { "../base-xform": 31 }], 35: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          t3.leafNode("workbookPr", { date1904: e3.date1904 ? 1 : void 0, defaultThemeVersion: 164011, filterPrivacy: 1 });
        } }, { key: "parseOpen", value: function(t3) {
          return t3.name === "workbookPr" && (this.model = { date1904: t3.attributes.date1904 === "1" }, true);
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function() {
          return false;
        } }]) && o(e2.prototype, r2), c2;
      }(t("../base-xform"));
      e.exports = f;
    }, { "../base-xform": 31 }], 36: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          var r3 = { xWindow: e3.x || 0, yWindow: e3.y || 0, windowWidth: e3.width || 12e3, windowHeight: e3.height || 24e3, firstSheet: e3.firstSheet, activeTab: e3.activeTab };
          e3.visibility && e3.visibility !== "visible" && (r3.visibility = e3.visibility), t3.leafNode("workbookView", r3);
        } }, { key: "parseOpen", value: function(t3) {
          if (t3.name === "workbookView") {
            var e3 = this.model = {}, r3 = function(t4, r4, n4) {
              var i3 = r4 !== void 0 ? e3[t4] = parseInt(r4, 10) : n4;
              i3 !== void 0 && (e3[t4] = i3);
            };
            return r3("x", t3.attributes.xWindow, 0), r3("y", t3.attributes.yWindow, 0), r3("width", t3.attributes.windowWidth, 25e3), r3("height", t3.attributes.windowHeight, 1e4), n3 = "visibility", i2 = t3.attributes.visibility, o2 = "visible", (a2 = i2 !== void 0 ? e3[n3] = i2 : o2) !== void 0 && (e3[n3] = a2), r3("activeTab", t3.attributes.activeTab, void 0), r3("firstSheet", t3.attributes.firstSheet, void 0), true;
          }
          var n3, i2, o2, a2;
          return false;
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function() {
          return false;
        } }]) && o(e2.prototype, r2), c2;
      }(t("../base-xform"));
      e.exports = f;
    }, { "../base-xform": 31 }], 37: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("../../../utils/under-dash"), f = t("../../../utils/col-cache"), l = t("../../../utils/xml-stream"), h = t("../base-xform"), d = t("../static-xform"), p = t("../list-xform"), m = t("./defined-name-xform"), y = t("./sheet-xform"), b = t("./workbook-view-xform"), v = t("./workbook-properties-xform"), g = t("./workbook-calc-properties-xform"), w = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2() {
          var t3;
          return function(t4, e3) {
            if (!(t4 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (t3 = s2.call(this)).map = { fileVersion: u2.STATIC_XFORMS.fileVersion, workbookPr: new v(), bookViews: new p({ tag: "bookViews", count: false, childXform: new b() }), sheets: new p({ tag: "sheets", count: false, childXform: new y() }), definedNames: new p({ tag: "definedNames", count: false, childXform: new m() }), calcPr: new g() }, t3;
        }
        return e2 = u2, (r2 = [{ key: "prepare", value: function(t3) {
          t3.sheets = t3.worksheets;
          var e3 = [], r3 = 0;
          t3.sheets.forEach(function(t4) {
            if (t4.pageSetup && t4.pageSetup.printArea && t4.pageSetup.printArea.split("&&").forEach(function(n4) {
              var i3 = n4.split(":"), o3 = { name: "_xlnm.Print_Area", ranges: ["'".concat(t4.name, "'!$").concat(i3[0], ":$").concat(i3[1])], localSheetId: r3 };
              e3.push(o3);
            }), t4.pageSetup && (t4.pageSetup.printTitlesRow || t4.pageSetup.printTitlesColumn)) {
              var n3 = [];
              if (t4.pageSetup.printTitlesColumn) {
                var i2 = t4.pageSetup.printTitlesColumn.split(":");
                n3.push("'".concat(t4.name, "'!$").concat(i2[0], ":$").concat(i2[1]));
              }
              if (t4.pageSetup.printTitlesRow) {
                var o2 = t4.pageSetup.printTitlesRow.split(":");
                n3.push("'".concat(t4.name, "'!$").concat(o2[0], ":$").concat(o2[1]));
              }
              var a2 = { name: "_xlnm.Print_Titles", ranges: n3, localSheetId: r3 };
              e3.push(a2);
            }
            r3++;
          }), e3.length && (t3.definedNames = t3.definedNames.concat(e3)), (t3.media || []).forEach(function(t4, e4) {
            t4.name = t4.type + (e4 + 1);
          });
        } }, { key: "render", value: function(t3, e3) {
          t3.openXml(l.StdDocAttributes), t3.openNode("workbook", u2.WORKBOOK_ATTRIBUTES), this.map.fileVersion.render(t3), this.map.workbookPr.render(t3, e3.properties), this.map.bookViews.render(t3, e3.views), this.map.sheets.render(t3, e3.sheets), this.map.definedNames.render(t3, e3.definedNames), this.map.calcPr.render(t3, e3.calcProperties), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          if (this.parser)
            return this.parser.parseOpen(t3), true;
          switch (t3.name) {
            case "workbook":
              return true;
            default:
              return this.parser = this.map[t3.name], this.parser && this.parser.parseOpen(t3), true;
          }
        } }, { key: "parseText", value: function(t3) {
          this.parser && this.parser.parseText(t3);
        } }, { key: "parseClose", value: function(t3) {
          if (this.parser)
            return this.parser.parseClose(t3) || (this.parser = void 0), true;
          switch (t3) {
            case "workbook":
              return this.model = { sheets: this.map.sheets.model, properties: this.map.workbookPr.model || {}, views: this.map.bookViews.model, calcProperties: {} }, this.map.definedNames.model && (this.model.definedNames = this.map.definedNames.model), false;
            default:
              return true;
          }
        } }, { key: "reconcile", value: function(t3) {
          var e3, r3 = (t3.workbookRels || []).reduce(function(t4, e4) {
            return t4[e4.Id] = e4, t4;
          }, {}), n3 = [], i2 = 0;
          (t3.sheets || []).forEach(function(o3) {
            var a2 = r3[o3.rId];
            a2 && (e3 = t3.worksheetHash["xl/".concat(a2.Target.replace(/^(\s|\/xl\/)+/, ""))]) && (e3.name = o3.name, e3.id = o3.id, e3.state = o3.state, n3[i2++] = e3);
          });
          var o2 = [];
          c.each(t3.definedNames, function(t4) {
            if (t4.name === "_xlnm.Print_Area") {
              if (e3 = n3[t4.localSheetId]) {
                e3.pageSetup || (e3.pageSetup = {});
                var r4 = f.decodeEx(t4.ranges[0]);
                e3.pageSetup.printArea = e3.pageSetup.printArea ? "".concat(e3.pageSetup.printArea, "&&").concat(r4.dimensions) : r4.dimensions;
              }
            } else if (t4.name === "_xlnm.Print_Titles") {
              if (e3 = n3[t4.localSheetId]) {
                e3.pageSetup || (e3.pageSetup = {});
                var i3 = t4.ranges.join(","), a2 = /\$/g, s3 = i3.match(/\$\d+:\$\d+/);
                if (s3 && s3.length) {
                  var u3 = s3[0];
                  e3.pageSetup.printTitlesRow = u3.replace(a2, "");
                }
                var c2 = i3.match(/\$[A-Z]+:\$[A-Z]+/);
                if (c2 && c2.length) {
                  var l2 = c2[0];
                  e3.pageSetup.printTitlesColumn = l2.replace(a2, "");
                }
              }
            } else
              o2.push(t4);
          }), t3.definedNames = o2, t3.media.forEach(function(t4, e4) {
            t4.index = e4;
          });
        } }]) && i(e2.prototype, r2), u2;
      }(h);
      w.WORKBOOK_ATTRIBUTES = { xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main", "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships", "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006", "mc:Ignorable": "x15", "xmlns:x15": "http://schemas.microsoft.com/office/spreadsheetml/2010/11/main" }, w.STATIC_XFORMS = { fileVersion: new d({ tag: "fileVersion", $: { appName: "xl", lastEdited: 5, lowestEdited: 5, rupBuild: 9303 } }) }, e.exports = w;
    }, { "../../../utils/col-cache": 19, "../../../utils/under-dash": 25, "../../../utils/xml-stream": 27, "../base-xform": 31, "../list-xform": 70, "../static-xform": 119, "./defined-name-xform": 32, "./sheet-xform": 33, "./workbook-calc-properties-xform": 34, "./workbook-properties-xform": 35, "./workbook-view-xform": 36 }], 38: [function(t, e, r) {
      function n(t2, e2) {
        var r2 = Object.keys(t2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t2);
          e2 && (n2 = n2.filter(function(e3) {
            return Object.getOwnPropertyDescriptor(t2, e3).enumerable;
          })), r2.push.apply(r2, n2);
        }
        return r2;
      }
      function i(t2, e2, r2) {
        return e2 in t2 ? Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }) : t2[e2] = r2, t2;
      }
      var o = t("../strings/rich-text-xform"), a = t("../../../utils/utils"), s = t("../base-xform"), u = e.exports = function(t2) {
        this.model = t2;
      };
      a.inherits(u, s, { get tag() {
        return "r";
      }, get richTextXform() {
        return this._richTextXform || (this._richTextXform = new o()), this._richTextXform;
      }, render: function(t2, e2) {
        var r2 = this;
        e2 = e2 || this.model, t2.openNode("comment", { ref: e2.ref, authorId: 0 }), t2.openNode("text"), e2 && e2.note && e2.note.texts && e2.note.texts.forEach(function(e3) {
          r2.richTextXform.render(t2, e3);
        }), t2.closeNode(), t2.closeNode();
      }, parseOpen: function(t2) {
        if (this.parser)
          return this.parser.parseOpen(t2), true;
        switch (t2.name) {
          case "comment":
            return this.model = function(t3) {
              for (var e2 = 1; e2 < arguments.length; e2++) {
                var r2 = arguments[e2] != null ? arguments[e2] : {};
                e2 % 2 ? n(Object(r2), true).forEach(function(e3) {
                  i(t3, e3, r2[e3]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t3, Object.getOwnPropertyDescriptors(r2)) : n(Object(r2)).forEach(function(e3) {
                  Object.defineProperty(t3, e3, Object.getOwnPropertyDescriptor(r2, e3));
                });
              }
              return t3;
            }({ type: "note", note: { texts: [] } }, t2.attributes), true;
          case "r":
            return this.parser = this.richTextXform, this.parser.parseOpen(t2), true;
          default:
            return false;
        }
      }, parseText: function(t2) {
        this.parser && this.parser.parseText(t2);
      }, parseClose: function(t2) {
        switch (t2) {
          case "comment":
            return false;
          case "r":
            return this.model.note.texts.push(this.parser.model), this.parser = void 0, true;
          default:
            return this.parser && this.parser.parseClose(t2), true;
        }
      } });
    }, { "../../../utils/utils": 26, "../base-xform": 31, "../strings/rich-text-xform": 121 }], 39: [function(t, e, r) {
      var n = t("../../../utils/xml-stream"), i = t("../../../utils/utils"), o = t("../base-xform"), a = t("./comment-xform"), s = e.exports = function() {
        this.map = { comment: new a() };
      };
      i.inherits(s, o, { COMMENTS_ATTRIBUTES: { xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main" } }, { render: function(t2, e2) {
        var r2 = this;
        e2 = e2 || this.model, t2.openXml(n.StdDocAttributes), t2.openNode("comments", s.COMMENTS_ATTRIBUTES), t2.openNode("authors"), t2.leafNode("author", null, "Author"), t2.closeNode(), t2.openNode("commentList"), e2.comments.forEach(function(e3) {
          r2.map.comment.render(t2, e3);
        }), t2.closeNode(), t2.closeNode();
      }, parseOpen: function(t2) {
        if (this.parser)
          return this.parser.parseOpen(t2), true;
        switch (t2.name) {
          case "commentList":
            return this.model = { comments: [] }, true;
          case "comment":
            return this.parser = this.map.comment, this.parser.parseOpen(t2), true;
          default:
            return false;
        }
      }, parseText: function(t2) {
        this.parser && this.parser.parseText(t2);
      }, parseClose: function(t2) {
        switch (t2) {
          case "commentList":
            return false;
          case "comment":
            return this.model.comments.push(this.parser.model), this.parser = void 0, true;
          default:
            return this.parser && this.parser.parseClose(t2), true;
        }
      } });
    }, { "../../../utils/utils": 26, "../../../utils/xml-stream": 27, "../base-xform": 31, "./comment-xform": 38 }], 40: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2(t3) {
          var e3;
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (e3 = s2.call(this))._model = t3, e3;
        }
        return e2 = u2, (r2 = [{ key: "render", value: function(t3, e3, r3) {
          (e3 === r3[2] || this.tag === "x:SizeWithCells" && e3 === r3[1]) && t3.leafNode(this.tag);
        } }, { key: "parseOpen", value: function(t3) {
          switch (t3.name) {
            case this.tag:
              return this.model = {}, this.model[this.tag] = true, true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function() {
          return false;
        } }, { key: "tag", get: function() {
          return this._model && this._model.tag;
        } }]) && i(e2.prototype, r2), u2;
      }(t("../../base-xform"));
      e.exports = c;
    }, { "../../base-xform": 31 }], 41: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2(t3) {
          var e3;
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (e3 = s2.call(this))._model = t3, e3;
        }
        return e2 = u2, (r2 = [{ key: "render", value: function(t3, e3) {
          t3.leafNode(this.tag, null, e3);
        } }, { key: "parseOpen", value: function(t3) {
          switch (t3.name) {
            case this.tag:
              return this.text = "", true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function(t3) {
          this.text = t3;
        } }, { key: "parseClose", value: function() {
          return false;
        } }, { key: "tag", get: function() {
          return this._model && this._model.tag;
        } }]) && i(e2.prototype, r2), u2;
      }(t("../../base-xform"));
      e.exports = c;
    }, { "../../base-xform": 31 }], 42: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "getAnchorRect", value: function(t3) {
          var e3 = Math.floor(t3.left), r3 = Math.floor(68 * (t3.left - e3)), n3 = Math.floor(t3.top), i2 = Math.floor(18 * (t3.top - n3)), o2 = Math.floor(t3.right), a2 = Math.floor(68 * (t3.right - o2)), s2 = Math.floor(t3.bottom);
          return [e3, r3, n3, i2, o2, a2, s2, Math.floor(18 * (t3.bottom - s2))];
        } }, { key: "getDefaultRect", value: function(t3) {
          var e3 = t3.col, r3 = Math.max(t3.row - 2, 0);
          return [e3, 6, r3, 14, e3 + 2, 2, r3 + 4, 16];
        } }, { key: "render", value: function(t3, e3) {
          var r3 = e3.anchor ? this.getAnchorRect(e3.anchor) : this.getDefaultRect(e3.refAddress);
          t3.leafNode("x:Anchor", null, r3.join(", "));
        } }, { key: "parseOpen", value: function(t3) {
          switch (t3.name) {
            case this.tag:
              return this.text = "", true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function(t3) {
          this.text = t3;
        } }, { key: "parseClose", value: function() {
          return false;
        } }, { key: "tag", get: function() {
          return "x:Anchor";
        } }]) && o(e2.prototype, r2), c2;
      }(t("../base-xform"));
      e.exports = f;
    }, { "../base-xform": 31 }], 43: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("../base-xform"), f = t("./vml-anchor-xform"), l = t("./style/vml-protection-xform"), h = t("./style/vml-position-xform"), d = ["twoCells", "oneCells", "absolute"], p = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2() {
          var t3;
          return function(t4, e3) {
            if (!(t4 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (t3 = s2.call(this)).map = { "x:Anchor": new f(), "x:Locked": new l({ tag: "x:Locked" }), "x:LockText": new l({ tag: "x:LockText" }), "x:SizeWithCells": new h({ tag: "x:SizeWithCells" }), "x:MoveWithCells": new h({ tag: "x:MoveWithCells" }) }, t3;
        }
        return e2 = u2, (r2 = [{ key: "render", value: function(t3, e3) {
          var r3 = e3.note, n3 = r3.protection, i2 = r3.editAs;
          t3.openNode(this.tag, { ObjectType: "Note" }), this.map["x:MoveWithCells"].render(t3, i2, d), this.map["x:SizeWithCells"].render(t3, i2, d), this.map["x:Anchor"].render(t3, e3), this.map["x:Locked"].render(t3, n3.locked), t3.leafNode("x:AutoFill", null, "False"), this.map["x:LockText"].render(t3, n3.lockText), t3.leafNode("x:Row", null, e3.refAddress.row - 1), t3.leafNode("x:Column", null, e3.refAddress.col - 1), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          switch (t3.name) {
            case this.tag:
              this.reset(), this.model = { anchor: [], protection: {}, editAs: "" };
              break;
            default:
              this.parser = this.map[t3.name], this.parser && this.parser.parseOpen(t3);
          }
          return true;
        } }, { key: "parseText", value: function(t3) {
          this.parser && this.parser.parseText(t3);
        } }, { key: "parseClose", value: function(t3) {
          if (this.parser)
            return this.parser.parseClose(t3) || (this.parser = void 0), true;
          switch (t3) {
            case this.tag:
              return this.normalizeModel(), false;
            default:
              return true;
          }
        } }, { key: "normalizeModel", value: function() {
          var t3 = Object.assign({}, this.map["x:MoveWithCells"].model, this.map["x:SizeWithCells"].model), e3 = Object.keys(t3).length;
          this.model.editAs = d[e3], this.model.anchor = this.map["x:Anchor"].text, this.model.protection.locked = this.map["x:Locked"].text, this.model.protection.lockText = this.map["x:LockText"].text;
        } }, { key: "tag", get: function() {
          return "x:ClientData";
        } }]) && i(e2.prototype, r2), u2;
      }(c);
      e.exports = p;
    }, { "../base-xform": 31, "./style/vml-position-xform": 40, "./style/vml-protection-xform": 41, "./vml-anchor-xform": 42 }], 44: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("../../../utils/xml-stream"), f = t("../base-xform"), l = t("./vml-shape-xform"), h = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2() {
          var t3;
          return function(t4, e3) {
            if (!(t4 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (t3 = s2.call(this)).map = { "v:shape": new l() }, t3;
        }
        return e2 = u2, (r2 = [{ key: "render", value: function(t3, e3) {
          var r3 = this;
          t3.openXml(c.StdDocAttributes), t3.openNode(this.tag, u2.DRAWING_ATTRIBUTES), t3.openNode("o:shapelayout", { "v:ext": "edit" }), t3.leafNode("o:idmap", { "v:ext": "edit", data: 1 }), t3.closeNode(), t3.openNode("v:shapetype", { id: "_x0000_t202", coordsize: "21600,21600", "o:spt": 202, path: "m,l,21600r21600,l21600,xe" }), t3.leafNode("v:stroke", { joinstyle: "miter" }), t3.leafNode("v:path", { gradientshapeok: "t", "o:connecttype": "rect" }), t3.closeNode(), e3.comments.forEach(function(e4, n3) {
            r3.map["v:shape"].render(t3, e4, n3);
          }), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          if (this.parser)
            return this.parser.parseOpen(t3), true;
          switch (t3.name) {
            case this.tag:
              this.reset(), this.model = { comments: [] };
              break;
            default:
              this.parser = this.map[t3.name], this.parser && this.parser.parseOpen(t3);
          }
          return true;
        } }, { key: "parseText", value: function(t3) {
          this.parser && this.parser.parseText(t3);
        } }, { key: "parseClose", value: function(t3) {
          if (this.parser)
            return this.parser.parseClose(t3) || (this.model.comments.push(this.parser.model), this.parser = void 0), true;
          switch (t3) {
            case this.tag:
              return false;
            default:
              return true;
          }
        } }, { key: "reconcile", value: function(t3, e3) {
          var r3 = this;
          t3.anchors.forEach(function(t4) {
            t4.br ? r3.map["xdr:twoCellAnchor"].reconcile(t4, e3) : r3.map["xdr:oneCellAnchor"].reconcile(t4, e3);
          });
        } }, { key: "tag", get: function() {
          return "xml";
        } }]) && i(e2.prototype, r2), u2;
      }(f);
      h.DRAWING_ATTRIBUTES = { "xmlns:v": "urn:schemas-microsoft-com:vml", "xmlns:o": "urn:schemas-microsoft-com:office:office", "xmlns:x": "urn:schemas-microsoft-com:office:excel" }, e.exports = h;
    }, { "../../../utils/xml-stream": 27, "../base-xform": 31, "./vml-shape-xform": 45 }], 45: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("../base-xform"), f = t("./vml-textbox-xform"), l = t("./vml-client-data-xform"), h = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2() {
          var t3;
          return function(t4, e3) {
            if (!(t4 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (t3 = s2.call(this)).map = { "v:textbox": new f(), "x:ClientData": new l() }, t3;
        }
        return e2 = u2, (r2 = [{ key: "render", value: function(t3, e3, r3) {
          t3.openNode("v:shape", u2.V_SHAPE_ATTRIBUTES(e3, r3)), t3.leafNode("v:fill", { color2: "infoBackground [80]" }), t3.leafNode("v:shadow", { color: "none [81]", obscured: "t" }), t3.leafNode("v:path", { "o:connecttype": "none" }), this.map["v:textbox"].render(t3, e3), this.map["x:ClientData"].render(t3, e3), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          if (this.parser)
            return this.parser.parseOpen(t3), true;
          switch (t3.name) {
            case this.tag:
              this.reset(), this.model = { margins: { insetmode: t3.attributes["o:insetmode"] }, anchor: "", editAs: "", protection: {} };
              break;
            default:
              this.parser = this.map[t3.name], this.parser && this.parser.parseOpen(t3);
          }
          return true;
        } }, { key: "parseText", value: function(t3) {
          this.parser && this.parser.parseText(t3);
        } }, { key: "parseClose", value: function(t3) {
          if (this.parser)
            return this.parser.parseClose(t3) || (this.parser = void 0), true;
          switch (t3) {
            case this.tag:
              return this.model.margins.inset = this.map["v:textbox"].model && this.map["v:textbox"].model.inset, this.model.protection = this.map["x:ClientData"].model && this.map["x:ClientData"].model.protection, this.model.anchor = this.map["x:ClientData"].model && this.map["x:ClientData"].model.anchor, this.model.editAs = this.map["x:ClientData"].model && this.map["x:ClientData"].model.editAs, false;
            default:
              return true;
          }
        } }, { key: "tag", get: function() {
          return "v:shape";
        } }]) && i(e2.prototype, r2), u2;
      }(c);
      h.V_SHAPE_ATTRIBUTES = function(t2, e2) {
        return { id: "_x0000_s".concat(1025 + e2), type: "#_x0000_t202", style: "position:absolute; margin-left:105.3pt;margin-top:10.5pt;width:97.8pt;height:59.1pt;z-index:1;visibility:hidden", fillcolor: "infoBackground [80]", strokecolor: "none [81]", "o:insetmode": t2.note.margins && t2.note.margins.insetmode };
      }, e.exports = h;
    }, { "../base-xform": 31, "./vml-client-data-xform": 43, "./vml-textbox-xform": 46 }], 46: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "conversionUnit", value: function(t3, e3, r3) {
          return "".concat(parseFloat(t3) * e3.toFixed(2)).concat(r3);
        } }, { key: "reverseConversionUnit", value: function(t3) {
          var e3 = this;
          return (t3 || "").split(",").map(function(t4) {
            return Number(parseFloat(e3.conversionUnit(parseFloat(t4), 0.1, "")).toFixed(2));
          });
        } }, { key: "render", value: function(t3, e3) {
          var r3 = this, n3 = { style: "mso-direction-alt:auto" };
          if (e3 && e3.note) {
            var i2 = (e3.note && e3.note.margins).inset;
            Array.isArray(i2) && (i2 = i2.map(function(t4) {
              return r3.conversionUnit(t4, 10, "mm");
            }).join(",")), i2 && (n3.inset = i2);
          }
          t3.openNode("v:textbox", n3), t3.leafNode("div", { style: "text-align:left" }), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          switch (t3.name) {
            case this.tag:
              return this.model = { inset: this.reverseConversionUnit(t3.attributes.inset) }, true;
            default:
              return true;
          }
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function(t3) {
          switch (t3) {
            case this.tag:
              return false;
            default:
              return true;
          }
        } }, { key: "tag", get: function() {
          return "v:textbox";
        } }]) && o(e2.prototype, r2), c2;
      }(t("../base-xform"));
      e.exports = f;
    }, { "../base-xform": 31 }], 47: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "createNewModel", value: function(t3) {
          return {};
        } }, { key: "parseOpen", value: function(t3) {
          return this.parser = this.parser || this.map[t3.name], this.parser ? (this.parser.parseOpen(t3), true) : t3.name === this.tag && (this.model = this.createNewModel(t3), true);
        } }, { key: "parseText", value: function(t3) {
          this.parser && this.parser.parseText(t3);
        } }, { key: "onParserClose", value: function(t3, e3) {
          this.model[t3] = e3.model;
        } }, { key: "parseClose", value: function(t3) {
          return this.parser ? (this.parser.parseClose(t3) || (this.onParserClose(t3, this.parser), this.parser = void 0), true) : t3 !== this.tag;
        } }]) && o(e2.prototype, r2), c2;
      }(t("./base-xform"));
      e.exports = f;
    }, { "./base-xform": 31 }], 48: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          t3.openNode("HeadingPairs"), t3.openNode("vt:vector", { size: 2, baseType: "variant" }), t3.openNode("vt:variant"), t3.leafNode("vt:lpstr", void 0, "Worksheets"), t3.closeNode(), t3.openNode("vt:variant"), t3.leafNode("vt:i4", void 0, e3.length), t3.closeNode(), t3.closeNode(), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          return t3.name === "HeadingPairs";
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function(t3) {
          return t3 !== "HeadingPairs";
        } }]) && o(e2.prototype, r2), c2;
      }(t("../base-xform"));
      e.exports = f;
    }, { "../base-xform": 31 }], 49: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          t3.openNode("TitlesOfParts"), t3.openNode("vt:vector", { size: e3.length, baseType: "lpstr" }), e3.forEach(function(e4) {
            t3.leafNode("vt:lpstr", void 0, e4.name);
          }), t3.closeNode(), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          return t3.name === "TitlesOfParts";
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function(t3) {
          return t3 !== "TitlesOfParts";
        } }]) && o(e2.prototype, r2), c2;
      }(t("../base-xform"));
      e.exports = f;
    }, { "../base-xform": 31 }], 50: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("../../../utils/xml-stream"), f = t("../base-xform"), l = t("../simple/string-xform"), h = t("./app-heading-pairs-xform"), d = t("./app-titles-of-parts-xform"), p = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2() {
          var t3;
          return function(t4, e3) {
            if (!(t4 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (t3 = s2.call(this)).map = { Company: new l({ tag: "Company" }), Manager: new l({ tag: "Manager" }), HeadingPairs: new h(), TitleOfParts: new d() }, t3;
        }
        return e2 = u2, (r2 = [{ key: "render", value: function(t3, e3) {
          t3.openXml(c.StdDocAttributes), t3.openNode("Properties", u2.PROPERTY_ATTRIBUTES), t3.leafNode("Application", void 0, "Microsoft Excel"), t3.leafNode("DocSecurity", void 0, "0"), t3.leafNode("ScaleCrop", void 0, "false"), this.map.HeadingPairs.render(t3, e3.worksheets), this.map.TitleOfParts.render(t3, e3.worksheets), this.map.Company.render(t3, e3.company || ""), this.map.Manager.render(t3, e3.manager), t3.leafNode("LinksUpToDate", void 0, "false"), t3.leafNode("SharedDoc", void 0, "false"), t3.leafNode("HyperlinksChanged", void 0, "false"), t3.leafNode("AppVersion", void 0, "16.0300"), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          if (this.parser)
            return this.parser.parseOpen(t3), true;
          switch (t3.name) {
            case "Properties":
              return true;
            default:
              return this.parser = this.map[t3.name], !!this.parser && (this.parser.parseOpen(t3), true);
          }
        } }, { key: "parseText", value: function(t3) {
          this.parser && this.parser.parseText(t3);
        } }, { key: "parseClose", value: function(t3) {
          if (this.parser)
            return this.parser.parseClose(t3) || (this.parser = void 0), true;
          switch (t3) {
            case "Properties":
              return this.model = { worksheets: this.map.TitleOfParts.model, company: this.map.Company.model, manager: this.map.Manager.model }, false;
            default:
              return true;
          }
        } }]) && i(e2.prototype, r2), u2;
      }(f);
      p.DateFormat = function(t2) {
        return t2.toISOString().replace(/[.]\d{3,6}/, "");
      }, p.DateAttrs = { "xsi:type": "dcterms:W3CDTF" }, p.PROPERTY_ATTRIBUTES = { xmlns: "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties", "xmlns:vt": "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes" }, e.exports = p;
    }, { "../../../utils/xml-stream": 27, "../base-xform": 31, "../simple/string-xform": 118, "./app-heading-pairs-xform": 48, "./app-titles-of-parts-xform": 49 }], 51: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = t("../../../utils/xml-stream"), l = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          t3.openXml(f.StdDocAttributes), t3.openNode("Types", c2.PROPERTY_ATTRIBUTES);
          var r3 = {};
          (e3.media || []).forEach(function(e4) {
            if (e4.type === "image") {
              var n3 = e4.extension;
              r3[n3] || (r3[n3] = true, t3.leafNode("Default", { Extension: n3, ContentType: "image/".concat(n3) }));
            }
          }), t3.leafNode("Default", { Extension: "rels", ContentType: "application/vnd.openxmlformats-package.relationships+xml" }), t3.leafNode("Default", { Extension: "xml", ContentType: "application/xml" }), t3.leafNode("Override", { PartName: "/xl/workbook.xml", ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml" }), e3.worksheets.forEach(function(e4) {
            var r4 = "/xl/worksheets/sheet".concat(e4.id, ".xml");
            t3.leafNode("Override", { PartName: r4, ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml" });
          }), t3.leafNode("Override", { PartName: "/xl/theme/theme1.xml", ContentType: "application/vnd.openxmlformats-officedocument.theme+xml" }), t3.leafNode("Override", { PartName: "/xl/styles.xml", ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml" }), e3.sharedStrings && e3.sharedStrings.count && t3.leafNode("Override", { PartName: "/xl/sharedStrings.xml", ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml" }), e3.tables && e3.tables.forEach(function(e4) {
            t3.leafNode("Override", { PartName: "/xl/tables/".concat(e4.target), ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml" });
          }), e3.drawings && e3.drawings.forEach(function(e4) {
            t3.leafNode("Override", { PartName: "/xl/drawings/".concat(e4.name, ".xml"), ContentType: "application/vnd.openxmlformats-officedocument.drawing+xml" });
          }), e3.commentRefs && (t3.leafNode("Default", { Extension: "vml", ContentType: "application/vnd.openxmlformats-officedocument.vmlDrawing" }), e3.commentRefs.forEach(function(e4) {
            var r4 = e4.commentName;
            t3.leafNode("Override", { PartName: "/xl/".concat(r4, ".xml"), ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml" });
          })), t3.leafNode("Override", { PartName: "/docProps/core.xml", ContentType: "application/vnd.openxmlformats-package.core-properties+xml" }), t3.leafNode("Override", { PartName: "/docProps/app.xml", ContentType: "application/vnd.openxmlformats-officedocument.extended-properties+xml" }), t3.closeNode();
        } }, { key: "parseOpen", value: function() {
          return false;
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function() {
          return false;
        } }]) && o(e2.prototype, r2), c2;
      }(t("../base-xform"));
      l.PROPERTY_ATTRIBUTES = { xmlns: "http://schemas.openxmlformats.org/package/2006/content-types" }, e.exports = l;
    }, { "../../../utils/xml-stream": 27, "../base-xform": 31 }], 52: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("../../../utils/xml-stream"), f = t("../base-xform"), l = t("../simple/date-xform"), h = t("../simple/string-xform"), d = t("../simple/integer-xform"), p = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2() {
          var t3;
          return function(t4, e3) {
            if (!(t4 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (t3 = s2.call(this)).map = { "dc:creator": new h({ tag: "dc:creator" }), "dc:title": new h({ tag: "dc:title" }), "dc:subject": new h({ tag: "dc:subject" }), "dc:description": new h({ tag: "dc:description" }), "dc:identifier": new h({ tag: "dc:identifier" }), "dc:language": new h({ tag: "dc:language" }), "cp:keywords": new h({ tag: "cp:keywords" }), "cp:category": new h({ tag: "cp:category" }), "cp:lastModifiedBy": new h({ tag: "cp:lastModifiedBy" }), "cp:lastPrinted": new l({ tag: "cp:lastPrinted", format: u2.DateFormat }), "cp:revision": new d({ tag: "cp:revision" }), "cp:version": new h({ tag: "cp:version" }), "cp:contentStatus": new h({ tag: "cp:contentStatus" }), "cp:contentType": new h({ tag: "cp:contentType" }), "dcterms:created": new l({ tag: "dcterms:created", attrs: u2.DateAttrs, format: u2.DateFormat }), "dcterms:modified": new l({ tag: "dcterms:modified", attrs: u2.DateAttrs, format: u2.DateFormat }) }, t3;
        }
        return e2 = u2, (r2 = [{ key: "render", value: function(t3, e3) {
          t3.openXml(c.StdDocAttributes), t3.openNode("cp:coreProperties", u2.CORE_PROPERTY_ATTRIBUTES), this.map["dc:creator"].render(t3, e3.creator), this.map["dc:title"].render(t3, e3.title), this.map["dc:subject"].render(t3, e3.subject), this.map["dc:description"].render(t3, e3.description), this.map["dc:identifier"].render(t3, e3.identifier), this.map["dc:language"].render(t3, e3.language), this.map["cp:keywords"].render(t3, e3.keywords), this.map["cp:category"].render(t3, e3.category), this.map["cp:lastModifiedBy"].render(t3, e3.lastModifiedBy), this.map["cp:lastPrinted"].render(t3, e3.lastPrinted), this.map["cp:revision"].render(t3, e3.revision), this.map["cp:version"].render(t3, e3.version), this.map["cp:contentStatus"].render(t3, e3.contentStatus), this.map["cp:contentType"].render(t3, e3.contentType), this.map["dcterms:created"].render(t3, e3.created), this.map["dcterms:modified"].render(t3, e3.modified), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          if (this.parser)
            return this.parser.parseOpen(t3), true;
          switch (t3.name) {
            case "cp:coreProperties":
            case "coreProperties":
              return true;
            default:
              if (this.parser = this.map[t3.name], this.parser)
                return this.parser.parseOpen(t3), true;
              throw new Error("Unexpected xml node in parseOpen: ".concat(JSON.stringify(t3)));
          }
        } }, { key: "parseText", value: function(t3) {
          this.parser && this.parser.parseText(t3);
        } }, { key: "parseClose", value: function(t3) {
          if (this.parser)
            return this.parser.parseClose(t3) || (this.parser = void 0), true;
          switch (t3) {
            case "cp:coreProperties":
            case "coreProperties":
              return this.model = { creator: this.map["dc:creator"].model, title: this.map["dc:title"].model, subject: this.map["dc:subject"].model, description: this.map["dc:description"].model, identifier: this.map["dc:identifier"].model, language: this.map["dc:language"].model, keywords: this.map["cp:keywords"].model, category: this.map["cp:category"].model, lastModifiedBy: this.map["cp:lastModifiedBy"].model, lastPrinted: this.map["cp:lastPrinted"].model, revision: this.map["cp:revision"].model, contentStatus: this.map["cp:contentStatus"].model, contentType: this.map["cp:contentType"].model, created: this.map["dcterms:created"].model, modified: this.map["dcterms:modified"].model }, false;
            default:
              throw new Error("Unexpected xml node in parseClose: ".concat(t3));
          }
        } }]) && i(e2.prototype, r2), u2;
      }(f);
      p.DateFormat = function(t2) {
        return t2.toISOString().replace(/[.]\d{3}/, "");
      }, p.DateAttrs = { "xsi:type": "dcterms:W3CDTF" }, p.CORE_PROPERTY_ATTRIBUTES = { "xmlns:cp": "http://schemas.openxmlformats.org/package/2006/metadata/core-properties", "xmlns:dc": "http://purl.org/dc/elements/1.1/", "xmlns:dcterms": "http://purl.org/dc/terms/", "xmlns:dcmitype": "http://purl.org/dc/dcmitype/", "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance" }, e.exports = p;
    }, { "../../../utils/xml-stream": 27, "../base-xform": 31, "../simple/date-xform": 116, "../simple/integer-xform": 117, "../simple/string-xform": 118 }], 53: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          t3.leafNode("Relationship", e3);
        } }, { key: "parseOpen", value: function(t3) {
          switch (t3.name) {
            case "Relationship":
              return this.model = t3.attributes, true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function() {
          return false;
        } }]) && o(e2.prototype, r2), c2;
      }(t("../base-xform"));
      e.exports = f;
    }, { "../base-xform": 31 }], 54: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("../../../utils/xml-stream"), f = t("../base-xform"), l = t("./relationship-xform"), h = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2() {
          var t3;
          return function(t4, e3) {
            if (!(t4 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (t3 = s2.call(this)).map = { Relationship: new l() }, t3;
        }
        return e2 = u2, (r2 = [{ key: "render", value: function(t3, e3) {
          var r3 = this;
          e3 = e3 || this._values, t3.openXml(c.StdDocAttributes), t3.openNode("Relationships", u2.RELATIONSHIPS_ATTRIBUTES), e3.forEach(function(e4) {
            r3.map.Relationship.render(t3, e4);
          }), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          if (this.parser)
            return this.parser.parseOpen(t3), true;
          switch (t3.name) {
            case "Relationships":
              return this.model = [], true;
            default:
              if (this.parser = this.map[t3.name], this.parser)
                return this.parser.parseOpen(t3), true;
              throw new Error("Unexpected xml node in parseOpen: ".concat(JSON.stringify(t3)));
          }
        } }, { key: "parseText", value: function(t3) {
          this.parser && this.parser.parseText(t3);
        } }, { key: "parseClose", value: function(t3) {
          if (this.parser)
            return this.parser.parseClose(t3) || (this.model.push(this.parser.model), this.parser = void 0), true;
          switch (t3) {
            case "Relationships":
              return false;
            default:
              throw new Error("Unexpected xml node in parseClose: ".concat(t3));
          }
        } }]) && i(e2.prototype, r2), u2;
      }(f);
      h.RELATIONSHIPS_ATTRIBUTES = { xmlns: "http://schemas.openxmlformats.org/package/2006/relationships" }, e.exports = h;
    }, { "../../../utils/xml-stream": 27, "../base-xform": 31, "./relationship-xform": 53 }], 55: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "parseOpen", value: function(t3) {
          if (this.parser)
            return this.parser.parseOpen(t3), true;
          switch (t3.name) {
            case this.tag:
              this.reset(), this.model = { range: { editAs: t3.attributes.editAs || "oneCell" } };
              break;
            default:
              this.parser = this.map[t3.name], this.parser && this.parser.parseOpen(t3);
          }
          return true;
        } }, { key: "parseText", value: function(t3) {
          this.parser && this.parser.parseText(t3);
        } }, { key: "reconcilePicture", value: function(t3, e3) {
          if (t3 && t3.rId) {
            var r3 = e3.rels[t3.rId].Target.match(/.*\/media\/(.+[.][a-zA-Z]{3,4})/);
            if (r3) {
              var n3 = r3[1], i2 = e3.mediaIndex[n3];
              return e3.media[i2];
            }
          }
        } }]) && o(e2.prototype, r2), c2;
      }(t("../base-xform"));
      e.exports = f;
    }, { "../base-xform": 31 }], 56: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("../base-xform"), f = t("./blip-xform"), l = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2() {
          var t3;
          return function(t4, e3) {
            if (!(t4 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (t3 = s2.call(this)).map = { "a:blip": new f() }, t3;
        }
        return e2 = u2, (r2 = [{ key: "render", value: function(t3, e3) {
          t3.openNode(this.tag), this.map["a:blip"].render(t3, e3), t3.openNode("a:stretch"), t3.leafNode("a:fillRect"), t3.closeNode(), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          if (this.parser)
            return this.parser.parseOpen(t3), true;
          switch (t3.name) {
            case this.tag:
              this.reset();
              break;
            default:
              this.parser = this.map[t3.name], this.parser && this.parser.parseOpen(t3);
          }
          return true;
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function(t3) {
          if (this.parser)
            return this.parser.parseClose(t3) || (this.parser = void 0), true;
          switch (t3) {
            case this.tag:
              return this.model = this.map["a:blip"].model, false;
            default:
              return true;
          }
        } }, { key: "tag", get: function() {
          return "xdr:blipFill";
        } }]) && i(e2.prototype, r2), u2;
      }(c);
      e.exports = l;
    }, { "../base-xform": 31, "./blip-xform": 57 }], 57: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          t3.leafNode(this.tag, { "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships", "r:embed": e3.rId, cstate: "print" });
        } }, { key: "parseOpen", value: function(t3) {
          switch (t3.name) {
            case this.tag:
              return this.model = { rId: t3.attributes["r:embed"] }, true;
            default:
              return true;
          }
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function(t3) {
          switch (t3) {
            case this.tag:
              return false;
            default:
              return true;
          }
        } }, { key: "tag", get: function() {
          return "a:blip";
        } }]) && o(e2.prototype, r2), c2;
      }(t("../base-xform"));
      e.exports = f;
    }, { "../base-xform": 31 }], 58: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3) {
          t3.openNode(this.tag), t3.leafNode("a:picLocks", { noChangeAspect: "1" }), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          switch (t3.name) {
            case this.tag:
            default:
              return true;
          }
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function(t3) {
          switch (t3) {
            case this.tag:
              return false;
            default:
              return true;
          }
        } }, { key: "tag", get: function() {
          return "xdr:cNvPicPr";
        } }]) && o(e2.prototype, r2), c2;
      }(t("../base-xform"));
      e.exports = f;
    }, { "../base-xform": 31 }], 59: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("../base-xform"), f = t("./hlink-click-xform"), l = t("./ext-lst-xform"), h = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2() {
          var t3;
          return function(t4, e3) {
            if (!(t4 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (t3 = s2.call(this)).map = { "a:hlinkClick": new f(), "a:extLst": new l() }, t3;
        }
        return e2 = u2, (r2 = [{ key: "render", value: function(t3, e3) {
          t3.openNode(this.tag, { id: e3.index, name: "Picture ".concat(e3.index) }), this.map["a:hlinkClick"].render(t3, e3), this.map["a:extLst"].render(t3, e3), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          if (this.parser)
            return this.parser.parseOpen(t3), true;
          switch (t3.name) {
            case this.tag:
              this.reset();
              break;
            default:
              this.parser = this.map[t3.name], this.parser && this.parser.parseOpen(t3);
          }
          return true;
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function(t3) {
          if (this.parser)
            return this.parser.parseClose(t3) || (this.parser = void 0), true;
          switch (t3) {
            case this.tag:
              return this.model = this.map["a:hlinkClick"].model, false;
            default:
              return true;
          }
        } }, { key: "tag", get: function() {
          return "xdr:cNvPr";
        } }]) && i(e2.prototype, r2), u2;
      }(c);
      e.exports = h;
    }, { "../base-xform": 31, "./ext-lst-xform": 62, "./hlink-click-xform": 64 }], 60: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("../base-xform"), f = t("../simple/integer-xform"), l = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2(t3) {
          var e3;
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (e3 = s2.call(this)).tag = t3.tag, e3.map = { "xdr:col": new f({ tag: "xdr:col", zero: true }), "xdr:colOff": new f({ tag: "xdr:colOff", zero: true }), "xdr:row": new f({ tag: "xdr:row", zero: true }), "xdr:rowOff": new f({ tag: "xdr:rowOff", zero: true }) }, e3;
        }
        return e2 = u2, (r2 = [{ key: "render", value: function(t3, e3) {
          t3.openNode(this.tag), this.map["xdr:col"].render(t3, e3.nativeCol), this.map["xdr:colOff"].render(t3, e3.nativeColOff), this.map["xdr:row"].render(t3, e3.nativeRow), this.map["xdr:rowOff"].render(t3, e3.nativeRowOff), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          if (this.parser)
            return this.parser.parseOpen(t3), true;
          switch (t3.name) {
            case this.tag:
              this.reset();
              break;
            default:
              this.parser = this.map[t3.name], this.parser && this.parser.parseOpen(t3);
          }
          return true;
        } }, { key: "parseText", value: function(t3) {
          this.parser && this.parser.parseText(t3);
        } }, { key: "parseClose", value: function(t3) {
          if (this.parser)
            return this.parser.parseClose(t3) || (this.parser = void 0), true;
          switch (t3) {
            case this.tag:
              return this.model = { nativeCol: this.map["xdr:col"].model, nativeColOff: this.map["xdr:colOff"].model, nativeRow: this.map["xdr:row"].model, nativeRowOff: this.map["xdr:rowOff"].model }, false;
            default:
              return true;
          }
        } }]) && i(e2.prototype, r2), u2;
      }(c);
      e.exports = l;
    }, { "../base-xform": 31, "../simple/integer-xform": 117 }], 61: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("../../../utils/col-cache"), f = t("../../../utils/xml-stream"), l = t("../base-xform"), h = t("./two-cell-anchor-xform"), d = t("./one-cell-anchor-xform");
      var p = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2() {
          var t3;
          return function(t4, e3) {
            if (!(t4 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (t3 = s2.call(this)).map = { "xdr:twoCellAnchor": new h(), "xdr:oneCellAnchor": new d() }, t3;
        }
        return e2 = u2, (r2 = [{ key: "prepare", value: function(t3) {
          var e3 = this;
          t3.anchors.forEach(function(t4, r3) {
            t4.anchorType = function(t5) {
              return (typeof t5.range == "string" ? c.decode(t5.range) : t5.range).br ? "xdr:twoCellAnchor" : "xdr:oneCellAnchor";
            }(t4), e3.map[t4.anchorType].prepare(t4, { index: r3 });
          });
        } }, { key: "render", value: function(t3, e3) {
          var r3 = this;
          t3.openXml(f.StdDocAttributes), t3.openNode(this.tag, u2.DRAWING_ATTRIBUTES), e3.anchors.forEach(function(e4) {
            r3.map[e4.anchorType].render(t3, e4);
          }), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          if (this.parser)
            return this.parser.parseOpen(t3), true;
          switch (t3.name) {
            case this.tag:
              this.reset(), this.model = { anchors: [] };
              break;
            default:
              this.parser = this.map[t3.name], this.parser && this.parser.parseOpen(t3);
          }
          return true;
        } }, { key: "parseText", value: function(t3) {
          this.parser && this.parser.parseText(t3);
        } }, { key: "parseClose", value: function(t3) {
          if (this.parser)
            return this.parser.parseClose(t3) || (this.model.anchors.push(this.parser.model), this.parser = void 0), true;
          switch (t3) {
            case this.tag:
              return false;
            default:
              return true;
          }
        } }, { key: "reconcile", value: function(t3, e3) {
          var r3 = this;
          t3.anchors.forEach(function(t4) {
            t4.br ? r3.map["xdr:twoCellAnchor"].reconcile(t4, e3) : r3.map["xdr:oneCellAnchor"].reconcile(t4, e3);
          });
        } }, { key: "tag", get: function() {
          return "xdr:wsDr";
        } }]) && i(e2.prototype, r2), u2;
      }(l);
      p.DRAWING_ATTRIBUTES = { "xmlns:xdr": "http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing", "xmlns:a": "http://schemas.openxmlformats.org/drawingml/2006/main" }, e.exports = p;
    }, { "../../../utils/col-cache": 19, "../../../utils/xml-stream": 27, "../base-xform": 31, "./one-cell-anchor-xform": 66, "./two-cell-anchor-xform": 69 }], 62: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3) {
          t3.openNode(this.tag), t3.openNode("a:ext", { uri: "{FF2B5EF4-FFF2-40B4-BE49-F238E27FC236}" }), t3.leafNode("a16:creationId", { "xmlns:a16": "http://schemas.microsoft.com/office/drawing/2014/main", id: "{00000000-0008-0000-0000-000002000000}" }), t3.closeNode(), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          switch (t3.name) {
            case this.tag:
            default:
              return true;
          }
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function(t3) {
          switch (t3) {
            case this.tag:
              return false;
            default:
              return true;
          }
        } }, { key: "tag", get: function() {
          return "a:extLst";
        } }]) && o(e2.prototype, r2), c2;
      }(t("../base-xform"));
      e.exports = f;
    }, { "../base-xform": 31 }], 63: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("../base-xform"), f = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2(t3) {
          var e3;
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (e3 = s2.call(this)).tag = t3.tag, e3.map = {}, e3;
        }
        return e2 = u2, (r2 = [{ key: "render", value: function(t3, e3) {
          t3.openNode(this.tag);
          var r3 = Math.floor(9525 * e3.width), n3 = Math.floor(9525 * e3.height);
          t3.addAttribute("cx", r3), t3.addAttribute("cy", n3), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          return t3.name === this.tag && (this.model = { width: parseInt(t3.attributes.cx || "0", 10) / 9525, height: parseInt(t3.attributes.cy || "0", 10) / 9525 }, true);
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function() {
          return false;
        } }]) && i(e2.prototype, r2), u2;
      }(c);
      e.exports = f;
    }, { "../base-xform": 31 }], 64: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          e3.hyperlinks && e3.hyperlinks.rId && t3.leafNode(this.tag, { "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships", "r:id": e3.hyperlinks.rId, tooltip: e3.hyperlinks.tooltip });
        } }, { key: "parseOpen", value: function(t3) {
          switch (t3.name) {
            case this.tag:
              return this.model = { hyperlinks: { rId: t3.attributes["r:id"], tooltip: t3.attributes.tooltip } }, true;
            default:
              return true;
          }
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function() {
          return false;
        } }, { key: "tag", get: function() {
          return "a:hlinkClick";
        } }]) && o(e2.prototype, r2), c2;
      }(t("../base-xform"));
      e.exports = f;
    }, { "../base-xform": 31 }], 65: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("../base-xform"), f = t("./c-nv-pr-xform"), l = t("./c-nv-pic-pr-xform"), h = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2() {
          var t3;
          return function(t4, e3) {
            if (!(t4 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (t3 = s2.call(this)).map = { "xdr:cNvPr": new f(), "xdr:cNvPicPr": new l() }, t3;
        }
        return e2 = u2, (r2 = [{ key: "render", value: function(t3, e3) {
          t3.openNode(this.tag), this.map["xdr:cNvPr"].render(t3, e3), this.map["xdr:cNvPicPr"].render(t3, e3), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          if (this.parser)
            return this.parser.parseOpen(t3), true;
          switch (t3.name) {
            case this.tag:
              this.reset();
              break;
            default:
              this.parser = this.map[t3.name], this.parser && this.parser.parseOpen(t3);
          }
          return true;
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function(t3) {
          if (this.parser)
            return this.parser.parseClose(t3) || (this.parser = void 0), true;
          switch (t3) {
            case this.tag:
              return this.model = this.map["xdr:cNvPr"].model, false;
            default:
              return true;
          }
        } }, { key: "tag", get: function() {
          return "xdr:nvPicPr";
        } }]) && i(e2.prototype, r2), u2;
      }(c);
      e.exports = h;
    }, { "../base-xform": 31, "./c-nv-pic-pr-xform": 58, "./c-nv-pr-xform": 59 }], 66: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("./base-cell-anchor-xform"), f = t("../static-xform"), l = t("./cell-position-xform"), h = t("./ext-xform"), d = t("./pic-xform"), p = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2() {
          var t3;
          return function(t4, e3) {
            if (!(t4 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (t3 = s2.call(this)).map = { "xdr:from": new l({ tag: "xdr:from" }), "xdr:ext": new h({ tag: "xdr:ext" }), "xdr:pic": new d(), "xdr:clientData": new f({ tag: "xdr:clientData" }) }, t3;
        }
        return e2 = u2, (r2 = [{ key: "prepare", value: function(t3, e3) {
          this.map["xdr:pic"].prepare(t3.picture, e3);
        } }, { key: "render", value: function(t3, e3) {
          t3.openNode(this.tag, { editAs: e3.range.editAs || "oneCell" }), this.map["xdr:from"].render(t3, e3.range.tl), this.map["xdr:ext"].render(t3, e3.range.ext), this.map["xdr:pic"].render(t3, e3.picture), this.map["xdr:clientData"].render(t3, {}), t3.closeNode();
        } }, { key: "parseClose", value: function(t3) {
          if (this.parser)
            return this.parser.parseClose(t3) || (this.parser = void 0), true;
          switch (t3) {
            case this.tag:
              return this.model.range.tl = this.map["xdr:from"].model, this.model.range.ext = this.map["xdr:ext"].model, this.model.picture = this.map["xdr:pic"].model, false;
            default:
              return true;
          }
        } }, { key: "reconcile", value: function(t3, e3) {
          t3.medium = this.reconcilePicture(t3.picture, e3);
        } }, { key: "tag", get: function() {
          return "xdr:oneCellAnchor";
        } }]) && i(e2.prototype, r2), u2;
      }(c);
      e.exports = p;
    }, { "../static-xform": 119, "./base-cell-anchor-xform": 55, "./cell-position-xform": 60, "./ext-xform": 63, "./pic-xform": 67 }], 67: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("../base-xform"), f = t("../static-xform"), l = t("./blip-fill-xform"), h = t("./nv-pic-pr-xform"), d = t("./sp-pr"), p = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2() {
          var t3;
          return function(t4, e3) {
            if (!(t4 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (t3 = s2.call(this)).map = { "xdr:nvPicPr": new h(), "xdr:blipFill": new l(), "xdr:spPr": new f(d) }, t3;
        }
        return e2 = u2, (r2 = [{ key: "prepare", value: function(t3, e3) {
          t3.index = e3.index + 1;
        } }, { key: "render", value: function(t3, e3) {
          t3.openNode(this.tag), this.map["xdr:nvPicPr"].render(t3, e3), this.map["xdr:blipFill"].render(t3, e3), this.map["xdr:spPr"].render(t3, e3), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          if (this.parser)
            return this.parser.parseOpen(t3), true;
          switch (t3.name) {
            case this.tag:
              this.reset();
              break;
            default:
              this.parser = this.map[t3.name], this.parser && this.parser.parseOpen(t3);
          }
          return true;
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function(t3) {
          if (this.parser)
            return this.parser.parseClose(t3) || (this.mergeModel(this.parser.model), this.parser = void 0), true;
          switch (t3) {
            case this.tag:
              return false;
            default:
              return true;
          }
        } }, { key: "tag", get: function() {
          return "xdr:pic";
        } }]) && i(e2.prototype, r2), u2;
      }(c);
      e.exports = p;
    }, { "../base-xform": 31, "../static-xform": 119, "./blip-fill-xform": 56, "./nv-pic-pr-xform": 65, "./sp-pr": 68 }], 68: [function(t, e, r) {
      e.exports = { tag: "xdr:spPr", c: [{ tag: "a:xfrm", c: [{ tag: "a:off", $: { x: "0", y: "0" } }, { tag: "a:ext", $: { cx: "0", cy: "0" } }] }, { tag: "a:prstGeom", $: { prst: "rect" }, c: [{ tag: "a:avLst" }] }] };
    }, {}], 69: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("./base-cell-anchor-xform"), f = t("../static-xform"), l = t("./cell-position-xform"), h = t("./pic-xform"), d = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2() {
          var t3;
          return function(t4, e3) {
            if (!(t4 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (t3 = s2.call(this)).map = { "xdr:from": new l({ tag: "xdr:from" }), "xdr:to": new l({ tag: "xdr:to" }), "xdr:pic": new h(), "xdr:clientData": new f({ tag: "xdr:clientData" }) }, t3;
        }
        return e2 = u2, (r2 = [{ key: "prepare", value: function(t3, e3) {
          this.map["xdr:pic"].prepare(t3.picture, e3);
        } }, { key: "render", value: function(t3, e3) {
          t3.openNode(this.tag, { editAs: e3.range.editAs || "oneCell" }), this.map["xdr:from"].render(t3, e3.range.tl), this.map["xdr:to"].render(t3, e3.range.br), this.map["xdr:pic"].render(t3, e3.picture), this.map["xdr:clientData"].render(t3, {}), t3.closeNode();
        } }, { key: "parseClose", value: function(t3) {
          if (this.parser)
            return this.parser.parseClose(t3) || (this.parser = void 0), true;
          switch (t3) {
            case this.tag:
              return this.model.range.tl = this.map["xdr:from"].model, this.model.range.br = this.map["xdr:to"].model, this.model.picture = this.map["xdr:pic"].model, false;
            default:
              return true;
          }
        } }, { key: "reconcile", value: function(t3, e3) {
          t3.medium = this.reconcilePicture(t3.picture, e3);
        } }, { key: "tag", get: function() {
          return "xdr:twoCellAnchor";
        } }]) && i(e2.prototype, r2), u2;
      }(c);
      e.exports = d;
    }, { "../static-xform": 119, "./base-cell-anchor-xform": 55, "./cell-position-xform": 60, "./pic-xform": 67 }], 70: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2(t3) {
          var e3;
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (e3 = s2.call(this)).tag = t3.tag, e3.always = !!t3.always, e3.count = t3.count, e3.empty = t3.empty, e3.$count = t3.$count || "count", e3.$ = t3.$, e3.childXform = t3.childXform, e3.maxItems = t3.maxItems, e3;
        }
        return e2 = u2, (r2 = [{ key: "prepare", value: function(t3, e3) {
          var r3 = this.childXform;
          t3 && t3.forEach(function(t4, n3) {
            e3.index = n3, r3.prepare(t4, e3);
          });
        } }, { key: "render", value: function(t3, e3) {
          if (this.always || e3 && e3.length) {
            t3.openNode(this.tag, this.$), this.count && t3.addAttribute(this.$count, e3 && e3.length || 0);
            var r3 = this.childXform;
            (e3 || []).forEach(function(e4, n3) {
              r3.render(t3, e4, n3);
            }), t3.closeNode();
          } else
            this.empty && t3.leafNode(this.tag);
        } }, { key: "parseOpen", value: function(t3) {
          if (this.parser)
            return this.parser.parseOpen(t3), true;
          switch (t3.name) {
            case this.tag:
              return this.model = [], true;
            default:
              return !!this.childXform.parseOpen(t3) && (this.parser = this.childXform, true);
          }
        } }, { key: "parseText", value: function(t3) {
          this.parser && this.parser.parseText(t3);
        } }, { key: "parseClose", value: function(t3) {
          if (this.parser) {
            if (!this.parser.parseClose(t3) && (this.model.push(this.parser.model), this.parser = void 0, this.maxItems && this.model.length > this.maxItems))
              throw new Error("Max ".concat(this.childXform.tag, " count (").concat(this.maxItems, ") exceeded"));
            return true;
          }
          return false;
        } }, { key: "reconcile", value: function(t3, e3) {
          if (t3) {
            var r3 = this.childXform;
            t3.forEach(function(t4) {
              r3.reconcile(t4, e3);
            });
          }
        } }]) && i(e2.prototype, r2), u2;
      }(t("./base-xform"));
      e.exports = c;
    }, { "./base-xform": 31 }], 71: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = t("../../../utils/col-cache"), l = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          if (e3)
            if (typeof e3 == "string")
              t3.leafNode("autoFilter", { ref: e3 });
            else {
              var r3 = function(t4) {
                return typeof t4 == "string" ? t4 : f.getAddress(t4.row, t4.column).address;
              }, n3 = r3(e3.from), i2 = r3(e3.to);
              n3 && i2 && t3.leafNode("autoFilter", { ref: "".concat(n3, ":").concat(i2) });
            }
        } }, { key: "parseOpen", value: function(t3) {
          t3.name === "autoFilter" && (this.model = t3.attributes.ref);
        } }, { key: "tag", get: function() {
          return "autoFilter";
        } }]) && o(e2.prototype, r2), c2;
      }(t("../base-xform"));
      e.exports = l;
    }, { "../../../utils/col-cache": 19, "../base-xform": 31 }], 72: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        var r2 = Object.keys(t2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t2);
          e2 && (n2 = n2.filter(function(e3) {
            return Object.getOwnPropertyDescriptor(t2, e3).enumerable;
          })), r2.push.apply(r2, n2);
        }
        return r2;
      }
      function o(t2) {
        for (var e2 = 1; e2 < arguments.length; e2++) {
          var r2 = arguments[e2] != null ? arguments[e2] : {};
          e2 % 2 ? i(Object(r2), true).forEach(function(e3) {
            a(t2, e3, r2[e3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(r2)) : i(Object(r2)).forEach(function(e3) {
            Object.defineProperty(t2, e3, Object.getOwnPropertyDescriptor(r2, e3));
          });
        }
        return t2;
      }
      function a(t2, e2, r2) {
        return e2 in t2 ? Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }) : t2[e2] = r2, t2;
      }
      function s(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function u(t2, e2) {
        return (u = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function c(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = l(t2);
          if (e2) {
            var i2 = l(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return f(this, r2);
        };
      }
      function f(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function l(t2) {
        return (l = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var h = t("../../../utils/utils"), d = t("../base-xform"), p = t("../../../doc/range"), m = t("../../../doc/enums"), y = t("../strings/rich-text-xform");
      function b(t2) {
        if (t2 == null)
          return m.ValueType.Null;
        if (t2 instanceof String || typeof t2 == "string")
          return m.ValueType.String;
        if (typeof t2 == "number")
          return m.ValueType.Number;
        if (typeof t2 == "boolean")
          return m.ValueType.Boolean;
        if (t2 instanceof Date)
          return m.ValueType.Date;
        if (t2.text && t2.hyperlink)
          return m.ValueType.Hyperlink;
        if (t2.formula)
          return m.ValueType.Formula;
        if (t2.error)
          return m.ValueType.Error;
        throw new Error("I could not understand type of value");
      }
      var v = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && u(t3, e3);
        }(a2, t2);
        var e2, r2, i2 = c(a2);
        function a2() {
          var t3;
          return function(t4, e3) {
            if (!(t4 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), (t3 = i2.call(this)).richTextXForm = new y(), t3;
        }
        return e2 = a2, (r2 = [{ key: "prepare", value: function(t3, e3) {
          var r3 = e3.styles.addStyleModel(t3.style || {}, function(t4) {
            switch (t4.type) {
              case m.ValueType.Formula:
                return b(t4.result);
              default:
                return t4.type;
            }
          }(t3));
          switch (r3 && (t3.styleId = r3), t3.comment && e3.comments.push(o(o({}, t3.comment), {}, { ref: t3.address })), t3.type) {
            case m.ValueType.String:
            case m.ValueType.RichText:
              e3.sharedStrings && (t3.ssId = e3.sharedStrings.add(t3.value));
              break;
            case m.ValueType.Date:
              e3.date1904 && (t3.date1904 = true);
              break;
            case m.ValueType.Hyperlink:
              e3.sharedStrings && t3.text !== void 0 && t3.text !== null && (t3.ssId = e3.sharedStrings.add(t3.text)), e3.hyperlinks.push({ address: t3.address, target: t3.hyperlink, tooltip: t3.tooltip });
              break;
            case m.ValueType.Merge:
              e3.merges.add(t3);
              break;
            case m.ValueType.Formula:
              if (e3.date1904 && (t3.date1904 = true), t3.shareType === "shared" && (t3.si = e3.siFormulae++), t3.formula)
                e3.formulae[t3.address] = t3;
              else if (t3.sharedFormula) {
                var n3 = e3.formulae[t3.sharedFormula];
                if (!n3)
                  throw new Error("Shared Formula master must exist above and or left of clone for cell ".concat(t3.address));
                n3.si === void 0 ? (n3.shareType = "shared", n3.si = e3.siFormulae++, n3.range = new p(n3.address, t3.address)) : n3.range && n3.range.expandToAddress(t3.address), t3.si = n3.si;
              }
          }
        } }, { key: "renderFormula", value: function(t3, e3) {
          var r3 = null;
          switch (e3.shareType) {
            case "shared":
              r3 = { t: "shared", ref: e3.ref || e3.range.range, si: e3.si };
              break;
            case "array":
              r3 = { t: "array", ref: e3.ref };
              break;
            default:
              e3.si !== void 0 && (r3 = { t: "shared", si: e3.si });
          }
          switch (b(e3.result)) {
            case m.ValueType.Null:
              t3.leafNode("f", r3, e3.formula);
              break;
            case m.ValueType.String:
              t3.addAttribute("t", "str"), t3.leafNode("f", r3, e3.formula), t3.leafNode("v", null, e3.result);
              break;
            case m.ValueType.Number:
              t3.leafNode("f", r3, e3.formula), t3.leafNode("v", null, e3.result);
              break;
            case m.ValueType.Boolean:
              t3.addAttribute("t", "b"), t3.leafNode("f", r3, e3.formula), t3.leafNode("v", null, e3.result ? 1 : 0);
              break;
            case m.ValueType.Error:
              t3.addAttribute("t", "e"), t3.leafNode("f", r3, e3.formula), t3.leafNode("v", null, e3.result.error);
              break;
            case m.ValueType.Date:
              t3.leafNode("f", r3, e3.formula), t3.leafNode("v", null, h.dateToExcel(e3.result, e3.date1904));
              break;
            default:
              throw new Error("I could not understand type of value");
          }
        } }, { key: "render", value: function(t3, e3) {
          var r3 = this;
          if (e3.type !== m.ValueType.Null || e3.styleId) {
            switch (t3.openNode("c"), t3.addAttribute("r", e3.address), e3.styleId && t3.addAttribute("s", e3.styleId), e3.type) {
              case m.ValueType.Null:
                break;
              case m.ValueType.Number:
                t3.leafNode("v", null, e3.value);
                break;
              case m.ValueType.Boolean:
                t3.addAttribute("t", "b"), t3.leafNode("v", null, e3.value ? "1" : "0");
                break;
              case m.ValueType.Error:
                t3.addAttribute("t", "e"), t3.leafNode("v", null, e3.value.error);
                break;
              case m.ValueType.String:
              case m.ValueType.RichText:
                e3.ssId !== void 0 ? (t3.addAttribute("t", "s"), t3.leafNode("v", null, e3.ssId)) : e3.value && e3.value.richText ? (t3.addAttribute("t", "inlineStr"), t3.openNode("is"), e3.value.richText.forEach(function(e4) {
                  r3.richTextXForm.render(t3, e4);
                }), t3.closeNode("is")) : (t3.addAttribute("t", "str"), t3.leafNode("v", null, e3.value));
                break;
              case m.ValueType.Date:
                t3.leafNode("v", null, h.dateToExcel(e3.value, e3.date1904));
                break;
              case m.ValueType.Hyperlink:
                e3.ssId !== void 0 ? (t3.addAttribute("t", "s"), t3.leafNode("v", null, e3.ssId)) : (t3.addAttribute("t", "str"), t3.leafNode("v", null, e3.text));
                break;
              case m.ValueType.Formula:
                this.renderFormula(t3, e3);
                break;
              case m.ValueType.Merge:
            }
            t3.closeNode();
          }
        } }, { key: "parseOpen", value: function(t3) {
          if (this.parser)
            return this.parser.parseOpen(t3), true;
          switch (t3.name) {
            case "c":
              return this.model = { address: t3.attributes.r }, this.t = t3.attributes.t, t3.attributes.s && (this.model.styleId = parseInt(t3.attributes.s, 10)), true;
            case "f":
              return this.currentNode = "f", this.model.si = t3.attributes.si, this.model.shareType = t3.attributes.t, this.model.ref = t3.attributes.ref, true;
            case "v":
              return this.currentNode = "v", true;
            case "t":
              return this.currentNode = "t", true;
            case "r":
              return this.parser = this.richTextXForm, this.parser.parseOpen(t3), true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function(t3) {
          if (this.parser)
            this.parser.parseText(t3);
          else
            switch (this.currentNode) {
              case "f":
                this.model.formula = this.model.formula ? this.model.formula + t3 : t3;
                break;
              case "v":
              case "t":
                this.model.value && this.model.value.richText ? this.model.value.richText.text = this.model.value.richText.text ? this.model.value.richText.text + t3 : t3 : this.model.value = this.model.value ? this.model.value + t3 : t3;
            }
        } }, { key: "parseClose", value: function(t3) {
          switch (t3) {
            case "c":
              var e3 = this.model;
              if (e3.formula || e3.shareType)
                e3.type = m.ValueType.Formula, e3.value && (this.t === "str" ? e3.result = h.xmlDecode(e3.value) : this.t === "b" ? e3.result = parseInt(e3.value, 10) !== 0 : this.t === "e" ? e3.result = { error: e3.value } : e3.result = parseFloat(e3.value), e3.value = void 0);
              else if (e3.value !== void 0)
                switch (this.t) {
                  case "s":
                    e3.type = m.ValueType.String, e3.value = parseInt(e3.value, 10);
                    break;
                  case "str":
                    e3.type = m.ValueType.String, e3.value = h.xmlDecode(e3.value);
                    break;
                  case "inlineStr":
                    e3.type = m.ValueType.String;
                    break;
                  case "b":
                    e3.type = m.ValueType.Boolean, e3.value = parseInt(e3.value, 10) !== 0;
                    break;
                  case "e":
                    e3.type = m.ValueType.Error, e3.value = { error: e3.value };
                    break;
                  default:
                    e3.type = m.ValueType.Number, e3.value = parseFloat(e3.value);
                }
              else
                e3.styleId ? e3.type = m.ValueType.Null : e3.type = m.ValueType.Merge;
              return false;
            case "f":
            case "v":
            case "is":
              return this.currentNode = void 0, true;
            case "t":
              return this.parser ? (this.parser.parseClose(t3), true) : (this.currentNode = void 0, true);
            case "r":
              return this.model.value = this.model.value || {}, this.model.value.richText = this.model.value.richText || [], this.model.value.richText.push(this.parser.model), this.parser = void 0, this.currentNode = void 0, true;
            default:
              return !!this.parser && (this.parser.parseClose(t3), true);
          }
        } }, { key: "reconcile", value: function(t3, e3) {
          var r3 = t3.styleId && e3.styles && e3.styles.getStyleModel(t3.styleId);
          switch (r3 && (t3.style = r3), t3.styleId !== void 0 && (t3.styleId = void 0), t3.type) {
            case m.ValueType.String:
              typeof t3.value == "number" && e3.sharedStrings && (t3.value = e3.sharedStrings.getString(t3.value)), t3.value.richText && (t3.type = m.ValueType.RichText);
              break;
            case m.ValueType.Number:
              r3 && h.isDateFmt(r3.numFmt) && (t3.type = m.ValueType.Date, t3.value = h.excelToDate(t3.value, e3.date1904));
              break;
            case m.ValueType.Formula:
              t3.result !== void 0 && r3 && h.isDateFmt(r3.numFmt) && (t3.result = h.excelToDate(t3.result, e3.date1904)), t3.shareType === "shared" && (t3.ref ? e3.formulae[t3.si] = t3.address : (t3.sharedFormula = e3.formulae[t3.si], delete t3.shareType), delete t3.si);
          }
          var n3 = e3.hyperlinkMap[t3.address];
          n3 && (t3.type === m.ValueType.Formula ? (t3.text = t3.result, t3.result = void 0) : (t3.text = t3.value, t3.value = void 0), t3.type = m.ValueType.Hyperlink, t3.hyperlink = n3);
          var i3 = e3.commentsMap && e3.commentsMap[t3.address];
          i3 && (t3.comment = i3);
        } }, { key: "tag", get: function() {
          return "c";
        } }]) && s(e2.prototype, r2), a2;
      }(d);
      e.exports = v;
    }, { "../../../doc/enums": 7, "../../../doc/range": 10, "../../../utils/utils": 26, "../base-xform": 31, "../strings/rich-text-xform": 121 }], 73: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = t("../../base-xform"), l = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          t3.leafNode(this.tag, { iconSet: e3.iconSet, iconId: e3.iconId });
        } }, { key: "parseOpen", value: function(t3) {
          var e3 = t3.attributes;
          this.model = { iconSet: e3.iconSet, iconId: f.toIntValue(e3.iconId) };
        } }, { key: "parseClose", value: function(t3) {
          return t3 !== this.tag;
        } }, { key: "tag", get: function() {
          return "x14:cfIcon";
        } }]) && o(e2.prototype, r2), c2;
      }(f);
      e.exports = l;
    }, { "../../base-xform": 31 }], 74: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("uuid").v4, f = t("../../base-xform"), l = t("../../composite-xform"), h = t("./databar-ext-xform"), d = t("./icon-set-ext-xform"), p = { "3Triangles": true, "3Stars": true, "5Boxes": true }, m = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, n2, s2 = a(u2);
        function u2() {
          var t3;
          return function(t4, e3) {
            if (!(t4 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (t3 = s2.call(this)).map = { "x14:dataBar": t3.databarXform = new h(), "x14:iconSet": t3.iconSetXform = new d() }, t3;
        }
        return e2 = u2, n2 = [{ key: "isExt", value: function(t3) {
          return t3.type === "dataBar" ? h.isExt(t3) : !(t3.type !== "iconSet" || !t3.custom && !p[t3.iconSet]);
        } }], (r2 = [{ key: "prepare", value: function(t3) {
          u2.isExt(t3) && (t3.x14Id = "{".concat(c(), "}").toUpperCase());
        } }, { key: "render", value: function(t3, e3) {
          if (u2.isExt(e3))
            switch (e3.type) {
              case "dataBar":
                this.renderDataBar(t3, e3);
                break;
              case "iconSet":
                this.renderIconSet(t3, e3);
            }
        } }, { key: "renderDataBar", value: function(t3, e3) {
          t3.openNode(this.tag, { type: "dataBar", id: e3.x14Id }), this.databarXform.render(t3, e3), t3.closeNode();
        } }, { key: "renderIconSet", value: function(t3, e3) {
          t3.openNode(this.tag, { type: "iconSet", priority: e3.priority, id: e3.x14Id || "{".concat(c(), "}") }), this.iconSetXform.render(t3, e3), t3.closeNode();
        } }, { key: "createNewModel", value: function(t3) {
          var e3 = t3.attributes;
          return { type: e3.type, x14Id: e3.id, priority: f.toIntValue(e3.priority) };
        } }, { key: "onParserClose", value: function(t3, e3) {
          Object.assign(this.model, e3.model);
        } }, { key: "tag", get: function() {
          return "x14:cfRule";
        } }]) && i(e2.prototype, r2), n2 && i(e2, n2), u2;
      }(l);
      e.exports = m;
    }, { "../../base-xform": 31, "../../composite-xform": 47, "./databar-ext-xform": 78, "./icon-set-ext-xform": 80, uuid: 526 }], 75: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("../../composite-xform"), f = t("./f-ext-xform"), l = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2() {
          var t3;
          return function(t4, e3) {
            if (!(t4 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (t3 = s2.call(this)).map = { "xm:f": t3.fExtXform = new f() }, t3;
        }
        return e2 = u2, (r2 = [{ key: "render", value: function(t3, e3) {
          t3.openNode(this.tag, { type: e3.type }), e3.value !== void 0 && this.fExtXform.render(t3, e3.value), t3.closeNode();
        } }, { key: "createNewModel", value: function(t3) {
          return { type: t3.attributes.type };
        } }, { key: "onParserClose", value: function(t3, e3) {
          switch (t3) {
            case "xm:f":
              this.model.value = e3.model ? parseFloat(e3.model) : 0;
          }
        } }, { key: "tag", get: function() {
          return "x14:cfvo";
        } }]) && i(e2.prototype, r2), u2;
      }(c);
      e.exports = l;
    }, { "../../composite-xform": 47, "./f-ext-xform": 79 }], 76: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("../../composite-xform"), f = t("./sqref-ext-xform"), l = t("./cf-rule-ext-xform"), h = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2() {
          var t3;
          return function(t4, e3) {
            if (!(t4 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (t3 = s2.call(this)).map = { "xm:sqref": t3.sqRef = new f(), "x14:cfRule": t3.cfRule = new l() }, t3;
        }
        return e2 = u2, (r2 = [{ key: "prepare", value: function(t3, e3) {
          var r3 = this;
          t3.rules.forEach(function(t4) {
            r3.cfRule.prepare(t4, e3);
          });
        } }, { key: "render", value: function(t3, e3) {
          var r3 = this;
          e3.rules.some(l.isExt) && (t3.openNode(this.tag, { "xmlns:xm": "http://schemas.microsoft.com/office/excel/2006/main" }), e3.rules.filter(l.isExt).forEach(function(e4) {
            return r3.cfRule.render(t3, e4);
          }), this.sqRef.render(t3, e3.ref), t3.closeNode());
        } }, { key: "createNewModel", value: function() {
          return { rules: [] };
        } }, { key: "onParserClose", value: function(t3, e3) {
          switch (t3) {
            case "xm:sqref":
              this.model.ref = e3.model;
              break;
            case "x14:cfRule":
              this.model.rules.push(e3.model);
          }
        } }, { key: "tag", get: function() {
          return "x14:conditionalFormatting";
        } }]) && i(e2.prototype, r2), u2;
      }(c);
      e.exports = h;
    }, { "../../composite-xform": 47, "./cf-rule-ext-xform": 74, "./sqref-ext-xform": 81 }], 77: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("../../composite-xform"), f = t("./cf-rule-ext-xform"), l = t("./conditional-formatting-ext-xform"), h = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2() {
          var t3;
          return function(t4, e3) {
            if (!(t4 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (t3 = s2.call(this)).map = { "x14:conditionalFormatting": t3.cfXform = new l() }, t3;
        }
        return e2 = u2, (r2 = [{ key: "hasContent", value: function(t3) {
          return t3.hasExtContent === void 0 && (t3.hasExtContent = t3.some(function(t4) {
            return t4.rules.some(f.isExt);
          })), t3.hasExtContent;
        } }, { key: "prepare", value: function(t3, e3) {
          var r3 = this;
          t3.forEach(function(t4) {
            r3.cfXform.prepare(t4, e3);
          });
        } }, { key: "render", value: function(t3, e3) {
          var r3 = this;
          this.hasContent(e3) && (t3.openNode(this.tag), e3.forEach(function(e4) {
            return r3.cfXform.render(t3, e4);
          }), t3.closeNode());
        } }, { key: "createNewModel", value: function() {
          return [];
        } }, { key: "onParserClose", value: function(t3, e3) {
          this.model.push(e3.model);
        } }, { key: "tag", get: function() {
          return "x14:conditionalFormattings";
        } }]) && i(e2.prototype, r2), u2;
      }(c);
      e.exports = h;
    }, { "../../composite-xform": 47, "./cf-rule-ext-xform": 74, "./conditional-formatting-ext-xform": 76 }], 78: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        return function(t3) {
          if (Array.isArray(t3))
            return t3;
        }(t2) || function(t3, e3) {
          if (typeof Symbol == "undefined" || !(Symbol.iterator in Object(t3)))
            return;
          var r2 = [], n2 = true, i2 = false, o2 = void 0;
          try {
            for (var a2, s2 = t3[Symbol.iterator](); !(n2 = (a2 = s2.next()).done) && (r2.push(a2.value), !e3 || r2.length !== e3); n2 = true)
              ;
          } catch (t4) {
            i2 = true, o2 = t4;
          } finally {
            try {
              n2 || s2.return == null || s2.return();
            } finally {
              if (i2)
                throw o2;
            }
          }
          return r2;
        }(t2, e2) || function(t3, e3) {
          if (!t3)
            return;
          if (typeof t3 == "string")
            return o(t3, e3);
          var r2 = Object.prototype.toString.call(t3).slice(8, -1);
          r2 === "Object" && t3.constructor && (r2 = t3.constructor.name);
          if (r2 === "Map" || r2 === "Set")
            return Array.from(t3);
          if (r2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
            return o(t3, e3);
        }(t2, e2) || function() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function o(t2, e2) {
        (e2 == null || e2 > t2.length) && (e2 = t2.length);
        for (var r2 = 0, n2 = new Array(e2); r2 < e2; r2++)
          n2[r2] = t2[r2];
        return n2;
      }
      function a(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function s(t2, e2) {
        return (s = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function u(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = f(t2);
          if (e2) {
            var i2 = f(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return c(this, r2);
        };
      }
      function c(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function f(t2) {
        return (f = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var l = t("../../base-xform"), h = t("../../composite-xform"), d = t("../../style/color-xform"), p = t("./cfvo-ext-xform"), m = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && s(t3, e3);
        }(c2, t2);
        var e2, r2, n2, o2 = u(c2);
        function c2() {
          var t3;
          return function(t4, e3) {
            if (!(t4 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, c2), (t3 = o2.call(this)).map = { "x14:cfvo": t3.cfvoXform = new p(), "x14:borderColor": t3.borderColorXform = new d("x14:borderColor"), "x14:negativeBorderColor": t3.negativeBorderColorXform = new d("x14:negativeBorderColor"), "x14:negativeFillColor": t3.negativeFillColorXform = new d("x14:negativeFillColor"), "x14:axisColor": t3.axisColorXform = new d("x14:axisColor") }, t3;
        }
        return e2 = c2, n2 = [{ key: "isExt", value: function(t3) {
          return !t3.gradient;
        } }], (r2 = [{ key: "render", value: function(t3, e3) {
          var r3 = this;
          t3.openNode(this.tag, { minLength: l.toIntAttribute(e3.minLength, 0, true), maxLength: l.toIntAttribute(e3.maxLength, 100, true), border: l.toBoolAttribute(e3.border, false), gradient: l.toBoolAttribute(e3.gradient, true), negativeBarColorSameAsPositive: l.toBoolAttribute(e3.negativeBarColorSameAsPositive, true), negativeBarBorderColorSameAsPositive: l.toBoolAttribute(e3.negativeBarBorderColorSameAsPositive, true), axisPosition: l.toAttribute(e3.axisPosition, "auto"), direction: l.toAttribute(e3.direction, "leftToRight") }), e3.cfvo.forEach(function(e4) {
            r3.cfvoXform.render(t3, e4);
          }), this.borderColorXform.render(t3, e3.borderColor), this.negativeBorderColorXform.render(t3, e3.negativeBorderColor), this.negativeFillColorXform.render(t3, e3.negativeFillColor), this.axisColorXform.render(t3, e3.axisColor), t3.closeNode();
        } }, { key: "createNewModel", value: function(t3) {
          var e3 = t3.attributes;
          return { cfvo: [], minLength: l.toIntValue(e3.minLength, 0), maxLength: l.toIntValue(e3.maxLength, 100), border: l.toBoolValue(e3.border, false), gradient: l.toBoolValue(e3.gradient, true), negativeBarColorSameAsPositive: l.toBoolValue(e3.negativeBarColorSameAsPositive, true), negativeBarBorderColorSameAsPositive: l.toBoolValue(e3.negativeBarBorderColorSameAsPositive, true), axisPosition: l.toStringValue(e3.axisPosition, "auto"), direction: l.toStringValue(e3.direction, "leftToRight") };
        } }, { key: "onParserClose", value: function(t3, e3) {
          var r3 = i(t3.split(":"), 2)[1];
          switch (r3) {
            case "cfvo":
              this.model.cfvo.push(e3.model);
              break;
            default:
              this.model[r3] = e3.model;
          }
        } }, { key: "tag", get: function() {
          return "x14:dataBar";
        } }]) && a(e2.prototype, r2), n2 && a(e2, n2), c2;
      }(h);
      e.exports = m;
    }, { "../../base-xform": 31, "../../composite-xform": 47, "../../style/color-xform": 127, "./cfvo-ext-xform": 75 }], 79: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          t3.leafNode(this.tag, null, e3);
        } }, { key: "parseOpen", value: function() {
          this.model = "";
        } }, { key: "parseText", value: function(t3) {
          this.model += t3;
        } }, { key: "parseClose", value: function(t3) {
          return t3 !== this.tag;
        } }, { key: "tag", get: function() {
          return "xm:f";
        } }]) && o(e2.prototype, r2), c2;
      }(t("../../base-xform"));
      e.exports = f;
    }, { "../../base-xform": 31 }], 80: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        return function(t3) {
          if (Array.isArray(t3))
            return t3;
        }(t2) || function(t3, e3) {
          if (typeof Symbol == "undefined" || !(Symbol.iterator in Object(t3)))
            return;
          var r2 = [], n2 = true, i2 = false, o2 = void 0;
          try {
            for (var a2, s2 = t3[Symbol.iterator](); !(n2 = (a2 = s2.next()).done) && (r2.push(a2.value), !e3 || r2.length !== e3); n2 = true)
              ;
          } catch (t4) {
            i2 = true, o2 = t4;
          } finally {
            try {
              n2 || s2.return == null || s2.return();
            } finally {
              if (i2)
                throw o2;
            }
          }
          return r2;
        }(t2, e2) || function(t3, e3) {
          if (!t3)
            return;
          if (typeof t3 == "string")
            return o(t3, e3);
          var r2 = Object.prototype.toString.call(t3).slice(8, -1);
          r2 === "Object" && t3.constructor && (r2 = t3.constructor.name);
          if (r2 === "Map" || r2 === "Set")
            return Array.from(t3);
          if (r2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
            return o(t3, e3);
        }(t2, e2) || function() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function o(t2, e2) {
        (e2 == null || e2 > t2.length) && (e2 = t2.length);
        for (var r2 = 0, n2 = new Array(e2); r2 < e2; r2++)
          n2[r2] = t2[r2];
        return n2;
      }
      function a(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function s(t2, e2) {
        return (s = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function u(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = f(t2);
          if (e2) {
            var i2 = f(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return c(this, r2);
        };
      }
      function c(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function f(t2) {
        return (f = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var l = t("../../base-xform"), h = t("../../composite-xform"), d = t("./cfvo-ext-xform"), p = t("./cf-icon-ext-xform"), m = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && s(t3, e3);
        }(c2, t2);
        var e2, r2, o2 = u(c2);
        function c2() {
          var t3;
          return function(t4, e3) {
            if (!(t4 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, c2), (t3 = o2.call(this)).map = { "x14:cfvo": t3.cfvoXform = new d(), "x14:cfIcon": t3.cfIconXform = new p() }, t3;
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          var r3 = this;
          t3.openNode(this.tag, { iconSet: l.toStringAttribute(e3.iconSet), reverse: l.toBoolAttribute(e3.reverse, false), showValue: l.toBoolAttribute(e3.showValue, true), custom: l.toBoolAttribute(e3.icons, false) }), e3.cfvo.forEach(function(e4) {
            r3.cfvoXform.render(t3, e4);
          }), e3.icons && e3.icons.forEach(function(e4, n3) {
            e4.iconId = n3, r3.cfIconXform.render(t3, e4);
          }), t3.closeNode();
        } }, { key: "createNewModel", value: function(t3) {
          var e3 = t3.attributes;
          return { cfvo: [], iconSet: l.toStringValue(e3.iconSet, "3TrafficLights"), reverse: l.toBoolValue(e3.reverse, false), showValue: l.toBoolValue(e3.showValue, true) };
        } }, { key: "onParserClose", value: function(t3, e3) {
          var r3 = i(t3.split(":"), 2)[1];
          switch (r3) {
            case "cfvo":
              this.model.cfvo.push(e3.model);
              break;
            case "cfIcon":
              this.model.icons || (this.model.icons = []), this.model.icons.push(e3.model);
              break;
            default:
              this.model[r3] = e3.model;
          }
        } }, { key: "tag", get: function() {
          return "x14:iconSet";
        } }]) && a(e2.prototype, r2), c2;
      }(h);
      e.exports = m;
    }, { "../../base-xform": 31, "../../composite-xform": 47, "./cf-icon-ext-xform": 73, "./cfvo-ext-xform": 75 }], 81: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          t3.leafNode(this.tag, null, e3);
        } }, { key: "parseOpen", value: function() {
          this.model = "";
        } }, { key: "parseText", value: function(t3) {
          this.model += t3;
        } }, { key: "parseClose", value: function(t3) {
          return t3 !== this.tag;
        } }, { key: "tag", get: function() {
          return "xm:sqref";
        } }]) && o(e2.prototype, r2), c2;
      }(t("../../base-xform"));
      e.exports = f;
    }, { "../../base-xform": 31 }], 82: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        var r2 = Object.keys(t2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t2);
          e2 && (n2 = n2.filter(function(e3) {
            return Object.getOwnPropertyDescriptor(t2, e3).enumerable;
          })), r2.push.apply(r2, n2);
        }
        return r2;
      }
      function o(t2) {
        for (var e2 = 1; e2 < arguments.length; e2++) {
          var r2 = arguments[e2] != null ? arguments[e2] : {};
          e2 % 2 ? i(Object(r2), true).forEach(function(e3) {
            a(t2, e3, r2[e3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(r2)) : i(Object(r2)).forEach(function(e3) {
            Object.defineProperty(t2, e3, Object.getOwnPropertyDescriptor(r2, e3));
          });
        }
        return t2;
      }
      function a(t2, e2, r2) {
        return e2 in t2 ? Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }) : t2[e2] = r2, t2;
      }
      function s(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function u(t2, e2) {
        return (u = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function c(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = l(t2);
          if (e2) {
            var i2 = l(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return f(this, r2);
        };
      }
      function f(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function l(t2) {
        return (l = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var h = t("../../base-xform"), d = t("../../composite-xform"), p = t("../../../../doc/range"), m = t("./databar-xform"), y = t("./ext-lst-ref-xform"), b = t("./formula-xform"), v = t("./color-scale-xform"), g = t("./icon-set-xform"), w = { "3Triangles": true, "3Stars": true, "5Boxes": true }, _ = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && u(t3, e3);
        }(a2, t2);
        var e2, r2, n2, i2 = c(a2);
        function a2() {
          var t3;
          return function(t4, e3) {
            if (!(t4 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), (t3 = i2.call(this)).map = { dataBar: t3.databarXform = new m(), extLst: t3.extLstRefXform = new y(), formula: t3.formulaXform = new b(), colorScale: t3.colorScaleXform = new v(), iconSet: t3.iconSetXform = new g() }, t3;
        }
        return e2 = a2, n2 = [{ key: "isPrimitive", value: function(t3) {
          return t3.type !== "iconSet" || !t3.custom && !w[t3.iconSet];
        } }], (r2 = [{ key: "render", value: function(t3, e3) {
          switch (e3.type) {
            case "expression":
              this.renderExpression(t3, e3);
              break;
            case "cellIs":
              this.renderCellIs(t3, e3);
              break;
            case "top10":
              this.renderTop10(t3, e3);
              break;
            case "aboveAverage":
              this.renderAboveAverage(t3, e3);
              break;
            case "dataBar":
              this.renderDataBar(t3, e3);
              break;
            case "colorScale":
              this.renderColorScale(t3, e3);
              break;
            case "iconSet":
              this.renderIconSet(t3, e3);
              break;
            case "containsText":
              this.renderText(t3, e3);
              break;
            case "timePeriod":
              this.renderTimePeriod(t3, e3);
          }
        } }, { key: "renderExpression", value: function(t3, e3) {
          t3.openNode(this.tag, { type: "expression", dxfId: e3.dxfId, priority: e3.priority }), this.formulaXform.render(t3, e3.formulae[0]), t3.closeNode();
        } }, { key: "renderCellIs", value: function(t3, e3) {
          var r3 = this;
          t3.openNode(this.tag, { type: "cellIs", dxfId: e3.dxfId, priority: e3.priority, operator: e3.operator }), e3.formulae.forEach(function(e4) {
            r3.formulaXform.render(t3, e4);
          }), t3.closeNode();
        } }, { key: "renderTop10", value: function(t3, e3) {
          t3.leafNode(this.tag, { type: "top10", dxfId: e3.dxfId, priority: e3.priority, percent: h.toBoolAttribute(e3.percent, false), bottom: h.toBoolAttribute(e3.bottom, false), rank: h.toIntValue(e3.rank, 10, true) });
        } }, { key: "renderAboveAverage", value: function(t3, e3) {
          t3.leafNode(this.tag, { type: "aboveAverage", dxfId: e3.dxfId, priority: e3.priority, aboveAverage: h.toBoolAttribute(e3.aboveAverage, true) });
        } }, { key: "renderDataBar", value: function(t3, e3) {
          t3.openNode(this.tag, { type: "dataBar", priority: e3.priority }), this.databarXform.render(t3, e3), this.extLstRefXform.render(t3, e3), t3.closeNode();
        } }, { key: "renderColorScale", value: function(t3, e3) {
          t3.openNode(this.tag, { type: "colorScale", priority: e3.priority }), this.colorScaleXform.render(t3, e3), t3.closeNode();
        } }, { key: "renderIconSet", value: function(t3, e3) {
          a2.isPrimitive(e3) && (t3.openNode(this.tag, { type: "iconSet", priority: e3.priority }), this.iconSetXform.render(t3, e3), t3.closeNode());
        } }, { key: "renderText", value: function(t3, e3) {
          t3.openNode(this.tag, { type: e3.operator, dxfId: e3.dxfId, priority: e3.priority, operator: h.toStringAttribute(e3.operator, "containsText") });
          var r3 = function(t4) {
            if (t4.formulae && t4.formulae[0])
              return t4.formulae[0];
            var e4 = new p(t4.ref).tl;
            switch (t4.operator) {
              case "containsText":
                return 'NOT(ISERROR(SEARCH("'.concat(t4.text, '",').concat(e4, ")))");
              case "containsBlanks":
                return "LEN(TRIM(".concat(e4, "))=0");
              case "notContainsBlanks":
                return "LEN(TRIM(".concat(e4, "))>0");
              case "containsErrors":
                return "ISERROR(".concat(e4, ")");
              case "notContainsErrors":
                return "NOT(ISERROR(".concat(e4, "))");
              default:
                return;
            }
          }(e3);
          r3 && this.formulaXform.render(t3, r3), t3.closeNode();
        } }, { key: "renderTimePeriod", value: function(t3, e3) {
          t3.openNode(this.tag, { type: "timePeriod", dxfId: e3.dxfId, priority: e3.priority, timePeriod: e3.timePeriod });
          var r3 = function(t4) {
            if (t4.formulae && t4.formulae[0])
              return t4.formulae[0];
            var e4 = new p(t4.ref).tl;
            switch (t4.timePeriod) {
              case "thisWeek":
                return "AND(TODAY()-ROUNDDOWN(".concat(e4, ",0)<=WEEKDAY(TODAY())-1,ROUNDDOWN(").concat(e4, ",0)-TODAY()<=7-WEEKDAY(TODAY()))");
              case "lastWeek":
                return "AND(TODAY()-ROUNDDOWN(".concat(e4, ",0)>=(WEEKDAY(TODAY())),TODAY()-ROUNDDOWN(").concat(e4, ",0)<(WEEKDAY(TODAY())+7))");
              case "nextWeek":
                return "AND(ROUNDDOWN(".concat(e4, ",0)-TODAY()>(7-WEEKDAY(TODAY())),ROUNDDOWN(").concat(e4, ",0)-TODAY()<(15-WEEKDAY(TODAY())))");
              case "yesterday":
                return "FLOOR(".concat(e4, ",1)=TODAY()-1");
              case "today":
                return "FLOOR(".concat(e4, ",1)=TODAY()");
              case "tomorrow":
                return "FLOOR(".concat(e4, ",1)=TODAY()+1");
              case "last7Days":
                return "AND(TODAY()-FLOOR(".concat(e4, ",1)<=6,FLOOR(").concat(e4, ",1)<=TODAY())");
              case "lastMonth":
                return "AND(MONTH(".concat(e4, ")=MONTH(EDATE(TODAY(),0-1)),YEAR(").concat(e4, ")=YEAR(EDATE(TODAY(),0-1)))");
              case "thisMonth":
                return "AND(MONTH(".concat(e4, ")=MONTH(TODAY()),YEAR(").concat(e4, ")=YEAR(TODAY()))");
              case "nextMonth":
                return "AND(MONTH(".concat(e4, ")=MONTH(EDATE(TODAY(),0+1)),YEAR(").concat(e4, ")=YEAR(EDATE(TODAY(),0+1)))");
              default:
                return;
            }
          }(e3);
          r3 && this.formulaXform.render(t3, r3), t3.closeNode();
        } }, { key: "createNewModel", value: function(t3) {
          var e3 = t3.attributes;
          return o(o({}, function(t4) {
            var e4 = t4.type, r3 = t4.operator;
            switch (e4) {
              case "containsText":
              case "containsBlanks":
              case "notContainsBlanks":
              case "containsErrors":
              case "notContainsErrors":
                return { type: "containsText", operator: e4 };
              default:
                return { type: e4, operator: r3 };
            }
          }(e3)), {}, { dxfId: h.toIntValue(e3.dxfId), priority: h.toIntValue(e3.priority), timePeriod: e3.timePeriod, percent: h.toBoolValue(e3.percent), bottom: h.toBoolValue(e3.bottom), rank: h.toIntValue(e3.rank), aboveAverage: h.toBoolValue(e3.aboveAverage) });
        } }, { key: "onParserClose", value: function(t3, e3) {
          switch (t3) {
            case "dataBar":
            case "extLst":
            case "colorScale":
            case "iconSet":
              Object.assign(this.model, e3.model);
              break;
            case "formula":
              this.model.formulae = this.model.formulae || [], this.model.formulae.push(e3.model);
          }
        } }, { key: "tag", get: function() {
          return "cfRule";
        } }]) && s(e2.prototype, r2), n2 && s(e2, n2), a2;
      }(d);
      e.exports = _;
    }, { "../../../../doc/range": 10, "../../base-xform": 31, "../../composite-xform": 47, "./color-scale-xform": 84, "./databar-xform": 87, "./ext-lst-ref-xform": 88, "./formula-xform": 89, "./icon-set-xform": 90 }], 83: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = t("../../base-xform"), l = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          t3.leafNode(this.tag, { type: e3.type, val: e3.value });
        } }, { key: "parseOpen", value: function(t3) {
          this.model = { type: t3.attributes.type, value: f.toFloatValue(t3.attributes.val) };
        } }, { key: "parseClose", value: function(t3) {
          return t3 !== this.tag;
        } }, { key: "tag", get: function() {
          return "cfvo";
        } }]) && o(e2.prototype, r2), c2;
      }(f);
      e.exports = l;
    }, { "../../base-xform": 31 }], 84: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("../../composite-xform"), f = t("../../style/color-xform"), l = t("./cfvo-xform"), h = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2() {
          var t3;
          return function(t4, e3) {
            if (!(t4 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (t3 = s2.call(this)).map = { cfvo: t3.cfvoXform = new l(), color: t3.colorXform = new f() }, t3;
        }
        return e2 = u2, (r2 = [{ key: "render", value: function(t3, e3) {
          var r3 = this;
          t3.openNode(this.tag), e3.cfvo.forEach(function(e4) {
            r3.cfvoXform.render(t3, e4);
          }), e3.color.forEach(function(e4) {
            r3.colorXform.render(t3, e4);
          }), t3.closeNode();
        } }, { key: "createNewModel", value: function(t3) {
          return { cfvo: [], color: [] };
        } }, { key: "onParserClose", value: function(t3, e3) {
          this.model[t3].push(e3.model);
        } }, { key: "tag", get: function() {
          return "colorScale";
        } }]) && i(e2.prototype, r2), u2;
      }(c);
      e.exports = h;
    }, { "../../composite-xform": 47, "../../style/color-xform": 127, "./cfvo-xform": 83 }], 85: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("../../composite-xform"), f = t("./cf-rule-xform"), l = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2() {
          var t3;
          return function(t4, e3) {
            if (!(t4 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (t3 = s2.call(this)).map = { cfRule: new f() }, t3;
        }
        return e2 = u2, (r2 = [{ key: "render", value: function(t3, e3) {
          var r3 = this;
          e3.rules.some(f.isPrimitive) && (t3.openNode(this.tag, { sqref: e3.ref }), e3.rules.forEach(function(n3) {
            f.isPrimitive(n3) && (n3.ref = e3.ref, r3.map.cfRule.render(t3, n3));
          }), t3.closeNode());
        } }, { key: "createNewModel", value: function(t3) {
          return { ref: t3.attributes.sqref, rules: [] };
        } }, { key: "onParserClose", value: function(t3, e3) {
          this.model.rules.push(e3.model);
        } }, { key: "tag", get: function() {
          return "conditionalFormatting";
        } }]) && i(e2.prototype, r2), u2;
      }(c);
      e.exports = l;
    }, { "../../composite-xform": 47, "./cf-rule-xform": 82 }], 86: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2) {
        return function(t3) {
          if (Array.isArray(t3))
            return o(t3);
        }(t2) || function(t3) {
          if (typeof Symbol != "undefined" && Symbol.iterator in Object(t3))
            return Array.from(t3);
        }(t2) || function(t3, e2) {
          if (!t3)
            return;
          if (typeof t3 == "string")
            return o(t3, e2);
          var r2 = Object.prototype.toString.call(t3).slice(8, -1);
          r2 === "Object" && t3.constructor && (r2 = t3.constructor.name);
          if (r2 === "Map" || r2 === "Set")
            return Array.from(t3);
          if (r2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
            return o(t3, e2);
        }(t2) || function() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function o(t2, e2) {
        (e2 == null || e2 > t2.length) && (e2 = t2.length);
        for (var r2 = 0, n2 = new Array(e2); r2 < e2; r2++)
          n2[r2] = t2[r2];
        return n2;
      }
      function a(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function s(t2, e2) {
        return (s = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function u(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = f(t2);
          if (e2) {
            var i2 = f(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return c(this, r2);
        };
      }
      function c(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function f(t2) {
        return (f = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var l = t("../../base-xform"), h = t("./conditional-formatting-xform"), d = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && s(t3, e3);
        }(c2, t2);
        var e2, r2, o2 = u(c2);
        function c2() {
          var t3;
          return function(t4, e3) {
            if (!(t4 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, c2), (t3 = o2.call(this)).cfXform = new h(), t3;
        }
        return e2 = c2, (r2 = [{ key: "reset", value: function() {
          this.model = [];
        } }, { key: "prepare", value: function(t3, e3) {
          var r3 = t3.reduce(function(t4, e4) {
            return Math.max.apply(Math, [t4].concat(i(e4.rules.map(function(t5) {
              return t5.priority || 0;
            }))));
          }, 1);
          t3.forEach(function(t4) {
            t4.rules.forEach(function(t5) {
              t5.priority || (t5.priority = r3++), t5.style && (t5.dxfId = e3.styles.addDxfStyle(t5.style));
            });
          });
        } }, { key: "render", value: function(t3, e3) {
          var r3 = this;
          e3.forEach(function(e4) {
            r3.cfXform.render(t3, e4);
          });
        } }, { key: "parseOpen", value: function(t3) {
          if (this.parser)
            return this.parser.parseOpen(t3), true;
          switch (t3.name) {
            case "conditionalFormatting":
              return this.parser = this.cfXform, this.parser.parseOpen(t3), true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function(t3) {
          this.parser && this.parser.parseText(t3);
        } }, { key: "parseClose", value: function(t3) {
          return !(!this.parser || !this.parser.parseClose(t3) && (this.model.push(this.parser.model), this.parser = void 0, 1));
        } }, { key: "reconcile", value: function(t3, e3) {
          t3.forEach(function(t4) {
            t4.rules.forEach(function(t5) {
              t5.dxfId !== void 0 && (t5.style = e3.styles.getDxfStyle(t5.dxfId), delete t5.dxfId);
            });
          });
        } }, { key: "tag", get: function() {
          return "conditionalFormatting";
        } }]) && a(e2.prototype, r2), c2;
      }(l);
      e.exports = d;
    }, { "../../base-xform": 31, "./conditional-formatting-xform": 85 }], 87: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("../../composite-xform"), f = t("../../style/color-xform"), l = t("./cfvo-xform"), h = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2() {
          var t3;
          return function(t4, e3) {
            if (!(t4 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (t3 = s2.call(this)).map = { cfvo: t3.cfvoXform = new l(), color: t3.colorXform = new f() }, t3;
        }
        return e2 = u2, (r2 = [{ key: "render", value: function(t3, e3) {
          var r3 = this;
          t3.openNode(this.tag), e3.cfvo.forEach(function(e4) {
            r3.cfvoXform.render(t3, e4);
          }), this.colorXform.render(t3, e3.color), t3.closeNode();
        } }, { key: "createNewModel", value: function() {
          return { cfvo: [] };
        } }, { key: "onParserClose", value: function(t3, e3) {
          switch (t3) {
            case "cfvo":
              this.model.cfvo.push(e3.model);
              break;
            case "color":
              this.model.color = e3.model;
          }
        } }, { key: "tag", get: function() {
          return "dataBar";
        } }]) && i(e2.prototype, r2), u2;
      }(c);
      e.exports = h;
    }, { "../../composite-xform": 47, "../../style/color-xform": 127, "./cfvo-xform": 83 }], 88: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2, r2) {
        return e2 && o(t2.prototype, e2), r2 && o(t2, r2), t2;
      }
      function s(t2, e2) {
        if (typeof e2 != "function" && e2 !== null)
          throw new TypeError("Super expression must either be null or a function");
        t2.prototype = Object.create(e2 && e2.prototype, { constructor: { value: t2, writable: true, configurable: true } }), e2 && u(t2, e2);
      }
      function u(t2, e2) {
        return (u = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function c(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = l(t2);
          if (e2) {
            var i2 = l(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return f(this, r2);
        };
      }
      function f(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function l(t2) {
        return (l = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var h = t("../../base-xform"), d = t("../../composite-xform"), p = function(t2) {
        s(r2, t2);
        var e2 = c(r2);
        function r2() {
          return i(this, r2), e2.apply(this, arguments);
        }
        return a(r2, [{ key: "render", value: function(t3, e3) {
          t3.leafNode(this.tag, null, e3);
        } }, { key: "parseOpen", value: function() {
          this.model = "";
        } }, { key: "parseText", value: function(t3) {
          this.model += t3;
        } }, { key: "parseClose", value: function(t3) {
          return t3 !== this.tag;
        } }, { key: "tag", get: function() {
          return "x14:id";
        } }]), r2;
      }(h), m = function(t2) {
        s(r2, t2);
        var e2 = c(r2);
        function r2() {
          var t3;
          return i(this, r2), (t3 = e2.call(this)).map = { "x14:id": t3.idXform = new p() }, t3;
        }
        return a(r2, [{ key: "render", value: function(t3, e3) {
          t3.openNode(this.tag, { uri: "{B025F937-C7B1-47D3-B67F-A62EFF666E3E}", "xmlns:x14": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/main" }), this.idXform.render(t3, e3.x14Id), t3.closeNode();
        } }, { key: "createNewModel", value: function() {
          return {};
        } }, { key: "onParserClose", value: function(t3, e3) {
          this.model.x14Id = e3.model;
        } }, { key: "tag", get: function() {
          return "ext";
        } }]), r2;
      }(d), y = function(t2) {
        s(r2, t2);
        var e2 = c(r2);
        function r2() {
          var t3;
          return i(this, r2), (t3 = e2.call(this)).map = { ext: new m() }, t3;
        }
        return a(r2, [{ key: "render", value: function(t3, e3) {
          t3.openNode(this.tag), this.map.ext.render(t3, e3), t3.closeNode();
        } }, { key: "createNewModel", value: function() {
          return {};
        } }, { key: "onParserClose", value: function(t3, e3) {
          Object.assign(this.model, e3.model);
        } }, { key: "tag", get: function() {
          return "extLst";
        } }]), r2;
      }(d);
      e.exports = y;
    }, { "../../base-xform": 31, "../../composite-xform": 47 }], 89: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          t3.leafNode(this.tag, null, e3);
        } }, { key: "parseOpen", value: function() {
          this.model = "";
        } }, { key: "parseText", value: function(t3) {
          this.model += t3;
        } }, { key: "parseClose", value: function(t3) {
          return t3 !== this.tag;
        } }, { key: "tag", get: function() {
          return "formula";
        } }]) && o(e2.prototype, r2), c2;
      }(t("../../base-xform"));
      e.exports = f;
    }, { "../../base-xform": 31 }], 90: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("../../base-xform"), f = t("../../composite-xform"), l = t("./cfvo-xform"), h = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2() {
          var t3;
          return function(t4, e3) {
            if (!(t4 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (t3 = s2.call(this)).map = { cfvo: t3.cfvoXform = new l() }, t3;
        }
        return e2 = u2, (r2 = [{ key: "render", value: function(t3, e3) {
          var r3 = this;
          t3.openNode(this.tag, { iconSet: c.toStringAttribute(e3.iconSet, "3TrafficLights"), reverse: c.toBoolAttribute(e3.reverse, false), showValue: c.toBoolAttribute(e3.showValue, true) }), e3.cfvo.forEach(function(e4) {
            r3.cfvoXform.render(t3, e4);
          }), t3.closeNode();
        } }, { key: "createNewModel", value: function(t3) {
          var e3 = t3.attributes;
          return { iconSet: c.toStringValue(e3.iconSet, "3TrafficLights"), reverse: c.toBoolValue(e3.reverse), showValue: c.toBoolValue(e3.showValue), cfvo: [] };
        } }, { key: "onParserClose", value: function(t3, e3) {
          this.model[t3].push(e3.model);
        } }, { key: "tag", get: function() {
          return "iconSet";
        } }]) && i(e2.prototype, r2), u2;
      }(f);
      e.exports = h;
    }, { "../../base-xform": 31, "../../composite-xform": 47, "./cfvo-xform": 83 }], 91: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "prepare", value: function(t3, e3) {
          var r3 = e3.styles.addStyleModel(t3.style || {});
          r3 && (t3.styleId = r3);
        } }, { key: "render", value: function(t3, e3) {
          t3.openNode("col"), t3.addAttribute("min", e3.min), t3.addAttribute("max", e3.max), e3.width && t3.addAttribute("width", e3.width), e3.styleId && t3.addAttribute("style", e3.styleId), e3.hidden && t3.addAttribute("hidden", "1"), e3.bestFit && t3.addAttribute("bestFit", "1"), e3.outlineLevel && t3.addAttribute("outlineLevel", e3.outlineLevel), e3.collapsed && t3.addAttribute("collapsed", "1"), t3.addAttribute("customWidth", "1"), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          if (t3.name === "col") {
            var e3 = this.model = { min: parseInt(t3.attributes.min || "0", 10), max: parseInt(t3.attributes.max || "0", 10), width: t3.attributes.width === void 0 ? void 0 : parseFloat(t3.attributes.width || "0") };
            return t3.attributes.style && (e3.styleId = parseInt(t3.attributes.style, 10)), t3.attributes.hidden !== true && t3.attributes.hidden !== "true" && t3.attributes.hidden !== 1 && t3.attributes.hidden !== "1" || (e3.hidden = true), t3.attributes.bestFit && (e3.bestFit = true), t3.attributes.outlineLevel && (e3.outlineLevel = parseInt(t3.attributes.outlineLevel, 10)), t3.attributes.collapsed && (e3.collapsed = true), true;
          }
          return false;
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function() {
          return false;
        } }, { key: "reconcile", value: function(t3, e3) {
          t3.styleId && (t3.style = e3.styles.getStyleModel(t3.styleId));
        } }, { key: "tag", get: function() {
          return "col";
        } }]) && o(e2.prototype, r2), c2;
      }(t("../base-xform"));
      e.exports = f;
    }, { "../base-xform": 31 }], 92: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      function f(t2, e2) {
        var r2 = Object.keys(t2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t2);
          e2 && (n2 = n2.filter(function(e3) {
            return Object.getOwnPropertyDescriptor(t2, e3).enumerable;
          })), r2.push.apply(r2, n2);
        }
        return r2;
      }
      function l(t2) {
        for (var e2 = 1; e2 < arguments.length; e2++) {
          var r2 = arguments[e2] != null ? arguments[e2] : {};
          e2 % 2 ? f(Object(r2), true).forEach(function(e3) {
            h(t2, e3, r2[e3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(r2)) : f(Object(r2)).forEach(function(e3) {
            Object.defineProperty(t2, e3, Object.getOwnPropertyDescriptor(r2, e3));
          });
        }
        return t2;
      }
      function h(t2, e2, r2) {
        return e2 in t2 ? Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }) : t2[e2] = r2, t2;
      }
      var d = t("../../../utils/under-dash"), p = t("../../../utils/utils"), m = t("../../../utils/col-cache"), y = t("../base-xform"), b = t("../../../doc/range");
      function v(t2, e2, r2, n2) {
        var i2 = e2[r2];
        i2 !== void 0 ? t2[r2] = i2 : n2 !== void 0 && (t2[r2] = n2);
      }
      function g(t2, e2, r2, n2) {
        var i2 = e2[r2];
        i2 !== void 0 ? t2[r2] = function(t3) {
          switch (t3) {
            case "1":
            case "true":
              return true;
            default:
              return false;
          }
        }(i2) : n2 !== void 0 && (t2[r2] = n2);
      }
      var w = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          var r3 = function(t4) {
            var e4 = d.map(t4, function(t5, e5) {
              return { address: e5, dataValidation: t5, marked: false };
            }).sort(function(t5, e5) {
              return d.strcmp(t5.address, e5.address);
            }), r4 = d.keyBy(e4, "address"), n3 = function(e5, r5, n4) {
              for (var i2 = 0; i2 < r5; i2++) {
                var o2 = m.encodeAddress(e5.row + i2, n4);
                if (!t4[o2] || !d.isEqual(t4[e5.address], t4[o2]))
                  return false;
              }
              return true;
            };
            return e4.map(function(e5) {
              if (!e5.marked) {
                var i2 = m.decodeEx(e5.address);
                if (i2.dimensions)
                  return r4[i2.dimensions].marked = true, l(l({}, e5.dataValidation), {}, { sqref: e5.address });
                for (var o2 = 1, a2 = m.encodeAddress(i2.row + o2, i2.col); t4[a2] && d.isEqual(e5.dataValidation, t4[a2]); )
                  o2++, a2 = m.encodeAddress(i2.row + o2, i2.col);
                for (var s2 = 1; n3(i2, o2, i2.col + s2); )
                  s2++;
                for (var u3 = 0; u3 < o2; u3++)
                  for (var c3 = 0; c3 < s2; c3++)
                    a2 = m.encodeAddress(i2.row + u3, i2.col + c3), r4[a2].marked = true;
                if (o2 > 1 || s2 > 1) {
                  var f2 = i2.row + (o2 - 1), h2 = i2.col + (s2 - 1);
                  return l(l({}, e5.dataValidation), {}, { sqref: "".concat(e5.address, ":").concat(m.encodeAddress(f2, h2)) });
                }
                return l(l({}, e5.dataValidation), {}, { sqref: e5.address });
              }
              return null;
            }).filter(Boolean);
          }(e3);
          r3.length && (t3.openNode("dataValidations", { count: r3.length }), r3.forEach(function(e4) {
            t3.openNode("dataValidation"), e4.type !== "any" && (t3.addAttribute("type", e4.type), e4.operator && e4.type !== "list" && e4.operator !== "between" && t3.addAttribute("operator", e4.operator), e4.allowBlank && t3.addAttribute("allowBlank", "1")), e4.showInputMessage && t3.addAttribute("showInputMessage", "1"), e4.promptTitle && t3.addAttribute("promptTitle", e4.promptTitle), e4.prompt && t3.addAttribute("prompt", e4.prompt), e4.showErrorMessage && t3.addAttribute("showErrorMessage", "1"), e4.errorStyle && t3.addAttribute("errorStyle", e4.errorStyle), e4.errorTitle && t3.addAttribute("errorTitle", e4.errorTitle), e4.error && t3.addAttribute("error", e4.error), t3.addAttribute("sqref", e4.sqref), (e4.formulae || []).forEach(function(r4, n3) {
              t3.openNode("formula".concat(n3 + 1)), e4.type === "date" ? t3.writeText(p.dateToExcel(new Date(r4))) : t3.writeText(r4), t3.closeNode();
            }), t3.closeNode();
          }), t3.closeNode());
        } }, { key: "parseOpen", value: function(t3) {
          switch (t3.name) {
            case "dataValidations":
              return this.model = {}, true;
            case "dataValidation":
              this._address = t3.attributes.sqref;
              var e3 = { type: t3.attributes.type || "any", formulae: [] };
              switch (t3.attributes.type && g(e3, t3.attributes, "allowBlank"), g(e3, t3.attributes, "showInputMessage"), g(e3, t3.attributes, "showErrorMessage"), e3.type) {
                case "any":
                case "list":
                case "custom":
                  break;
                default:
                  v(e3, t3.attributes, "operator", "between");
              }
              return v(e3, t3.attributes, "promptTitle"), v(e3, t3.attributes, "prompt"), v(e3, t3.attributes, "errorStyle"), v(e3, t3.attributes, "errorTitle"), v(e3, t3.attributes, "error"), this._dataValidation = e3, true;
            case "formula1":
            case "formula2":
              return this._formula = [], true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function(t3) {
          this._formula && this._formula.push(t3);
        } }, { key: "parseClose", value: function(t3) {
          var e3 = this;
          switch (t3) {
            case "dataValidations":
              return false;
            case "dataValidation":
              return this._dataValidation.formulae && this._dataValidation.formulae.length || (delete this._dataValidation.formulae, delete this._dataValidation.operator), (this._address.split(/\s+/g) || []).forEach(function(t4) {
                t4.includes(":") ? new b(t4).forEachAddress(function(t5) {
                  e3.model[t5] = e3._dataValidation;
                }) : e3.model[t4] = e3._dataValidation;
              }), true;
            case "formula1":
            case "formula2":
              var r3 = this._formula.join("");
              switch (this._dataValidation.type) {
                case "whole":
                case "textLength":
                  r3 = parseInt(r3, 10);
                  break;
                case "decimal":
                  r3 = parseFloat(r3);
                  break;
                case "date":
                  r3 = p.excelToDate(parseFloat(r3));
              }
              return this._dataValidation.formulae.push(r3), this._formula = void 0, true;
            default:
              return true;
          }
        } }, { key: "tag", get: function() {
          return "dataValidations";
        } }]) && o(e2.prototype, r2), c2;
      }(y);
      e.exports = w;
    }, { "../../../doc/range": 10, "../../../utils/col-cache": 19, "../../../utils/under-dash": 25, "../../../utils/utils": 26, "../base-xform": 31 }], 93: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          e3 && t3.leafNode("dimension", { ref: e3 });
        } }, { key: "parseOpen", value: function(t3) {
          return t3.name === "dimension" && (this.model = t3.attributes.ref, true);
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function() {
          return false;
        } }, { key: "tag", get: function() {
          return "dimension";
        } }]) && o(e2.prototype, r2), c2;
      }(t("../base-xform"));
      e.exports = f;
    }, { "../base-xform": 31 }], 94: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          e3 && t3.leafNode(this.tag, { "r:id": e3.rId });
        } }, { key: "parseOpen", value: function(t3) {
          switch (t3.name) {
            case this.tag:
              return this.model = { rId: t3.attributes["r:id"] }, true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function() {
          return false;
        } }, { key: "tag", get: function() {
          return "drawing";
        } }]) && o(e2.prototype, r2), c2;
      }(t("../base-xform"));
      e.exports = f;
    }, { "../base-xform": 31 }], 95: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2, r2) {
        return e2 && o(t2.prototype, e2), r2 && o(t2, r2), t2;
      }
      function s(t2, e2) {
        if (typeof e2 != "function" && e2 !== null)
          throw new TypeError("Super expression must either be null or a function");
        t2.prototype = Object.create(e2 && e2.prototype, { constructor: { value: t2, writable: true, configurable: true } }), e2 && u(t2, e2);
      }
      function u(t2, e2) {
        return (u = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function c(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = l(t2);
          if (e2) {
            var i2 = l(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return f(this, r2);
        };
      }
      function f(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function l(t2) {
        return (l = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var h = t("../composite-xform"), d = t("./cf-ext/conditional-formattings-ext-xform"), p = function(t2) {
        s(r2, t2);
        var e2 = c(r2);
        function r2() {
          var t3;
          return i(this, r2), (t3 = e2.call(this)).map = { "x14:conditionalFormattings": t3.conditionalFormattings = new d() }, t3;
        }
        return a(r2, [{ key: "hasContent", value: function(t3) {
          return this.conditionalFormattings.hasContent(t3.conditionalFormattings);
        } }, { key: "prepare", value: function(t3, e3) {
          this.conditionalFormattings.prepare(t3.conditionalFormattings, e3);
        } }, { key: "render", value: function(t3, e3) {
          t3.openNode("ext", { uri: "{78C0D931-6437-407d-A8EE-F0AAD7539E65}", "xmlns:x14": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/main" }), this.conditionalFormattings.render(t3, e3.conditionalFormattings), t3.closeNode();
        } }, { key: "createNewModel", value: function() {
          return {};
        } }, { key: "onParserClose", value: function(t3, e3) {
          this.model[t3] = e3.model;
        } }, { key: "tag", get: function() {
          return "ext";
        } }]), r2;
      }(h), m = function(t2) {
        s(r2, t2);
        var e2 = c(r2);
        function r2() {
          var t3;
          return i(this, r2), (t3 = e2.call(this)).map = { ext: t3.ext = new p() }, t3;
        }
        return a(r2, [{ key: "prepare", value: function(t3, e3) {
          this.ext.prepare(t3, e3);
        } }, { key: "hasContent", value: function(t3) {
          return this.ext.hasContent(t3);
        } }, { key: "render", value: function(t3, e3) {
          this.hasContent(e3) && (t3.openNode("extLst"), this.ext.render(t3, e3), t3.closeNode());
        } }, { key: "createNewModel", value: function() {
          return {};
        } }, { key: "onParserClose", value: function(t3, e3) {
          Object.assign(this.model, e3.model);
        } }, { key: "tag", get: function() {
          return "extLst";
        } }]), r2;
      }(h);
      e.exports = m;
    }, { "../composite-xform": 47, "./cf-ext/conditional-formattings-ext-xform": 77 }], 96: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          if (e3) {
            t3.addRollback();
            var r3 = false;
            t3.openNode("headerFooter"), e3.differentFirst && (t3.addAttribute("differentFirst", "1"), r3 = true), e3.differentOddEven && (t3.addAttribute("differentOddEven", "1"), r3 = true), e3.oddHeader && typeof e3.oddHeader == "string" && (t3.leafNode("oddHeader", null, e3.oddHeader), r3 = true), e3.oddFooter && typeof e3.oddFooter == "string" && (t3.leafNode("oddFooter", null, e3.oddFooter), r3 = true), e3.evenHeader && typeof e3.evenHeader == "string" && (t3.leafNode("evenHeader", null, e3.evenHeader), r3 = true), e3.evenFooter && typeof e3.evenFooter == "string" && (t3.leafNode("evenFooter", null, e3.evenFooter), r3 = true), e3.firstHeader && typeof e3.firstHeader == "string" && (t3.leafNode("firstHeader", null, e3.firstHeader), r3 = true), e3.firstFooter && typeof e3.firstFooter == "string" && (t3.leafNode("firstFooter", null, e3.firstFooter), r3 = true), r3 ? (t3.closeNode(), t3.commit()) : t3.rollback();
          }
        } }, { key: "parseOpen", value: function(t3) {
          switch (t3.name) {
            case "headerFooter":
              return this.model = {}, t3.attributes.differentFirst && (this.model.differentFirst = parseInt(t3.attributes.differentFirst, 0) === 1), t3.attributes.differentOddEven && (this.model.differentOddEven = parseInt(t3.attributes.differentOddEven, 0) === 1), true;
            case "oddHeader":
              return this.currentNode = "oddHeader", true;
            case "oddFooter":
              return this.currentNode = "oddFooter", true;
            case "evenHeader":
              return this.currentNode = "evenHeader", true;
            case "evenFooter":
              return this.currentNode = "evenFooter", true;
            case "firstHeader":
              return this.currentNode = "firstHeader", true;
            case "firstFooter":
              return this.currentNode = "firstFooter", true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function(t3) {
          switch (this.currentNode) {
            case "oddHeader":
              this.model.oddHeader = t3;
              break;
            case "oddFooter":
              this.model.oddFooter = t3;
              break;
            case "evenHeader":
              this.model.evenHeader = t3;
              break;
            case "evenFooter":
              this.model.evenFooter = t3;
              break;
            case "firstHeader":
              this.model.firstHeader = t3;
              break;
            case "firstFooter":
              this.model.firstFooter = t3;
          }
        } }, { key: "parseClose", value: function() {
          switch (this.currentNode) {
            case "oddHeader":
            case "oddFooter":
            case "evenHeader":
            case "evenFooter":
            case "firstHeader":
            case "firstFooter":
              return this.currentNode = void 0, true;
            default:
              return false;
          }
        } }, { key: "tag", get: function() {
          return "headerFooter";
        } }]) && o(e2.prototype, r2), c2;
      }(t("../base-xform"));
      e.exports = f;
    }, { "../base-xform": 31 }], 97: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          t3.leafNode("hyperlink", { ref: e3.address, "r:id": e3.rId, tooltip: e3.tooltip });
        } }, { key: "parseOpen", value: function(t3) {
          return t3.name === "hyperlink" && (this.model = { address: t3.attributes.ref, rId: t3.attributes["r:id"], tooltip: t3.attributes.tooltip }, true);
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function() {
          return false;
        } }, { key: "tag", get: function() {
          return "hyperlink";
        } }]) && o(e2.prototype, r2), c2;
      }(t("../base-xform"));
      e.exports = f;
    }, { "../base-xform": 31 }], 98: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          t3.leafNode("mergeCell", { ref: e3 });
        } }, { key: "parseOpen", value: function(t3) {
          return t3.name === "mergeCell" && (this.model = t3.attributes.ref, true);
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function() {
          return false;
        } }, { key: "tag", get: function() {
          return "mergeCell";
        } }]) && o(e2.prototype, r2), c2;
      }(t("../base-xform"));
      e.exports = f;
    }, { "../base-xform": 31 }], 99: [function(t, e, r) {
      function n(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      var i = t("../../../utils/under-dash"), o = t("../../../doc/range"), a = t("../../../utils/col-cache"), s = t("../../../doc/enums"), u = function() {
        function t2() {
          !function(t3, e3) {
            if (!(t3 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, t2), this.merges = {};
        }
        var e2, r2;
        return e2 = t2, (r2 = [{ key: "add", value: function(t3) {
          if (this.merges[t3.master])
            this.merges[t3.master].expandToAddress(t3.address);
          else {
            var e3 = "".concat(t3.master, ":").concat(t3.address);
            this.merges[t3.master] = new o(e3);
          }
        } }, { key: "reconcile", value: function(t3, e3) {
          i.each(t3, function(t4) {
            for (var r3 = a.decode(t4), n2 = r3.top; n2 <= r3.bottom; n2++)
              for (var i2 = e3[n2 - 1], o2 = r3.left; o2 <= r3.right; o2++) {
                var u3 = i2.cells[o2 - 1];
                u3 ? u3.type === s.ValueType.Merge && (u3.master = r3.tl) : i2.cells[o2] = { type: s.ValueType.Null, address: a.encodeAddress(n2, o2) };
              }
          });
        } }, { key: "getMasterAddress", value: function(t3) {
          var e3 = this.hash[t3];
          return e3 && e3.tl;
        } }, { key: "mergeCells", get: function() {
          return i.map(this.merges, function(t3) {
            return t3.range;
          });
        } }]) && n(e2.prototype, r2), t2;
      }();
      e.exports = u;
    }, { "../../../doc/enums": 7, "../../../doc/range": 10, "../../../utils/col-cache": 19, "../../../utils/under-dash": 25 }], 100: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = t("../base-xform"), l = function(t2) {
        return t2 !== void 0;
      }, h = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          return !(!e3 || !l(e3.summaryBelow) && !l(e3.summaryRight) || (t3.leafNode(this.tag, { summaryBelow: l(e3.summaryBelow) ? Number(e3.summaryBelow) : void 0, summaryRight: l(e3.summaryRight) ? Number(e3.summaryRight) : void 0 }), 0));
        } }, { key: "parseOpen", value: function(t3) {
          return t3.name === this.tag && (this.model = { summaryBelow: l(t3.attributes.summaryBelow) ? Boolean(Number(t3.attributes.summaryBelow)) : void 0, summaryRight: l(t3.attributes.summaryRight) ? Boolean(Number(t3.attributes.summaryRight)) : void 0 }, true);
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function() {
          return false;
        } }, { key: "tag", get: function() {
          return "outlinePr";
        } }]) && o(e2.prototype, r2), c2;
      }(f);
      e.exports = h;
    }, { "../base-xform": 31 }], 101: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          t3.leafNode("brk", e3);
        } }, { key: "parseOpen", value: function(t3) {
          return t3.name === "brk" && (this.model = t3.attributes.ref, true);
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function() {
          return false;
        } }, { key: "tag", get: function() {
          return "brk";
        } }]) && o(e2.prototype, r2), c2;
      }(t("../base-xform"));
      e.exports = f;
    }, { "../base-xform": 31 }], 102: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = t("../../../utils/under-dash"), l = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          if (e3) {
            var r3 = { left: e3.left, right: e3.right, top: e3.top, bottom: e3.bottom, header: e3.header, footer: e3.footer };
            f.some(r3, function(t4) {
              return t4 !== void 0;
            }) && t3.leafNode(this.tag, r3);
          }
        } }, { key: "parseOpen", value: function(t3) {
          switch (t3.name) {
            case this.tag:
              return this.model = { left: parseFloat(t3.attributes.left || 0.7), right: parseFloat(t3.attributes.right || 0.7), top: parseFloat(t3.attributes.top || 0.75), bottom: parseFloat(t3.attributes.bottom || 0.75), header: parseFloat(t3.attributes.header || 0.3), footer: parseFloat(t3.attributes.footer || 0.3) }, true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function() {
          return false;
        } }, { key: "tag", get: function() {
          return "pageMargins";
        } }]) && o(e2.prototype, r2), c2;
      }(t("../base-xform"));
      e.exports = l;
    }, { "../../../utils/under-dash": 25, "../base-xform": 31 }], 103: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          return !(!e3 || !e3.fitToPage || (t3.leafNode(this.tag, { fitToPage: e3.fitToPage ? "1" : void 0 }), 0));
        } }, { key: "parseOpen", value: function(t3) {
          return t3.name === this.tag && (this.model = { fitToPage: t3.attributes.fitToPage === "1" }, true);
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function() {
          return false;
        } }, { key: "tag", get: function() {
          return "pageSetUpPr";
        } }]) && o(e2.prototype, r2), c2;
      }(t("../base-xform"));
      e.exports = f;
    }, { "../base-xform": 31 }], 104: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = t("../../../utils/under-dash");
      function l(t2) {
        return t2 ? "1" : void 0;
      }
      function h(t2) {
        switch (t2) {
          case "overThenDown":
            return t2;
          default:
            return;
        }
      }
      function d(t2) {
        switch (t2) {
          case "atEnd":
          case "asDisplyed":
            return t2;
          default:
            return;
        }
      }
      function p(t2) {
        switch (t2) {
          case "dash":
          case "blank":
          case "NA":
            return t2;
          default:
            return;
        }
      }
      var m = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          if (e3) {
            var r3 = { paperSize: e3.paperSize, orientation: e3.orientation, horizontalDpi: e3.horizontalDpi, verticalDpi: e3.verticalDpi, pageOrder: h(e3.pageOrder), blackAndWhite: l(e3.blackAndWhite), draft: l(e3.draft), cellComments: d(e3.cellComments), errors: p(e3.errors), scale: e3.scale, fitToWidth: e3.fitToWidth, fitToHeight: e3.fitToHeight, firstPageNumber: e3.firstPageNumber, useFirstPageNumber: l(e3.firstPageNumber), usePrinterDefaults: l(e3.usePrinterDefaults), copies: e3.copies };
            f.some(r3, function(t4) {
              return t4 !== void 0;
            }) && t3.leafNode(this.tag, r3);
          }
        } }, { key: "parseOpen", value: function(t3) {
          switch (t3.name) {
            case this.tag:
              return this.model = { paperSize: (e3 = t3.attributes.paperSize, e3 !== void 0 ? parseInt(e3, 10) : void 0), orientation: t3.attributes.orientation || "portrait", horizontalDpi: parseInt(t3.attributes.horizontalDpi || "4294967295", 10), verticalDpi: parseInt(t3.attributes.verticalDpi || "4294967295", 10), pageOrder: t3.attributes.pageOrder || "downThenOver", blackAndWhite: t3.attributes.blackAndWhite === "1", draft: t3.attributes.draft === "1", cellComments: t3.attributes.cellComments || "None", errors: t3.attributes.errors || "displayed", scale: parseInt(t3.attributes.scale || "100", 10), fitToWidth: parseInt(t3.attributes.fitToWidth || "1", 10), fitToHeight: parseInt(t3.attributes.fitToHeight || "1", 10), firstPageNumber: parseInt(t3.attributes.firstPageNumber || "1", 10), useFirstPageNumber: t3.attributes.useFirstPageNumber === "1", usePrinterDefaults: t3.attributes.usePrinterDefaults === "1", copies: parseInt(t3.attributes.copies || "1", 10) }, true;
            default:
              return false;
          }
          var e3;
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function() {
          return false;
        } }, { key: "tag", get: function() {
          return "pageSetup";
        } }]) && o(e2.prototype, r2), c2;
      }(t("../base-xform"));
      e.exports = m;
    }, { "../../../utils/under-dash": 25, "../base-xform": 31 }], 105: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          e3 && t3.leafNode(this.tag, { "r:id": e3.rId });
        } }, { key: "parseOpen", value: function(t3) {
          switch (t3.name) {
            case this.tag:
              return this.model = { rId: t3.attributes["r:id"] }, true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function() {
          return false;
        } }, { key: "tag", get: function() {
          return "picture";
        } }]) && o(e2.prototype, r2), c2;
      }(t("../base-xform"));
      e.exports = f;
    }, { "../base-xform": 31 }], 106: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = t("../../../utils/under-dash");
      function l(t2) {
        return t2 ? "1" : void 0;
      }
      var h = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          if (e3) {
            var r3 = { headings: l(e3.showRowColHeaders), gridLines: l(e3.showGridLines), horizontalCentered: l(e3.horizontalCentered), verticalCentered: l(e3.verticalCentered) };
            f.some(r3, function(t4) {
              return t4 !== void 0;
            }) && t3.leafNode(this.tag, r3);
          }
        } }, { key: "parseOpen", value: function(t3) {
          switch (t3.name) {
            case this.tag:
              return this.model = { showRowColHeaders: t3.attributes.headings === "1", showGridLines: t3.attributes.gridLines === "1", horizontalCentered: t3.attributes.horizontalCentered === "1", verticalCentered: t3.attributes.verticalCentered === "1" }, true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function() {
          return false;
        } }, { key: "tag", get: function() {
          return "printOptions";
        } }]) && o(e2.prototype, r2), c2;
      }(t("../base-xform"));
      e.exports = h;
    }, { "../../../utils/under-dash": 25, "../base-xform": 31 }], 107: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("./page-breaks-xform"), f = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2() {
          !function(t4, e3) {
            if (!(t4 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2);
          var t3 = { tag: "rowBreaks", count: true, childXform: new c() };
          return s2.call(this, t3);
        }
        return e2 = u2, (r2 = [{ key: "render", value: function(t3, e3) {
          if (e3 && e3.length) {
            t3.openNode(this.tag, this.$), this.count && (t3.addAttribute(this.$count, e3.length), t3.addAttribute("manualBreakCount", e3.length));
            var r3 = this.childXform;
            e3.forEach(function(e4) {
              r3.render(t3, e4);
            }), t3.closeNode();
          } else
            this.empty && t3.leafNode(this.tag);
        } }]) && i(e2.prototype, r2), u2;
      }(t("../list-xform"));
      e.exports = f;
    }, { "../list-xform": 70, "./page-breaks-xform": 101 }], 108: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("../base-xform"), f = t("./cell-xform"), l = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2(t3) {
          var e3;
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (e3 = s2.call(this)).maxItems = t3 && t3.maxItems, e3.map = { c: new f() }, e3;
        }
        return e2 = u2, (r2 = [{ key: "prepare", value: function(t3, e3) {
          var r3 = e3.styles.addStyleModel(t3.style);
          r3 && (t3.styleId = r3);
          var n3 = this.map.c;
          t3.cells.forEach(function(t4) {
            n3.prepare(t4, e3);
          });
        } }, { key: "render", value: function(t3, e3, r3) {
          t3.openNode("row"), t3.addAttribute("r", e3.number), e3.height && (t3.addAttribute("ht", e3.height), t3.addAttribute("customHeight", "1")), e3.hidden && t3.addAttribute("hidden", "1"), e3.min > 0 && e3.max > 0 && e3.min <= e3.max && t3.addAttribute("spans", "".concat(e3.min, ":").concat(e3.max)), e3.styleId && (t3.addAttribute("s", e3.styleId), t3.addAttribute("customFormat", "1")), t3.addAttribute("x14ac:dyDescent", "0.25"), e3.outlineLevel && t3.addAttribute("outlineLevel", e3.outlineLevel), e3.collapsed && t3.addAttribute("collapsed", "1");
          var n3 = this.map.c;
          e3.cells.forEach(function(e4) {
            n3.render(t3, e4, r3);
          }), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          if (this.parser)
            return this.parser.parseOpen(t3), true;
          if (t3.name === "row") {
            this.numRowsSeen += 1;
            var e3 = t3.attributes.spans ? t3.attributes.spans.split(":").map(function(t4) {
              return parseInt(t4, 10);
            }) : [void 0, void 0], r3 = this.model = { number: parseInt(t3.attributes.r, 10), min: e3[0], max: e3[1], cells: [] };
            return t3.attributes.s && (r3.styleId = parseInt(t3.attributes.s, 10)), t3.attributes.hidden !== true && t3.attributes.hidden !== "true" && t3.attributes.hidden !== 1 && t3.attributes.hidden !== "1" || (r3.hidden = true), t3.attributes.bestFit && (r3.bestFit = true), t3.attributes.ht && (r3.height = parseFloat(t3.attributes.ht)), t3.attributes.outlineLevel && (r3.outlineLevel = parseInt(t3.attributes.outlineLevel, 10)), t3.attributes.collapsed && (r3.collapsed = true), true;
          }
          return this.parser = this.map[t3.name], !!this.parser && (this.parser.parseOpen(t3), true);
        } }, { key: "parseText", value: function(t3) {
          this.parser && this.parser.parseText(t3);
        } }, { key: "parseClose", value: function(t3) {
          if (this.parser) {
            if (!this.parser.parseClose(t3)) {
              if (this.model.cells.push(this.parser.model), this.maxItems && this.model.cells.length > this.maxItems)
                throw new Error("Max column count (".concat(this.maxItems, ") exceeded"));
              this.parser = void 0;
            }
            return true;
          }
          return false;
        } }, { key: "reconcile", value: function(t3, e3) {
          t3.style = t3.styleId ? e3.styles.getStyleModel(t3.styleId) : {}, t3.styleId !== void 0 && (t3.styleId = void 0);
          var r3 = this.map.c;
          t3.cells.forEach(function(t4) {
            r3.reconcile(t4, e3);
          });
        } }, { key: "tag", get: function() {
          return "row";
        } }]) && i(e2.prototype, r2), u2;
      }(c);
      e.exports = l;
    }, { "../base-xform": 31, "./cell-xform": 72 }], 109: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = t("../../../utils/under-dash"), l = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          if (e3) {
            var r3 = { defaultRowHeight: e3.defaultRowHeight, outlineLevelRow: e3.outlineLevelRow, outlineLevelCol: e3.outlineLevelCol, "x14ac:dyDescent": e3.dyDescent };
            e3.defaultColWidth && (r3.defaultColWidth = e3.defaultColWidth), e3.defaultRowHeight && e3.defaultRowHeight === 15 || (r3.customHeight = "1"), f.some(r3, function(t4) {
              return t4 !== void 0;
            }) && t3.leafNode("sheetFormatPr", r3);
          }
        } }, { key: "parseOpen", value: function(t3) {
          return t3.name === "sheetFormatPr" && (this.model = { defaultRowHeight: parseFloat(t3.attributes.defaultRowHeight || "0"), dyDescent: parseFloat(t3.attributes["x14ac:dyDescent"] || "0"), outlineLevelRow: parseInt(t3.attributes.outlineLevelRow || "0", 10), outlineLevelCol: parseInt(t3.attributes.outlineLevelCol || "0", 10) }, t3.attributes.defaultColWidth && (this.model.defaultColWidth = parseFloat(t3.attributes.defaultColWidth)), true);
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function() {
          return false;
        } }, { key: "tag", get: function() {
          return "sheetFormatPr";
        } }]) && o(e2.prototype, r2), c2;
      }(t("../base-xform"));
      e.exports = l;
    }, { "../../../utils/under-dash": 25, "../base-xform": 31 }], 110: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("../base-xform"), f = t("../style/color-xform"), l = t("./page-setup-properties-xform"), h = t("./outline-properties-xform"), d = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2() {
          var t3;
          return function(t4, e3) {
            if (!(t4 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (t3 = s2.call(this)).map = { tabColor: new f("tabColor"), pageSetUpPr: new l(), outlinePr: new h() }, t3;
        }
        return e2 = u2, (r2 = [{ key: "render", value: function(t3, e3) {
          if (e3) {
            t3.addRollback(), t3.openNode("sheetPr");
            var r3 = false;
            r3 = this.map.tabColor.render(t3, e3.tabColor) || r3, r3 = this.map.pageSetUpPr.render(t3, e3.pageSetup) || r3, (r3 = this.map.outlinePr.render(t3, e3.outlineProperties) || r3) ? (t3.closeNode(), t3.commit()) : t3.rollback();
          }
        } }, { key: "parseOpen", value: function(t3) {
          return this.parser ? (this.parser.parseOpen(t3), true) : t3.name === this.tag ? (this.reset(), true) : !!this.map[t3.name] && (this.parser = this.map[t3.name], this.parser.parseOpen(t3), true);
        } }, { key: "parseText", value: function(t3) {
          return !!this.parser && (this.parser.parseText(t3), true);
        } }, { key: "parseClose", value: function(t3) {
          return this.parser ? (this.parser.parseClose(t3) || (this.parser = void 0), true) : (this.map.tabColor.model || this.map.pageSetUpPr.model || this.map.outlinePr.model ? (this.model = {}, this.map.tabColor.model && (this.model.tabColor = this.map.tabColor.model), this.map.pageSetUpPr.model && (this.model.pageSetup = this.map.pageSetUpPr.model), this.map.outlinePr.model && (this.model.outlineProperties = this.map.outlinePr.model)) : this.model = null, false);
        } }, { key: "tag", get: function() {
          return "sheetPr";
        } }]) && i(e2.prototype, r2), u2;
      }(c);
      e.exports = d;
    }, { "../base-xform": 31, "../style/color-xform": 127, "./outline-properties-xform": 100, "./page-setup-properties-xform": 103 }], 111: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = t("../../../utils/under-dash");
      function l(t2, e2) {
        return t2 ? e2 : void 0;
      }
      function h(t2, e2) {
        return t2 === e2 || void 0;
      }
      var d = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          if (e3) {
            var r3 = { sheet: l(e3.sheet, "1"), selectLockedCells: e3.selectLockedCells === false ? "1" : void 0, selectUnlockedCells: e3.selectUnlockedCells === false ? "1" : void 0, formatCells: l(e3.formatCells, "0"), formatColumns: l(e3.formatColumns, "0"), formatRows: l(e3.formatRows, "0"), insertColumns: l(e3.insertColumns, "0"), insertRows: l(e3.insertRows, "0"), insertHyperlinks: l(e3.insertHyperlinks, "0"), deleteColumns: l(e3.deleteColumns, "0"), deleteRows: l(e3.deleteRows, "0"), sort: l(e3.sort, "0"), autoFilter: l(e3.autoFilter, "0"), pivotTables: l(e3.pivotTables, "0") };
            e3.sheet && (r3.algorithmName = e3.algorithmName, r3.hashValue = e3.hashValue, r3.saltValue = e3.saltValue, r3.spinCount = e3.spinCount, r3.objects = l(e3.objects === false, "1"), r3.scenarios = l(e3.scenarios === false, "1")), f.some(r3, function(t4) {
              return t4 !== void 0;
            }) && t3.leafNode(this.tag, r3);
          }
        } }, { key: "parseOpen", value: function(t3) {
          switch (t3.name) {
            case this.tag:
              return this.model = { sheet: h(t3.attributes.sheet, "1"), objects: t3.attributes.objects !== "1" && void 0, scenarios: t3.attributes.scenarios !== "1" && void 0, selectLockedCells: t3.attributes.selectLockedCells !== "1" && void 0, selectUnlockedCells: t3.attributes.selectUnlockedCells !== "1" && void 0, formatCells: h(t3.attributes.formatCells, "0"), formatColumns: h(t3.attributes.formatColumns, "0"), formatRows: h(t3.attributes.formatRows, "0"), insertColumns: h(t3.attributes.insertColumns, "0"), insertRows: h(t3.attributes.insertRows, "0"), insertHyperlinks: h(t3.attributes.insertHyperlinks, "0"), deleteColumns: h(t3.attributes.deleteColumns, "0"), deleteRows: h(t3.attributes.deleteRows, "0"), sort: h(t3.attributes.sort, "0"), autoFilter: h(t3.attributes.autoFilter, "0"), pivotTables: h(t3.attributes.pivotTables, "0") }, t3.attributes.algorithmName && (this.model.algorithmName = t3.attributes.algorithmName, this.model.hashValue = t3.attributes.hashValue, this.model.saltValue = t3.attributes.saltValue, this.model.spinCount = parseInt(t3.attributes.spinCount, 10)), true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function() {
          return false;
        } }, { key: "tag", get: function() {
          return "sheetProtection";
        } }]) && o(e2.prototype, r2), c2;
      }(t("../base-xform"));
      e.exports = d;
    }, { "../../../utils/under-dash": 25, "../base-xform": 31 }], 112: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = t("../../../utils/col-cache"), l = t("../base-xform"), h = { frozen: "frozen", frozenSplit: "frozen", split: "split" }, d = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "prepare", value: function(t3) {
          switch (t3.state) {
            case "frozen":
            case "split":
              break;
            default:
              t3.state = "normal";
          }
        } }, { key: "render", value: function(t3, e3) {
          t3.openNode("sheetView", { workbookViewId: e3.workbookViewId || 0 });
          var r3, n3, i2, o2, a2 = function(e4, r4, n4) {
            n4 && t3.addAttribute(e4, r4);
          };
          switch (a2("rightToLeft", "1", e3.rightToLeft === true), a2("tabSelected", "1", e3.tabSelected), a2("showRuler", "0", e3.showRuler === false), a2("showRowColHeaders", "0", e3.showRowColHeaders === false), a2("showGridLines", "0", e3.showGridLines === false), a2("zoomScale", e3.zoomScale, e3.zoomScale), a2("zoomScaleNormal", e3.zoomScaleNormal, e3.zoomScaleNormal), a2("view", e3.style, e3.style), e3.state) {
            case "frozen":
              n3 = e3.xSplit || 0, i2 = e3.ySplit || 0, r3 = e3.topLeftCell || f.getAddress(i2 + 1, n3 + 1).address, o2 = (e3.xSplit && e3.ySplit ? "bottomRight" : e3.xSplit && "topRight") || "bottomLeft", t3.leafNode("pane", { xSplit: e3.xSplit || void 0, ySplit: e3.ySplit || void 0, topLeftCell: r3, activePane: o2, state: "frozen" }), t3.leafNode("selection", { pane: o2, activeCell: e3.activeCell, sqref: e3.activeCell });
              break;
            case "split":
              e3.activePane === "topLeft" && (e3.activePane = void 0), t3.leafNode("pane", { xSplit: e3.xSplit || void 0, ySplit: e3.ySplit || void 0, topLeftCell: e3.topLeftCell, activePane: e3.activePane }), t3.leafNode("selection", { pane: e3.activePane, activeCell: e3.activeCell, sqref: e3.activeCell });
              break;
            case "normal":
              e3.activeCell && t3.leafNode("selection", { activeCell: e3.activeCell, sqref: e3.activeCell });
          }
          t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          switch (t3.name) {
            case "sheetView":
              return this.sheetView = { workbookViewId: parseInt(t3.attributes.workbookViewId, 10), rightToLeft: t3.attributes.rightToLeft === "1", tabSelected: t3.attributes.tabSelected === "1", showRuler: !(t3.attributes.showRuler === "0"), showRowColHeaders: !(t3.attributes.showRowColHeaders === "0"), showGridLines: !(t3.attributes.showGridLines === "0"), zoomScale: parseInt(t3.attributes.zoomScale || "100", 10), zoomScaleNormal: parseInt(t3.attributes.zoomScaleNormal || "100", 10), style: t3.attributes.view }, this.pane = void 0, this.selections = {}, true;
            case "pane":
              return this.pane = { xSplit: parseInt(t3.attributes.xSplit || "0", 10), ySplit: parseInt(t3.attributes.ySplit || "0", 10), topLeftCell: t3.attributes.topLeftCell, activePane: t3.attributes.activePane || "topLeft", state: t3.attributes.state }, true;
            case "selection":
              var e3 = t3.attributes.pane || "topLeft";
              return this.selections[e3] = { pane: e3, activeCell: t3.attributes.activeCell }, true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function(t3) {
          var e3, r3;
          switch (t3) {
            case "sheetView":
              return this.sheetView && this.pane ? (e3 = this.model = { workbookViewId: this.sheetView.workbookViewId, rightToLeft: this.sheetView.rightToLeft, state: h[this.pane.state] || "split", xSplit: this.pane.xSplit, ySplit: this.pane.ySplit, topLeftCell: this.pane.topLeftCell, showRuler: this.sheetView.showRuler, showRowColHeaders: this.sheetView.showRowColHeaders, showGridLines: this.sheetView.showGridLines, zoomScale: this.sheetView.zoomScale, zoomScaleNormal: this.sheetView.zoomScaleNormal }, this.model.state === "split" && (e3.activePane = this.pane.activePane), (r3 = this.selections[this.pane.activePane]) && r3.activeCell && (e3.activeCell = r3.activeCell), this.sheetView.style && (e3.style = this.sheetView.style)) : (e3 = this.model = { workbookViewId: this.sheetView.workbookViewId, rightToLeft: this.sheetView.rightToLeft, state: "normal", showRuler: this.sheetView.showRuler, showRowColHeaders: this.sheetView.showRowColHeaders, showGridLines: this.sheetView.showGridLines, zoomScale: this.sheetView.zoomScale, zoomScaleNormal: this.sheetView.zoomScaleNormal }, (r3 = this.selections.topLeft) && r3.activeCell && (e3.activeCell = r3.activeCell), this.sheetView.style && (e3.style = this.sheetView.style)), false;
            default:
              return true;
          }
        } }, { key: "reconcile", value: function() {
        } }, { key: "tag", get: function() {
          return "sheetView";
        } }]) && o(e2.prototype, r2), c2;
      }(l);
      e.exports = d;
    }, { "../../../utils/col-cache": 19, "../base-xform": 31 }], 113: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          e3 && t3.leafNode(this.tag, { "r:id": e3.rId });
        } }, { key: "parseOpen", value: function(t3) {
          switch (t3.name) {
            case this.tag:
              return this.model = { rId: t3.attributes["r:id"] }, true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function() {
          return false;
        } }, { key: "tag", get: function() {
          return "tablePart";
        } }]) && o(e2.prototype, r2), c2;
      }(t("../base-xform"));
      e.exports = f;
    }, { "../base-xform": 31 }], 114: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("../../../utils/under-dash"), f = t("../../../utils/col-cache"), l = t("../../../utils/xml-stream"), h = t("../../rel-type"), d = t("./merges"), p = t("../base-xform"), m = t("../list-xform"), y = t("./row-xform"), b = t("./col-xform"), v = t("./dimension-xform"), g = t("./hyperlink-xform"), w = t("./merge-cell-xform"), _ = t("./data-validations-xform"), k = t("./sheet-properties-xform"), x = t("./sheet-format-properties-xform"), S = t("./sheet-view-xform"), O = t("./sheet-protection-xform"), j = t("./page-margins-xform"), E = t("./page-setup-xform"), R = t("./print-options-xform"), T = t("./auto-filter-xform"), C = t("./picture-xform"), P = t("./drawing-xform"), M = t("./table-part-xform"), A = t("./row-breaks-xform"), I = t("./header-footer-xform"), N = t("./cf/conditional-formattings-xform"), D = t("./ext-lst-xform"), B = function(t2, e2) {
        if (!e2 || !e2.length)
          return t2;
        if (!t2 || !t2.length)
          return e2;
        var r2 = {}, n2 = {};
        return t2.forEach(function(t3) {
          r2[t3.ref] = t3, t3.rules.forEach(function(t4) {
            var e3 = t4.x14Id;
            e3 && (n2[e3] = t4);
          });
        }), e2.forEach(function(e3) {
          e3.rules.forEach(function(i2) {
            var o2 = n2[i2.x14Id];
            o2 ? function(t3, e4) {
              Object.keys(e4).forEach(function(r3) {
                var n3 = t3[r3], i3 = e4[r3];
                n3 === void 0 && i3 !== void 0 && (t3[r3] = i3);
              });
            }(o2, i2) : r2[e3.ref] ? r2[e3.ref].rules.push(i2) : t2.push({ ref: e3.ref, rules: [i2] });
          });
        }), t2;
      }, F = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2(t3) {
          var e3;
          !function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), e3 = s2.call(this);
          var r3 = t3 || {}, n3 = r3.maxRows, i2 = r3.maxCols;
          return e3.map = { sheetPr: new k(), dimension: new v(), sheetViews: new m({ tag: "sheetViews", count: false, childXform: new S() }), sheetFormatPr: new x(), cols: new m({ tag: "cols", count: false, childXform: new b() }), sheetData: new m({ tag: "sheetData", count: false, empty: true, childXform: new y({ maxItems: i2 }), maxItems: n3 }), autoFilter: new T(), mergeCells: new m({ tag: "mergeCells", count: true, childXform: new w() }), rowBreaks: new A(), hyperlinks: new m({ tag: "hyperlinks", count: false, childXform: new g() }), pageMargins: new j(), dataValidations: new _(), pageSetup: new E(), headerFooter: new I(), printOptions: new R(), picture: new C(), drawing: new P(), sheetProtection: new O(), tableParts: new m({ tag: "tableParts", count: true, childXform: new M() }), conditionalFormatting: new N(), extLst: new D() }, e3;
        }
        return e2 = u2, (r2 = [{ key: "prepare", value: function(t3, e3) {
          var r3 = this;
          e3.merges = new d(), t3.hyperlinks = e3.hyperlinks = [], t3.comments = e3.comments = [], e3.formulae = {}, e3.siFormulae = 0, this.map.cols.prepare(t3.cols, e3), this.map.sheetData.prepare(t3.rows, e3), this.map.conditionalFormatting.prepare(t3.conditionalFormattings, e3), t3.mergeCells = e3.merges.mergeCells;
          var n3 = t3.rels = [];
          function i2(t4) {
            return "rId".concat(t4.length + 1);
          }
          if (t3.hyperlinks.forEach(function(t4) {
            var e4 = i2(n3);
            t4.rId = e4, n3.push({ Id: e4, Type: h.Hyperlink, Target: t4.target, TargetMode: "External" });
          }), t3.comments.length > 0) {
            var o2 = { Id: i2(n3), Type: h.Comments, Target: "../comments".concat(t3.id, ".xml") };
            n3.push(o2);
            var a2 = { Id: i2(n3), Type: h.VmlDrawing, Target: "../drawings/vmlDrawing".concat(t3.id, ".vml") };
            n3.push(a2), t3.comments.forEach(function(t4) {
              t4.refAddress = f.decodeAddress(t4.ref);
            }), e3.commentRefs.push({ commentName: "comments".concat(t3.id), vmlDrawing: "vmlDrawing".concat(t3.id) });
          }
          var s3, u3 = [];
          t3.media.forEach(function(o3) {
            if (o3.type === "background") {
              var a3 = i2(n3);
              s3 = e3.media[o3.imageId], n3.push({ Id: a3, Type: h.Image, Target: "../media/".concat(s3.name, ".").concat(s3.extension) }), t3.background = { rId: a3 }, t3.image = e3.media[o3.imageId];
            } else if (o3.type === "image") {
              var c2 = t3.drawing;
              s3 = e3.media[o3.imageId], c2 || (c2 = t3.drawing = { rId: i2(n3), name: "drawing".concat(++e3.drawingsCount), anchors: [], rels: [] }, e3.drawings.push(c2), n3.push({ Id: c2.rId, Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing", Target: "../drawings/".concat(c2.name, ".xml") }));
              var f2 = r3.preImageId === o3.imageId ? u3[o3.imageId] : u3[c2.rels.length];
              f2 || (f2 = i2(c2.rels), u3[c2.rels.length] = f2, c2.rels.push({ Id: f2, Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image", Target: "../media/".concat(s3.name, ".").concat(s3.extension) }));
              var l2 = { picture: { rId: f2 }, range: o3.range };
              if (o3.hyperlinks && o3.hyperlinks.hyperlink) {
                var d2 = i2(c2.rels);
                u3[c2.rels.length] = d2, l2.picture.hyperlinks = { tooltip: o3.hyperlinks.tooltip, rId: d2 }, c2.rels.push({ Id: d2, Type: h.Hyperlink, Target: o3.hyperlinks.hyperlink, TargetMode: "External" });
              }
              r3.preImageId = o3.imageId, c2.anchors.push(l2);
            }
          }), t3.tables.forEach(function(t4) {
            var r4 = i2(n3);
            t4.rId = r4, n3.push({ Id: r4, Type: h.Table, Target: "../tables/".concat(t4.target) }), t4.columns.forEach(function(t5) {
              var r5 = t5.style;
              r5 && (t5.dxfId = e3.styles.addDxfStyle(r5));
            });
          }), this.map.extLst.prepare(t3, e3);
        } }, { key: "render", value: function(t3, e3) {
          t3.openXml(l.StdDocAttributes), t3.openNode("worksheet", u2.WORKSHEET_ATTRIBUTES);
          var r3 = e3.properties ? { defaultRowHeight: e3.properties.defaultRowHeight, dyDescent: e3.properties.dyDescent, outlineLevelCol: e3.properties.outlineLevelCol, outlineLevelRow: e3.properties.outlineLevelRow } : void 0;
          e3.properties && e3.properties.defaultColWidth && (r3.defaultColWidth = e3.properties.defaultColWidth);
          var n3 = { outlineProperties: e3.properties && e3.properties.outlineProperties, tabColor: e3.properties && e3.properties.tabColor, pageSetup: e3.pageSetup && e3.pageSetup.fitToPage ? { fitToPage: e3.pageSetup.fitToPage } : void 0 }, i2 = e3.pageSetup && e3.pageSetup.margins, o2 = { showRowColHeaders: e3.pageSetup && e3.pageSetup.showRowColHeaders, showGridLines: e3.pageSetup && e3.pageSetup.showGridLines, horizontalCentered: e3.pageSetup && e3.pageSetup.horizontalCentered, verticalCentered: e3.pageSetup && e3.pageSetup.verticalCentered }, a2 = e3.sheetProtection;
          this.map.sheetPr.render(t3, n3), this.map.dimension.render(t3, e3.dimensions), this.map.sheetViews.render(t3, e3.views), this.map.sheetFormatPr.render(t3, r3), this.map.cols.render(t3, e3.cols), this.map.sheetData.render(t3, e3.rows), this.map.sheetProtection.render(t3, a2), this.map.autoFilter.render(t3, e3.autoFilter), this.map.mergeCells.render(t3, e3.mergeCells), this.map.conditionalFormatting.render(t3, e3.conditionalFormattings), this.map.dataValidations.render(t3, e3.dataValidations), this.map.hyperlinks.render(t3, e3.hyperlinks), this.map.printOptions.render(t3, o2), this.map.pageMargins.render(t3, i2), this.map.pageSetup.render(t3, e3.pageSetup), this.map.headerFooter.render(t3, e3.headerFooter), this.map.rowBreaks.render(t3, e3.rowBreaks), this.map.drawing.render(t3, e3.drawing), this.map.picture.render(t3, e3.background), this.map.tableParts.render(t3, e3.tables), this.map.extLst.render(t3, e3), e3.rels && e3.rels.forEach(function(e4) {
            e4.Type === h.VmlDrawing && t3.leafNode("legacyDrawing", { "r:id": e4.Id });
          }), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          return this.parser ? (this.parser.parseOpen(t3), true) : t3.name === "worksheet" ? (c.each(this.map, function(t4) {
            t4.reset();
          }), true) : (this.parser = this.map[t3.name], this.parser && this.parser.parseOpen(t3), true);
        } }, { key: "parseText", value: function(t3) {
          this.parser && this.parser.parseText(t3);
        } }, { key: "parseClose", value: function(t3) {
          if (this.parser)
            return this.parser.parseClose(t3) || (this.parser = void 0), true;
          switch (t3) {
            case "worksheet":
              var e3 = this.map.sheetFormatPr.model || {};
              this.map.sheetPr.model && this.map.sheetPr.model.tabColor && (e3.tabColor = this.map.sheetPr.model.tabColor), this.map.sheetPr.model && this.map.sheetPr.model.outlineProperties && (e3.outlineProperties = this.map.sheetPr.model.outlineProperties);
              var r3 = { fitToPage: this.map.sheetPr.model && this.map.sheetPr.model.pageSetup && this.map.sheetPr.model.pageSetup.fitToPage || false, margins: this.map.pageMargins.model }, n3 = Object.assign(r3, this.map.pageSetup.model, this.map.printOptions.model), i2 = B(this.map.conditionalFormatting.model, this.map.extLst.model && this.map.extLst.model["x14:conditionalFormattings"]);
              return this.model = { dimensions: this.map.dimension.model, cols: this.map.cols.model, rows: this.map.sheetData.model, mergeCells: this.map.mergeCells.model, hyperlinks: this.map.hyperlinks.model, dataValidations: this.map.dataValidations.model, properties: e3, views: this.map.sheetViews.model, pageSetup: n3, headerFooter: this.map.headerFooter.model, background: this.map.picture.model, drawing: this.map.drawing.model, tables: this.map.tableParts.model, conditionalFormattings: i2 }, this.map.autoFilter.model && (this.model.autoFilter = this.map.autoFilter.model), this.map.sheetProtection.model && (this.model.sheetProtection = this.map.sheetProtection.model), false;
            default:
              return true;
          }
        } }, { key: "reconcile", value: function(t3, e3) {
          var r3 = (t3.relationships || []).reduce(function(r4, n4) {
            if (r4[n4.Id] = n4, n4.Type === h.Comments && (t3.comments = e3.comments[n4.Target].comments), n4.Type === h.VmlDrawing && t3.comments && t3.comments.length) {
              var i3 = e3.vmlDrawings[n4.Target].comments;
              t3.comments.forEach(function(t4, e4) {
                t4.note = Object.assign({}, t4.note, i3[e4]);
              });
            }
            return r4;
          }, {});
          if (e3.commentsMap = (t3.comments || []).reduce(function(t4, e4) {
            return e4.ref && (t4[e4.ref] = e4), t4;
          }, {}), e3.hyperlinkMap = (t3.hyperlinks || []).reduce(function(t4, e4) {
            return e4.rId && (t4[e4.address] = r3[e4.rId].Target), t4;
          }, {}), e3.formulae = {}, t3.rows = t3.rows && t3.rows.filter(Boolean) || [], t3.rows.forEach(function(t4) {
            t4.cells = t4.cells && t4.cells.filter(Boolean) || [];
          }), this.map.cols.reconcile(t3.cols, e3), this.map.sheetData.reconcile(t3.rows, e3), this.map.conditionalFormatting.reconcile(t3.conditionalFormattings, e3), t3.media = [], t3.drawing) {
            var n3 = r3[t3.drawing.rId].Target.match(/\/drawings\/([a-zA-Z0-9]+)[.][a-zA-Z]{3,4}$/);
            if (n3) {
              var i2 = n3[1];
              e3.drawings[i2].anchors.forEach(function(e4) {
                if (e4.medium) {
                  var r4 = { type: "image", imageId: e4.medium.index, range: e4.range, hyperlinks: e4.picture.hyperlinks };
                  t3.media.push(r4);
                }
              });
            }
          }
          var o2 = t3.background && r3[t3.background.rId];
          if (o2) {
            var a2 = o2.Target.split("/media/")[1], s3 = e3.mediaIndex && e3.mediaIndex[a2];
            s3 !== void 0 && t3.media.push({ type: "background", imageId: s3 });
          }
          t3.tables = (t3.tables || []).map(function(t4) {
            var n4 = r3[t4.rId];
            return e3.tables[n4.Target];
          }), delete t3.relationships, delete t3.hyperlinks, delete t3.comments;
        } }]) && i(e2.prototype, r2), u2;
      }(p);
      F.WORKSHEET_ATTRIBUTES = { xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main", "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships", "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006", "mc:Ignorable": "x14ac", "xmlns:x14ac": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" }, e.exports = F;
    }, { "../../../utils/col-cache": 19, "../../../utils/under-dash": 25, "../../../utils/xml-stream": 27, "../../rel-type": 30, "../base-xform": 31, "../list-xform": 70, "./auto-filter-xform": 71, "./cf/conditional-formattings-xform": 86, "./col-xform": 91, "./data-validations-xform": 92, "./dimension-xform": 93, "./drawing-xform": 94, "./ext-lst-xform": 95, "./header-footer-xform": 96, "./hyperlink-xform": 97, "./merge-cell-xform": 98, "./merges": 99, "./page-margins-xform": 102, "./page-setup-xform": 104, "./picture-xform": 105, "./print-options-xform": 106, "./row-breaks-xform": 107, "./row-xform": 108, "./sheet-format-properties-xform": 109, "./sheet-properties-xform": 110, "./sheet-protection-xform": 111, "./sheet-view-xform": 112, "./table-part-xform": 113 }], 115: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2(t3) {
          var e3;
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (e3 = s2.call(this)).tag = t3.tag, e3.attr = t3.attr, e3;
        }
        return e2 = u2, (r2 = [{ key: "render", value: function(t3, e3) {
          e3 && (t3.openNode(this.tag), t3.closeNode());
        } }, { key: "parseOpen", value: function(t3) {
          t3.name === this.tag && (this.model = true);
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function() {
          return false;
        } }]) && i(e2.prototype, r2), u2;
      }(t("../base-xform"));
      e.exports = c;
    }, { "../base-xform": 31 }], 116: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2(t3) {
          var e3;
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (e3 = s2.call(this)).tag = t3.tag, e3.attr = t3.attr, e3.attrs = t3.attrs, e3._format = t3.format || function(t4) {
            try {
              return Number.isNaN(t4.getTime()) ? "" : t4.toISOString();
            } catch (t5) {
              return "";
            }
          }, e3._parse = t3.parse || function(t4) {
            return new Date(t4);
          }, e3;
        }
        return e2 = u2, (r2 = [{ key: "render", value: function(t3, e3) {
          e3 && (t3.openNode(this.tag), this.attrs && t3.addAttributes(this.attrs), this.attr ? t3.addAttribute(this.attr, this._format(e3)) : t3.writeText(this._format(e3)), t3.closeNode());
        } }, { key: "parseOpen", value: function(t3) {
          t3.name === this.tag && (this.attr ? this.model = this._parse(t3.attributes[this.attr]) : this.text = []);
        } }, { key: "parseText", value: function(t3) {
          this.attr || this.text.push(t3);
        } }, { key: "parseClose", value: function() {
          return this.attr || (this.model = this._parse(this.text.join(""))), false;
        } }]) && i(e2.prototype, r2), u2;
      }(t("../base-xform"));
      e.exports = c;
    }, { "../base-xform": 31 }], 117: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2(t3) {
          var e3;
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (e3 = s2.call(this)).tag = t3.tag, e3.attr = t3.attr, e3.attrs = t3.attrs, e3.zero = t3.zero, e3;
        }
        return e2 = u2, (r2 = [{ key: "render", value: function(t3, e3) {
          (e3 || this.zero) && (t3.openNode(this.tag), this.attrs && t3.addAttributes(this.attrs), this.attr ? t3.addAttribute(this.attr, e3) : t3.writeText(e3), t3.closeNode());
        } }, { key: "parseOpen", value: function(t3) {
          return t3.name === this.tag && (this.attr ? this.model = parseInt(t3.attributes[this.attr], 10) : this.text = [], true);
        } }, { key: "parseText", value: function(t3) {
          this.attr || this.text.push(t3);
        } }, { key: "parseClose", value: function() {
          return this.attr || (this.model = parseInt(this.text.join("") || 0, 10)), false;
        } }]) && i(e2.prototype, r2), u2;
      }(t("../base-xform"));
      e.exports = c;
    }, { "../base-xform": 31 }], 118: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2(t3) {
          var e3;
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (e3 = s2.call(this)).tag = t3.tag, e3.attr = t3.attr, e3.attrs = t3.attrs, e3;
        }
        return e2 = u2, (r2 = [{ key: "render", value: function(t3, e3) {
          e3 !== void 0 && (t3.openNode(this.tag), this.attrs && t3.addAttributes(this.attrs), this.attr ? t3.addAttribute(this.attr, e3) : t3.writeText(e3), t3.closeNode());
        } }, { key: "parseOpen", value: function(t3) {
          t3.name === this.tag && (this.attr ? this.model = t3.attributes[this.attr] : this.text = []);
        } }, { key: "parseText", value: function(t3) {
          this.attr || this.text.push(t3);
        } }, { key: "parseClose", value: function() {
          return this.attr || (this.model = this.text.join("")), false;
        } }]) && i(e2.prototype, r2), u2;
      }(t("../base-xform"));
      e.exports = c;
    }, { "../base-xform": 31 }], 119: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("./base-xform"), f = t("../../utils/xml-stream");
      var l = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2(t3) {
          var e3;
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (e3 = s2.call(this))._model = t3, e3;
        }
        return e2 = u2, (r2 = [{ key: "render", value: function(t3) {
          if (!this._xml) {
            var e3 = new f();
            !function t4(e4, r3) {
              e4.openNode(r3.tag, r3.$), r3.c && r3.c.forEach(function(r4) {
                t4(e4, r4);
              }), r3.t && e4.writeText(r3.t), e4.closeNode();
            }(e3, this._model), this._xml = e3.xml;
          }
          t3.writeXml(this._xml);
        } }, { key: "parseOpen", value: function() {
          return true;
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function(t3) {
          switch (t3) {
            case this._model.tag:
              return false;
            default:
              return true;
          }
        } }]) && i(e2.prototype, r2), u2;
      }(c);
      e.exports = l;
    }, { "../../utils/xml-stream": 27, "./base-xform": 31 }], 120: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("./text-xform"), f = t("./rich-text-xform"), l = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2() {
          var t3;
          return function(t4, e3) {
            if (!(t4 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (t3 = s2.call(this)).map = { r: new f(), t: new c() }, t3;
        }
        return e2 = u2, (r2 = [{ key: "render", value: function(t3, e3) {
          if (t3.openNode(this.tag, { sb: e3.sb || 0, eb: e3.eb || 0 }), e3 && e3.hasOwnProperty("richText") && e3.richText) {
            var r3 = this.map.r;
            e3.richText.forEach(function(e4) {
              r3.render(t3, e4);
            });
          } else
            e3 && this.map.t.render(t3, e3.text);
          t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          var e3 = t3.name;
          return this.parser ? (this.parser.parseOpen(t3), true) : e3 === this.tag ? (this.model = { sb: parseInt(t3.attributes.sb, 10), eb: parseInt(t3.attributes.eb, 10) }, true) : (this.parser = this.map[e3], !!this.parser && (this.parser.parseOpen(t3), true));
        } }, { key: "parseText", value: function(t3) {
          this.parser && this.parser.parseText(t3);
        } }, { key: "parseClose", value: function(t3) {
          if (this.parser) {
            if (!this.parser.parseClose(t3)) {
              switch (t3) {
                case "r":
                  var e3 = this.model.richText;
                  e3 || (e3 = this.model.richText = []), e3.push(this.parser.model);
                  break;
                case "t":
                  this.model.text = this.parser.model;
              }
              this.parser = void 0;
            }
            return true;
          }
          switch (t3) {
            case this.tag:
              return false;
            default:
              return true;
          }
        } }, { key: "tag", get: function() {
          return "rPh";
        } }]) && i(e2.prototype, r2), u2;
      }(t("../base-xform"));
      e.exports = l;
    }, { "../base-xform": 31, "./rich-text-xform": 121, "./text-xform": 124 }], 121: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("./text-xform"), f = t("../style/font-xform"), l = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2(t3) {
          var e3;
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (e3 = s2.call(this)).model = t3, e3;
        }
        return e2 = u2, (r2 = [{ key: "render", value: function(t3, e3) {
          e3 = e3 || this.model, t3.openNode("r"), e3.font && this.fontXform.render(t3, e3.font), this.textXform.render(t3, e3.text), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          if (this.parser)
            return this.parser.parseOpen(t3), true;
          switch (t3.name) {
            case "r":
              return this.model = {}, true;
            case "t":
              return this.parser = this.textXform, this.parser.parseOpen(t3), true;
            case "rPr":
              return this.parser = this.fontXform, this.parser.parseOpen(t3), true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function(t3) {
          this.parser && this.parser.parseText(t3);
        } }, { key: "parseClose", value: function(t3) {
          switch (t3) {
            case "r":
              return false;
            case "t":
              return this.model.text = this.parser.model, this.parser = void 0, true;
            case "rPr":
              return this.model.font = this.parser.model, this.parser = void 0, true;
            default:
              return this.parser && this.parser.parseClose(t3), true;
          }
        } }, { key: "tag", get: function() {
          return "r";
        } }, { key: "textXform", get: function() {
          return this._textXform || (this._textXform = new c());
        } }, { key: "fontXform", get: function() {
          return this._fontXform || (this._fontXform = new f(u2.FONT_OPTIONS));
        } }]) && i(e2.prototype, r2), u2;
      }(t("../base-xform"));
      l.FONT_OPTIONS = { tagName: "rPr", fontNameTag: "rFont" }, e.exports = l;
    }, { "../base-xform": 31, "../style/font-xform": 130, "./text-xform": 124 }], 122: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("./text-xform"), f = t("./rich-text-xform"), l = t("./phonetic-text-xform"), h = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2(t3) {
          var e3;
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (e3 = s2.call(this)).model = t3, e3.map = { r: new f(), t: new c(), rPh: new l() }, e3;
        }
        return e2 = u2, (r2 = [{ key: "render", value: function(t3, e3) {
          var r3 = this;
          t3.openNode(this.tag), e3 && e3.hasOwnProperty("richText") && e3.richText ? e3.richText.length ? e3.richText.forEach(function(e4) {
            r3.map.r.render(t3, e4);
          }) : this.map.t.render(t3, "") : e3 != null && this.map.t.render(t3, e3), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          var e3 = t3.name;
          return this.parser ? (this.parser.parseOpen(t3), true) : e3 === this.tag ? (this.model = {}, true) : (this.parser = this.map[e3], !!this.parser && (this.parser.parseOpen(t3), true));
        } }, { key: "parseText", value: function(t3) {
          this.parser && this.parser.parseText(t3);
        } }, { key: "parseClose", value: function(t3) {
          if (this.parser) {
            if (!this.parser.parseClose(t3)) {
              switch (t3) {
                case "r":
                  var e3 = this.model.richText;
                  e3 || (e3 = this.model.richText = []), e3.push(this.parser.model);
                  break;
                case "t":
                  this.model = this.parser.model;
              }
              this.parser = void 0;
            }
            return true;
          }
          switch (t3) {
            case this.tag:
              return false;
            default:
              return true;
          }
        } }, { key: "tag", get: function() {
          return "si";
        } }]) && i(e2.prototype, r2), u2;
      }(t("../base-xform"));
      e.exports = h;
    }, { "../base-xform": 31, "./phonetic-text-xform": 120, "./rich-text-xform": 121, "./text-xform": 124 }], 123: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("../../../utils/xml-stream"), f = t("../base-xform"), l = t("./shared-string-xform"), h = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2(t3) {
          var e3;
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (e3 = s2.call(this)).model = t3 || { values: [], count: 0 }, e3.hash = Object.create(null), e3.rich = Object.create(null), e3;
        }
        return e2 = u2, (r2 = [{ key: "getString", value: function(t3) {
          return this.model.values[t3];
        } }, { key: "add", value: function(t3) {
          return t3.richText ? this.addRichText(t3) : this.addText(t3);
        } }, { key: "addText", value: function(t3) {
          var e3 = this.hash[t3];
          return e3 === void 0 && (e3 = this.hash[t3] = this.model.values.length, this.model.values.push(t3)), this.model.count++, e3;
        } }, { key: "addRichText", value: function(t3) {
          var e3 = this.sharedStringXform.toXml(t3), r3 = this.rich[e3];
          return r3 === void 0 && (r3 = this.rich[e3] = this.model.values.length, this.model.values.push(t3)), this.model.count++, r3;
        } }, { key: "render", value: function(t3, e3) {
          e3 = e3 || this._values, t3.openXml(c.StdDocAttributes), t3.openNode("sst", { xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main", count: e3.count, uniqueCount: e3.values.length });
          var r3 = this.sharedStringXform;
          e3.values.forEach(function(e4) {
            r3.render(t3, e4);
          }), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          if (this.parser)
            return this.parser.parseOpen(t3), true;
          switch (t3.name) {
            case "sst":
              return true;
            case "si":
              return this.parser = this.sharedStringXform, this.parser.parseOpen(t3), true;
            default:
              throw new Error("Unexpected xml node in parseOpen: ".concat(JSON.stringify(t3)));
          }
        } }, { key: "parseText", value: function(t3) {
          this.parser && this.parser.parseText(t3);
        } }, { key: "parseClose", value: function(t3) {
          if (this.parser)
            return this.parser.parseClose(t3) || (this.model.values.push(this.parser.model), this.model.count++, this.parser = void 0), true;
          switch (t3) {
            case "sst":
              return false;
            default:
              throw new Error("Unexpected xml node in parseClose: ".concat(t3));
          }
        } }, { key: "sharedStringXform", get: function() {
          return this._sharedStringXform || (this._sharedStringXform = new l());
        } }, { key: "values", get: function() {
          return this.model.values;
        } }, { key: "uniqueCount", get: function() {
          return this.model.values.length;
        } }, { key: "count", get: function() {
          return this.model.count;
        } }]) && i(e2.prototype, r2), u2;
      }(f);
      e.exports = h;
    }, { "../../../utils/xml-stream": 27, "../base-xform": 31, "./shared-string-xform": 122 }], 124: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          t3.openNode("t"), /^\s|\n|\s$/.test(e3) && t3.addAttribute("xml:space", "preserve"), t3.writeText(e3), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          switch (t3.name) {
            case "t":
              return this._text = [], true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function(t3) {
          this._text.push(t3);
        } }, { key: "parseClose", value: function() {
          return false;
        } }, { key: "tag", get: function() {
          return "t";
        } }, { key: "model", get: function() {
          return this._text.join("").replace(/_x([0-9A-F]{4})_/g, function(t3, e3) {
            return String.fromCharCode(parseInt(e3, 16));
          });
        } }]) && o(e2.prototype, r2), c2;
      }(t("../base-xform"));
      e.exports = f;
    }, { "../base-xform": 31 }], 125: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = t("../../../doc/enums"), l = t("../../../utils/utils"), h = t("../base-xform"), d = { horizontalValues: ["left", "center", "right", "fill", "centerContinuous", "distributed", "justify"].reduce(function(t2, e2) {
        return t2[e2] = true, t2;
      }, {}), horizontal: function(t2) {
        return this.horizontalValues[t2] ? t2 : void 0;
      }, verticalValues: ["top", "middle", "bottom", "distributed", "justify"].reduce(function(t2, e2) {
        return t2[e2] = true, t2;
      }, {}), vertical: function(t2) {
        return t2 === "middle" ? "center" : this.verticalValues[t2] ? t2 : void 0;
      }, wrapText: function(t2) {
        return !!t2 || void 0;
      }, shrinkToFit: function(t2) {
        return !!t2 || void 0;
      }, textRotation: function(t2) {
        switch (t2) {
          case "vertical":
            return t2;
          default:
            return (t2 = l.validInt(t2)) >= -90 && t2 <= 90 ? t2 : void 0;
        }
      }, indent: function(t2) {
        return t2 = l.validInt(t2), Math.max(0, t2);
      }, readingOrder: function(t2) {
        switch (t2) {
          case "ltr":
            return f.ReadingOrder.LeftToRight;
          case "rtl":
            return f.ReadingOrder.RightToLeft;
          default:
            return;
        }
      } }, p = function(t2) {
        if (t2 = d.textRotation(t2)) {
          if (t2 === "vertical")
            return 255;
          var e2 = Math.round(t2);
          if (e2 >= 0 && e2 <= 90)
            return e2;
          if (e2 < 0 && e2 >= -90)
            return 90 - e2;
        }
      }, m = function(t2) {
        var e2 = l.validInt(t2);
        if (e2 !== void 0) {
          if (e2 === 255)
            return "vertical";
          if (e2 >= 0 && e2 <= 90)
            return e2;
          if (e2 > 90 && e2 <= 180)
            return 90 - e2;
        }
      }, y = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          t3.addRollback(), t3.openNode("alignment");
          var r3 = false;
          function n3(e4, n4) {
            n4 && (t3.addAttribute(e4, n4), r3 = true);
          }
          n3("horizontal", d.horizontal(e3.horizontal)), n3("vertical", d.vertical(e3.vertical)), n3("wrapText", !!d.wrapText(e3.wrapText) && "1"), n3("shrinkToFit", !!d.shrinkToFit(e3.shrinkToFit) && "1"), n3("indent", d.indent(e3.indent)), n3("textRotation", p(e3.textRotation)), n3("readingOrder", d.readingOrder(e3.readingOrder)), t3.closeNode(), r3 ? t3.commit() : t3.rollback();
        } }, { key: "parseOpen", value: function(t3) {
          var e3 = {}, r3 = false;
          function n3(t4, n4, i2) {
            t4 && (e3[n4] = i2, r3 = true);
          }
          n3(t3.attributes.horizontal, "horizontal", t3.attributes.horizontal), n3(t3.attributes.vertical, "vertical", t3.attributes.vertical === "center" ? "middle" : t3.attributes.vertical), n3(t3.attributes.wrapText, "wrapText", !!t3.attributes.wrapText), n3(t3.attributes.shrinkToFit, "shrinkToFit", !!t3.attributes.shrinkToFit), n3(t3.attributes.indent, "indent", parseInt(t3.attributes.indent, 10)), n3(t3.attributes.textRotation, "textRotation", m(t3.attributes.textRotation)), n3(t3.attributes.readingOrder, "readingOrder", t3.attributes.readingOrder === "2" ? "rtl" : "ltr"), this.model = r3 ? e3 : null;
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function() {
          return false;
        } }, { key: "tag", get: function() {
          return "alignment";
        } }]) && o(e2.prototype, r2), c2;
      }(h);
      e.exports = y;
    }, { "../../../doc/enums": 7, "../../../utils/utils": 26, "../base-xform": 31 }], 126: [function(t, e, r) {
      function n(t2, e2) {
        var r2 = Object.keys(t2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t2);
          e2 && (n2 = n2.filter(function(e3) {
            return Object.getOwnPropertyDescriptor(t2, e3).enumerable;
          })), r2.push.apply(r2, n2);
        }
        return r2;
      }
      function i(t2) {
        for (var e2 = 1; e2 < arguments.length; e2++) {
          var r2 = arguments[e2] != null ? arguments[e2] : {};
          e2 % 2 ? n(Object(r2), true).forEach(function(e3) {
            o(t2, e3, r2[e3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(r2)) : n(Object(r2)).forEach(function(e3) {
            Object.defineProperty(t2, e3, Object.getOwnPropertyDescriptor(r2, e3));
          });
        }
        return t2;
      }
      function o(t2, e2, r2) {
        return e2 in t2 ? Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }) : t2[e2] = r2, t2;
      }
      function a(t2) {
        return (a = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function s(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function u(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function c(t2, e2, r2) {
        return e2 && u(t2.prototype, e2), r2 && u(t2, r2), t2;
      }
      function f(t2, e2) {
        if (typeof e2 != "function" && e2 !== null)
          throw new TypeError("Super expression must either be null or a function");
        t2.prototype = Object.create(e2 && e2.prototype, { constructor: { value: t2, writable: true, configurable: true } }), e2 && l(t2, e2);
      }
      function l(t2, e2) {
        return (l = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function h(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = p(t2);
          if (e2) {
            var i2 = p(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return d(this, r2);
        };
      }
      function d(t2, e2) {
        return !e2 || a(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function p(t2) {
        return (p = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var m = t("../base-xform"), y = t("./color-xform"), b = function(t2) {
        f(r2, t2);
        var e2 = h(r2);
        function r2(t3) {
          var n2;
          return s(this, r2), (n2 = e2.call(this)).name = t3, n2.map = { color: new y() }, n2;
        }
        return c(r2, [{ key: "render", value: function(t3, e3, r3) {
          var n2 = e3 && e3.color || r3 || this.defaultColor;
          t3.openNode(this.name), e3 && e3.style && (t3.addAttribute("style", e3.style), n2 && this.map.color.render(t3, n2)), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          if (this.parser)
            return this.parser.parseOpen(t3), true;
          switch (t3.name) {
            case this.name:
              var e3 = t3.attributes.style;
              return this.model = e3 ? { style: e3 } : void 0, true;
            case "color":
              return this.parser = this.map.color, this.parser.parseOpen(t3), true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function(t3) {
          this.parser && this.parser.parseText(t3);
        } }, { key: "parseClose", value: function(t3) {
          return this.parser ? (this.parser.parseClose(t3) || (this.parser = void 0), true) : (t3 === this.name && this.map.color.model && (this.model || (this.model = {}), this.model.color = this.map.color.model), false);
        } }, { key: "validStyle", value: function(t3) {
          return r2.validStyleValues[t3];
        } }, { key: "tag", get: function() {
          return this.name;
        } }]), r2;
      }(m);
      b.validStyleValues = ["thin", "dotted", "dashDot", "hair", "dashDotDot", "slantDashDot", "mediumDashed", "mediumDashDotDot", "mediumDashDot", "medium", "double", "thick"].reduce(function(t2, e2) {
        return t2[e2] = true, t2;
      }, {});
      var v = function(t2) {
        f(r2, t2);
        var e2 = h(r2);
        function r2() {
          var t3;
          return s(this, r2), (t3 = e2.call(this)).map = { top: new b("top"), left: new b("left"), bottom: new b("bottom"), right: new b("right"), diagonal: new b("diagonal") }, t3;
        }
        return c(r2, [{ key: "render", value: function(t3, e3) {
          var r3 = e3.color;
          function n2(n3, o2) {
            n3 && !n3.color && e3.color && (n3 = i(i({}, n3), {}, { color: e3.color })), o2.render(t3, n3, r3);
          }
          t3.openNode("border"), e3.diagonal && e3.diagonal.style && (e3.diagonal.up && t3.addAttribute("diagonalUp", "1"), e3.diagonal.down && t3.addAttribute("diagonalDown", "1")), n2(e3.left, this.map.left), n2(e3.right, this.map.right), n2(e3.top, this.map.top), n2(e3.bottom, this.map.bottom), n2(e3.diagonal, this.map.diagonal), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          if (this.parser)
            return this.parser.parseOpen(t3), true;
          switch (t3.name) {
            case "border":
              return this.reset(), this.diagonalUp = !!t3.attributes.diagonalUp, this.diagonalDown = !!t3.attributes.diagonalDown, true;
            default:
              return this.parser = this.map[t3.name], !!this.parser && (this.parser.parseOpen(t3), true);
          }
        } }, { key: "parseText", value: function(t3) {
          this.parser && this.parser.parseText(t3);
        } }, { key: "parseClose", value: function(t3) {
          if (this.parser)
            return this.parser.parseClose(t3) || (this.parser = void 0), true;
          if (t3 === "border") {
            var e3 = this.model = {}, r3 = function(t4, r4, n2) {
              r4 && (n2 && Object.assign(r4, n2), e3[t4] = r4);
            };
            r3("left", this.map.left.model), r3("right", this.map.right.model), r3("top", this.map.top.model), r3("bottom", this.map.bottom.model), r3("diagonal", this.map.diagonal.model, { up: this.diagonalUp, down: this.diagonalDown });
          }
          return false;
        } }]), r2;
      }(m);
      e.exports = v;
    }, { "../base-xform": 31, "./color-xform": 127 }], 127: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2(t3) {
          var e3;
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (e3 = s2.call(this)).name = t3 || "color", e3;
        }
        return e2 = u2, (r2 = [{ key: "render", value: function(t3, e3) {
          return !!e3 && (t3.openNode(this.name), e3.argb ? t3.addAttribute("rgb", e3.argb) : e3.theme !== void 0 ? (t3.addAttribute("theme", e3.theme), e3.tint !== void 0 && t3.addAttribute("tint", e3.tint)) : e3.indexed !== void 0 ? t3.addAttribute("indexed", e3.indexed) : t3.addAttribute("auto", "1"), t3.closeNode(), true);
        } }, { key: "parseOpen", value: function(t3) {
          return t3.name === this.name && (t3.attributes.rgb ? this.model = { argb: t3.attributes.rgb } : t3.attributes.theme ? (this.model = { theme: parseInt(t3.attributes.theme, 10) }, t3.attributes.tint && (this.model.tint = parseFloat(t3.attributes.tint))) : t3.attributes.indexed ? this.model = { indexed: parseInt(t3.attributes.indexed, 10) } : this.model = void 0, true);
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function() {
          return false;
        } }, { key: "tag", get: function() {
          return this.name;
        } }]) && i(e2.prototype, r2), u2;
      }(t("../base-xform"));
      e.exports = c;
    }, { "../base-xform": 31 }], 128: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("../base-xform"), f = t("./alignment-xform"), l = t("./border-xform"), h = t("./fill-xform"), d = t("./font-xform"), p = t("./numfmt-xform"), m = t("./protection-xform"), y = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2() {
          var t3;
          return function(t4, e3) {
            if (!(t4 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (t3 = s2.call(this)).map = { alignment: new f(), border: new l(), fill: new h(), font: new d(), numFmt: new p(), protection: new m() }, t3;
        }
        return e2 = u2, (r2 = [{ key: "render", value: function(t3, e3) {
          t3.openNode(this.tag), e3.alignment && this.map.alignment.render(t3, e3.alignment), e3.border && this.map.border.render(t3, e3.border), e3.fill && this.map.fill.render(t3, e3.fill), e3.font && this.map.font.render(t3, e3.font), e3.numFmt && this.map.numFmt.render(t3, e3.numFmt), e3.protection && this.map.protection.render(t3, e3.protection), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          if (this.parser)
            return this.parser.parseOpen(t3), true;
          switch (t3.name) {
            case this.tag:
              return this.reset(), true;
            default:
              return this.parser = this.map[t3.name], this.parser && this.parser.parseOpen(t3), true;
          }
        } }, { key: "parseText", value: function(t3) {
          this.parser && this.parser.parseText(t3);
        } }, { key: "parseClose", value: function(t3) {
          return this.parser ? (this.parser.parseClose(t3) || (this.parser = void 0), true) : t3 !== this.tag || (this.model = { alignment: this.map.alignment.model, border: this.map.border.model, fill: this.map.fill.model, font: this.map.font.model, numFmt: this.map.numFmt.model, protection: this.map.protection.model }, false);
        } }, { key: "tag", get: function() {
          return "dxf";
        } }]) && i(e2.prototype, r2), u2;
      }(c);
      e.exports = y;
    }, { "../base-xform": 31, "./alignment-xform": 125, "./border-xform": 126, "./fill-xform": 129, "./font-xform": 130, "./numfmt-xform": 131, "./protection-xform": 132 }], 129: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2, r2) {
        return e2 && o(t2.prototype, e2), r2 && o(t2, r2), t2;
      }
      function s(t2, e2) {
        if (typeof e2 != "function" && e2 !== null)
          throw new TypeError("Super expression must either be null or a function");
        t2.prototype = Object.create(e2 && e2.prototype, { constructor: { value: t2, writable: true, configurable: true } }), e2 && u(t2, e2);
      }
      function u(t2, e2) {
        return (u = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function c(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = l(t2);
          if (e2) {
            var i2 = l(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return f(this, r2);
        };
      }
      function f(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function l(t2) {
        return (l = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var h = t("../base-xform"), d = t("./color-xform"), p = function(t2) {
        s(r2, t2);
        var e2 = c(r2);
        function r2() {
          var t3;
          return i(this, r2), (t3 = e2.call(this)).map = { color: new d() }, t3;
        }
        return a(r2, [{ key: "render", value: function(t3, e3) {
          t3.openNode("stop"), t3.addAttribute("position", e3.position), this.map.color.render(t3, e3.color), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          if (this.parser)
            return this.parser.parseOpen(t3), true;
          switch (t3.name) {
            case "stop":
              return this.model = { position: parseFloat(t3.attributes.position) }, true;
            case "color":
              return this.parser = this.map.color, this.parser.parseOpen(t3), true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function(t3) {
          return !!this.parser && (this.parser.parseClose(t3) || (this.model.color = this.parser.model, this.parser = void 0), true);
        } }, { key: "tag", get: function() {
          return "stop";
        } }]), r2;
      }(h), m = function(t2) {
        s(r2, t2);
        var e2 = c(r2);
        function r2() {
          var t3;
          return i(this, r2), (t3 = e2.call(this)).map = { fgColor: new d("fgColor"), bgColor: new d("bgColor") }, t3;
        }
        return a(r2, [{ key: "render", value: function(t3, e3) {
          t3.openNode("patternFill"), t3.addAttribute("patternType", e3.pattern), e3.fgColor && this.map.fgColor.render(t3, e3.fgColor), e3.bgColor && this.map.bgColor.render(t3, e3.bgColor), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          if (this.parser)
            return this.parser.parseOpen(t3), true;
          switch (t3.name) {
            case "patternFill":
              return this.model = { type: "pattern", pattern: t3.attributes.patternType }, true;
            default:
              return this.parser = this.map[t3.name], !!this.parser && (this.parser.parseOpen(t3), true);
          }
        } }, { key: "parseText", value: function(t3) {
          this.parser && this.parser.parseText(t3);
        } }, { key: "parseClose", value: function(t3) {
          return !!this.parser && (this.parser.parseClose(t3) || (this.parser.model && (this.model[t3] = this.parser.model), this.parser = void 0), true);
        } }, { key: "name", get: function() {
          return "pattern";
        } }, { key: "tag", get: function() {
          return "patternFill";
        } }]), r2;
      }(h), y = function(t2) {
        s(r2, t2);
        var e2 = c(r2);
        function r2() {
          var t3;
          return i(this, r2), (t3 = e2.call(this)).map = { stop: new p() }, t3;
        }
        return a(r2, [{ key: "render", value: function(t3, e3) {
          switch (t3.openNode("gradientFill"), e3.gradient) {
            case "angle":
              t3.addAttribute("degree", e3.degree);
              break;
            case "path":
              t3.addAttribute("type", "path"), e3.center.left && (t3.addAttribute("left", e3.center.left), e3.center.right === void 0 && t3.addAttribute("right", e3.center.left)), e3.center.right && t3.addAttribute("right", e3.center.right), e3.center.top && (t3.addAttribute("top", e3.center.top), e3.center.bottom === void 0 && t3.addAttribute("bottom", e3.center.top)), e3.center.bottom && t3.addAttribute("bottom", e3.center.bottom);
          }
          var r3 = this.map.stop;
          e3.stops.forEach(function(e4) {
            r3.render(t3, e4);
          }), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          if (this.parser)
            return this.parser.parseOpen(t3), true;
          switch (t3.name) {
            case "gradientFill":
              var e3 = this.model = { stops: [] };
              return t3.attributes.degree ? (e3.gradient = "angle", e3.degree = parseInt(t3.attributes.degree, 10)) : t3.attributes.type === "path" && (e3.gradient = "path", e3.center = { left: t3.attributes.left ? parseFloat(t3.attributes.left) : 0, top: t3.attributes.top ? parseFloat(t3.attributes.top) : 0 }, t3.attributes.right !== t3.attributes.left && (e3.center.right = t3.attributes.right ? parseFloat(t3.attributes.right) : 0), t3.attributes.bottom !== t3.attributes.top && (e3.center.bottom = t3.attributes.bottom ? parseFloat(t3.attributes.bottom) : 0)), true;
            case "stop":
              return this.parser = this.map.stop, this.parser.parseOpen(t3), true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function(t3) {
          this.parser && this.parser.parseText(t3);
        } }, { key: "parseClose", value: function(t3) {
          return !!this.parser && (this.parser.parseClose(t3) || (this.model.stops.push(this.parser.model), this.parser = void 0), true);
        } }, { key: "name", get: function() {
          return "gradient";
        } }, { key: "tag", get: function() {
          return "gradientFill";
        } }]), r2;
      }(h), b = function(t2) {
        s(r2, t2);
        var e2 = c(r2);
        function r2() {
          var t3;
          return i(this, r2), (t3 = e2.call(this)).map = { patternFill: new m(), gradientFill: new y() }, t3;
        }
        return a(r2, [{ key: "render", value: function(t3, e3) {
          switch (t3.addRollback(), t3.openNode("fill"), e3.type) {
            case "pattern":
              this.map.patternFill.render(t3, e3);
              break;
            case "gradient":
              this.map.gradientFill.render(t3, e3);
              break;
            default:
              return void t3.rollback();
          }
          t3.closeNode(), t3.commit();
        } }, { key: "parseOpen", value: function(t3) {
          if (this.parser)
            return this.parser.parseOpen(t3), true;
          switch (t3.name) {
            case "fill":
              return this.model = {}, true;
            default:
              return this.parser = this.map[t3.name], !!this.parser && (this.parser.parseOpen(t3), true);
          }
        } }, { key: "parseText", value: function(t3) {
          this.parser && this.parser.parseText(t3);
        } }, { key: "parseClose", value: function(t3) {
          return !!this.parser && (this.parser.parseClose(t3) || (this.model = this.parser.model, this.model.type = this.parser.name, this.parser = void 0), true);
        } }, { key: "validStyle", value: function(t3) {
          return r2.validPatternValues[t3];
        } }, { key: "tag", get: function() {
          return "fill";
        } }]), r2;
      }(h);
      b.validPatternValues = ["none", "solid", "darkVertical", "darkGray", "mediumGray", "lightGray", "gray125", "gray0625", "darkHorizontal", "darkVertical", "darkDown", "darkUp", "darkGrid", "darkTrellis", "lightHorizontal", "lightVertical", "lightDown", "lightUp", "lightGrid", "lightTrellis", "lightGrid"].reduce(function(t2, e2) {
        return t2[e2] = true, t2;
      }, {}), b.StopXform = p, b.PatternFillXform = m, b.GradientFillXform = y, e.exports = b;
    }, { "../base-xform": 31, "./color-xform": 127 }], 130: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("./color-xform"), f = t("../simple/boolean-xform"), l = t("../simple/integer-xform"), h = t("../simple/string-xform"), d = t("./underline-xform"), p = t("../../../utils/under-dash"), m = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2(t3) {
          var e3;
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (e3 = s2.call(this)).options = t3 || u2.OPTIONS, e3.map = { b: { prop: "bold", xform: new f({ tag: "b", attr: "val" }) }, i: { prop: "italic", xform: new f({ tag: "i", attr: "val" }) }, u: { prop: "underline", xform: new d() }, charset: { prop: "charset", xform: new l({ tag: "charset", attr: "val" }) }, color: { prop: "color", xform: new c() }, condense: { prop: "condense", xform: new f({ tag: "condense", attr: "val" }) }, extend: { prop: "extend", xform: new f({ tag: "extend", attr: "val" }) }, family: { prop: "family", xform: new l({ tag: "family", attr: "val" }) }, outline: { prop: "outline", xform: new f({ tag: "outline", attr: "val" }) }, vertAlign: { prop: "vertAlign", xform: new h({ tag: "vertAlign", attr: "val" }) }, scheme: { prop: "scheme", xform: new h({ tag: "scheme", attr: "val" }) }, shadow: { prop: "shadow", xform: new f({ tag: "shadow", attr: "val" }) }, strike: { prop: "strike", xform: new f({ tag: "strike", attr: "val" }) }, sz: { prop: "size", xform: new l({ tag: "sz", attr: "val" }) } }, e3.map[e3.options.fontNameTag] = { prop: "name", xform: new h({ tag: e3.options.fontNameTag, attr: "val" }) }, e3;
        }
        return e2 = u2, (r2 = [{ key: "render", value: function(t3, e3) {
          var r3 = this.map;
          t3.openNode(this.options.tagName), p.each(this.map, function(n3, i2) {
            r3[i2].xform.render(t3, e3[n3.prop]);
          }), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          if (this.parser)
            return this.parser.parseOpen(t3), true;
          if (this.map[t3.name])
            return this.parser = this.map[t3.name].xform, this.parser.parseOpen(t3);
          switch (t3.name) {
            case this.options.tagName:
              return this.model = {}, true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function(t3) {
          this.parser && this.parser.parseText(t3);
        } }, { key: "parseClose", value: function(t3) {
          if (this.parser && !this.parser.parseClose(t3)) {
            var e3 = this.map[t3];
            return this.parser.model && (this.model[e3.prop] = this.parser.model), this.parser = void 0, true;
          }
          switch (t3) {
            case this.options.tagName:
              return false;
            default:
              return true;
          }
        } }, { key: "tag", get: function() {
          return this.options.tagName;
        } }]) && i(e2.prototype, r2), u2;
      }(t("../base-xform"));
      m.OPTIONS = { tagName: "font", fontNameTag: "name" }, e.exports = m;
    }, { "../../../utils/under-dash": 25, "../base-xform": 31, "../simple/boolean-xform": 115, "../simple/integer-xform": 117, "../simple/string-xform": 118, "./color-xform": 127, "./underline-xform": 135 }], 131: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("../../../utils/under-dash"), f = t("../../defaultnumformats"), l = t("../base-xform");
      var h, d = (h = {}, c.each(f, function(t2, e2) {
        t2.f && (h[t2.f] = parseInt(e2, 10));
      }), h), p = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2(t3, e3) {
          var r3;
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (r3 = s2.call(this)).id = t3, r3.formatCode = e3, r3;
        }
        return e2 = u2, (r2 = [{ key: "render", value: function(t3, e3) {
          t3.leafNode("numFmt", { numFmtId: e3.id, formatCode: e3.formatCode });
        } }, { key: "parseOpen", value: function(t3) {
          switch (t3.name) {
            case "numFmt":
              return this.model = { id: parseInt(t3.attributes.numFmtId, 10), formatCode: t3.attributes.formatCode.replace(/[\\](.)/g, "$1") }, true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function() {
          return false;
        } }, { key: "tag", get: function() {
          return "numFmt";
        } }]) && i(e2.prototype, r2), u2;
      }(l);
      p.getDefaultFmtId = function(t2) {
        return d[t2];
      }, p.getDefaultFmtCode = function(t2) {
        return f[t2] && f[t2].f;
      }, e.exports = p;
    }, { "../../../utils/under-dash": 25, "../../defaultnumformats": 29, "../base-xform": 31 }], 132: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = t("../base-xform"), l = function(t2, e2) {
        return t2 === void 0 ? e2 : t2;
      }, h = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          t3.addRollback(), t3.openNode("protection");
          var r3 = false;
          function n3(e4, n4) {
            n4 !== void 0 && (t3.addAttribute(e4, n4), r3 = true);
          }
          n3("locked", l(e3.locked, true) ? void 0 : "0"), n3("hidden", l(e3.hidden, false) ? "1" : void 0), t3.closeNode(), r3 ? t3.commit() : t3.rollback();
        } }, { key: "parseOpen", value: function(t3) {
          var e3 = { locked: !(t3.attributes.locked === "0"), hidden: t3.attributes.hidden === "1" }, r3 = !e3.locked || e3.hidden;
          this.model = r3 ? e3 : null;
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function() {
          return false;
        } }, { key: "tag", get: function() {
          return "protection";
        } }]) && o(e2.prototype, r2), c2;
      }(f);
      e.exports = h;
    }, { "../base-xform": 31 }], 133: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("../base-xform"), f = t("./alignment-xform"), l = t("./protection-xform"), h = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2(t3) {
          var e3;
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (e3 = s2.call(this)).xfId = !(!t3 || !t3.xfId), e3.map = { alignment: new f(), protection: new l() }, e3;
        }
        return e2 = u2, (r2 = [{ key: "render", value: function(t3, e3) {
          t3.openNode("xf", { numFmtId: e3.numFmtId || 0, fontId: e3.fontId || 0, fillId: e3.fillId || 0, borderId: e3.borderId || 0 }), this.xfId && t3.addAttribute("xfId", e3.xfId || 0), e3.numFmtId && t3.addAttribute("applyNumberFormat", "1"), e3.fontId && t3.addAttribute("applyFont", "1"), e3.fillId && t3.addAttribute("applyFill", "1"), e3.borderId && t3.addAttribute("applyBorder", "1"), e3.alignment && t3.addAttribute("applyAlignment", "1"), e3.protection && t3.addAttribute("applyProtection", "1"), e3.alignment && this.map.alignment.render(t3, e3.alignment), e3.protection && this.map.protection.render(t3, e3.protection), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          if (this.parser)
            return this.parser.parseOpen(t3), true;
          switch (t3.name) {
            case "xf":
              return this.model = { numFmtId: parseInt(t3.attributes.numFmtId, 10), fontId: parseInt(t3.attributes.fontId, 10), fillId: parseInt(t3.attributes.fillId, 10), borderId: parseInt(t3.attributes.borderId, 10) }, this.xfId && (this.model.xfId = parseInt(t3.attributes.xfId, 10)), true;
            case "alignment":
              return this.parser = this.map.alignment, this.parser.parseOpen(t3), true;
            case "protection":
              return this.parser = this.map.protection, this.parser.parseOpen(t3), true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function(t3) {
          this.parser && this.parser.parseText(t3);
        } }, { key: "parseClose", value: function(t3) {
          return this.parser ? (this.parser.parseClose(t3) || (this.map.protection === this.parser ? this.model.protection = this.parser.model : this.model.alignment = this.parser.model, this.parser = void 0), true) : t3 !== "xf";
        } }, { key: "tag", get: function() {
          return "xf";
        } }]) && i(e2.prototype, r2), u2;
      }(c);
      e.exports = h;
    }, { "../base-xform": 31, "./alignment-xform": 125, "./protection-xform": 132 }], 134: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2, r2) {
        return e2 && o(t2.prototype, e2), r2 && o(t2, r2), t2;
      }
      function s(t2, e2) {
        if (typeof e2 != "function" && e2 !== null)
          throw new TypeError("Super expression must either be null or a function");
        t2.prototype = Object.create(e2 && e2.prototype, { constructor: { value: t2, writable: true, configurable: true } }), e2 && u(t2, e2);
      }
      function u(t2, e2) {
        return (u = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function c(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = l(t2);
          if (e2) {
            var i2 = l(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return f(this, r2);
        };
      }
      function f(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function l(t2) {
        return (l = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var h = t("../../../doc/enums"), d = t("../../../utils/xml-stream"), p = t("../base-xform"), m = t("../static-xform"), y = t("../list-xform"), b = t("./font-xform"), v = t("./fill-xform"), g = t("./border-xform"), w = t("./numfmt-xform"), _ = t("./style-xform"), k = t("./dxf-xform"), x = function(t2) {
        s(r2, t2);
        var e2 = c(r2);
        function r2(t3) {
          var n2;
          return i(this, r2), (n2 = e2.call(this)).map = { numFmts: new y({ tag: "numFmts", count: true, childXform: new w() }), fonts: new y({ tag: "fonts", count: true, childXform: new b(), $: { "x14ac:knownFonts": 1 } }), fills: new y({ tag: "fills", count: true, childXform: new v() }), borders: new y({ tag: "borders", count: true, childXform: new g() }), cellStyleXfs: new y({ tag: "cellStyleXfs", count: true, childXform: new _() }), cellXfs: new y({ tag: "cellXfs", count: true, childXform: new _({ xfId: true }) }), dxfs: new y({ tag: "dxfs", always: true, count: true, childXform: new k() }), numFmt: new w(), font: new b(), fill: new v(), border: new g(), style: new _({ xfId: true }), cellStyles: r2.STATIC_XFORMS.cellStyles, tableStyles: r2.STATIC_XFORMS.tableStyles, extLst: r2.STATIC_XFORMS.extLst }, t3 && n2.init(), n2;
        }
        return a(r2, [{ key: "initIndex", value: function() {
          this.index = { style: {}, numFmt: {}, numFmtNextId: 164, font: {}, border: {}, fill: {} };
        } }, { key: "init", value: function() {
          this.model = { styles: [], numFmts: [], fonts: [], borders: [], fills: [], dxfs: [] }, this.initIndex(), this._addBorder({}), this._addStyle({ numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0 }), this._addFill({ type: "pattern", pattern: "none" }), this._addFill({ type: "pattern", pattern: "gray125" }), this.weakMap = new WeakMap();
        } }, { key: "render", value: function(t3, e3) {
          e3 = e3 || this.model, t3.openXml(d.StdDocAttributes), t3.openNode("styleSheet", r2.STYLESHEET_ATTRIBUTES), this.index ? (e3.numFmts && e3.numFmts.length && (t3.openNode("numFmts", { count: e3.numFmts.length }), e3.numFmts.forEach(function(e4) {
            t3.writeXml(e4);
          }), t3.closeNode()), e3.fonts.length || this._addFont({ size: 11, color: { theme: 1 }, name: "Calibri", family: 2, scheme: "minor" }), t3.openNode("fonts", { count: e3.fonts.length, "x14ac:knownFonts": 1 }), e3.fonts.forEach(function(e4) {
            t3.writeXml(e4);
          }), t3.closeNode(), t3.openNode("fills", { count: e3.fills.length }), e3.fills.forEach(function(e4) {
            t3.writeXml(e4);
          }), t3.closeNode(), t3.openNode("borders", { count: e3.borders.length }), e3.borders.forEach(function(e4) {
            t3.writeXml(e4);
          }), t3.closeNode(), this.map.cellStyleXfs.render(t3, [{ numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0 }]), t3.openNode("cellXfs", { count: e3.styles.length }), e3.styles.forEach(function(e4) {
            t3.writeXml(e4);
          }), t3.closeNode()) : (this.map.numFmts.render(t3, e3.numFmts), this.map.fonts.render(t3, e3.fonts), this.map.fills.render(t3, e3.fills), this.map.borders.render(t3, e3.borders), this.map.cellStyleXfs.render(t3, [{ numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0 }]), this.map.cellXfs.render(t3, e3.styles)), r2.STATIC_XFORMS.cellStyles.render(t3), this.map.dxfs.render(t3, e3.dxfs), r2.STATIC_XFORMS.tableStyles.render(t3), r2.STATIC_XFORMS.extLst.render(t3), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          if (this.parser)
            return this.parser.parseOpen(t3), true;
          switch (t3.name) {
            case "styleSheet":
              return this.initIndex(), true;
            default:
              return this.parser = this.map[t3.name], this.parser && this.parser.parseOpen(t3), true;
          }
        } }, { key: "parseText", value: function(t3) {
          this.parser && this.parser.parseText(t3);
        } }, { key: "parseClose", value: function(t3) {
          var e3 = this;
          if (this.parser)
            return this.parser.parseClose(t3) || (this.parser = void 0), true;
          switch (t3) {
            case "styleSheet":
              this.model = {};
              var r3 = function(t4, r4) {
                r4.model && r4.model.length && (e3.model[t4] = r4.model);
              };
              if (r3("numFmts", this.map.numFmts), r3("fonts", this.map.fonts), r3("fills", this.map.fills), r3("borders", this.map.borders), r3("styles", this.map.cellXfs), r3("dxfs", this.map.dxfs), this.index = { model: [], numFmt: [] }, this.model.numFmts) {
                var n2 = this.index.numFmt;
                this.model.numFmts.forEach(function(t4) {
                  n2[t4.id] = t4.formatCode;
                });
              }
              return false;
            default:
              return true;
          }
        } }, { key: "addStyleModel", value: function(t3, e3) {
          if (!t3)
            return 0;
          if (this.model.fonts.length || this._addFont({ size: 11, color: { theme: 1 }, name: "Calibri", family: 2, scheme: "minor" }), this.weakMap && this.weakMap.has(t3))
            return this.weakMap.get(t3);
          var r3 = {};
          if (e3 = e3 || h.ValueType.Number, t3.numFmt)
            r3.numFmtId = this._addNumFmtStr(t3.numFmt);
          else
            switch (e3) {
              case h.ValueType.Number:
                r3.numFmtId = this._addNumFmtStr("General");
                break;
              case h.ValueType.Date:
                r3.numFmtId = this._addNumFmtStr("mm-dd-yy");
            }
          t3.font && (r3.fontId = this._addFont(t3.font)), t3.border && (r3.borderId = this._addBorder(t3.border)), t3.fill && (r3.fillId = this._addFill(t3.fill)), t3.alignment && (r3.alignment = t3.alignment), t3.protection && (r3.protection = t3.protection);
          var n2 = this._addStyle(r3);
          return this.weakMap && this.weakMap.set(t3, n2), n2;
        } }, { key: "getStyleModel", value: function(t3) {
          var e3 = this.model.styles[t3];
          if (!e3)
            return null;
          var r3 = this.index.model[t3];
          if (r3)
            return r3;
          if (r3 = this.index.model[t3] = {}, e3.numFmtId) {
            var n2 = this.index.numFmt[e3.numFmtId] || w.getDefaultFmtCode(e3.numFmtId);
            n2 && (r3.numFmt = n2);
          }
          function i2(t4, e4, n3) {
            if (n3 || n3 === 0) {
              var i3 = e4[n3];
              i3 && (r3[t4] = i3);
            }
          }
          return i2("font", this.model.fonts, e3.fontId), i2("border", this.model.borders, e3.borderId), i2("fill", this.model.fills, e3.fillId), e3.alignment && (r3.alignment = e3.alignment), e3.protection && (r3.protection = e3.protection), r3;
        } }, { key: "addDxfStyle", value: function(t3) {
          return this.model.dxfs.push(t3), this.model.dxfs.length - 1;
        } }, { key: "getDxfStyle", value: function(t3) {
          return this.model.dxfs[t3];
        } }, { key: "_addStyle", value: function(t3) {
          var e3 = this.map.style.toXml(t3), r3 = this.index.style[e3];
          return r3 === void 0 && (r3 = this.index.style[e3] = this.model.styles.length, this.model.styles.push(e3)), r3;
        } }, { key: "_addNumFmtStr", value: function(t3) {
          var e3 = w.getDefaultFmtId(t3);
          if (e3 !== void 0)
            return e3;
          if ((e3 = this.index.numFmt[t3]) !== void 0)
            return e3;
          e3 = this.index.numFmt[t3] = 164 + this.model.numFmts.length;
          var r3 = this.map.numFmt.toXml({ id: e3, formatCode: t3 });
          return this.model.numFmts.push(r3), e3;
        } }, { key: "_addFont", value: function(t3) {
          var e3 = this.map.font.toXml(t3), r3 = this.index.font[e3];
          return r3 === void 0 && (r3 = this.index.font[e3] = this.model.fonts.length, this.model.fonts.push(e3)), r3;
        } }, { key: "_addBorder", value: function(t3) {
          var e3 = this.map.border.toXml(t3), r3 = this.index.border[e3];
          return r3 === void 0 && (r3 = this.index.border[e3] = this.model.borders.length, this.model.borders.push(e3)), r3;
        } }, { key: "_addFill", value: function(t3) {
          var e3 = this.map.fill.toXml(t3), r3 = this.index.fill[e3];
          return r3 === void 0 && (r3 = this.index.fill[e3] = this.model.fills.length, this.model.fills.push(e3)), r3;
        } }]), r2;
      }(p);
      x.STYLESHEET_ATTRIBUTES = { xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main", "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006", "mc:Ignorable": "x14ac x16r2", "xmlns:x14ac": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac", "xmlns:x16r2": "http://schemas.microsoft.com/office/spreadsheetml/2015/02/main" }, x.STATIC_XFORMS = { cellStyles: new m({ tag: "cellStyles", $: { count: 1 }, c: [{ tag: "cellStyle", $: { name: "Normal", xfId: 0, builtinId: 0 } }] }), dxfs: new m({ tag: "dxfs", $: { count: 0 } }), tableStyles: new m({ tag: "tableStyles", $: { count: 0, defaultTableStyle: "TableStyleMedium2", defaultPivotStyle: "PivotStyleLight16" } }), extLst: new m({ tag: "extLst", c: [{ tag: "ext", $: { uri: "{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}", "xmlns:x14": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/main" }, c: [{ tag: "x14:slicerStyles", $: { defaultSlicerStyle: "SlicerStyleLight1" } }] }, { tag: "ext", $: { uri: "{9260A510-F301-46a8-8635-F512D64BE5F5}", "xmlns:x15": "http://schemas.microsoft.com/office/spreadsheetml/2010/11/main" }, c: [{ tag: "x15:timelineStyles", $: { defaultTimelineStyle: "TimeSlicerStyleLight1" } }] }] }) };
      var S = function(t2) {
        s(r2, t2);
        var e2 = c(r2);
        function r2() {
          var t3;
          return i(this, r2), (t3 = e2.call(this)).model = { styles: [{ numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0 }], numFmts: [], fonts: [{ size: 11, color: { theme: 1 }, name: "Calibri", family: 2, scheme: "minor" }], borders: [{}], fills: [{ type: "pattern", pattern: "none" }, { type: "pattern", pattern: "gray125" }] }, t3;
        }
        return a(r2, [{ key: "parseStream", value: function(t3) {
          return t3.autodrain(), Promise.resolve();
        } }, { key: "addStyleModel", value: function(t3, e3) {
          switch (e3) {
            case h.ValueType.Date:
              return this.dateStyleId;
            default:
              return 0;
          }
        } }, { key: "getStyleModel", value: function() {
          return {};
        } }, { key: "dateStyleId", get: function() {
          if (!this._dateStyleId) {
            var t3 = { numFmtId: w.getDefaultFmtId("mm-dd-yy") };
            this._dateStyleId = this.model.styles.length, this.model.styles.push(t3);
          }
          return this._dateStyleId;
        } }]), r2;
      }(x);
      x.Mock = S, e.exports = x;
    }, { "../../../doc/enums": 7, "../../../utils/xml-stream": 27, "../base-xform": 31, "../list-xform": 70, "../static-xform": 119, "./border-xform": 126, "./dxf-xform": 128, "./fill-xform": 129, "./font-xform": 130, "./numfmt-xform": 131, "./style-xform": 133 }], 135: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2(t3) {
          var e3;
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (e3 = s2.call(this)).model = t3, e3;
        }
        return e2 = u2, (r2 = [{ key: "render", value: function(t3, e3) {
          if ((e3 = e3 || this.model) === true)
            t3.leafNode("u");
          else {
            var r3 = u2.Attributes[e3];
            r3 && t3.leafNode("u", r3);
          }
        } }, { key: "parseOpen", value: function(t3) {
          t3.name === "u" && (this.model = t3.attributes.val || true);
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function() {
          return false;
        } }, { key: "tag", get: function() {
          return "u";
        } }]) && i(e2.prototype, r2), u2;
      }(t("../base-xform"));
      c.Attributes = { single: {}, double: { val: "double" }, singleAccounting: { val: "singleAccounting" }, doubleAccounting: { val: "doubleAccounting" } }, e.exports = c;
    }, { "../base-xform": 31 }], 136: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function o(t2, e2) {
        return (o = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function a(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = u(t2);
          if (e2) {
            var i2 = u(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return s(this, r2);
        };
      }
      function s(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function u(t2) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var c = t("../base-xform"), f = t("./filter-column-xform"), l = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
        }(u2, t2);
        var e2, r2, s2 = a(u2);
        function u2() {
          var t3;
          return function(t4, e3) {
            if (!(t4 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, u2), (t3 = s2.call(this)).map = { filterColumn: new f() }, t3;
        }
        return e2 = u2, (r2 = [{ key: "prepare", value: function(t3) {
          var e3 = this;
          t3.columns.forEach(function(t4, r3) {
            e3.map.filterColumn.prepare(t4, { index: r3 });
          });
        } }, { key: "render", value: function(t3, e3) {
          var r3 = this;
          return t3.openNode(this.tag, { ref: e3.autoFilterRef }), e3.columns.forEach(function(e4) {
            r3.map.filterColumn.render(t3, e4);
          }), t3.closeNode(), true;
        } }, { key: "parseOpen", value: function(t3) {
          if (this.parser)
            return this.parser.parseOpen(t3), true;
          switch (t3.name) {
            case this.tag:
              return this.model = { autoFilterRef: t3.attributes.ref, columns: [] }, true;
            default:
              if (this.parser = this.map[t3.name], this.parser)
                return this.parseOpen(t3), true;
              throw new Error("Unexpected xml node in parseOpen: ".concat(JSON.stringify(t3)));
          }
        } }, { key: "parseText", value: function(t3) {
          this.parser && this.parser.parseText(t3);
        } }, { key: "parseClose", value: function(t3) {
          if (this.parser)
            return this.parser.parseClose(t3) || (this.model.columns.push(this.parser.model), this.parser = void 0), true;
          switch (t3) {
            case this.tag:
              return false;
            default:
              throw new Error("Unexpected xml node in parseClose: ".concat(t3));
          }
        } }, { key: "tag", get: function() {
          return "autoFilter";
        } }]) && i(e2.prototype, r2), u2;
      }(c);
      e.exports = l;
    }, { "../base-xform": 31, "./filter-column-xform": 137 }], 137: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "prepare", value: function(t3, e3) {
          t3.colId = e3.index.toString();
        } }, { key: "render", value: function(t3, e3) {
          return t3.leafNode(this.tag, { colId: e3.colId, hiddenButton: e3.filterButton ? "0" : "1" }), true;
        } }, { key: "parseOpen", value: function(t3) {
          if (t3.name === this.tag) {
            var e3 = t3.attributes;
            return this.model = { filterButton: e3.hiddenButton === "0" }, true;
          }
          return false;
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function() {
          return false;
        } }, { key: "tag", get: function() {
          return "filterColumn";
        } }]) && o(e2.prototype, r2), c2;
      }(t("../base-xform"));
      e.exports = f;
    }, { "../base-xform": 31 }], 138: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "prepare", value: function(t3, e3) {
          t3.id = e3.index + 1;
        } }, { key: "render", value: function(t3, e3) {
          return t3.leafNode(this.tag, { id: e3.id.toString(), name: e3.name, totalsRowLabel: e3.totalsRowLabel, totalsRowFunction: e3.totalsRowFunction, dxfId: e3.dxfId }), true;
        } }, { key: "parseOpen", value: function(t3) {
          if (t3.name === this.tag) {
            var e3 = t3.attributes;
            return this.model = { name: e3.name, totalsRowLabel: e3.totalsRowLabel, totalsRowFunction: e3.totalsRowFunction, dxfId: e3.dxfId }, true;
          }
          return false;
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function() {
          return false;
        } }, { key: "tag", get: function() {
          return "tableColumn";
        } }]) && o(e2.prototype, r2), c2;
      }(t("../base-xform"));
      e.exports = f;
    }, { "../base-xform": 31 }], 139: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2, e2) {
        return (a = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function s(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = c(t2);
          if (e2) {
            var i2 = c(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return u(this, r2);
        };
      }
      function u(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function c(t2) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var f = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
        }(c2, t2);
        var e2, r2, u2 = s(c2);
        function c2() {
          return i(this, c2), u2.apply(this, arguments);
        }
        return e2 = c2, (r2 = [{ key: "render", value: function(t3, e3) {
          return t3.leafNode(this.tag, { name: e3.theme ? e3.theme : void 0, showFirstColumn: e3.showFirstColumn ? "1" : "0", showLastColumn: e3.showLastColumn ? "1" : "0", showRowStripes: e3.showRowStripes ? "1" : "0", showColumnStripes: e3.showColumnStripes ? "1" : "0" }), true;
        } }, { key: "parseOpen", value: function(t3) {
          if (t3.name === this.tag) {
            var e3 = t3.attributes;
            return this.model = { theme: e3.name ? e3.name : null, showFirstColumn: e3.showFirstColumn === "1", showLastColumn: e3.showLastColumn === "1", showRowStripes: e3.showRowStripes === "1", showColumnStripes: e3.showColumnStripes === "1" }, true;
          }
          return false;
        } }, { key: "parseText", value: function() {
        } }, { key: "parseClose", value: function() {
          return false;
        } }, { key: "tag", get: function() {
          return "tableStyleInfo";
        } }]) && o(e2.prototype, r2), c2;
      }(t("../base-xform"));
      e.exports = f;
    }, { "../base-xform": 31 }], 140: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function i(t2, e2) {
        var r2 = Object.keys(t2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t2);
          e2 && (n2 = n2.filter(function(e3) {
            return Object.getOwnPropertyDescriptor(t2, e3).enumerable;
          })), r2.push.apply(r2, n2);
        }
        return r2;
      }
      function o(t2) {
        for (var e2 = 1; e2 < arguments.length; e2++) {
          var r2 = arguments[e2] != null ? arguments[e2] : {};
          e2 % 2 ? i(Object(r2), true).forEach(function(e3) {
            a(t2, e3, r2[e3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(r2)) : i(Object(r2)).forEach(function(e3) {
            Object.defineProperty(t2, e3, Object.getOwnPropertyDescriptor(r2, e3));
          });
        }
        return t2;
      }
      function a(t2, e2, r2) {
        return e2 in t2 ? Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }) : t2[e2] = r2, t2;
      }
      function s(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function u(t2, e2) {
        return (u = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function c(t2) {
        var e2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }();
        return function() {
          var r2, n2 = l(t2);
          if (e2) {
            var i2 = l(this).constructor;
            r2 = Reflect.construct(n2, arguments, i2);
          } else
            r2 = n2.apply(this, arguments);
          return f(this, r2);
        };
      }
      function f(t2, e2) {
        return !e2 || n(e2) !== "object" && typeof e2 != "function" ? function(t3) {
          if (t3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t3;
        }(t2) : e2;
      }
      function l(t2) {
        return (l = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      var h = t("../../../utils/xml-stream"), d = t("../base-xform"), p = t("../list-xform"), m = t("./auto-filter-xform"), y = t("./table-column-xform"), b = t("./table-style-info-xform"), v = function(t2) {
        !function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && u(t3, e3);
        }(a2, t2);
        var e2, r2, i2 = c(a2);
        function a2() {
          var t3;
          return function(t4, e3) {
            if (!(t4 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), (t3 = i2.call(this)).map = { autoFilter: new m(), tableColumns: new p({ tag: "tableColumns", count: true, empty: true, childXform: new y() }), tableStyleInfo: new b() }, t3;
        }
        return e2 = a2, (r2 = [{ key: "prepare", value: function(t3, e3) {
          this.map.autoFilter.prepare(t3), this.map.tableColumns.prepare(t3.columns, e3);
        } }, { key: "render", value: function(t3, e3) {
          t3.openXml(h.StdDocAttributes), t3.openNode(this.tag, o(o({}, a2.TABLE_ATTRIBUTES), {}, { id: e3.id, name: e3.name, displayName: e3.displayName || e3.name, ref: e3.tableRef, totalsRowCount: e3.totalsRow ? "1" : void 0, totalsRowShown: e3.totalsRow ? void 0 : "1", headerRowCount: e3.headerRow ? "1" : "0" })), this.map.autoFilter.render(t3, e3), this.map.tableColumns.render(t3, e3.columns), this.map.tableStyleInfo.render(t3, e3.style), t3.closeNode();
        } }, { key: "parseOpen", value: function(t3) {
          if (this.parser)
            return this.parser.parseOpen(t3), true;
          var e3 = t3.name, r3 = t3.attributes;
          switch (e3) {
            case this.tag:
              this.reset(), this.model = { name: r3.name, displayName: r3.displayName || r3.name, tableRef: r3.ref, totalsRow: r3.totalsRowCount === "1", headerRow: r3.headerRowCount === "1" };
              break;
            default:
              this.parser = this.map[t3.name], this.parser && this.parser.parseOpen(t3);
          }
          return true;
        } }, { key: "parseText", value: function(t3) {
          this.parser && this.parser.parseText(t3);
        } }, { key: "parseClose", value: function(t3) {
          var e3 = this;
          if (this.parser)
            return this.parser.parseClose(t3) || (this.parser = void 0), true;
          switch (t3) {
            case this.tag:
              return this.model.columns = this.map.tableColumns.model, this.map.autoFilter.model && (this.model.autoFilterRef = this.map.autoFilter.model.autoFilterRef, this.map.autoFilter.model.columns.forEach(function(t4, r3) {
                e3.model.columns[r3].filterButton = t4.filterButton;
              })), this.model.style = this.map.tableStyleInfo.model, false;
            default:
              return true;
          }
        } }, { key: "reconcile", value: function(t3, e3) {
          t3.columns.forEach(function(t4) {
            t4.dxfId !== void 0 && (t4.style = e3.styles.getDxfStyle(t4.dxfId));
          });
        } }, { key: "tag", get: function() {
          return "table";
        } }]) && s(e2.prototype, r2), a2;
      }(d);
      v.TABLE_ATTRIBUTES = { xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main", "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006", "mc:Ignorable": "xr xr3", "xmlns:xr": "http://schemas.microsoft.com/office/spreadsheetml/2014/revision", "xmlns:xr3": "http://schemas.microsoft.com/office/spreadsheetml/2016/revision3" }, e.exports = v;
    }, { "../../../utils/xml-stream": 27, "../base-xform": 31, "../list-xform": 70, "./auto-filter-xform": 136, "./table-column-xform": 138, "./table-style-info-xform": 139 }], 141: [function(t, e, r) {
      (function(r2, n) {
        function i(t2, e2, r3, n2, i2, o2, a2) {
          try {
            var s2 = t2[o2](a2), u2 = s2.value;
          } catch (t3) {
            return void r3(t3);
          }
          s2.done ? e2(u2) : Promise.resolve(u2).then(n2, i2);
        }
        function o(t2) {
          return function() {
            var e2 = this, r3 = arguments;
            return new Promise(function(n2, o2) {
              var a2 = t2.apply(e2, r3);
              function s2(t3) {
                i(a2, n2, o2, s2, u2, "next", t3);
              }
              function u2(t3) {
                i(a2, n2, o2, s2, u2, "throw", t3);
              }
              s2(void 0);
            });
          };
        }
        function a(t2, e2) {
          for (var r3 = 0; r3 < e2.length; r3++) {
            var n2 = e2[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
          }
        }
        function s(t2) {
          var e2;
          if (typeof Symbol != "undefined") {
            if (Symbol.asyncIterator && (e2 = t2[Symbol.asyncIterator]) != null)
              return e2.call(t2);
            if (Symbol.iterator && (e2 = t2[Symbol.iterator]) != null)
              return e2.call(t2);
          }
          throw new TypeError("Object is not async iterable");
        }
        var u = t("fs"), c = t("jszip"), f = t("readable-stream").PassThrough, l = t("../utils/zip-stream"), h = t("../utils/stream-buf"), d = t("../utils/utils"), p = t("../utils/xml-stream"), m = t("../utils/browser-buffer-decode").bufferToString, y = t("./xform/style/styles-xform"), b = t("./xform/core/core-xform"), v = t("./xform/strings/shared-strings-xform"), g = t("./xform/core/relationships-xform"), w = t("./xform/core/content-types-xform"), _ = t("./xform/core/app-xform"), k = t("./xform/book/workbook-xform"), x = t("./xform/sheet/worksheet-xform"), S = t("./xform/drawing/drawing-xform"), O = t("./xform/table/table-xform"), j = t("./xform/comment/comments-xform"), E = t("./xform/comment/vml-notes-xform"), R = t("./xml/theme1.js");
        function T(t2, e2) {
          return new Promise(function(r3, n2) {
            u.readFile(t2, e2, function(t3, e3) {
              t3 ? n2(t3) : r3(e3);
            });
          });
        }
        var C = function() {
          function t2(e3) {
            !function(t3, e4) {
              if (!(t3 instanceof e4))
                throw new TypeError("Cannot call a class as a function");
            }(this, t2), this.workbook = e3;
          }
          var e2, i2, P, M, A, I, N, D, B, F, L, z, U, H, V, q, W, $, X, K, Z, Y, G, J, Q, tt, et;
          return e2 = t2, (i2 = [{ key: "readFile", value: (et = o(regeneratorRuntime.mark(function t3(e3, r3) {
            var n2, i3;
            return regeneratorRuntime.wrap(function(t4) {
              for (; ; )
                switch (t4.prev = t4.next) {
                  case 0:
                    return t4.next = 2, d.fs.exists(e3);
                  case 2:
                    if (t4.sent) {
                      t4.next = 4;
                      break;
                    }
                    throw new Error("File not found: ".concat(e3));
                  case 4:
                    return n2 = u.createReadStream(e3), t4.prev = 5, t4.next = 8, this.read(n2, r3);
                  case 8:
                    return i3 = t4.sent, n2.close(), t4.abrupt("return", i3);
                  case 13:
                    throw t4.prev = 13, t4.t0 = t4.catch(5), n2.close(), t4.t0;
                  case 17:
                  case "end":
                    return t4.stop();
                }
            }, t3, this, [[5, 13]]);
          })), function(t3, e3) {
            return et.apply(this, arguments);
          }) }, { key: "parseRels", value: function(t3) {
            return new g().parseStream(t3);
          } }, { key: "parseWorkbook", value: function(t3) {
            return new k().parseStream(t3);
          } }, { key: "parseSharedStrings", value: function(t3) {
            return new v().parseStream(t3);
          } }, { key: "reconcile", value: function(t3, e3) {
            var r3 = new k(), n2 = new x(e3), i3 = new S(), o2 = new O();
            r3.reconcile(t3);
            var a2 = { media: t3.media, mediaIndex: t3.mediaIndex };
            Object.keys(t3.drawings).forEach(function(e4) {
              var r4 = t3.drawings[e4], n3 = t3.drawingRels[e4];
              n3 && (a2.rels = n3.reduce(function(t4, e5) {
                return t4[e5.Id] = e5, t4;
              }, {}), (r4.anchors || []).forEach(function(t4) {
                var e5 = t4.picture && t4.picture.hyperlinks;
                e5 && a2.rels[e5.rId] && (e5.hyperlink = a2.rels[e5.rId].Target, delete e5.rId);
              }), i3.reconcile(r4, a2));
            });
            var s2 = { styles: t3.styles };
            Object.values(t3.tables).forEach(function(t4) {
              o2.reconcile(t4, s2);
            });
            var u2 = { styles: t3.styles, sharedStrings: t3.sharedStrings, media: t3.media, mediaIndex: t3.mediaIndex, date1904: t3.properties && t3.properties.date1904, drawings: t3.drawings, comments: t3.comments, tables: t3.tables, vmlDrawings: t3.vmlDrawings };
            t3.worksheets.forEach(function(e4) {
              e4.relationships = t3.worksheetRels[e4.sheetNo], n2.reconcile(e4, u2);
            }), delete t3.worksheetHash, delete t3.worksheetRels, delete t3.globalRels, delete t3.sharedStrings, delete t3.workbookRels, delete t3.sheetDefs, delete t3.styles, delete t3.mediaIndex, delete t3.drawings, delete t3.drawingRels, delete t3.vmlDrawings;
          } }, { key: "_processWorksheetEntry", value: (tt = o(regeneratorRuntime.mark(function t3(e3, r3, n2, i3, o2) {
            var a2, s2;
            return regeneratorRuntime.wrap(function(t4) {
              for (; ; )
                switch (t4.prev = t4.next) {
                  case 0:
                    return a2 = new x(i3), t4.next = 3, a2.parseStream(e3);
                  case 3:
                    (s2 = t4.sent).sheetNo = n2, r3.worksheetHash[o2] = s2, r3.worksheets.push(s2);
                  case 7:
                  case "end":
                    return t4.stop();
                }
            }, t3);
          })), function(t3, e3, r3, n2, i3) {
            return tt.apply(this, arguments);
          }) }, { key: "_processCommentEntry", value: (Q = o(regeneratorRuntime.mark(function t3(e3, r3, n2) {
            var i3, o2;
            return regeneratorRuntime.wrap(function(t4) {
              for (; ; )
                switch (t4.prev = t4.next) {
                  case 0:
                    return i3 = new j(), t4.next = 3, i3.parseStream(e3);
                  case 3:
                    o2 = t4.sent, r3.comments["../".concat(n2, ".xml")] = o2;
                  case 5:
                  case "end":
                    return t4.stop();
                }
            }, t3);
          })), function(t3, e3, r3) {
            return Q.apply(this, arguments);
          }) }, { key: "_processTableEntry", value: (J = o(regeneratorRuntime.mark(function t3(e3, r3, n2) {
            var i3, o2;
            return regeneratorRuntime.wrap(function(t4) {
              for (; ; )
                switch (t4.prev = t4.next) {
                  case 0:
                    return i3 = new O(), t4.next = 3, i3.parseStream(e3);
                  case 3:
                    o2 = t4.sent, r3.tables["../tables/".concat(n2, ".xml")] = o2;
                  case 5:
                  case "end":
                    return t4.stop();
                }
            }, t3);
          })), function(t3, e3, r3) {
            return J.apply(this, arguments);
          }) }, { key: "_processWorksheetRelsEntry", value: (G = o(regeneratorRuntime.mark(function t3(e3, r3, n2) {
            var i3, o2;
            return regeneratorRuntime.wrap(function(t4) {
              for (; ; )
                switch (t4.prev = t4.next) {
                  case 0:
                    return i3 = new g(), t4.next = 3, i3.parseStream(e3);
                  case 3:
                    o2 = t4.sent, r3.worksheetRels[n2] = o2;
                  case 5:
                  case "end":
                    return t4.stop();
                }
            }, t3);
          })), function(t3, e3, r3) {
            return G.apply(this, arguments);
          }) }, { key: "_processMediaEntry", value: (Y = o(regeneratorRuntime.mark(function t3(e3, r3, n2) {
            var i3, o2, a2;
            return regeneratorRuntime.wrap(function(t4) {
              for (; ; )
                switch (t4.prev = t4.next) {
                  case 0:
                    if (!((i3 = n2.lastIndexOf(".")) >= 1)) {
                      t4.next = 6;
                      break;
                    }
                    return o2 = n2.substr(i3 + 1), a2 = n2.substr(0, i3), t4.next = 6, new Promise(function(t5, i4) {
                      var s2 = new h();
                      s2.on("finish", function() {
                        r3.mediaIndex[n2] = r3.media.length, r3.mediaIndex[a2] = r3.media.length;
                        var e4 = { type: "image", name: a2, extension: o2, buffer: s2.toBuffer() };
                        r3.media.push(e4), t5();
                      }), e3.on("error", function(t6) {
                        i4(t6);
                      }), e3.pipe(s2);
                    });
                  case 6:
                  case "end":
                    return t4.stop();
                }
            }, t3);
          })), function(t3, e3, r3) {
            return Y.apply(this, arguments);
          }) }, { key: "_processDrawingEntry", value: (Z = o(regeneratorRuntime.mark(function t3(e3, r3, n2) {
            var i3, o2;
            return regeneratorRuntime.wrap(function(t4) {
              for (; ; )
                switch (t4.prev = t4.next) {
                  case 0:
                    return i3 = new S(), t4.next = 3, i3.parseStream(e3);
                  case 3:
                    o2 = t4.sent, r3.drawings[n2] = o2;
                  case 5:
                  case "end":
                    return t4.stop();
                }
            }, t3);
          })), function(t3, e3, r3) {
            return Z.apply(this, arguments);
          }) }, { key: "_processDrawingRelsEntry", value: (K = o(regeneratorRuntime.mark(function t3(e3, r3, n2) {
            var i3, o2;
            return regeneratorRuntime.wrap(function(t4) {
              for (; ; )
                switch (t4.prev = t4.next) {
                  case 0:
                    return i3 = new g(), t4.next = 3, i3.parseStream(e3);
                  case 3:
                    o2 = t4.sent, r3.drawingRels[n2] = o2;
                  case 5:
                  case "end":
                    return t4.stop();
                }
            }, t3);
          })), function(t3, e3, r3) {
            return K.apply(this, arguments);
          }) }, { key: "_processVmlDrawingEntry", value: (X = o(regeneratorRuntime.mark(function t3(e3, r3, n2) {
            var i3, o2;
            return regeneratorRuntime.wrap(function(t4) {
              for (; ; )
                switch (t4.prev = t4.next) {
                  case 0:
                    return i3 = new E(), t4.next = 3, i3.parseStream(e3);
                  case 3:
                    o2 = t4.sent, r3.vmlDrawings["../drawings/".concat(n2, ".vml")] = o2;
                  case 5:
                  case "end":
                    return t4.stop();
                }
            }, t3);
          })), function(t3, e3, r3) {
            return X.apply(this, arguments);
          }) }, { key: "_processThemeEntry", value: ($ = o(regeneratorRuntime.mark(function t3(e3, r3, n2) {
            return regeneratorRuntime.wrap(function(t4) {
              for (; ; )
                switch (t4.prev = t4.next) {
                  case 0:
                    return t4.next = 2, new Promise(function(t5, i3) {
                      var o2 = new h();
                      e3.on("error", i3), o2.on("error", i3), o2.on("finish", function() {
                        r3.themes[n2] = o2.read().toString(), t5();
                      }), e3.pipe(o2);
                    });
                  case 2:
                  case "end":
                    return t4.stop();
                }
            }, t3);
          })), function(t3, e3, r3) {
            return $.apply(this, arguments);
          }) }, { key: "createInputStream", value: function() {
            throw new Error("`XLSX#createInputStream` is deprecated. You should use `XLSX#read` instead. This method will be removed in version 5.0. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md");
          } }, { key: "read", value: (W = o(regeneratorRuntime.mark(function t3(e3, r3) {
            var i3, o2, a2, u2, c2, l2, h2, d2;
            return regeneratorRuntime.wrap(function(t4) {
              for (; ; )
                switch (t4.prev = t4.next) {
                  case 0:
                    !e3[Symbol.asyncIterator] && e3.pipe && (e3 = e3.pipe(new f())), i3 = [], o2 = true, a2 = false, t4.prev = 4, c2 = s(e3);
                  case 6:
                    return t4.next = 8, c2.next();
                  case 8:
                    return l2 = t4.sent, o2 = l2.done, t4.next = 12, l2.value;
                  case 12:
                    if (h2 = t4.sent, o2) {
                      t4.next = 19;
                      break;
                    }
                    d2 = h2, i3.push(d2);
                  case 16:
                    o2 = true, t4.next = 6;
                    break;
                  case 19:
                    t4.next = 25;
                    break;
                  case 21:
                    t4.prev = 21, t4.t0 = t4.catch(4), a2 = true, u2 = t4.t0;
                  case 25:
                    if (t4.prev = 25, t4.prev = 26, o2 || c2.return == null) {
                      t4.next = 30;
                      break;
                    }
                    return t4.next = 30, c2.return();
                  case 30:
                    if (t4.prev = 30, !a2) {
                      t4.next = 33;
                      break;
                    }
                    throw u2;
                  case 33:
                    return t4.finish(30);
                  case 34:
                    return t4.finish(25);
                  case 35:
                    return t4.abrupt("return", this.load(n.concat(i3), r3));
                  case 36:
                  case "end":
                    return t4.stop();
                }
            }, t3, this, [[4, 21, 25, 35], [26, , 30, 34]]);
          })), function(t3, e3) {
            return W.apply(this, arguments);
          }) }, { key: "load", value: (q = o(regeneratorRuntime.mark(function t3(e3, i3) {
            var o2, a2, s2, u2, l2, h2, d2, p2, g2, w2, k2, x2, S2, O2, j2, E2;
            return regeneratorRuntime.wrap(function(t4) {
              for (; ; )
                switch (t4.prev = t4.next) {
                  case 0:
                    return o2 = i3 && i3.base64 ? n.from(e3.toString(), "base64") : e3, a2 = { worksheets: [], worksheetHash: {}, worksheetRels: [], themes: {}, media: [], mediaIndex: {}, drawings: {}, drawingRels: {}, comments: {}, tables: {}, vmlDrawings: {} }, t4.next = 4, c.loadAsync(o2);
                  case 4:
                    s2 = t4.sent, u2 = 0, l2 = Object.values(s2.files);
                  case 6:
                    if (!(u2 < l2.length)) {
                      t4.next = 126;
                      break;
                    }
                    if ((h2 = l2[u2]).dir) {
                      t4.next = 123;
                      break;
                    }
                    if ((d2 = h2.name)[0] === "/" && (d2 = d2.substr(1)), p2 = void 0, !d2.match(/xl\/media\//) && !d2.match(/xl\/theme\/([a-zA-Z0-9]+)[.]xml/)) {
                      t4.next = 21;
                      break;
                    }
                    return p2 = new f(), t4.t0 = p2, t4.next = 17, h2.async("nodebuffer");
                  case 17:
                    t4.t1 = t4.sent, t4.t0.write.call(t4.t0, t4.t1), t4.next = 36;
                    break;
                  case 21:
                    if (p2 = new f({ writableObjectMode: true, readableObjectMode: true }), g2 = void 0, !r2.browser) {
                      t4.next = 31;
                      break;
                    }
                    return t4.t2 = m, t4.next = 27, h2.async("nodebuffer");
                  case 27:
                    t4.t3 = t4.sent, g2 = (0, t4.t2)(t4.t3), t4.next = 34;
                    break;
                  case 31:
                    return t4.next = 33, h2.async("string");
                  case 33:
                    g2 = t4.sent;
                  case 34:
                    for (w2 = 0; w2 < g2.length; w2 += 16384)
                      p2.write(g2.substring(w2, w2 + 16384));
                  case 36:
                    p2.end(), t4.t4 = d2, t4.next = t4.t4 === "_rels/.rels" ? 40 : t4.t4 === "xl/workbook.xml" ? 44 : t4.t4 === "xl/_rels/workbook.xml.rels" ? 53 : t4.t4 === "xl/sharedStrings.xml" ? 57 : t4.t4 === "xl/styles.xml" ? 61 : t4.t4 === "docProps/app.xml" ? 65 : t4.t4 === "docProps/core.xml" ? 72 : 78;
                    break;
                  case 40:
                    return t4.next = 42, this.parseRels(p2);
                  case 42:
                    return a2.globalRels = t4.sent, t4.abrupt("break", 123);
                  case 44:
                    return t4.next = 46, this.parseWorkbook(p2);
                  case 46:
                    return k2 = t4.sent, a2.sheets = k2.sheets, a2.definedNames = k2.definedNames, a2.views = k2.views, a2.properties = k2.properties, a2.calcProperties = k2.calcProperties, t4.abrupt("break", 123);
                  case 53:
                    return t4.next = 55, this.parseRels(p2);
                  case 55:
                    return a2.workbookRels = t4.sent, t4.abrupt("break", 123);
                  case 57:
                    return a2.sharedStrings = new v(), t4.next = 60, a2.sharedStrings.parseStream(p2);
                  case 60:
                    return t4.abrupt("break", 123);
                  case 61:
                    return a2.styles = new y(), t4.next = 64, a2.styles.parseStream(p2);
                  case 64:
                    return t4.abrupt("break", 123);
                  case 65:
                    return x2 = new _(), t4.next = 68, x2.parseStream(p2);
                  case 68:
                    return S2 = t4.sent, a2.company = S2.company, a2.manager = S2.manager, t4.abrupt("break", 123);
                  case 72:
                    return O2 = new b(), t4.next = 75, O2.parseStream(p2);
                  case 75:
                    return j2 = t4.sent, Object.assign(a2, j2), t4.abrupt("break", 123);
                  case 78:
                    if (!(E2 = d2.match(/xl\/worksheets\/sheet(\d+)[.]xml/))) {
                      t4.next = 83;
                      break;
                    }
                    return t4.next = 82, this._processWorksheetEntry(p2, a2, E2[1], i3, d2);
                  case 82:
                    return t4.abrupt("break", 123);
                  case 83:
                    if (!(E2 = d2.match(/xl\/worksheets\/_rels\/sheet(\d+)[.]xml.rels/))) {
                      t4.next = 88;
                      break;
                    }
                    return t4.next = 87, this._processWorksheetRelsEntry(p2, a2, E2[1]);
                  case 87:
                    return t4.abrupt("break", 123);
                  case 88:
                    if (!(E2 = d2.match(/xl\/theme\/([a-zA-Z0-9]+)[.]xml/))) {
                      t4.next = 93;
                      break;
                    }
                    return t4.next = 92, this._processThemeEntry(p2, a2, E2[1]);
                  case 92:
                    return t4.abrupt("break", 123);
                  case 93:
                    if (!(E2 = d2.match(/xl\/media\/([a-zA-Z0-9]+[.][a-zA-Z0-9]{3,4})$/))) {
                      t4.next = 98;
                      break;
                    }
                    return t4.next = 97, this._processMediaEntry(p2, a2, E2[1]);
                  case 97:
                    return t4.abrupt("break", 123);
                  case 98:
                    if (!(E2 = d2.match(/xl\/drawings\/([a-zA-Z0-9]+)[.]xml/))) {
                      t4.next = 103;
                      break;
                    }
                    return t4.next = 102, this._processDrawingEntry(p2, a2, E2[1]);
                  case 102:
                    return t4.abrupt("break", 123);
                  case 103:
                    if (!(E2 = d2.match(/xl\/(comments\d+)[.]xml/))) {
                      t4.next = 108;
                      break;
                    }
                    return t4.next = 107, this._processCommentEntry(p2, a2, E2[1]);
                  case 107:
                    return t4.abrupt("break", 123);
                  case 108:
                    if (!(E2 = d2.match(/xl\/tables\/(table\d+)[.]xml/))) {
                      t4.next = 113;
                      break;
                    }
                    return t4.next = 112, this._processTableEntry(p2, a2, E2[1]);
                  case 112:
                    return t4.abrupt("break", 123);
                  case 113:
                    if (!(E2 = d2.match(/xl\/drawings\/_rels\/([a-zA-Z0-9]+)[.]xml[.]rels/))) {
                      t4.next = 118;
                      break;
                    }
                    return t4.next = 117, this._processDrawingRelsEntry(p2, a2, E2[1]);
                  case 117:
                    return t4.abrupt("break", 123);
                  case 118:
                    if (!(E2 = d2.match(/xl\/drawings\/(vmlDrawing\d+)[.]vml/))) {
                      t4.next = 123;
                      break;
                    }
                    return t4.next = 122, this._processVmlDrawingEntry(p2, a2, E2[1]);
                  case 122:
                    return t4.abrupt("break", 123);
                  case 123:
                    u2++, t4.next = 6;
                    break;
                  case 126:
                    return this.reconcile(a2, i3), this.workbook.model = a2, t4.abrupt("return", this.workbook);
                  case 129:
                  case "end":
                    return t4.stop();
                }
            }, t3, this);
          })), function(t3, e3) {
            return q.apply(this, arguments);
          }) }, { key: "addMedia", value: (V = o(regeneratorRuntime.mark(function t3(e3, r3) {
            return regeneratorRuntime.wrap(function(t4) {
              for (; ; )
                switch (t4.prev = t4.next) {
                  case 0:
                    return t4.next = 2, Promise.all(r3.media.map(function() {
                      var t5 = o(regeneratorRuntime.mark(function t6(r4) {
                        var n2, i3, o2, a2;
                        return regeneratorRuntime.wrap(function(t7) {
                          for (; ; )
                            switch (t7.prev = t7.next) {
                              case 0:
                                if (r4.type !== "image") {
                                  t7.next = 13;
                                  break;
                                }
                                if (n2 = "xl/media/".concat(r4.name, ".").concat(r4.extension), !r4.filename) {
                                  t7.next = 7;
                                  break;
                                }
                                return t7.next = 5, T(r4.filename);
                              case 5:
                                return i3 = t7.sent, t7.abrupt("return", e3.append(i3, { name: n2 }));
                              case 7:
                                if (!r4.buffer) {
                                  t7.next = 9;
                                  break;
                                }
                                return t7.abrupt("return", e3.append(r4.buffer, { name: n2 }));
                              case 9:
                                if (!r4.base64) {
                                  t7.next = 13;
                                  break;
                                }
                                return o2 = r4.base64, a2 = o2.substring(o2.indexOf(",") + 1), t7.abrupt("return", e3.append(a2, { name: n2, base64: true }));
                              case 13:
                                throw new Error("Unsupported media");
                              case 14:
                              case "end":
                                return t7.stop();
                            }
                        }, t6);
                      }));
                      return function(e4) {
                        return t5.apply(this, arguments);
                      };
                    }()));
                  case 2:
                  case "end":
                    return t4.stop();
                }
            }, t3);
          })), function(t3, e3) {
            return V.apply(this, arguments);
          }) }, { key: "addDrawings", value: function(t3, e3) {
            var r3 = new S(), n2 = new g();
            e3.worksheets.forEach(function(e4) {
              var i3 = e4.drawing;
              if (i3) {
                r3.prepare(i3, {});
                var o2 = r3.toXml(i3);
                t3.append(o2, { name: "xl/drawings/".concat(i3.name, ".xml") }), o2 = n2.toXml(i3.rels), t3.append(o2, { name: "xl/drawings/_rels/".concat(i3.name, ".xml.rels") });
              }
            });
          } }, { key: "addTables", value: function(t3, e3) {
            var r3 = new O();
            e3.worksheets.forEach(function(e4) {
              e4.tables.forEach(function(e5) {
                r3.prepare(e5, {});
                var n2 = r3.toXml(e5);
                t3.append(n2, { name: "xl/tables/".concat(e5.target) });
              });
            });
          } }, { key: "addContentTypes", value: (H = o(regeneratorRuntime.mark(function t3(e3, r3) {
            var n2, i3;
            return regeneratorRuntime.wrap(function(t4) {
              for (; ; )
                switch (t4.prev = t4.next) {
                  case 0:
                    n2 = new w(), i3 = n2.toXml(r3), e3.append(i3, { name: "[Content_Types].xml" });
                  case 3:
                  case "end":
                    return t4.stop();
                }
            }, t3);
          })), function(t3, e3) {
            return H.apply(this, arguments);
          }) }, { key: "addApp", value: (U = o(regeneratorRuntime.mark(function t3(e3, r3) {
            var n2, i3;
            return regeneratorRuntime.wrap(function(t4) {
              for (; ; )
                switch (t4.prev = t4.next) {
                  case 0:
                    n2 = new _(), i3 = n2.toXml(r3), e3.append(i3, { name: "docProps/app.xml" });
                  case 3:
                  case "end":
                    return t4.stop();
                }
            }, t3);
          })), function(t3, e3) {
            return U.apply(this, arguments);
          }) }, { key: "addCore", value: (z = o(regeneratorRuntime.mark(function t3(e3, r3) {
            var n2;
            return regeneratorRuntime.wrap(function(t4) {
              for (; ; )
                switch (t4.prev = t4.next) {
                  case 0:
                    n2 = new b(), e3.append(n2.toXml(r3), { name: "docProps/core.xml" });
                  case 2:
                  case "end":
                    return t4.stop();
                }
            }, t3);
          })), function(t3, e3) {
            return z.apply(this, arguments);
          }) }, { key: "addThemes", value: (L = o(regeneratorRuntime.mark(function t3(e3, r3) {
            var n2;
            return regeneratorRuntime.wrap(function(t4) {
              for (; ; )
                switch (t4.prev = t4.next) {
                  case 0:
                    n2 = r3.themes || { theme1: R }, Object.keys(n2).forEach(function(t5) {
                      var r4 = n2[t5], i3 = "xl/theme/".concat(t5, ".xml");
                      e3.append(r4, { name: i3 });
                    });
                  case 2:
                  case "end":
                    return t4.stop();
                }
            }, t3);
          })), function(t3, e3) {
            return L.apply(this, arguments);
          }) }, { key: "addOfficeRels", value: (F = o(regeneratorRuntime.mark(function e3(r3) {
            var n2, i3;
            return regeneratorRuntime.wrap(function(e4) {
              for (; ; )
                switch (e4.prev = e4.next) {
                  case 0:
                    n2 = new g(), i3 = n2.toXml([{ Id: "rId1", Type: t2.RelType.OfficeDocument, Target: "xl/workbook.xml" }, { Id: "rId2", Type: t2.RelType.CoreProperties, Target: "docProps/core.xml" }, { Id: "rId3", Type: t2.RelType.ExtenderProperties, Target: "docProps/app.xml" }]), r3.append(i3, { name: "_rels/.rels" });
                  case 3:
                  case "end":
                    return e4.stop();
                }
            }, e3);
          })), function(t3) {
            return F.apply(this, arguments);
          }) }, { key: "addWorkbookRels", value: (B = o(regeneratorRuntime.mark(function e3(r3, n2) {
            var i3, o2, a2, s2;
            return regeneratorRuntime.wrap(function(e4) {
              for (; ; )
                switch (e4.prev = e4.next) {
                  case 0:
                    i3 = 1, o2 = [{ Id: "rId".concat(i3++), Type: t2.RelType.Styles, Target: "styles.xml" }, { Id: "rId".concat(i3++), Type: t2.RelType.Theme, Target: "theme/theme1.xml" }], n2.sharedStrings.count && o2.push({ Id: "rId".concat(i3++), Type: t2.RelType.SharedStrings, Target: "sharedStrings.xml" }), n2.worksheets.forEach(function(e5) {
                      e5.rId = "rId".concat(i3++), o2.push({ Id: e5.rId, Type: t2.RelType.Worksheet, Target: "worksheets/sheet".concat(e5.id, ".xml") });
                    }), a2 = new g(), s2 = a2.toXml(o2), r3.append(s2, { name: "xl/_rels/workbook.xml.rels" });
                  case 7:
                  case "end":
                    return e4.stop();
                }
            }, e3);
          })), function(t3, e3) {
            return B.apply(this, arguments);
          }) }, { key: "addSharedStrings", value: (D = o(regeneratorRuntime.mark(function t3(e3, r3) {
            return regeneratorRuntime.wrap(function(t4) {
              for (; ; )
                switch (t4.prev = t4.next) {
                  case 0:
                    r3.sharedStrings && r3.sharedStrings.count && e3.append(r3.sharedStrings.xml, { name: "xl/sharedStrings.xml" });
                  case 1:
                  case "end":
                    return t4.stop();
                }
            }, t3);
          })), function(t3, e3) {
            return D.apply(this, arguments);
          }) }, { key: "addStyles", value: (N = o(regeneratorRuntime.mark(function t3(e3, r3) {
            var n2;
            return regeneratorRuntime.wrap(function(t4) {
              for (; ; )
                switch (t4.prev = t4.next) {
                  case 0:
                    (n2 = r3.styles.xml) && e3.append(n2, { name: "xl/styles.xml" });
                  case 2:
                  case "end":
                    return t4.stop();
                }
            }, t3);
          })), function(t3, e3) {
            return N.apply(this, arguments);
          }) }, { key: "addWorkbook", value: (I = o(regeneratorRuntime.mark(function t3(e3, r3) {
            var n2;
            return regeneratorRuntime.wrap(function(t4) {
              for (; ; )
                switch (t4.prev = t4.next) {
                  case 0:
                    n2 = new k(), e3.append(n2.toXml(r3), { name: "xl/workbook.xml" });
                  case 2:
                  case "end":
                    return t4.stop();
                }
            }, t3);
          })), function(t3, e3) {
            return I.apply(this, arguments);
          }) }, { key: "addWorksheets", value: (A = o(regeneratorRuntime.mark(function t3(e3, r3) {
            var n2, i3, o2, a2;
            return regeneratorRuntime.wrap(function(t4) {
              for (; ; )
                switch (t4.prev = t4.next) {
                  case 0:
                    n2 = new x(), i3 = new g(), o2 = new j(), a2 = new E(), r3.worksheets.forEach(function(t5) {
                      var r4 = new p();
                      n2.render(r4, t5), e3.append(r4.xml, { name: "xl/worksheets/sheet".concat(t5.id, ".xml") }), t5.rels && t5.rels.length && (r4 = new p(), i3.render(r4, t5.rels), e3.append(r4.xml, { name: "xl/worksheets/_rels/sheet".concat(t5.id, ".xml.rels") })), t5.comments.length > 0 && (r4 = new p(), o2.render(r4, t5), e3.append(r4.xml, { name: "xl/comments".concat(t5.id, ".xml") }), r4 = new p(), a2.render(r4, t5), e3.append(r4.xml, { name: "xl/drawings/vmlDrawing".concat(t5.id, ".vml") }));
                    });
                  case 5:
                  case "end":
                    return t4.stop();
                }
            }, t3);
          })), function(t3, e3) {
            return A.apply(this, arguments);
          }) }, { key: "_finalize", value: function(t3) {
            var e3 = this;
            return new Promise(function(r3, n2) {
              t3.on("finish", function() {
                r3(e3);
              }), t3.on("error", n2), t3.finalize();
            });
          } }, { key: "prepareModel", value: function(t3, e3) {
            t3.creator = t3.creator || "ExcelJS", t3.lastModifiedBy = t3.lastModifiedBy || "ExcelJS", t3.created = t3.created || new Date(), t3.modified = t3.modified || new Date(), t3.useSharedStrings = e3.useSharedStrings === void 0 || e3.useSharedStrings, t3.useStyles = e3.useStyles === void 0 || e3.useStyles, t3.sharedStrings = new v(), t3.styles = t3.useStyles ? new y(true) : new y.Mock();
            var r3 = new k(), n2 = new x();
            r3.prepare(t3);
            var i3 = { sharedStrings: t3.sharedStrings, styles: t3.styles, date1904: t3.properties.date1904, drawingsCount: 0, media: t3.media };
            i3.drawings = t3.drawings = [], i3.commentRefs = t3.commentRefs = [];
            var o2 = 0;
            t3.tables = [], t3.worksheets.forEach(function(e4) {
              e4.tables.forEach(function(e5) {
                o2++, e5.target = "table".concat(o2, ".xml"), e5.id = o2, t3.tables.push(e5);
              }), n2.prepare(e4, i3);
            });
          } }, { key: "write", value: (M = o(regeneratorRuntime.mark(function t3(e3, r3) {
            var n2, i3;
            return regeneratorRuntime.wrap(function(t4) {
              for (; ; )
                switch (t4.prev = t4.next) {
                  case 0:
                    return r3 = r3 || {}, n2 = this.workbook.model, (i3 = new l.ZipWriter(r3.zip)).pipe(e3), this.prepareModel(n2, r3), t4.next = 7, this.addContentTypes(i3, n2);
                  case 7:
                    return t4.next = 9, this.addOfficeRels(i3, n2);
                  case 9:
                    return t4.next = 11, this.addWorkbookRels(i3, n2);
                  case 11:
                    return t4.next = 13, this.addWorksheets(i3, n2);
                  case 13:
                    return t4.next = 15, this.addSharedStrings(i3, n2);
                  case 15:
                    return t4.next = 17, this.addDrawings(i3, n2);
                  case 17:
                    return t4.next = 19, this.addTables(i3, n2);
                  case 19:
                    return t4.next = 21, Promise.all([this.addThemes(i3, n2), this.addStyles(i3, n2)]);
                  case 21:
                    return t4.next = 23, this.addMedia(i3, n2);
                  case 23:
                    return t4.next = 25, Promise.all([this.addApp(i3, n2), this.addCore(i3, n2)]);
                  case 25:
                    return t4.next = 27, this.addWorkbook(i3, n2);
                  case 27:
                    return t4.abrupt("return", this._finalize(i3));
                  case 28:
                  case "end":
                    return t4.stop();
                }
            }, t3, this);
          })), function(t3, e3) {
            return M.apply(this, arguments);
          }) }, { key: "writeFile", value: function(t3, e3) {
            var r3 = this, n2 = u.createWriteStream(t3);
            return new Promise(function(t4, i3) {
              n2.on("finish", function() {
                t4();
              }), n2.on("error", function(t5) {
                i3(t5);
              }), r3.write(n2, e3).then(function() {
                n2.end();
              });
            });
          } }, { key: "writeBuffer", value: (P = o(regeneratorRuntime.mark(function t3(e3) {
            var r3;
            return regeneratorRuntime.wrap(function(t4) {
              for (; ; )
                switch (t4.prev = t4.next) {
                  case 0:
                    return r3 = new h(), t4.next = 3, this.write(r3, e3);
                  case 3:
                    return t4.abrupt("return", r3.read());
                  case 4:
                  case "end":
                    return t4.stop();
                }
            }, t3, this);
          })), function(t3) {
            return P.apply(this, arguments);
          }) }]) && a(e2.prototype, i2), t2;
        }();
        C.RelType = t("./rel-type"), e.exports = C;
      }).call(this, t("_process"), t("buffer").Buffer);
    }, { "../utils/browser-buffer-decode": 16, "../utils/stream-buf": 23, "../utils/utils": 26, "../utils/xml-stream": 27, "../utils/zip-stream": 28, "./rel-type": 30, "./xform/book/workbook-xform": 37, "./xform/comment/comments-xform": 39, "./xform/comment/vml-notes-xform": 44, "./xform/core/app-xform": 50, "./xform/core/content-types-xform": 51, "./xform/core/core-xform": 52, "./xform/core/relationships-xform": 54, "./xform/drawing/drawing-xform": 61, "./xform/sheet/worksheet-xform": 114, "./xform/strings/shared-strings-xform": 123, "./xform/style/styles-xform": 134, "./xform/table/table-xform": 140, "./xml/theme1.js": 142, _process: 467, buffer: 216, fs: 215, jszip: 399, "readable-stream": 491 }], 142: [function(t, e, r) {
      e.exports = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"> <a:themeElements> <a:clrScheme name="Office"> <a:dk1> <a:sysClr val="windowText" lastClr="000000"/> </a:dk1> <a:lt1> <a:sysClr val="window" lastClr="FFFFFF"/> </a:lt1> <a:dk2> <a:srgbClr val="1F497D"/> </a:dk2> <a:lt2> <a:srgbClr val="EEECE1"/> </a:lt2> <a:accent1> <a:srgbClr val="4F81BD"/> </a:accent1> <a:accent2> <a:srgbClr val="C0504D"/> </a:accent2> <a:accent3> <a:srgbClr val="9BBB59"/> </a:accent3> <a:accent4> <a:srgbClr val="8064A2"/> </a:accent4> <a:accent5> <a:srgbClr val="4BACC6"/> </a:accent5> <a:accent6> <a:srgbClr val="F79646"/> </a:accent6> <a:hlink> <a:srgbClr val="0000FF"/> </a:hlink> <a:folHlink> <a:srgbClr val="800080"/> </a:folHlink> </a:clrScheme> <a:fontScheme name="Office"> <a:majorFont> <a:latin typeface="Cambria"/> <a:ea typeface=""/> <a:cs typeface=""/> <a:font script="Jpan" typeface="\uFF2D\uFF33 \uFF30\u30B4\u30B7\u30C3\u30AF"/> <a:font script="Hang" typeface="\uB9D1\uC740 \uACE0\uB515"/> <a:font script="Hans" typeface="\u5B8B\u4F53"/> <a:font script="Hant" typeface="\u65B0\u7D30\u660E\u9AD4"/> <a:font script="Arab" typeface="Times New Roman"/> <a:font script="Hebr" typeface="Times New Roman"/> <a:font script="Thai" typeface="Tahoma"/> <a:font script="Ethi" typeface="Nyala"/> <a:font script="Beng" typeface="Vrinda"/> <a:font script="Gujr" typeface="Shruti"/> <a:font script="Khmr" typeface="MoolBoran"/> <a:font script="Knda" typeface="Tunga"/> <a:font script="Guru" typeface="Raavi"/> <a:font script="Cans" typeface="Euphemia"/> <a:font script="Cher" typeface="Plantagenet Cherokee"/> <a:font script="Yiii" typeface="Microsoft Yi Baiti"/> <a:font script="Tibt" typeface="Microsoft Himalaya"/> <a:font script="Thaa" typeface="MV Boli"/> <a:font script="Deva" typeface="Mangal"/> <a:font script="Telu" typeface="Gautami"/> <a:font script="Taml" typeface="Latha"/> <a:font script="Syrc" typeface="Estrangelo Edessa"/> <a:font script="Orya" typeface="Kalinga"/> <a:font script="Mlym" typeface="Kartika"/> <a:font script="Laoo" typeface="DokChampa"/> <a:font script="Sinh" typeface="Iskoola Pota"/> <a:font script="Mong" typeface="Mongolian Baiti"/> <a:font script="Viet" typeface="Times New Roman"/> <a:font script="Uigh" typeface="Microsoft Uighur"/> <a:font script="Geor" typeface="Sylfaen"/> </a:majorFont> <a:minorFont> <a:latin typeface="Calibri"/> <a:ea typeface=""/> <a:cs typeface=""/> <a:font script="Jpan" typeface="\uFF2D\uFF33 \uFF30\u30B4\u30B7\u30C3\u30AF"/> <a:font script="Hang" typeface="\uB9D1\uC740 \uACE0\uB515"/> <a:font script="Hans" typeface="\u5B8B\u4F53"/> <a:font script="Hant" typeface="\u65B0\u7D30\u660E\u9AD4"/> <a:font script="Arab" typeface="Arial"/> <a:font script="Hebr" typeface="Arial"/> <a:font script="Thai" typeface="Tahoma"/> <a:font script="Ethi" typeface="Nyala"/> <a:font script="Beng" typeface="Vrinda"/> <a:font script="Gujr" typeface="Shruti"/> <a:font script="Khmr" typeface="DaunPenh"/> <a:font script="Knda" typeface="Tunga"/> <a:font script="Guru" typeface="Raavi"/> <a:font script="Cans" typeface="Euphemia"/> <a:font script="Cher" typeface="Plantagenet Cherokee"/> <a:font script="Yiii" typeface="Microsoft Yi Baiti"/> <a:font script="Tibt" typeface="Microsoft Himalaya"/> <a:font script="Thaa" typeface="MV Boli"/> <a:font script="Deva" typeface="Mangal"/> <a:font script="Telu" typeface="Gautami"/> <a:font script="Taml" typeface="Latha"/> <a:font script="Syrc" typeface="Estrangelo Edessa"/> <a:font script="Orya" typeface="Kalinga"/> <a:font script="Mlym" typeface="Kartika"/> <a:font script="Laoo" typeface="DokChampa"/> <a:font script="Sinh" typeface="Iskoola Pota"/> <a:font script="Mong" typeface="Mongolian Baiti"/> <a:font script="Viet" typeface="Arial"/> <a:font script="Uigh" typeface="Microsoft Uighur"/> <a:font script="Geor" typeface="Sylfaen"/> </a:minorFont> </a:fontScheme> <a:fmtScheme name="Office"> <a:fillStyleLst> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="50000"/> <a:satMod val="300000"/> </a:schemeClr> </a:gs> <a:gs pos="35000"> <a:schemeClr val="phClr"> <a:tint val="37000"/> <a:satMod val="300000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:tint val="15000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:lin ang="16200000" scaled="1"/> </a:gradFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="100000"/> <a:shade val="100000"/> <a:satMod val="130000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:tint val="50000"/> <a:shade val="100000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:lin ang="16200000" scaled="0"/> </a:gradFill> </a:fillStyleLst> <a:lnStyleLst> <a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"> <a:solidFill> <a:schemeClr val="phClr"> <a:shade val="95000"/> <a:satMod val="105000"/> </a:schemeClr> </a:solidFill> <a:prstDash val="solid"/> </a:ln> <a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:prstDash val="solid"/> </a:ln> <a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:prstDash val="solid"/> </a:ln> </a:lnStyleLst> <a:effectStyleLst> <a:effectStyle> <a:effectLst> <a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"> <a:srgbClr val="000000"> <a:alpha val="38000"/> </a:srgbClr> </a:outerShdw> </a:effectLst> </a:effectStyle> <a:effectStyle> <a:effectLst> <a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"> <a:srgbClr val="000000"> <a:alpha val="35000"/> </a:srgbClr> </a:outerShdw> </a:effectLst> </a:effectStyle> <a:effectStyle> <a:effectLst> <a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"> <a:srgbClr val="000000"> <a:alpha val="35000"/> </a:srgbClr> </a:outerShdw> </a:effectLst> <a:scene3d> <a:camera prst="orthographicFront"> <a:rot lat="0" lon="0" rev="0"/> </a:camera> <a:lightRig rig="threePt" dir="t"> <a:rot lat="0" lon="0" rev="1200000"/> </a:lightRig> </a:scene3d> <a:sp3d> <a:bevelT w="63500" h="25400"/> </a:sp3d> </a:effectStyle> </a:effectStyleLst> <a:bgFillStyleLst> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="40000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> <a:gs pos="40000"> <a:schemeClr val="phClr"> <a:tint val="45000"/> <a:shade val="99000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:shade val="20000"/> <a:satMod val="255000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:path path="circle"> <a:fillToRect l="50000" t="-80000" r="50000" b="180000"/> </a:path> </a:gradFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="80000"/> <a:satMod val="300000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:shade val="30000"/> <a:satMod val="200000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:path path="circle"> <a:fillToRect l="50000" t="50000" r="50000" b="50000"/> </a:path> </a:gradFill> </a:bgFillStyleLst> </a:fmtScheme> </a:themeElements> <a:objectDefaults> <a:spDef> <a:spPr/> <a:bodyPr/> <a:lstStyle/> <a:style> <a:lnRef idx="1"> <a:schemeClr val="accent1"/> </a:lnRef> <a:fillRef idx="3"> <a:schemeClr val="accent1"/> </a:fillRef> <a:effectRef idx="2"> <a:schemeClr val="accent1"/> </a:effectRef> <a:fontRef idx="minor"> <a:schemeClr val="lt1"/> </a:fontRef> </a:style> </a:spDef> <a:lnDef> <a:spPr/> <a:bodyPr/> <a:lstStyle/> <a:style> <a:lnRef idx="2"> <a:schemeClr val="accent1"/> </a:lnRef> <a:fillRef idx="0"> <a:schemeClr val="accent1"/> </a:fillRef> <a:effectRef idx="1"> <a:schemeClr val="accent1"/> </a:effectRef> <a:fontRef idx="minor"> <a:schemeClr val="tx1"/> </a:fontRef> </a:style> </a:lnDef> </a:objectDefaults> <a:extraClrSchemeLst/> </a:theme>';
    }, {}], 143: [function(t, e, r) {
      (function(e2) {
        function n(t2) {
          return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
            return typeof t3;
          } : function(t3) {
            return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
          })(t2);
        }
        function i(t2, e3) {
          for (var r2 = 0; r2 < e3.length; r2++) {
            var n2 = e3[r2];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
          }
        }
        function o(t2, e3) {
          return (o = Object.setPrototypeOf || function(t3, e4) {
            return t3.__proto__ = e4, t3;
          })(t2, e3);
        }
        function a(t2) {
          var e3 = function() {
            if (typeof Reflect == "undefined" || !Reflect.construct)
              return false;
            if (Reflect.construct.sham)
              return false;
            if (typeof Proxy == "function")
              return true;
            try {
              return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
              })), true;
            } catch (t3) {
              return false;
            }
          }();
          return function() {
            var r2, n2 = u(t2);
            if (e3) {
              var i2 = u(this).constructor;
              r2 = Reflect.construct(n2, arguments, i2);
            } else
              r2 = n2.apply(this, arguments);
            return s(this, r2);
          };
        }
        function s(t2, e3) {
          return !e3 || n(e3) !== "object" && typeof e3 != "function" ? function(t3) {
            if (t3 === void 0)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t3;
          }(t2) : e3;
        }
        function u(t2) {
          return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
            return t3.__proto__ || Object.getPrototypeOf(t3);
          })(t2);
        }
        Object.defineProperty(r, "__esModule", { value: true }), r.CsvFormatterStream = void 0;
        var c = t("stream"), f = t("./formatter"), l = function(t2) {
          !function(t3, e3) {
            if (typeof e3 != "function" && e3 !== null)
              throw new TypeError("Super expression must either be null or a function");
            t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && o(t3, e3);
          }(c2, t2);
          var r2, n2, u2 = a(c2);
          function c2(t3) {
            var e3;
            return function(t4, e4) {
              if (!(t4 instanceof e4))
                throw new TypeError("Cannot call a class as a function");
            }(this, c2), (e3 = u2.call(this, { writableObjectMode: t3.objectMode })).hasWrittenBOM = false, e3.formatterOptions = t3, e3.rowFormatter = new f.RowFormatter(t3), e3.hasWrittenBOM = !t3.writeBOM, e3;
          }
          return r2 = c2, (n2 = [{ key: "transform", value: function(t3) {
            return this.rowFormatter.rowTransform = t3, this;
          } }, { key: "_transform", value: function(t3, r3, n3) {
            var i2 = this, o2 = false;
            try {
              this.hasWrittenBOM || (this.push(this.formatterOptions.BOM), this.hasWrittenBOM = true), this.rowFormatter.format(t3, function(t4, r4) {
                return t4 ? (o2 = true, n3(t4)) : (r4 && r4.forEach(function(t5) {
                  i2.push(e2.from(t5, "utf8"));
                }), o2 = true, n3());
              });
            } catch (t4) {
              if (o2)
                throw t4;
              n3(t4);
            }
          } }, { key: "_flush", value: function(t3) {
            var r3 = this;
            this.rowFormatter.finish(function(n3, i2) {
              return n3 ? t3(n3) : (i2 && i2.forEach(function(t4) {
                r3.push(e2.from(t4, "utf8"));
              }), t3());
            });
          } }]) && i(r2.prototype, n2), c2;
        }(c.Transform);
        r.CsvFormatterStream = l;
      }).call(this, t("buffer").Buffer);
    }, { "./formatter": 147, buffer: 216, stream: 506 }], 144: [function(t, e, r) {
      function n(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      Object.defineProperty(r, "__esModule", { value: true }), r.FormatterOptions = void 0;
      r.FormatterOptions = function t2() {
        var e2, r2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        n(this, t2), this.objectMode = true, this.delimiter = ",", this.rowDelimiter = "\n", this.quote = '"', this.escape = this.quote, this.quoteColumns = false, this.quoteHeaders = this.quoteColumns, this.headers = null, this.includeEndRowDelimiter = false, this.writeBOM = false, this.BOM = "\uFEFF", this.alwaysWriteHeaders = false, Object.assign(this, r2 || {}), (r2 == null ? void 0 : r2.quoteHeaders) === void 0 && (this.quoteHeaders = this.quoteColumns), (r2 == null ? void 0 : r2.quote) === true ? this.quote = '"' : (r2 == null ? void 0 : r2.quote) === false && (this.quote = ""), typeof (r2 == null ? void 0 : r2.escape) != "string" && (this.escape = this.quote), this.shouldWriteHeaders = !!this.headers && ((e2 = r2.writeHeaders) === null || e2 === void 0 || e2), this.headers = Array.isArray(this.headers) ? this.headers : null, this.escapedQuote = "".concat(this.escape).concat(this.quote);
      };
    }, {}], 145: [function(t, e, r) {
      function n(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      var i = function(t2) {
        return t2 && t2.__esModule ? t2 : { default: t2 };
      };
      Object.defineProperty(r, "__esModule", { value: true }), r.FieldFormatter = void 0;
      var o = i(t("lodash.isboolean")), a = i(t("lodash.isnil")), s = i(t("lodash.escaperegexp")), u = function() {
        function t2(e3) {
          !function(t3, e4) {
            if (!(t3 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, t2), this._headers = null, this.formatterOptions = e3, e3.headers !== null && (this.headers = e3.headers), this.REPLACE_REGEXP = new RegExp(e3.quote, "g");
          var r3 = "[".concat(e3.delimiter).concat(s.default(e3.rowDelimiter), "|\r|\n']");
          this.ESCAPE_REGEXP = new RegExp(r3);
        }
        var e2, r2;
        return e2 = t2, (r2 = [{ key: "shouldQuote", value: function(t3, e3) {
          var r3 = e3 ? this.formatterOptions.quoteHeaders : this.formatterOptions.quoteColumns;
          return o.default(r3) ? r3 : Array.isArray(r3) ? r3[t3] : this._headers !== null && r3[this._headers[t3]];
        } }, { key: "format", value: function(t3, e3, r3) {
          var n2 = "".concat(a.default(t3) ? "" : t3).replace(/\0/g, ""), i3 = this.formatterOptions;
          return i3.quote !== "" && n2.indexOf(i3.quote) !== -1 ? this.quoteField(n2.replace(this.REPLACE_REGEXP, i3.escapedQuote)) : n2.search(this.ESCAPE_REGEXP) !== -1 || this.shouldQuote(e3, r3) ? this.quoteField(n2) : n2;
        } }, { key: "quoteField", value: function(t3) {
          var e3 = this.formatterOptions.quote;
          return "".concat(e3).concat(t3).concat(e3);
        } }, { key: "headers", set: function(t3) {
          this._headers = t3;
        } }]) && n(e2.prototype, r2), t2;
      }();
      r.FieldFormatter = u;
    }, { "lodash.escaperegexp": 426, "lodash.isboolean": 428, "lodash.isnil": 431 }], 146: [function(t, e, r) {
      function n(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      var i = function(t2) {
        return t2 && t2.__esModule ? t2 : { default: t2 };
      };
      Object.defineProperty(r, "__esModule", { value: true }), r.RowFormatter = void 0;
      var o = i(t("lodash.isfunction")), a = i(t("lodash.isequal")), s = t("./FieldFormatter"), u = t("../types"), c = function() {
        function t2(e3) {
          !function(t3, e4) {
            if (!(t3 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, t2), this.rowCount = 0, this.formatterOptions = e3, this.fieldFormatter = new s.FieldFormatter(e3), this.headers = e3.headers, this.shouldWriteHeaders = e3.shouldWriteHeaders, this.hasWrittenHeaders = false, this.headers !== null && (this.fieldFormatter.headers = this.headers), e3.transform && (this.rowTransform = e3.transform);
        }
        var e2, r2, i2;
        return e2 = t2, i2 = [{ key: "isHashArray", value: function(t3) {
          return !!Array.isArray(t3) && Array.isArray(t3[0]) && t3[0].length === 2;
        } }, { key: "gatherHeaders", value: function(e3) {
          return t2.isHashArray(e3) ? e3.map(function(t3) {
            return t3[0];
          }) : Array.isArray(e3) ? e3 : Object.keys(e3);
        } }, { key: "createTransform", value: function(t3) {
          return u.isSyncTransform(t3) ? function(e3, r3) {
            var n2 = null;
            try {
              n2 = t3(e3);
            } catch (t4) {
              return r3(t4);
            }
            return r3(null, n2);
          } : function(e3, r3) {
            t3(e3, r3);
          };
        } }], (r2 = [{ key: "format", value: function(t3, e3) {
          var r3 = this;
          this.callTransformer(t3, function(n2, i3) {
            if (n2)
              return e3(n2);
            if (!t3)
              return e3(null);
            var o2 = [];
            if (i3) {
              var a2 = r3.checkHeaders(i3), s2 = a2.shouldFormatColumns, u2 = a2.headers;
              if (r3.shouldWriteHeaders && u2 && !r3.hasWrittenHeaders && (o2.push(r3.formatColumns(u2, true)), r3.hasWrittenHeaders = true), s2) {
                var c2 = r3.gatherColumns(i3);
                o2.push(r3.formatColumns(c2, false));
              }
            }
            return e3(null, o2);
          });
        } }, { key: "finish", value: function(t3) {
          var e3 = [];
          if (this.formatterOptions.alwaysWriteHeaders && this.rowCount === 0) {
            if (!this.headers)
              return t3(new Error("`alwaysWriteHeaders` option is set to true but `headers` option not provided."));
            e3.push(this.formatColumns(this.headers, true));
          }
          return this.formatterOptions.includeEndRowDelimiter && e3.push(this.formatterOptions.rowDelimiter), t3(null, e3);
        } }, { key: "checkHeaders", value: function(e3) {
          if (this.headers)
            return { shouldFormatColumns: true, headers: this.headers };
          var r3 = t2.gatherHeaders(e3);
          return this.headers = r3, this.fieldFormatter.headers = r3, this.shouldWriteHeaders ? { shouldFormatColumns: !a.default(r3, e3), headers: r3 } : { shouldFormatColumns: true, headers: null };
        } }, { key: "gatherColumns", value: function(e3) {
          if (this.headers === null)
            throw new Error("Headers is currently null");
          return Array.isArray(e3) ? t2.isHashArray(e3) ? this.headers.map(function(t3, r3) {
            var n2 = e3[r3];
            return n2 ? n2[1] : "";
          }) : this.headers.map(function(t3, r3) {
            return e3[r3];
          }) : this.headers.map(function(t3) {
            return e3[t3];
          });
        } }, { key: "callTransformer", value: function(t3, e3) {
          return this._rowTransform ? this._rowTransform(t3, e3) : e3(null, t3);
        } }, { key: "formatColumns", value: function(t3, e3) {
          var r3 = this, n2 = t3.map(function(t4, n3) {
            return r3.fieldFormatter.format(t4, n3, e3);
          }).join(this.formatterOptions.delimiter), i3 = this.rowCount;
          return this.rowCount += 1, i3 ? [this.formatterOptions.rowDelimiter, n2].join("") : n2;
        } }, { key: "rowTransform", set: function(e3) {
          if (!o.default(e3))
            throw new TypeError("The transform should be a function");
          this._rowTransform = t2.createTransform(e3);
        } }]) && n(e2.prototype, r2), i2 && n(e2, i2), t2;
      }();
      r.RowFormatter = c;
    }, { "../types": 149, "./FieldFormatter": 145, "lodash.isequal": 429, "lodash.isfunction": 430 }], 147: [function(t, e, r) {
      Object.defineProperty(r, "__esModule", { value: true });
      var n = t("./RowFormatter");
      Object.defineProperty(r, "RowFormatter", { enumerable: true, get: function() {
        return n.RowFormatter;
      } });
      var i = t("./FieldFormatter");
      Object.defineProperty(r, "FieldFormatter", { enumerable: true, get: function() {
        return i.FieldFormatter;
      } });
    }, { "./FieldFormatter": 145, "./RowFormatter": 146 }], 148: [function(t, e, r) {
      (function(e2) {
        var n = Object.create ? function(t2, e3, r2, n2) {
          n2 === void 0 && (n2 = r2), Object.defineProperty(t2, n2, { enumerable: true, get: function() {
            return e3[r2];
          } });
        } : function(t2, e3, r2, n2) {
          n2 === void 0 && (n2 = r2), t2[n2] = e3[r2];
        }, i = Object.create ? function(t2, e3) {
          Object.defineProperty(t2, "default", { enumerable: true, value: e3 });
        } : function(t2, e3) {
          t2.default = e3;
        }, o = function(t2) {
          if (t2 && t2.__esModule)
            return t2;
          var e3 = {};
          if (t2 != null)
            for (var r2 in t2)
              r2 !== "default" && Object.hasOwnProperty.call(t2, r2) && n(e3, t2, r2);
          return i(e3, t2), e3;
        }, a = function(t2, e3) {
          for (var r2 in t2)
            r2 === "default" || e3.hasOwnProperty(r2) || n(e3, t2, r2);
        };
        Object.defineProperty(r, "__esModule", { value: true }), r.writeToPath = r.writeToString = r.writeToBuffer = r.writeToStream = r.write = r.format = void 0;
        var s = t("util"), u = t("stream"), c = o(t("fs")), f = t("./FormatterOptions"), l = t("./CsvFormatterStream");
        a(t("./types"), r);
        var h = t("./CsvFormatterStream");
        Object.defineProperty(r, "CsvFormatterStream", { enumerable: true, get: function() {
          return h.CsvFormatterStream;
        } });
        var d = t("./FormatterOptions");
        Object.defineProperty(r, "FormatterOptions", { enumerable: true, get: function() {
          return d.FormatterOptions;
        } }), r.format = function(t2) {
          return new l.CsvFormatterStream(new f.FormatterOptions(t2));
        }, r.write = function(t2, e3) {
          var n2 = r.format(e3), i2 = s.promisify(function(t3, e4) {
            n2.write(t3, void 0, e4);
          });
          return t2.reduce(function(t3, e4) {
            return t3.then(function() {
              return i2(e4);
            });
          }, Promise.resolve()).then(function() {
            return n2.end();
          }).catch(function(t3) {
            n2.emit("error", t3);
          }), n2;
        }, r.writeToStream = function(t2, e3, n2) {
          return r.write(e3, n2).pipe(t2);
        }, r.writeToBuffer = function(t2) {
          var n2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i2 = [], o2 = new u.Writable({ write: function(t3, e3, r2) {
            i2.push(t3), r2();
          } });
          return new Promise(function(a2, s2) {
            o2.on("error", s2).on("finish", function() {
              return a2(e2.concat(i2));
            }), r.write(t2, n2).pipe(o2);
          });
        }, r.writeToString = function(t2, e3) {
          return r.writeToBuffer(t2, e3).then(function(t3) {
            return t3.toString();
          });
        }, r.writeToPath = function(t2, e3, n2) {
          var i2 = c.createWriteStream(t2, { encoding: "utf8" });
          return r.write(e3, n2).pipe(i2);
        };
      }).call(this, t("buffer").Buffer);
    }, { "./CsvFormatterStream": 143, "./FormatterOptions": 144, "./types": 149, buffer: 216, fs: 215, stream: 506, util: 525 }], 149: [function(t, e, r) {
      Object.defineProperty(r, "__esModule", { value: true }), r.isSyncTransform = void 0, r.isSyncTransform = function(t2) {
        return t2.length === 1;
      };
    }, {}], 150: [function(t, e, r) {
      (function(e2) {
        function n(t2) {
          return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
            return typeof t3;
          } : function(t3) {
            return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
          })(t2);
        }
        function i(t2, e3) {
          for (var r2 = 0; r2 < e3.length; r2++) {
            var n2 = e3[r2];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
          }
        }
        function o(t2, e3, r2) {
          return (o = typeof Reflect != "undefined" && Reflect.get ? Reflect.get : function(t3, e4, r3) {
            var n2 = function(t4, e5) {
              for (; !Object.prototype.hasOwnProperty.call(t4, e5) && (t4 = c(t4)) !== null; )
                ;
              return t4;
            }(t3, e4);
            if (n2) {
              var i2 = Object.getOwnPropertyDescriptor(n2, e4);
              return i2.get ? i2.get.call(r3) : i2.value;
            }
          })(t2, e3, r2 || t2);
        }
        function a(t2, e3) {
          return (a = Object.setPrototypeOf || function(t3, e4) {
            return t3.__proto__ = e4, t3;
          })(t2, e3);
        }
        function s(t2) {
          var e3 = function() {
            if (typeof Reflect == "undefined" || !Reflect.construct)
              return false;
            if (Reflect.construct.sham)
              return false;
            if (typeof Proxy == "function")
              return true;
            try {
              return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
              })), true;
            } catch (t3) {
              return false;
            }
          }();
          return function() {
            var r2, n2 = c(t2);
            if (e3) {
              var i2 = c(this).constructor;
              r2 = Reflect.construct(n2, arguments, i2);
            } else
              r2 = n2.apply(this, arguments);
            return u(this, r2);
          };
        }
        function u(t2, e3) {
          return !e3 || n(e3) !== "object" && typeof e3 != "function" ? function(t3) {
            if (t3 === void 0)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t3;
          }(t2) : e3;
        }
        function c(t2) {
          return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
            return t3.__proto__ || Object.getPrototypeOf(t3);
          })(t2);
        }
        Object.defineProperty(r, "__esModule", { value: true }), r.CsvParserStream = void 0;
        var f = t("string_decoder"), l = t("stream"), h = t("./transforms"), d = t("./parser"), p = function(t2) {
          !function(t3, e3) {
            if (typeof e3 != "function" && e3 !== null)
              throw new TypeError("Super expression must either be null or a function");
            t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && a(t3, e3);
          }(p2, t2);
          var r2, n2, l2 = s(p2);
          function p2(t3) {
            var e3;
            return function(t4, e4) {
              if (!(t4 instanceof e4))
                throw new TypeError("Cannot call a class as a function");
            }(this, p2), (e3 = l2.call(this, { objectMode: t3.objectMode })).lines = "", e3.rowCount = 0, e3.parsedRowCount = 0, e3.parsedLineCount = 0, e3.endEmitted = false, e3.headersEmitted = false, e3.parserOptions = t3, e3.parser = new d.Parser(t3), e3.headerTransformer = new h.HeaderTransformer(t3), e3.decoder = new f.StringDecoder(t3.encoding), e3.rowTransformerValidator = new h.RowTransformerValidator(), e3;
          }
          return r2 = p2, (n2 = [{ key: "transform", value: function(t3) {
            return this.rowTransformerValidator.rowTransform = t3, this;
          } }, { key: "validate", value: function(t3) {
            return this.rowTransformerValidator.rowValidator = t3, this;
          } }, { key: "emit", value: function(t3) {
            var e3;
            if (t3 === "end")
              return this.endEmitted || (this.endEmitted = true, o(c(p2.prototype), "emit", this).call(this, "end", this.rowCount)), false;
            for (var r3 = arguments.length, n3 = new Array(r3 > 1 ? r3 - 1 : 0), i2 = 1; i2 < r3; i2++)
              n3[i2 - 1] = arguments[i2];
            return (e3 = o(c(p2.prototype), "emit", this)).call.apply(e3, [this, t3].concat(n3));
          } }, { key: "_transform", value: function(t3, e3, r3) {
            if (this.hasHitRowLimit)
              return r3();
            try {
              var n3 = this.lines + this.decoder.write(t3), i2 = this.parse(n3, true);
              return this.processRows(i2, r3);
            } catch (t4) {
              return r3(t4);
            }
          } }, { key: "_flush", value: function(t3) {
            if (this.hasHitRowLimit)
              return t3();
            try {
              var e3 = this.lines + this.decoder.end(), r3 = this.parse(e3, false);
              return this.processRows(r3, t3);
            } catch (e4) {
              return t3(e4);
            }
          } }, { key: "parse", value: function(t3, e3) {
            if (!t3)
              return [];
            var r3 = this.parser.parse(t3, e3), n3 = r3.line, i2 = r3.rows;
            return this.lines = n3, i2;
          } }, { key: "processRows", value: function(t3, r3) {
            var n3 = this, i2 = t3.length;
            !function o2(a2) {
              var s2 = function(t4) {
                return t4 ? r3(t4) : a2 % 100 != 0 ? o2(a2 + 1) : void e2(function() {
                  return o2(a2 + 1);
                });
              };
              if (n3.checkAndEmitHeaders(), a2 >= i2 || n3.hasHitRowLimit)
                return r3();
              if (n3.parsedLineCount += 1, n3.shouldSkipLine)
                return s2();
              var u3 = t3[a2];
              n3.rowCount += 1, n3.parsedRowCount += 1;
              var c2 = n3.rowCount;
              return n3.transformRow(u3, function(t4, e3) {
                if (t4)
                  return n3.rowCount -= 1, s2(t4);
                if (!e3)
                  return s2(new Error("expected transform result"));
                if (e3.isValid) {
                  if (e3.row)
                    return n3.pushRow(e3.row, s2);
                } else
                  n3.emit("data-invalid", e3.row, c2, e3.reason);
                return s2();
              });
            }(0);
          } }, { key: "transformRow", value: function(t3, e3) {
            var r3 = this;
            try {
              this.headerTransformer.transform(t3, function(n3, i2) {
                return n3 ? e3(n3) : i2 ? i2.isValid ? i2.row ? r3.shouldEmitRows ? r3.rowTransformerValidator.transformAndValidate(i2.row, e3) : r3.skipRow(e3) : (r3.rowCount -= 1, r3.parsedRowCount -= 1, e3(null, { row: null, isValid: true })) : r3.shouldEmitRows ? e3(null, { isValid: false, row: t3 }) : r3.skipRow(e3) : e3(new Error("Expected result from header transform"));
              });
            } catch (t4) {
              e3(t4);
            }
          } }, { key: "checkAndEmitHeaders", value: function() {
            !this.headersEmitted && this.headerTransformer.headers && (this.headersEmitted = true, this.emit("headers", this.headerTransformer.headers));
          } }, { key: "skipRow", value: function(t3) {
            return this.rowCount -= 1, t3(null, { row: null, isValid: true });
          } }, { key: "pushRow", value: function(t3, e3) {
            try {
              this.parserOptions.objectMode ? this.push(t3) : this.push(JSON.stringify(t3)), e3();
            } catch (t4) {
              e3(t4);
            }
          } }, { key: "hasHitRowLimit", get: function() {
            return this.parserOptions.limitRows && this.rowCount >= this.parserOptions.maxRows;
          } }, { key: "shouldEmitRows", get: function() {
            return this.parsedRowCount > this.parserOptions.skipRows;
          } }, { key: "shouldSkipLine", get: function() {
            return this.parsedLineCount <= this.parserOptions.skipLines;
          } }]) && i(r2.prototype, n2), p2;
        }(l.Transform);
        r.CsvParserStream = p;
      }).call(this, t("timers").setImmediate);
    }, { "./parser": 162, "./transforms": 165, stream: 506, string_decoder: 520, timers: 521 }], 151: [function(t, e, r) {
      var n = function(t2) {
        return t2 && t2.__esModule ? t2 : { default: t2 };
      };
      Object.defineProperty(r, "__esModule", { value: true }), r.ParserOptions = void 0;
      var i = n(t("lodash.escaperegexp")), o = n(t("lodash.isnil"));
      r.ParserOptions = function t2(e2) {
        var r2;
        if (function(t3, e3) {
          if (!(t3 instanceof e3))
            throw new TypeError("Cannot call a class as a function");
        }(this, t2), this.objectMode = true, this.delimiter = ",", this.ignoreEmpty = false, this.quote = '"', this.escape = null, this.escapeChar = this.quote, this.comment = null, this.supportsComments = false, this.ltrim = false, this.rtrim = false, this.trim = false, this.headers = null, this.renameHeaders = false, this.strictColumnHandling = false, this.discardUnmappedColumns = false, this.carriageReturn = "\r", this.encoding = "utf8", this.limitRows = false, this.maxRows = 0, this.skipLines = 0, this.skipRows = 0, Object.assign(this, e2 || {}), this.delimiter.length > 1)
          throw new Error("delimiter option must be one character long");
        this.escapedDelimiter = i.default(this.delimiter), this.escapeChar = (r2 = this.escape) !== null && r2 !== void 0 ? r2 : this.quote, this.supportsComments = !o.default(this.comment), this.NEXT_TOKEN_REGEXP = new RegExp("([^\\s]|\\r\\n|\\n|\\r|".concat(this.escapedDelimiter, ")")), this.maxRows > 0 && (this.limitRows = true);
      };
    }, { "lodash.escaperegexp": 426, "lodash.isnil": 431 }], 152: [function(t, e, r) {
      var n = Object.create ? function(t2, e2, r2, n2) {
        n2 === void 0 && (n2 = r2), Object.defineProperty(t2, n2, { enumerable: true, get: function() {
          return e2[r2];
        } });
      } : function(t2, e2, r2, n2) {
        n2 === void 0 && (n2 = r2), t2[n2] = e2[r2];
      }, i = Object.create ? function(t2, e2) {
        Object.defineProperty(t2, "default", { enumerable: true, value: e2 });
      } : function(t2, e2) {
        t2.default = e2;
      }, o = function(t2) {
        if (t2 && t2.__esModule)
          return t2;
        var e2 = {};
        if (t2 != null)
          for (var r2 in t2)
            r2 !== "default" && Object.hasOwnProperty.call(t2, r2) && n(e2, t2, r2);
        return i(e2, t2), e2;
      }, a = function(t2, e2) {
        for (var r2 in t2)
          r2 === "default" || e2.hasOwnProperty(r2) || n(e2, t2, r2);
      };
      Object.defineProperty(r, "__esModule", { value: true }), r.parseString = r.parseFile = r.parseStream = r.parse = void 0;
      var s = o(t("fs")), u = t("stream"), c = t("./ParserOptions"), f = t("./CsvParserStream");
      a(t("./types"), r);
      var l = t("./CsvParserStream");
      Object.defineProperty(r, "CsvParserStream", { enumerable: true, get: function() {
        return l.CsvParserStream;
      } });
      var h = t("./ParserOptions");
      Object.defineProperty(r, "ParserOptions", { enumerable: true, get: function() {
        return h.ParserOptions;
      } }), r.parse = function(t2) {
        return new f.CsvParserStream(new c.ParserOptions(t2));
      }, r.parseStream = function(t2, e2) {
        return t2.pipe(new f.CsvParserStream(new c.ParserOptions(e2)));
      }, r.parseFile = function(t2) {
        var e2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return s.createReadStream(t2).pipe(new f.CsvParserStream(new c.ParserOptions(e2)));
      }, r.parseString = function(t2, e2) {
        var r2 = new u.Readable();
        return r2.push(t2), r2.push(null), r2.pipe(new f.CsvParserStream(new c.ParserOptions(e2)));
      };
    }, { "./CsvParserStream": 150, "./ParserOptions": 151, "./types": 166, fs: 215, stream: 506 }], 153: [function(t, e, r) {
      function n(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      Object.defineProperty(r, "__esModule", { value: true }), r.Parser = void 0;
      var i = t("./Scanner"), o = t("./RowParser"), a = t("./Token"), s = /^\s*(?:''|"")?\s*(?:,\s*(?:''|"")?\s*)*$/, u = function() {
        function t2(e3) {
          !function(t3, e4) {
            if (!(t3 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, t2), this.parserOptions = e3, this.rowParser = new o.RowParser(this.parserOptions);
        }
        var e2, r2, u2;
        return e2 = t2, u2 = [{ key: "removeBOM", value: function(t3) {
          return t3 && t3.charCodeAt(0) === 65279 ? t3.slice(1) : t3;
        } }], (r2 = [{ key: "parse", value: function(e3, r3) {
          var n2 = new i.Scanner({ line: t2.removeBOM(e3), parserOptions: this.parserOptions, hasMoreData: r3 });
          return this.parserOptions.supportsComments ? this.parseWithComments(n2) : this.parseWithoutComments(n2);
        } }, { key: "parseWithoutComments", value: function(t3) {
          for (var e3 = [], r3 = true; r3; )
            r3 = this.parseRow(t3, e3);
          return { line: t3.line, rows: e3 };
        } }, { key: "parseWithComments", value: function(t3) {
          for (var e3 = this.parserOptions, r3 = [], n2 = t3.nextCharacterToken; n2 !== null; n2 = t3.nextCharacterToken)
            if (a.Token.isTokenComment(n2, e3)) {
              if (t3.advancePastLine() === null)
                return { line: t3.lineFromCursor, rows: r3 };
              if (!t3.hasMoreCharacters)
                return { line: t3.lineFromCursor, rows: r3 };
              t3.truncateToCursor();
            } else if (!this.parseRow(t3, r3))
              break;
          return { line: t3.line, rows: r3 };
        } }, { key: "parseRow", value: function(t3, e3) {
          if (!t3.nextNonSpaceToken)
            return false;
          var r3 = this.rowParser.parse(t3);
          return r3 !== null && (this.parserOptions.ignoreEmpty && s.test(r3.join("")) || e3.push(r3), true);
        } }]) && n(e2.prototype, r2), u2 && n(e2, u2), t2;
      }();
      r.Parser = u;
    }, { "./RowParser": 154, "./Scanner": 155, "./Token": 156 }], 154: [function(t, e, r) {
      function n(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      Object.defineProperty(r, "__esModule", { value: true }), r.RowParser = void 0;
      var i = t("./column"), o = t("./Token").Token, a = o.isTokenRowDelimiter, s = o.isTokenCarriageReturn, u = o.isTokenDelimiter, c = function() {
        function t2(e3) {
          !function(t3, e4) {
            if (!(t3 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, t2), this.parserOptions = e3, this.columnParser = new i.ColumnParser(e3);
        }
        var e2, r2;
        return e2 = t2, (r2 = [{ key: "parse", value: function(t3) {
          for (var e3 = this.parserOptions, r3 = t3.hasMoreData, n2 = t3, i2 = [], o3 = this.getStartToken(n2, i2); o3; ) {
            if (a(o3))
              return n2.advancePastToken(o3), !n2.hasMoreCharacters && s(o3, e3) && r3 ? null : (n2.truncateToCursor(), i2);
            if (!this.shouldSkipColumnParse(n2, o3, i2)) {
              var u2 = this.columnParser.parse(n2);
              if (u2 === null)
                return null;
              i2.push(u2);
            }
            o3 = n2.nextNonSpaceToken;
          }
          return r3 ? null : (n2.truncateToCursor(), i2);
        } }, { key: "getStartToken", value: function(t3, e3) {
          var r3 = t3.nextNonSpaceToken;
          return r3 !== null && u(r3, this.parserOptions) ? (e3.push(""), t3.nextNonSpaceToken) : r3;
        } }, { key: "shouldSkipColumnParse", value: function(t3, e3, r3) {
          var n2 = this.parserOptions;
          if (u(e3, n2)) {
            t3.advancePastToken(e3);
            var i2 = t3.nextCharacterToken;
            if (!t3.hasMoreCharacters || i2 !== null && a(i2))
              return r3.push(""), true;
            if (i2 !== null && u(i2, n2))
              return r3.push(""), true;
          }
          return false;
        } }]) && n(e2.prototype, r2), t2;
      }();
      r.RowParser = c;
    }, { "./Token": 156, "./column": 161 }], 155: [function(t, e, r) {
      function n(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      Object.defineProperty(r, "__esModule", { value: true }), r.Scanner = void 0;
      var i = t("./Token"), o = /((?:\r\n)|\n|\r)/, a = function() {
        function t2(e3) {
          !function(t3, e4) {
            if (!(t3 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, t2), this.cursor = 0, this.line = e3.line, this.lineLength = this.line.length, this.parserOptions = e3.parserOptions, this.hasMoreData = e3.hasMoreData, this.cursor = e3.cursor || 0;
        }
        var e2, r2;
        return e2 = t2, (r2 = [{ key: "advancePastLine", value: function() {
          var t3 = o.exec(this.lineFromCursor);
          return t3 ? (this.cursor += (t3.index || 0) + t3[0].length, this) : this.hasMoreData ? null : (this.cursor = this.lineLength, this);
        } }, { key: "advanceTo", value: function(t3) {
          return this.cursor = t3, this;
        } }, { key: "advanceToToken", value: function(t3) {
          return this.cursor = t3.startCursor, this;
        } }, { key: "advancePastToken", value: function(t3) {
          return this.cursor = t3.endCursor + 1, this;
        } }, { key: "truncateToCursor", value: function() {
          return this.line = this.lineFromCursor, this.lineLength = this.line.length, this.cursor = 0, this;
        } }, { key: "hasMoreCharacters", get: function() {
          return this.lineLength > this.cursor;
        } }, { key: "nextNonSpaceToken", get: function() {
          var t3 = this.lineFromCursor, e3 = this.parserOptions.NEXT_TOKEN_REGEXP;
          if (t3.search(e3) === -1)
            return null;
          var r3 = e3.exec(t3);
          if (r3 == null)
            return null;
          var n2 = r3[1], o2 = this.cursor + (r3.index || 0);
          return new i.Token({ token: n2, startCursor: o2, endCursor: o2 + n2.length - 1 });
        } }, { key: "nextCharacterToken", get: function() {
          var t3 = this.cursor;
          return this.lineLength <= t3 ? null : new i.Token({ token: this.line[t3], startCursor: t3, endCursor: t3 });
        } }, { key: "lineFromCursor", get: function() {
          return this.line.substr(this.cursor);
        } }]) && n(e2.prototype, r2), t2;
      }();
      r.Scanner = a;
    }, { "./Token": 156 }], 156: [function(t, e, r) {
      function n(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      Object.defineProperty(r, "__esModule", { value: true }), r.Token = void 0;
      var i = function() {
        function t2(e3) {
          !function(t3, e4) {
            if (!(t3 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, t2), this.token = e3.token, this.startCursor = e3.startCursor, this.endCursor = e3.endCursor;
        }
        var e2, r2, i2;
        return e2 = t2, i2 = [{ key: "isTokenRowDelimiter", value: function(t3) {
          var e3 = t3.token;
          return e3 === "\r" || e3 === "\n" || e3 === "\r\n";
        } }, { key: "isTokenCarriageReturn", value: function(t3, e3) {
          return t3.token === e3.carriageReturn;
        } }, { key: "isTokenComment", value: function(t3, e3) {
          return e3.supportsComments && !!t3 && t3.token === e3.comment;
        } }, { key: "isTokenEscapeCharacter", value: function(t3, e3) {
          return t3.token === e3.escapeChar;
        } }, { key: "isTokenQuote", value: function(t3, e3) {
          return t3.token === e3.quote;
        } }, { key: "isTokenDelimiter", value: function(t3, e3) {
          return t3.token === e3.delimiter;
        } }], (r2 = null) && n(e2.prototype, r2), i2 && n(e2, i2), t2;
      }();
      r.Token = i;
    }, {}], 157: [function(t, e, r) {
      Object.defineProperty(r, "__esModule", { value: true }), r.ColumnFormatter = void 0;
      r.ColumnFormatter = function t2(e2) {
        !function(t3, e3) {
          if (!(t3 instanceof e3))
            throw new TypeError("Cannot call a class as a function");
        }(this, t2), e2.trim ? this.format = function(t3) {
          return t3.trim();
        } : e2.ltrim ? this.format = function(t3) {
          return t3.trimLeft();
        } : e2.rtrim ? this.format = function(t3) {
          return t3.trimRight();
        } : this.format = function(t3) {
          return t3;
        };
      };
    }, {}], 158: [function(t, e, r) {
      function n(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      Object.defineProperty(r, "__esModule", { value: true }), r.ColumnParser = void 0;
      var i = t("./NonQuotedColumnParser"), o = t("./QuotedColumnParser"), a = t("../Token"), s = function() {
        function t2(e3) {
          !function(t3, e4) {
            if (!(t3 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, t2), this.parserOptions = e3, this.quotedColumnParser = new o.QuotedColumnParser(e3), this.nonQuotedColumnParser = new i.NonQuotedColumnParser(e3);
        }
        var e2, r2;
        return e2 = t2, (r2 = [{ key: "parse", value: function(t3) {
          var e3 = t3.nextNonSpaceToken;
          return e3 !== null && a.Token.isTokenQuote(e3, this.parserOptions) ? (t3.advanceToToken(e3), this.quotedColumnParser.parse(t3)) : this.nonQuotedColumnParser.parse(t3);
        } }]) && n(e2.prototype, r2), t2;
      }();
      r.ColumnParser = s;
    }, { "../Token": 156, "./NonQuotedColumnParser": 159, "./QuotedColumnParser": 160 }], 159: [function(t, e, r) {
      function n(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      Object.defineProperty(r, "__esModule", { value: true }), r.NonQuotedColumnParser = void 0;
      var i = t("./ColumnFormatter"), o = t("../Token").Token, a = o.isTokenDelimiter, s = o.isTokenRowDelimiter, u = function() {
        function t2(e3) {
          !function(t3, e4) {
            if (!(t3 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, t2), this.parserOptions = e3, this.columnFormatter = new i.ColumnFormatter(e3);
        }
        var e2, r2;
        return e2 = t2, (r2 = [{ key: "parse", value: function(t3) {
          if (!t3.hasMoreCharacters)
            return null;
          for (var e3 = this.parserOptions, r3 = [], n2 = t3.nextCharacterToken; n2 && !a(n2, e3) && !s(n2); n2 = t3.nextCharacterToken)
            r3.push(n2.token), t3.advancePastToken(n2);
          return this.columnFormatter.format(r3.join(""));
        } }]) && n(e2.prototype, r2), t2;
      }();
      r.NonQuotedColumnParser = u;
    }, { "../Token": 156, "./ColumnFormatter": 157 }], 160: [function(t, e, r) {
      function n(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      Object.defineProperty(r, "__esModule", { value: true }), r.QuotedColumnParser = void 0;
      var i = t("./ColumnFormatter"), o = t("../Token").Token, a = o.isTokenDelimiter, s = o.isTokenRowDelimiter, u = o.isTokenEscapeCharacter, c = o.isTokenQuote, f = function() {
        function t2(e3) {
          !function(t3, e4) {
            if (!(t3 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, t2), this.parserOptions = e3, this.columnFormatter = new i.ColumnFormatter(e3);
        }
        var e2, r2;
        return e2 = t2, (r2 = [{ key: "parse", value: function(t3) {
          if (!t3.hasMoreCharacters)
            return null;
          var e3 = t3.cursor, r3 = this.gatherDataBetweenQuotes(t3), n2 = r3.foundClosingQuote, i2 = r3.col;
          if (!n2) {
            if (t3.advanceTo(e3), !t3.hasMoreData)
              throw new Error("Parse Error: missing closing: '".concat(this.parserOptions.quote || "", "' in line: at '").concat(t3.lineFromCursor.replace(/[\r\n]/g, "\\n'"), "'"));
            return null;
          }
          return this.checkForMalformedColumn(t3), i2;
        } }, { key: "gatherDataBetweenQuotes", value: function(t3) {
          for (var e3 = this.parserOptions, r3 = false, n2 = false, i2 = [], o3 = t3.nextCharacterToken; !n2 && o3 !== null; o3 = t3.nextCharacterToken) {
            var a2 = c(o3, e3);
            if (!r3 && a2)
              r3 = true;
            else if (r3)
              if (u(o3, e3)) {
                t3.advancePastToken(o3);
                var s2 = t3.nextCharacterToken;
                s2 !== null && (c(s2, e3) || u(s2, e3)) ? (i2.push(s2.token), o3 = s2) : a2 ? n2 = true : i2.push(o3.token);
              } else
                a2 ? n2 = true : i2.push(o3.token);
            t3.advancePastToken(o3);
          }
          return { col: this.columnFormatter.format(i2.join("")), foundClosingQuote: n2 };
        } }, { key: "checkForMalformedColumn", value: function(t3) {
          var e3 = this.parserOptions, r3 = t3.nextNonSpaceToken;
          if (r3) {
            var n2 = a(r3, e3), i2 = s(r3);
            if (!n2 && !i2) {
              var o3 = t3.lineFromCursor.substr(0, 10).replace(/[\r\n]/g, "\\n'");
              throw new Error("Parse Error: expected: '".concat(e3.escapedDelimiter, "' OR new line got: '").concat(r3.token, "'. at '").concat(o3));
            }
            t3.advanceToToken(r3);
          } else
            t3.hasMoreData || t3.advancePastLine();
        } }]) && n(e2.prototype, r2), t2;
      }();
      r.QuotedColumnParser = f;
    }, { "../Token": 156, "./ColumnFormatter": 157 }], 161: [function(t, e, r) {
      Object.defineProperty(r, "__esModule", { value: true });
      var n = t("./ColumnParser");
      Object.defineProperty(r, "ColumnParser", { enumerable: true, get: function() {
        return n.ColumnParser;
      } });
      var i = t("./NonQuotedColumnParser");
      Object.defineProperty(r, "NonQuotedColumnParser", { enumerable: true, get: function() {
        return i.NonQuotedColumnParser;
      } });
      var o = t("./QuotedColumnParser");
      Object.defineProperty(r, "QuotedColumnParser", { enumerable: true, get: function() {
        return o.QuotedColumnParser;
      } });
      var a = t("./ColumnFormatter");
      Object.defineProperty(r, "ColumnFormatter", { enumerable: true, get: function() {
        return a.ColumnFormatter;
      } });
    }, { "./ColumnFormatter": 157, "./ColumnParser": 158, "./NonQuotedColumnParser": 159, "./QuotedColumnParser": 160 }], 162: [function(t, e, r) {
      Object.defineProperty(r, "__esModule", { value: true });
      var n = t("./Parser");
      Object.defineProperty(r, "Parser", { enumerable: true, get: function() {
        return n.Parser;
      } });
      var i = t("./RowParser");
      Object.defineProperty(r, "RowParser", { enumerable: true, get: function() {
        return i.RowParser;
      } });
      var o = t("./Scanner");
      Object.defineProperty(r, "Scanner", { enumerable: true, get: function() {
        return o.Scanner;
      } });
      var a = t("./Token");
      Object.defineProperty(r, "Token", { enumerable: true, get: function() {
        return a.Token;
      } });
      var s = t("./column");
      Object.defineProperty(r, "ColumnParser", { enumerable: true, get: function() {
        return s.ColumnParser;
      } }), Object.defineProperty(r, "NonQuotedColumnParser", { enumerable: true, get: function() {
        return s.NonQuotedColumnParser;
      } }), Object.defineProperty(r, "QuotedColumnParser", { enumerable: true, get: function() {
        return s.QuotedColumnParser;
      } });
    }, { "./Parser": 153, "./RowParser": 154, "./Scanner": 155, "./Token": 156, "./column": 161 }], 163: [function(t, e, r) {
      function n(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      var i = function(t2) {
        return t2 && t2.__esModule ? t2 : { default: t2 };
      };
      Object.defineProperty(r, "__esModule", { value: true }), r.HeaderTransformer = void 0;
      var o = i(t("lodash.isundefined")), a = i(t("lodash.isfunction")), s = i(t("lodash.uniq")), u = i(t("lodash.groupby")), c = function() {
        function t2(e3) {
          !function(t3, e4) {
            if (!(t3 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, t2), this.headers = null, this.receivedHeaders = false, this.shouldUseFirstRow = false, this.processedFirstRow = false, this.headersLength = 0, this.parserOptions = e3, e3.headers === true ? this.shouldUseFirstRow = true : Array.isArray(e3.headers) ? this.setHeaders(e3.headers) : a.default(e3.headers) && (this.headersTransform = e3.headers);
        }
        var e2, r2;
        return e2 = t2, (r2 = [{ key: "transform", value: function(t3, e3) {
          return this.shouldMapRow(t3) ? e3(null, this.processRow(t3)) : e3(null, { row: null, isValid: true });
        } }, { key: "shouldMapRow", value: function(t3) {
          var e3 = this.parserOptions;
          if (!this.headersTransform && e3.renameHeaders && !this.processedFirstRow) {
            if (!this.receivedHeaders)
              throw new Error("Error renaming headers: new headers must be provided in an array");
            return this.processedFirstRow = true, false;
          }
          if (!this.receivedHeaders && Array.isArray(t3)) {
            if (this.headersTransform)
              this.setHeaders(this.headersTransform(t3));
            else {
              if (!this.shouldUseFirstRow)
                return true;
              this.setHeaders(t3);
            }
            return false;
          }
          return true;
        } }, { key: "processRow", value: function(t3) {
          if (!this.headers)
            return { row: t3, isValid: true };
          var e3 = this.parserOptions;
          if (!e3.discardUnmappedColumns && t3.length > this.headersLength) {
            if (!e3.strictColumnHandling)
              throw new Error("Unexpected Error: column header mismatch expected: ".concat(this.headersLength, " columns got: ").concat(t3.length));
            return { row: t3, isValid: false, reason: "Column header mismatch expected: ".concat(this.headersLength, " columns got: ").concat(t3.length) };
          }
          return e3.strictColumnHandling && t3.length < this.headersLength ? { row: t3, isValid: false, reason: "Column header mismatch expected: ".concat(this.headersLength, " columns got: ").concat(t3.length) } : { row: this.mapHeaders(t3), isValid: true };
        } }, { key: "mapHeaders", value: function(t3) {
          for (var e3 = {}, r3 = this.headers, n2 = this.headersLength, i3 = 0; i3 < n2; i3 += 1) {
            var a2 = r3[i3];
            if (!o.default(a2)) {
              var s2 = t3[i3];
              o.default(s2) ? e3[a2] = "" : e3[a2] = s2;
            }
          }
          return e3;
        } }, { key: "setHeaders", value: function(t3) {
          var e3, r3 = t3.filter(function(t4) {
            return !!t4;
          });
          if (s.default(r3).length !== r3.length) {
            var n2 = u.default(r3), i3 = Object.keys(n2).filter(function(t4) {
              return n2[t4].length > 1;
            });
            throw new Error("Duplicate headers found ".concat(JSON.stringify(i3)));
          }
          this.headers = t3, this.receivedHeaders = true, this.headersLength = ((e3 = this.headers) === null || e3 === void 0 ? void 0 : e3.length) || 0;
        } }]) && n(e2.prototype, r2), t2;
      }();
      r.HeaderTransformer = c;
    }, { "lodash.groupby": 427, "lodash.isfunction": 430, "lodash.isundefined": 432, "lodash.uniq": 433 }], 164: [function(t, e, r) {
      function n(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      var i = function(t2) {
        return t2 && t2.__esModule ? t2 : { default: t2 };
      };
      Object.defineProperty(r, "__esModule", { value: true }), r.RowTransformerValidator = void 0;
      var o = i(t("lodash.isfunction")), a = t("../types"), s = function() {
        function t2() {
          !function(t3, e3) {
            if (!(t3 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, t2), this._rowTransform = null, this._rowValidator = null;
        }
        var e2, r2, i2;
        return e2 = t2, i2 = [{ key: "createTransform", value: function(t3) {
          return a.isSyncTransform(t3) ? function(e3, r3) {
            var n2 = null;
            try {
              n2 = t3(e3);
            } catch (t4) {
              return r3(t4);
            }
            return r3(null, n2);
          } : t3;
        } }, { key: "createValidator", value: function(t3) {
          return a.isSyncValidate(t3) ? function(e3, r3) {
            r3(null, { row: e3, isValid: t3(e3) });
          } : function(e3, r3) {
            t3(e3, function(t4, n2, i3) {
              return t4 ? r3(t4) : r3(null, n2 ? { row: e3, isValid: n2, reason: i3 } : { row: e3, isValid: false, reason: i3 });
            });
          };
        } }], (r2 = [{ key: "transformAndValidate", value: function(t3, e3) {
          var r3 = this;
          return this.callTransformer(t3, function(t4, n2) {
            return t4 ? e3(t4) : n2 ? r3.callValidator(n2, function(t5, r4) {
              return t5 ? e3(t5) : r4 && !r4.isValid ? e3(null, { row: n2, isValid: false, reason: r4.reason }) : e3(null, { row: n2, isValid: true });
            }) : e3(null, { row: null, isValid: true });
          });
        } }, { key: "callTransformer", value: function(t3, e3) {
          return this._rowTransform ? this._rowTransform(t3, e3) : e3(null, t3);
        } }, { key: "callValidator", value: function(t3, e3) {
          return this._rowValidator ? this._rowValidator(t3, e3) : e3(null, { row: t3, isValid: true });
        } }, { key: "rowTransform", set: function(e3) {
          if (!o.default(e3))
            throw new TypeError("The transform should be a function");
          this._rowTransform = t2.createTransform(e3);
        } }, { key: "rowValidator", set: function(e3) {
          if (!o.default(e3))
            throw new TypeError("The validate should be a function");
          this._rowValidator = t2.createValidator(e3);
        } }]) && n(e2.prototype, r2), i2 && n(e2, i2), t2;
      }();
      r.RowTransformerValidator = s;
    }, { "../types": 166, "lodash.isfunction": 430 }], 165: [function(t, e, r) {
      Object.defineProperty(r, "__esModule", { value: true });
      var n = t("./RowTransformerValidator");
      Object.defineProperty(r, "RowTransformerValidator", { enumerable: true, get: function() {
        return n.RowTransformerValidator;
      } });
      var i = t("./HeaderTransformer");
      Object.defineProperty(r, "HeaderTransformer", { enumerable: true, get: function() {
        return i.HeaderTransformer;
      } });
    }, { "./HeaderTransformer": 163, "./RowTransformerValidator": 164 }], 166: [function(t, e, r) {
      Object.defineProperty(r, "__esModule", { value: true }), r.isSyncValidate = r.isSyncTransform = void 0, r.isSyncTransform = function(t2) {
        return t2.length === 1;
      }, r.isSyncValidate = function(t2) {
        return t2.length === 1;
      };
    }, {}], 167: [function(t, e, r) {
      var n = r;
      n.bignum = t("bn.js"), n.define = t("./asn1/api").define, n.base = t("./asn1/base"), n.constants = t("./asn1/constants"), n.decoders = t("./asn1/decoders"), n.encoders = t("./asn1/encoders");
    }, { "./asn1/api": 168, "./asn1/base": 170, "./asn1/constants": 174, "./asn1/decoders": 176, "./asn1/encoders": 179, "bn.js": 181 }], 168: [function(t, e, r) {
      var n = t("./encoders"), i = t("./decoders"), o = t("inherits");
      function a(t2, e2) {
        this.name = t2, this.body = e2, this.decoders = {}, this.encoders = {};
      }
      r.define = function(t2, e2) {
        return new a(t2, e2);
      }, a.prototype._createNamed = function(t2) {
        var e2 = this.name;
        function r2(t3) {
          this._initNamed(t3, e2);
        }
        return o(r2, t2), r2.prototype._initNamed = function(e3, r3) {
          t2.call(this, e3, r3);
        }, new r2(this);
      }, a.prototype._getDecoder = function(t2) {
        return t2 = t2 || "der", this.decoders.hasOwnProperty(t2) || (this.decoders[t2] = this._createNamed(i[t2])), this.decoders[t2];
      }, a.prototype.decode = function(t2, e2, r2) {
        return this._getDecoder(e2).decode(t2, r2);
      }, a.prototype._getEncoder = function(t2) {
        return t2 = t2 || "der", this.encoders.hasOwnProperty(t2) || (this.encoders[t2] = this._createNamed(n[t2])), this.encoders[t2];
      }, a.prototype.encode = function(t2, e2, r2) {
        return this._getEncoder(e2).encode(t2, r2);
      };
    }, { "./decoders": 176, "./encoders": 179, inherits: 387 }], 169: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      var i = t("inherits"), o = t("../base/reporter").Reporter, a = t("safer-buffer").Buffer;
      function s(t2, e2) {
        o.call(this, e2), a.isBuffer(t2) ? (this.base = t2, this.offset = 0, this.length = t2.length) : this.error("Input not Buffer");
      }
      function u(t2, e2) {
        if (Array.isArray(t2))
          this.length = 0, this.value = t2.map(function(t3) {
            return u.isEncoderBuffer(t3) || (t3 = new u(t3, e2)), this.length += t3.length, t3;
          }, this);
        else if (typeof t2 == "number") {
          if (!(0 <= t2 && t2 <= 255))
            return e2.error("non-byte EncoderBuffer value");
          this.value = t2, this.length = 1;
        } else if (typeof t2 == "string")
          this.value = t2, this.length = a.byteLength(t2);
        else {
          if (!a.isBuffer(t2))
            return e2.error("Unsupported type: " + n(t2));
          this.value = t2, this.length = t2.length;
        }
      }
      i(s, o), r.DecoderBuffer = s, s.isDecoderBuffer = function(t2) {
        return t2 instanceof s || n(t2) === "object" && a.isBuffer(t2.base) && t2.constructor.name === "DecoderBuffer" && typeof t2.offset == "number" && typeof t2.length == "number" && typeof t2.save == "function" && typeof t2.restore == "function" && typeof t2.isEmpty == "function" && typeof t2.readUInt8 == "function" && typeof t2.skip == "function" && typeof t2.raw == "function";
      }, s.prototype.save = function() {
        return { offset: this.offset, reporter: o.prototype.save.call(this) };
      }, s.prototype.restore = function(t2) {
        var e2 = new s(this.base);
        return e2.offset = t2.offset, e2.length = this.offset, this.offset = t2.offset, o.prototype.restore.call(this, t2.reporter), e2;
      }, s.prototype.isEmpty = function() {
        return this.offset === this.length;
      }, s.prototype.readUInt8 = function(t2) {
        return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, true) : this.error(t2 || "DecoderBuffer overrun");
      }, s.prototype.skip = function(t2, e2) {
        if (!(this.offset + t2 <= this.length))
          return this.error(e2 || "DecoderBuffer overrun");
        var r2 = new s(this.base);
        return r2._reporterState = this._reporterState, r2.offset = this.offset, r2.length = this.offset + t2, this.offset += t2, r2;
      }, s.prototype.raw = function(t2) {
        return this.base.slice(t2 ? t2.offset : this.offset, this.length);
      }, r.EncoderBuffer = u, u.isEncoderBuffer = function(t2) {
        return t2 instanceof u || n(t2) === "object" && t2.constructor.name === "EncoderBuffer" && typeof t2.length == "number" && typeof t2.join == "function";
      }, u.prototype.join = function(t2, e2) {
        return t2 || (t2 = a.alloc(this.length)), e2 || (e2 = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(r2) {
          r2.join(t2, e2), e2 += r2.length;
        }) : (typeof this.value == "number" ? t2[e2] = this.value : typeof this.value == "string" ? t2.write(this.value, e2) : a.isBuffer(this.value) && this.value.copy(t2, e2), e2 += this.length)), t2;
      };
    }, { "../base/reporter": 172, inherits: 387, "safer-buffer": 495 }], 170: [function(t, e, r) {
      var n = r;
      n.Reporter = t("./reporter").Reporter, n.DecoderBuffer = t("./buffer").DecoderBuffer, n.EncoderBuffer = t("./buffer").EncoderBuffer, n.Node = t("./node");
    }, { "./buffer": 169, "./node": 171, "./reporter": 172 }], 171: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      var i = t("../base/reporter").Reporter, o = t("../base/buffer").EncoderBuffer, a = t("../base/buffer").DecoderBuffer, s = t("minimalistic-assert"), u = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"], c = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(u);
      function f(t2, e2, r2) {
        var n2 = {};
        this._baseState = n2, n2.name = r2, n2.enc = t2, n2.parent = e2 || null, n2.children = null, n2.tag = null, n2.args = null, n2.reverseArgs = null, n2.choice = null, n2.optional = false, n2.any = false, n2.obj = false, n2.use = null, n2.useDecoder = null, n2.key = null, n2.default = null, n2.explicit = null, n2.implicit = null, n2.contains = null, n2.parent || (n2.children = [], this._wrap());
      }
      e.exports = f;
      var l = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
      f.prototype.clone = function() {
        var t2 = this._baseState, e2 = {};
        l.forEach(function(r3) {
          e2[r3] = t2[r3];
        });
        var r2 = new this.constructor(e2.parent);
        return r2._baseState = e2, r2;
      }, f.prototype._wrap = function() {
        var t2 = this._baseState;
        c.forEach(function(e2) {
          this[e2] = function() {
            var r2 = new this.constructor(this);
            return t2.children.push(r2), r2[e2].apply(r2, arguments);
          };
        }, this);
      }, f.prototype._init = function(t2) {
        var e2 = this._baseState;
        s(e2.parent === null), t2.call(this), e2.children = e2.children.filter(function(t3) {
          return t3._baseState.parent === this;
        }, this), s.equal(e2.children.length, 1, "Root node can have only one child");
      }, f.prototype._useArgs = function(t2) {
        var e2 = this._baseState, r2 = t2.filter(function(t3) {
          return t3 instanceof this.constructor;
        }, this);
        t2 = t2.filter(function(t3) {
          return !(t3 instanceof this.constructor);
        }, this), r2.length !== 0 && (s(e2.children === null), e2.children = r2, r2.forEach(function(t3) {
          t3._baseState.parent = this;
        }, this)), t2.length !== 0 && (s(e2.args === null), e2.args = t2, e2.reverseArgs = t2.map(function(t3) {
          if (n(t3) !== "object" || t3.constructor !== Object)
            return t3;
          var e3 = {};
          return Object.keys(t3).forEach(function(r3) {
            r3 == (0 | r3) && (r3 |= 0);
            var n2 = t3[r3];
            e3[n2] = r3;
          }), e3;
        }));
      }, ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"].forEach(function(t2) {
        f.prototype[t2] = function() {
          var e2 = this._baseState;
          throw new Error(t2 + " not implemented for encoding: " + e2.enc);
        };
      }), u.forEach(function(t2) {
        f.prototype[t2] = function() {
          var e2 = this._baseState, r2 = Array.prototype.slice.call(arguments);
          return s(e2.tag === null), e2.tag = t2, this._useArgs(r2), this;
        };
      }), f.prototype.use = function(t2) {
        s(t2);
        var e2 = this._baseState;
        return s(e2.use === null), e2.use = t2, this;
      }, f.prototype.optional = function() {
        return this._baseState.optional = true, this;
      }, f.prototype.def = function(t2) {
        var e2 = this._baseState;
        return s(e2.default === null), e2.default = t2, e2.optional = true, this;
      }, f.prototype.explicit = function(t2) {
        var e2 = this._baseState;
        return s(e2.explicit === null && e2.implicit === null), e2.explicit = t2, this;
      }, f.prototype.implicit = function(t2) {
        var e2 = this._baseState;
        return s(e2.explicit === null && e2.implicit === null), e2.implicit = t2, this;
      }, f.prototype.obj = function() {
        var t2 = this._baseState, e2 = Array.prototype.slice.call(arguments);
        return t2.obj = true, e2.length !== 0 && this._useArgs(e2), this;
      }, f.prototype.key = function(t2) {
        var e2 = this._baseState;
        return s(e2.key === null), e2.key = t2, this;
      }, f.prototype.any = function() {
        return this._baseState.any = true, this;
      }, f.prototype.choice = function(t2) {
        var e2 = this._baseState;
        return s(e2.choice === null), e2.choice = t2, this._useArgs(Object.keys(t2).map(function(e3) {
          return t2[e3];
        })), this;
      }, f.prototype.contains = function(t2) {
        var e2 = this._baseState;
        return s(e2.use === null), e2.contains = t2, this;
      }, f.prototype._decode = function(t2, e2) {
        var r2 = this._baseState;
        if (r2.parent === null)
          return t2.wrapResult(r2.children[0]._decode(t2, e2));
        var n2, i2 = r2.default, o2 = true, s2 = null;
        if (r2.key !== null && (s2 = t2.enterKey(r2.key)), r2.optional) {
          var u2 = null;
          if (r2.explicit !== null ? u2 = r2.explicit : r2.implicit !== null ? u2 = r2.implicit : r2.tag !== null && (u2 = r2.tag), u2 !== null || r2.any) {
            if (o2 = this._peekTag(t2, u2, r2.any), t2.isError(o2))
              return o2;
          } else {
            var c2 = t2.save();
            try {
              r2.choice === null ? this._decodeGeneric(r2.tag, t2, e2) : this._decodeChoice(t2, e2), o2 = true;
            } catch (t3) {
              o2 = false;
            }
            t2.restore(c2);
          }
        }
        if (r2.obj && o2 && (n2 = t2.enterObject()), o2) {
          if (r2.explicit !== null) {
            var f2 = this._decodeTag(t2, r2.explicit);
            if (t2.isError(f2))
              return f2;
            t2 = f2;
          }
          var l2 = t2.offset;
          if (r2.use === null && r2.choice === null) {
            var h;
            r2.any && (h = t2.save());
            var d = this._decodeTag(t2, r2.implicit !== null ? r2.implicit : r2.tag, r2.any);
            if (t2.isError(d))
              return d;
            r2.any ? i2 = t2.raw(h) : t2 = d;
          }
          if (e2 && e2.track && r2.tag !== null && e2.track(t2.path(), l2, t2.length, "tagged"), e2 && e2.track && r2.tag !== null && e2.track(t2.path(), t2.offset, t2.length, "content"), r2.any || (i2 = r2.choice === null ? this._decodeGeneric(r2.tag, t2, e2) : this._decodeChoice(t2, e2)), t2.isError(i2))
            return i2;
          if (r2.any || r2.choice !== null || r2.children === null || r2.children.forEach(function(r3) {
            r3._decode(t2, e2);
          }), r2.contains && (r2.tag === "octstr" || r2.tag === "bitstr")) {
            var p = new a(i2);
            i2 = this._getUse(r2.contains, t2._reporterState.obj)._decode(p, e2);
          }
        }
        return r2.obj && o2 && (i2 = t2.leaveObject(n2)), r2.key === null || i2 === null && o2 !== true ? s2 !== null && t2.exitKey(s2) : t2.leaveKey(s2, r2.key, i2), i2;
      }, f.prototype._decodeGeneric = function(t2, e2, r2) {
        var n2 = this._baseState;
        return t2 === "seq" || t2 === "set" ? null : t2 === "seqof" || t2 === "setof" ? this._decodeList(e2, t2, n2.args[0], r2) : /str$/.test(t2) ? this._decodeStr(e2, t2, r2) : t2 === "objid" && n2.args ? this._decodeObjid(e2, n2.args[0], n2.args[1], r2) : t2 === "objid" ? this._decodeObjid(e2, null, null, r2) : t2 === "gentime" || t2 === "utctime" ? this._decodeTime(e2, t2, r2) : t2 === "null_" ? this._decodeNull(e2, r2) : t2 === "bool" ? this._decodeBool(e2, r2) : t2 === "objDesc" ? this._decodeStr(e2, t2, r2) : t2 === "int" || t2 === "enum" ? this._decodeInt(e2, n2.args && n2.args[0], r2) : n2.use !== null ? this._getUse(n2.use, e2._reporterState.obj)._decode(e2, r2) : e2.error("unknown tag: " + t2);
      }, f.prototype._getUse = function(t2, e2) {
        var r2 = this._baseState;
        return r2.useDecoder = this._use(t2, e2), s(r2.useDecoder._baseState.parent === null), r2.useDecoder = r2.useDecoder._baseState.children[0], r2.implicit !== r2.useDecoder._baseState.implicit && (r2.useDecoder = r2.useDecoder.clone(), r2.useDecoder._baseState.implicit = r2.implicit), r2.useDecoder;
      }, f.prototype._decodeChoice = function(t2, e2) {
        var r2 = this._baseState, n2 = null, i2 = false;
        return Object.keys(r2.choice).some(function(o2) {
          var a2 = t2.save(), s2 = r2.choice[o2];
          try {
            var u2 = s2._decode(t2, e2);
            if (t2.isError(u2))
              return false;
            n2 = { type: o2, value: u2 }, i2 = true;
          } catch (e3) {
            return t2.restore(a2), false;
          }
          return true;
        }, this), i2 ? n2 : t2.error("Choice not matched");
      }, f.prototype._createEncoderBuffer = function(t2) {
        return new o(t2, this.reporter);
      }, f.prototype._encode = function(t2, e2, r2) {
        var n2 = this._baseState;
        if (n2.default === null || n2.default !== t2) {
          var i2 = this._encodeValue(t2, e2, r2);
          if (i2 !== void 0 && !this._skipDefault(i2, e2, r2))
            return i2;
        }
      }, f.prototype._encodeValue = function(t2, e2, r2) {
        var o2 = this._baseState;
        if (o2.parent === null)
          return o2.children[0]._encode(t2, e2 || new i());
        var a2 = null;
        if (this.reporter = e2, o2.optional && t2 === void 0) {
          if (o2.default === null)
            return;
          t2 = o2.default;
        }
        var s2 = null, u2 = false;
        if (o2.any)
          a2 = this._createEncoderBuffer(t2);
        else if (o2.choice)
          a2 = this._encodeChoice(t2, e2);
        else if (o2.contains)
          s2 = this._getUse(o2.contains, r2)._encode(t2, e2), u2 = true;
        else if (o2.children)
          s2 = o2.children.map(function(r3) {
            if (r3._baseState.tag === "null_")
              return r3._encode(null, e2, t2);
            if (r3._baseState.key === null)
              return e2.error("Child should have a key");
            var i2 = e2.enterKey(r3._baseState.key);
            if (n(t2) !== "object")
              return e2.error("Child expected, but input is not object");
            var o3 = r3._encode(t2[r3._baseState.key], e2, t2);
            return e2.leaveKey(i2), o3;
          }, this).filter(function(t3) {
            return t3;
          }), s2 = this._createEncoderBuffer(s2);
        else if (o2.tag === "seqof" || o2.tag === "setof") {
          if (!o2.args || o2.args.length !== 1)
            return e2.error("Too many args for : " + o2.tag);
          if (!Array.isArray(t2))
            return e2.error("seqof/setof, but data is not Array");
          var c2 = this.clone();
          c2._baseState.implicit = null, s2 = this._createEncoderBuffer(t2.map(function(r3) {
            var n2 = this._baseState;
            return this._getUse(n2.args[0], t2)._encode(r3, e2);
          }, c2));
        } else
          o2.use !== null ? a2 = this._getUse(o2.use, r2)._encode(t2, e2) : (s2 = this._encodePrimitive(o2.tag, t2), u2 = true);
        if (!o2.any && o2.choice === null) {
          var f2 = o2.implicit !== null ? o2.implicit : o2.tag, l2 = o2.implicit === null ? "universal" : "context";
          f2 === null ? o2.use === null && e2.error("Tag could be omitted only for .use()") : o2.use === null && (a2 = this._encodeComposite(f2, u2, l2, s2));
        }
        return o2.explicit !== null && (a2 = this._encodeComposite(o2.explicit, false, "context", a2)), a2;
      }, f.prototype._encodeChoice = function(t2, e2) {
        var r2 = this._baseState, n2 = r2.choice[t2.type];
        return n2 || s(false, t2.type + " not found in " + JSON.stringify(Object.keys(r2.choice))), n2._encode(t2.value, e2);
      }, f.prototype._encodePrimitive = function(t2, e2) {
        var r2 = this._baseState;
        if (/str$/.test(t2))
          return this._encodeStr(e2, t2);
        if (t2 === "objid" && r2.args)
          return this._encodeObjid(e2, r2.reverseArgs[0], r2.args[1]);
        if (t2 === "objid")
          return this._encodeObjid(e2, null, null);
        if (t2 === "gentime" || t2 === "utctime")
          return this._encodeTime(e2, t2);
        if (t2 === "null_")
          return this._encodeNull();
        if (t2 === "int" || t2 === "enum")
          return this._encodeInt(e2, r2.args && r2.reverseArgs[0]);
        if (t2 === "bool")
          return this._encodeBool(e2);
        if (t2 === "objDesc")
          return this._encodeStr(e2, t2);
        throw new Error("Unsupported tag: " + t2);
      }, f.prototype._isNumstr = function(t2) {
        return /^[0-9 ]*$/.test(t2);
      }, f.prototype._isPrintstr = function(t2) {
        return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(t2);
      };
    }, { "../base/buffer": 169, "../base/reporter": 172, "minimalistic-assert": 437 }], 172: [function(t, e, r) {
      var n = t("inherits");
      function i(t2) {
        this._reporterState = { obj: null, path: [], options: t2 || {}, errors: [] };
      }
      function o(t2, e2) {
        this.path = t2, this.rethrow(e2);
      }
      r.Reporter = i, i.prototype.isError = function(t2) {
        return t2 instanceof o;
      }, i.prototype.save = function() {
        var t2 = this._reporterState;
        return { obj: t2.obj, pathLen: t2.path.length };
      }, i.prototype.restore = function(t2) {
        var e2 = this._reporterState;
        e2.obj = t2.obj, e2.path = e2.path.slice(0, t2.pathLen);
      }, i.prototype.enterKey = function(t2) {
        return this._reporterState.path.push(t2);
      }, i.prototype.exitKey = function(t2) {
        var e2 = this._reporterState;
        e2.path = e2.path.slice(0, t2 - 1);
      }, i.prototype.leaveKey = function(t2, e2, r2) {
        var n2 = this._reporterState;
        this.exitKey(t2), n2.obj !== null && (n2.obj[e2] = r2);
      }, i.prototype.path = function() {
        return this._reporterState.path.join("/");
      }, i.prototype.enterObject = function() {
        var t2 = this._reporterState, e2 = t2.obj;
        return t2.obj = {}, e2;
      }, i.prototype.leaveObject = function(t2) {
        var e2 = this._reporterState, r2 = e2.obj;
        return e2.obj = t2, r2;
      }, i.prototype.error = function(t2) {
        var e2, r2 = this._reporterState, n2 = t2 instanceof o;
        if (e2 = n2 ? t2 : new o(r2.path.map(function(t3) {
          return "[" + JSON.stringify(t3) + "]";
        }).join(""), t2.message || t2, t2.stack), !r2.options.partial)
          throw e2;
        return n2 || r2.errors.push(e2), e2;
      }, i.prototype.wrapResult = function(t2) {
        var e2 = this._reporterState;
        return e2.options.partial ? { result: this.isError(t2) ? null : t2, errors: e2.errors } : t2;
      }, n(o, Error), o.prototype.rethrow = function(t2) {
        if (this.message = t2 + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, o), !this.stack)
          try {
            throw new Error(this.message);
          } catch (t3) {
            this.stack = t3.stack;
          }
        return this;
      };
    }, { inherits: 387 }], 173: [function(t, e, r) {
      function n(t2) {
        var e2 = {};
        return Object.keys(t2).forEach(function(r2) {
          (0 | r2) == r2 && (r2 |= 0);
          var n2 = t2[r2];
          e2[n2] = r2;
        }), e2;
      }
      r.tagClass = { 0: "universal", 1: "application", 2: "context", 3: "private" }, r.tagClassByName = n(r.tagClass), r.tag = { 0: "end", 1: "bool", 2: "int", 3: "bitstr", 4: "octstr", 5: "null_", 6: "objid", 7: "objDesc", 8: "external", 9: "real", 10: "enum", 11: "embed", 12: "utf8str", 13: "relativeOid", 16: "seq", 17: "set", 18: "numstr", 19: "printstr", 20: "t61str", 21: "videostr", 22: "ia5str", 23: "utctime", 24: "gentime", 25: "graphstr", 26: "iso646str", 27: "genstr", 28: "unistr", 29: "charstr", 30: "bmpstr" }, r.tagByName = n(r.tag);
    }, {}], 174: [function(t, e, r) {
      var n = r;
      n._reverse = function(t2) {
        var e2 = {};
        return Object.keys(t2).forEach(function(r2) {
          (0 | r2) == r2 && (r2 |= 0);
          var n2 = t2[r2];
          e2[n2] = r2;
        }), e2;
      }, n.der = t("./der");
    }, { "./der": 173 }], 175: [function(t, e, r) {
      var n = t("inherits"), i = t("bn.js"), o = t("../base/buffer").DecoderBuffer, a = t("../base/node"), s = t("../constants/der");
      function u(t2) {
        this.enc = "der", this.name = t2.name, this.entity = t2, this.tree = new c(), this.tree._init(t2.body);
      }
      function c(t2) {
        a.call(this, "der", t2);
      }
      function f(t2, e2) {
        var r2 = t2.readUInt8(e2);
        if (t2.isError(r2))
          return r2;
        var n2 = s.tagClass[r2 >> 6], i2 = (32 & r2) == 0;
        if ((31 & r2) == 31) {
          var o2 = r2;
          for (r2 = 0; (128 & o2) == 128; ) {
            if (o2 = t2.readUInt8(e2), t2.isError(o2))
              return o2;
            r2 <<= 7, r2 |= 127 & o2;
          }
        } else
          r2 &= 31;
        return { cls: n2, primitive: i2, tag: r2, tagStr: s.tag[r2] };
      }
      function l(t2, e2, r2) {
        var n2 = t2.readUInt8(r2);
        if (t2.isError(n2))
          return n2;
        if (!e2 && n2 === 128)
          return null;
        if ((128 & n2) == 0)
          return n2;
        var i2 = 127 & n2;
        if (i2 > 4)
          return t2.error("length octect is too long");
        n2 = 0;
        for (var o2 = 0; o2 < i2; o2++) {
          n2 <<= 8;
          var a2 = t2.readUInt8(r2);
          if (t2.isError(a2))
            return a2;
          n2 |= a2;
        }
        return n2;
      }
      e.exports = u, u.prototype.decode = function(t2, e2) {
        return o.isDecoderBuffer(t2) || (t2 = new o(t2, e2)), this.tree._decode(t2, e2);
      }, n(c, a), c.prototype._peekTag = function(t2, e2, r2) {
        if (t2.isEmpty())
          return false;
        var n2 = t2.save(), i2 = f(t2, 'Failed to peek tag: "' + e2 + '"');
        return t2.isError(i2) ? i2 : (t2.restore(n2), i2.tag === e2 || i2.tagStr === e2 || i2.tagStr + "of" === e2 || r2);
      }, c.prototype._decodeTag = function(t2, e2, r2) {
        var n2 = f(t2, 'Failed to decode tag of "' + e2 + '"');
        if (t2.isError(n2))
          return n2;
        var i2 = l(t2, n2.primitive, 'Failed to get length of "' + e2 + '"');
        if (t2.isError(i2))
          return i2;
        if (!r2 && n2.tag !== e2 && n2.tagStr !== e2 && n2.tagStr + "of" !== e2)
          return t2.error('Failed to match tag: "' + e2 + '"');
        if (n2.primitive || i2 !== null)
          return t2.skip(i2, 'Failed to match body of: "' + e2 + '"');
        var o2 = t2.save(), a2 = this._skipUntilEnd(t2, 'Failed to skip indefinite length body: "' + this.tag + '"');
        return t2.isError(a2) ? a2 : (i2 = t2.offset - o2.offset, t2.restore(o2), t2.skip(i2, 'Failed to match body of: "' + e2 + '"'));
      }, c.prototype._skipUntilEnd = function(t2, e2) {
        for (; ; ) {
          var r2 = f(t2, e2);
          if (t2.isError(r2))
            return r2;
          var n2 = l(t2, r2.primitive, e2);
          if (t2.isError(n2))
            return n2;
          var i2 = void 0;
          if (i2 = r2.primitive || n2 !== null ? t2.skip(n2) : this._skipUntilEnd(t2, e2), t2.isError(i2))
            return i2;
          if (r2.tagStr === "end")
            break;
        }
      }, c.prototype._decodeList = function(t2, e2, r2, n2) {
        for (var i2 = []; !t2.isEmpty(); ) {
          var o2 = this._peekTag(t2, "end");
          if (t2.isError(o2))
            return o2;
          var a2 = r2.decode(t2, "der", n2);
          if (t2.isError(a2) && o2)
            break;
          i2.push(a2);
        }
        return i2;
      }, c.prototype._decodeStr = function(t2, e2) {
        if (e2 === "bitstr") {
          var r2 = t2.readUInt8();
          return t2.isError(r2) ? r2 : { unused: r2, data: t2.raw() };
        }
        if (e2 === "bmpstr") {
          var n2 = t2.raw();
          if (n2.length % 2 == 1)
            return t2.error("Decoding of string type: bmpstr length mismatch");
          for (var i2 = "", o2 = 0; o2 < n2.length / 2; o2++)
            i2 += String.fromCharCode(n2.readUInt16BE(2 * o2));
          return i2;
        }
        if (e2 === "numstr") {
          var a2 = t2.raw().toString("ascii");
          return this._isNumstr(a2) ? a2 : t2.error("Decoding of string type: numstr unsupported characters");
        }
        if (e2 === "octstr")
          return t2.raw();
        if (e2 === "objDesc")
          return t2.raw();
        if (e2 === "printstr") {
          var s2 = t2.raw().toString("ascii");
          return this._isPrintstr(s2) ? s2 : t2.error("Decoding of string type: printstr unsupported characters");
        }
        return /str$/.test(e2) ? t2.raw().toString() : t2.error("Decoding of string type: " + e2 + " unsupported");
      }, c.prototype._decodeObjid = function(t2, e2, r2) {
        for (var n2, i2 = [], o2 = 0, a2 = 0; !t2.isEmpty(); )
          o2 <<= 7, o2 |= 127 & (a2 = t2.readUInt8()), (128 & a2) == 0 && (i2.push(o2), o2 = 0);
        128 & a2 && i2.push(o2);
        var s2 = i2[0] / 40 | 0, u2 = i2[0] % 40;
        if (n2 = r2 ? i2 : [s2, u2].concat(i2.slice(1)), e2) {
          var c2 = e2[n2.join(" ")];
          c2 === void 0 && (c2 = e2[n2.join(".")]), c2 !== void 0 && (n2 = c2);
        }
        return n2;
      }, c.prototype._decodeTime = function(t2, e2) {
        var r2, n2, i2, o2, a2, s2, u2 = t2.raw().toString();
        if (e2 === "gentime")
          r2 = 0 | u2.slice(0, 4), n2 = 0 | u2.slice(4, 6), i2 = 0 | u2.slice(6, 8), o2 = 0 | u2.slice(8, 10), a2 = 0 | u2.slice(10, 12), s2 = 0 | u2.slice(12, 14);
        else {
          if (e2 !== "utctime")
            return t2.error("Decoding " + e2 + " time is not supported yet");
          r2 = 0 | u2.slice(0, 2), n2 = 0 | u2.slice(2, 4), i2 = 0 | u2.slice(4, 6), o2 = 0 | u2.slice(6, 8), a2 = 0 | u2.slice(8, 10), s2 = 0 | u2.slice(10, 12), r2 = r2 < 70 ? 2e3 + r2 : 1900 + r2;
        }
        return Date.UTC(r2, n2 - 1, i2, o2, a2, s2, 0);
      }, c.prototype._decodeNull = function() {
        return null;
      }, c.prototype._decodeBool = function(t2) {
        var e2 = t2.readUInt8();
        return t2.isError(e2) ? e2 : e2 !== 0;
      }, c.prototype._decodeInt = function(t2, e2) {
        var r2 = t2.raw(), n2 = new i(r2);
        return e2 && (n2 = e2[n2.toString(10)] || n2), n2;
      }, c.prototype._use = function(t2, e2) {
        return typeof t2 == "function" && (t2 = t2(e2)), t2._getDecoder("der").tree;
      };
    }, { "../base/buffer": 169, "../base/node": 171, "../constants/der": 173, "bn.js": 181, inherits: 387 }], 176: [function(t, e, r) {
      var n = r;
      n.der = t("./der"), n.pem = t("./pem");
    }, { "./der": 175, "./pem": 177 }], 177: [function(t, e, r) {
      var n = t("inherits"), i = t("safer-buffer").Buffer, o = t("./der");
      function a(t2) {
        o.call(this, t2), this.enc = "pem";
      }
      n(a, o), e.exports = a, a.prototype.decode = function(t2, e2) {
        for (var r2 = t2.toString().split(/[\r\n]+/g), n2 = e2.label.toUpperCase(), a2 = /^-----(BEGIN|END) ([^-]+)-----$/, s = -1, u = -1, c = 0; c < r2.length; c++) {
          var f = r2[c].match(a2);
          if (f !== null && f[2] === n2) {
            if (s !== -1) {
              if (f[1] !== "END")
                break;
              u = c;
              break;
            }
            if (f[1] !== "BEGIN")
              break;
            s = c;
          }
        }
        if (s === -1 || u === -1)
          throw new Error("PEM section not found for: " + n2);
        var l = r2.slice(s + 1, u).join("");
        l.replace(/[^a-z0-9+/=]+/gi, "");
        var h = i.from(l, "base64");
        return o.prototype.decode.call(this, h, e2);
      };
    }, { "./der": 175, inherits: 387, "safer-buffer": 495 }], 178: [function(t, e, r) {
      var n = t("inherits"), i = t("safer-buffer").Buffer, o = t("../base/node"), a = t("../constants/der");
      function s(t2) {
        this.enc = "der", this.name = t2.name, this.entity = t2, this.tree = new u(), this.tree._init(t2.body);
      }
      function u(t2) {
        o.call(this, "der", t2);
      }
      function c(t2) {
        return t2 < 10 ? "0" + t2 : t2;
      }
      e.exports = s, s.prototype.encode = function(t2, e2) {
        return this.tree._encode(t2, e2).join();
      }, n(u, o), u.prototype._encodeComposite = function(t2, e2, r2, n2) {
        var o2 = function(t3, e3, r3, n3) {
          var i2;
          t3 === "seqof" ? t3 = "seq" : t3 === "setof" && (t3 = "set");
          if (a.tagByName.hasOwnProperty(t3))
            i2 = a.tagByName[t3];
          else {
            if (typeof t3 != "number" || (0 | t3) !== t3)
              return n3.error("Unknown tag: " + t3);
            i2 = t3;
          }
          if (i2 >= 31)
            return n3.error("Multi-octet tag encoding unsupported");
          e3 || (i2 |= 32);
          return i2 |= a.tagClassByName[r3 || "universal"] << 6;
        }(t2, e2, r2, this.reporter);
        if (n2.length < 128) {
          var s2 = i.alloc(2);
          return s2[0] = o2, s2[1] = n2.length, this._createEncoderBuffer([s2, n2]);
        }
        for (var u2 = 1, c2 = n2.length; c2 >= 256; c2 >>= 8)
          u2++;
        var f = i.alloc(2 + u2);
        f[0] = o2, f[1] = 128 | u2;
        for (var l = 1 + u2, h = n2.length; h > 0; l--, h >>= 8)
          f[l] = 255 & h;
        return this._createEncoderBuffer([f, n2]);
      }, u.prototype._encodeStr = function(t2, e2) {
        if (e2 === "bitstr")
          return this._createEncoderBuffer([0 | t2.unused, t2.data]);
        if (e2 === "bmpstr") {
          for (var r2 = i.alloc(2 * t2.length), n2 = 0; n2 < t2.length; n2++)
            r2.writeUInt16BE(t2.charCodeAt(n2), 2 * n2);
          return this._createEncoderBuffer(r2);
        }
        return e2 === "numstr" ? this._isNumstr(t2) ? this._createEncoderBuffer(t2) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : e2 === "printstr" ? this._isPrintstr(t2) ? this._createEncoderBuffer(t2) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(e2) || e2 === "objDesc" ? this._createEncoderBuffer(t2) : this.reporter.error("Encoding of string type: " + e2 + " unsupported");
      }, u.prototype._encodeObjid = function(t2, e2, r2) {
        if (typeof t2 == "string") {
          if (!e2)
            return this.reporter.error("string objid given, but no values map found");
          if (!e2.hasOwnProperty(t2))
            return this.reporter.error("objid not found in values map");
          t2 = e2[t2].split(/[\s.]+/g);
          for (var n2 = 0; n2 < t2.length; n2++)
            t2[n2] |= 0;
        } else if (Array.isArray(t2)) {
          t2 = t2.slice();
          for (var o2 = 0; o2 < t2.length; o2++)
            t2[o2] |= 0;
        }
        if (!Array.isArray(t2))
          return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(t2));
        if (!r2) {
          if (t2[1] >= 40)
            return this.reporter.error("Second objid identifier OOB");
          t2.splice(0, 2, 40 * t2[0] + t2[1]);
        }
        for (var a2 = 0, s2 = 0; s2 < t2.length; s2++) {
          var u2 = t2[s2];
          for (a2++; u2 >= 128; u2 >>= 7)
            a2++;
        }
        for (var c2 = i.alloc(a2), f = c2.length - 1, l = t2.length - 1; l >= 0; l--) {
          var h = t2[l];
          for (c2[f--] = 127 & h; (h >>= 7) > 0; )
            c2[f--] = 128 | 127 & h;
        }
        return this._createEncoderBuffer(c2);
      }, u.prototype._encodeTime = function(t2, e2) {
        var r2, n2 = new Date(t2);
        return e2 === "gentime" ? r2 = [c(n2.getUTCFullYear()), c(n2.getUTCMonth() + 1), c(n2.getUTCDate()), c(n2.getUTCHours()), c(n2.getUTCMinutes()), c(n2.getUTCSeconds()), "Z"].join("") : e2 === "utctime" ? r2 = [c(n2.getUTCFullYear() % 100), c(n2.getUTCMonth() + 1), c(n2.getUTCDate()), c(n2.getUTCHours()), c(n2.getUTCMinutes()), c(n2.getUTCSeconds()), "Z"].join("") : this.reporter.error("Encoding " + e2 + " time is not supported yet"), this._encodeStr(r2, "octstr");
      }, u.prototype._encodeNull = function() {
        return this._createEncoderBuffer("");
      }, u.prototype._encodeInt = function(t2, e2) {
        if (typeof t2 == "string") {
          if (!e2)
            return this.reporter.error("String int or enum given, but no values map");
          if (!e2.hasOwnProperty(t2))
            return this.reporter.error("Values map doesn't contain: " + JSON.stringify(t2));
          t2 = e2[t2];
        }
        if (typeof t2 != "number" && !i.isBuffer(t2)) {
          var r2 = t2.toArray();
          !t2.sign && 128 & r2[0] && r2.unshift(0), t2 = i.from(r2);
        }
        if (i.isBuffer(t2)) {
          var n2 = t2.length;
          t2.length === 0 && n2++;
          var o2 = i.alloc(n2);
          return t2.copy(o2), t2.length === 0 && (o2[0] = 0), this._createEncoderBuffer(o2);
        }
        if (t2 < 128)
          return this._createEncoderBuffer(t2);
        if (t2 < 256)
          return this._createEncoderBuffer([0, t2]);
        for (var a2 = 1, s2 = t2; s2 >= 256; s2 >>= 8)
          a2++;
        for (var u2 = new Array(a2), c2 = u2.length - 1; c2 >= 0; c2--)
          u2[c2] = 255 & t2, t2 >>= 8;
        return 128 & u2[0] && u2.unshift(0), this._createEncoderBuffer(i.from(u2));
      }, u.prototype._encodeBool = function(t2) {
        return this._createEncoderBuffer(t2 ? 255 : 0);
      }, u.prototype._use = function(t2, e2) {
        return typeof t2 == "function" && (t2 = t2(e2)), t2._getEncoder("der").tree;
      }, u.prototype._skipDefault = function(t2, e2, r2) {
        var n2, i2 = this._baseState;
        if (i2.default === null)
          return false;
        var o2 = t2.join();
        if (i2.defaultBuffer === void 0 && (i2.defaultBuffer = this._encodeValue(i2.default, e2, r2).join()), o2.length !== i2.defaultBuffer.length)
          return false;
        for (n2 = 0; n2 < o2.length; n2++)
          if (o2[n2] !== i2.defaultBuffer[n2])
            return false;
        return true;
      };
    }, { "../base/node": 171, "../constants/der": 173, inherits: 387, "safer-buffer": 495 }], 179: [function(t, e, r) {
      var n = r;
      n.der = t("./der"), n.pem = t("./pem");
    }, { "./der": 178, "./pem": 180 }], 180: [function(t, e, r) {
      var n = t("inherits"), i = t("./der");
      function o(t2) {
        i.call(this, t2), this.enc = "pem";
      }
      n(o, i), e.exports = o, o.prototype.encode = function(t2, e2) {
        for (var r2 = i.prototype.encode.call(this, t2).toString("base64"), n2 = ["-----BEGIN " + e2.label + "-----"], o2 = 0; o2 < r2.length; o2 += 64)
          n2.push(r2.slice(o2, o2 + 64));
        return n2.push("-----END " + e2.label + "-----"), n2.join("\n");
      };
    }, { "./der": 178, inherits: 387 }], 181: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      !function(e2, r2) {
        function i(t2, e3) {
          if (!t2)
            throw new Error(e3 || "Assertion failed");
        }
        function o(t2, e3) {
          t2.super_ = e3;
          var r3 = function() {
          };
          r3.prototype = e3.prototype, t2.prototype = new r3(), t2.prototype.constructor = t2;
        }
        function a(t2, e3, r3) {
          if (a.isBN(t2))
            return t2;
          this.negative = 0, this.words = null, this.length = 0, this.red = null, t2 !== null && (e3 !== "le" && e3 !== "be" || (r3 = e3, e3 = 10), this._init(t2 || 0, e3 || 10, r3 || "be"));
        }
        var s;
        n(e2) === "object" ? e2.exports = a : (void 0).BN = a, a.BN = a, a.wordSize = 26;
        try {
          s = t("buffer").Buffer;
        } catch (t2) {
        }
        function u(t2, e3, r3) {
          for (var n2 = 0, i2 = Math.min(t2.length, r3), o2 = e3; o2 < i2; o2++) {
            var a2 = t2.charCodeAt(o2) - 48;
            n2 <<= 4, n2 |= a2 >= 49 && a2 <= 54 ? a2 - 49 + 10 : a2 >= 17 && a2 <= 22 ? a2 - 17 + 10 : 15 & a2;
          }
          return n2;
        }
        function c(t2, e3, r3, n2) {
          for (var i2 = 0, o2 = Math.min(t2.length, r3), a2 = e3; a2 < o2; a2++) {
            var s2 = t2.charCodeAt(a2) - 48;
            i2 *= n2, i2 += s2 >= 49 ? s2 - 49 + 10 : s2 >= 17 ? s2 - 17 + 10 : s2;
          }
          return i2;
        }
        a.isBN = function(t2) {
          return t2 instanceof a || t2 !== null && n(t2) === "object" && t2.constructor.wordSize === a.wordSize && Array.isArray(t2.words);
        }, a.max = function(t2, e3) {
          return t2.cmp(e3) > 0 ? t2 : e3;
        }, a.min = function(t2, e3) {
          return t2.cmp(e3) < 0 ? t2 : e3;
        }, a.prototype._init = function(t2, e3, r3) {
          if (typeof t2 == "number")
            return this._initNumber(t2, e3, r3);
          if (n(t2) === "object")
            return this._initArray(t2, e3, r3);
          e3 === "hex" && (e3 = 16), i(e3 === (0 | e3) && e3 >= 2 && e3 <= 36);
          var o2 = 0;
          (t2 = t2.toString().replace(/\s+/g, ""))[0] === "-" && o2++, e3 === 16 ? this._parseHex(t2, o2) : this._parseBase(t2, e3, o2), t2[0] === "-" && (this.negative = 1), this.strip(), r3 === "le" && this._initArray(this.toArray(), e3, r3);
        }, a.prototype._initNumber = function(t2, e3, r3) {
          t2 < 0 && (this.negative = 1, t2 = -t2), t2 < 67108864 ? (this.words = [67108863 & t2], this.length = 1) : t2 < 4503599627370496 ? (this.words = [67108863 & t2, t2 / 67108864 & 67108863], this.length = 2) : (i(t2 < 9007199254740992), this.words = [67108863 & t2, t2 / 67108864 & 67108863, 1], this.length = 3), r3 === "le" && this._initArray(this.toArray(), e3, r3);
        }, a.prototype._initArray = function(t2, e3, r3) {
          if (i(typeof t2.length == "number"), t2.length <= 0)
            return this.words = [0], this.length = 1, this;
          this.length = Math.ceil(t2.length / 3), this.words = new Array(this.length);
          for (var n2 = 0; n2 < this.length; n2++)
            this.words[n2] = 0;
          var o2, a2, s2 = 0;
          if (r3 === "be")
            for (n2 = t2.length - 1, o2 = 0; n2 >= 0; n2 -= 3)
              a2 = t2[n2] | t2[n2 - 1] << 8 | t2[n2 - 2] << 16, this.words[o2] |= a2 << s2 & 67108863, this.words[o2 + 1] = a2 >>> 26 - s2 & 67108863, (s2 += 24) >= 26 && (s2 -= 26, o2++);
          else if (r3 === "le")
            for (n2 = 0, o2 = 0; n2 < t2.length; n2 += 3)
              a2 = t2[n2] | t2[n2 + 1] << 8 | t2[n2 + 2] << 16, this.words[o2] |= a2 << s2 & 67108863, this.words[o2 + 1] = a2 >>> 26 - s2 & 67108863, (s2 += 24) >= 26 && (s2 -= 26, o2++);
          return this.strip();
        }, a.prototype._parseHex = function(t2, e3) {
          this.length = Math.ceil((t2.length - e3) / 6), this.words = new Array(this.length);
          for (var r3 = 0; r3 < this.length; r3++)
            this.words[r3] = 0;
          var n2, i2, o2 = 0;
          for (r3 = t2.length - 6, n2 = 0; r3 >= e3; r3 -= 6)
            i2 = u(t2, r3, r3 + 6), this.words[n2] |= i2 << o2 & 67108863, this.words[n2 + 1] |= i2 >>> 26 - o2 & 4194303, (o2 += 24) >= 26 && (o2 -= 26, n2++);
          r3 + 6 !== e3 && (i2 = u(t2, e3, r3 + 6), this.words[n2] |= i2 << o2 & 67108863, this.words[n2 + 1] |= i2 >>> 26 - o2 & 4194303), this.strip();
        }, a.prototype._parseBase = function(t2, e3, r3) {
          this.words = [0], this.length = 1;
          for (var n2 = 0, i2 = 1; i2 <= 67108863; i2 *= e3)
            n2++;
          n2--, i2 = i2 / e3 | 0;
          for (var o2 = t2.length - r3, a2 = o2 % n2, s2 = Math.min(o2, o2 - a2) + r3, u2 = 0, f2 = r3; f2 < s2; f2 += n2)
            u2 = c(t2, f2, f2 + n2, e3), this.imuln(i2), this.words[0] + u2 < 67108864 ? this.words[0] += u2 : this._iaddn(u2);
          if (a2 !== 0) {
            var l2 = 1;
            for (u2 = c(t2, f2, t2.length, e3), f2 = 0; f2 < a2; f2++)
              l2 *= e3;
            this.imuln(l2), this.words[0] + u2 < 67108864 ? this.words[0] += u2 : this._iaddn(u2);
          }
        }, a.prototype.copy = function(t2) {
          t2.words = new Array(this.length);
          for (var e3 = 0; e3 < this.length; e3++)
            t2.words[e3] = this.words[e3];
          t2.length = this.length, t2.negative = this.negative, t2.red = this.red;
        }, a.prototype.clone = function() {
          var t2 = new a(null);
          return this.copy(t2), t2;
        }, a.prototype._expand = function(t2) {
          for (; this.length < t2; )
            this.words[this.length++] = 0;
          return this;
        }, a.prototype.strip = function() {
          for (; this.length > 1 && this.words[this.length - 1] === 0; )
            this.length--;
          return this._normSign();
        }, a.prototype._normSign = function() {
          return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
        }, a.prototype.inspect = function() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        };
        var f = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], l = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], h = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        function d(t2, e3, r3) {
          r3.negative = e3.negative ^ t2.negative;
          var n2 = t2.length + e3.length | 0;
          r3.length = n2, n2 = n2 - 1 | 0;
          var i2 = 0 | t2.words[0], o2 = 0 | e3.words[0], a2 = i2 * o2, s2 = 67108863 & a2, u2 = a2 / 67108864 | 0;
          r3.words[0] = s2;
          for (var c2 = 1; c2 < n2; c2++) {
            for (var f2 = u2 >>> 26, l2 = 67108863 & u2, h2 = Math.min(c2, e3.length - 1), d2 = Math.max(0, c2 - t2.length + 1); d2 <= h2; d2++) {
              var p2 = c2 - d2 | 0;
              f2 += (a2 = (i2 = 0 | t2.words[p2]) * (o2 = 0 | e3.words[d2]) + l2) / 67108864 | 0, l2 = 67108863 & a2;
            }
            r3.words[c2] = 0 | l2, u2 = 0 | f2;
          }
          return u2 !== 0 ? r3.words[c2] = 0 | u2 : r3.length--, r3.strip();
        }
        a.prototype.toString = function(t2, e3) {
          var r3;
          if (e3 = 0 | e3 || 1, (t2 = t2 || 10) === 16 || t2 === "hex") {
            r3 = "";
            for (var n2 = 0, o2 = 0, a2 = 0; a2 < this.length; a2++) {
              var s2 = this.words[a2], u2 = (16777215 & (s2 << n2 | o2)).toString(16);
              r3 = (o2 = s2 >>> 24 - n2 & 16777215) !== 0 || a2 !== this.length - 1 ? f[6 - u2.length] + u2 + r3 : u2 + r3, (n2 += 2) >= 26 && (n2 -= 26, a2--);
            }
            for (o2 !== 0 && (r3 = o2.toString(16) + r3); r3.length % e3 != 0; )
              r3 = "0" + r3;
            return this.negative !== 0 && (r3 = "-" + r3), r3;
          }
          if (t2 === (0 | t2) && t2 >= 2 && t2 <= 36) {
            var c2 = l[t2], d2 = h[t2];
            r3 = "";
            var p2 = this.clone();
            for (p2.negative = 0; !p2.isZero(); ) {
              var m2 = p2.modn(d2).toString(t2);
              r3 = (p2 = p2.idivn(d2)).isZero() ? m2 + r3 : f[c2 - m2.length] + m2 + r3;
            }
            for (this.isZero() && (r3 = "0" + r3); r3.length % e3 != 0; )
              r3 = "0" + r3;
            return this.negative !== 0 && (r3 = "-" + r3), r3;
          }
          i(false, "Base should be between 2 and 36");
        }, a.prototype.toNumber = function() {
          var t2 = this.words[0];
          return this.length === 2 ? t2 += 67108864 * this.words[1] : this.length === 3 && this.words[2] === 1 ? t2 += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && i(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -t2 : t2;
        }, a.prototype.toJSON = function() {
          return this.toString(16);
        }, a.prototype.toBuffer = function(t2, e3) {
          return i(s !== void 0), this.toArrayLike(s, t2, e3);
        }, a.prototype.toArray = function(t2, e3) {
          return this.toArrayLike(Array, t2, e3);
        }, a.prototype.toArrayLike = function(t2, e3, r3) {
          var n2 = this.byteLength(), o2 = r3 || Math.max(1, n2);
          i(n2 <= o2, "byte array longer than desired length"), i(o2 > 0, "Requested array length <= 0"), this.strip();
          var a2, s2, u2 = e3 === "le", c2 = new t2(o2), f2 = this.clone();
          if (u2) {
            for (s2 = 0; !f2.isZero(); s2++)
              a2 = f2.andln(255), f2.iushrn(8), c2[s2] = a2;
            for (; s2 < o2; s2++)
              c2[s2] = 0;
          } else {
            for (s2 = 0; s2 < o2 - n2; s2++)
              c2[s2] = 0;
            for (s2 = 0; !f2.isZero(); s2++)
              a2 = f2.andln(255), f2.iushrn(8), c2[o2 - s2 - 1] = a2;
          }
          return c2;
        }, Math.clz32 ? a.prototype._countBits = function(t2) {
          return 32 - Math.clz32(t2);
        } : a.prototype._countBits = function(t2) {
          var e3 = t2, r3 = 0;
          return e3 >= 4096 && (r3 += 13, e3 >>>= 13), e3 >= 64 && (r3 += 7, e3 >>>= 7), e3 >= 8 && (r3 += 4, e3 >>>= 4), e3 >= 2 && (r3 += 2, e3 >>>= 2), r3 + e3;
        }, a.prototype._zeroBits = function(t2) {
          if (t2 === 0)
            return 26;
          var e3 = t2, r3 = 0;
          return (8191 & e3) == 0 && (r3 += 13, e3 >>>= 13), (127 & e3) == 0 && (r3 += 7, e3 >>>= 7), (15 & e3) == 0 && (r3 += 4, e3 >>>= 4), (3 & e3) == 0 && (r3 += 2, e3 >>>= 2), (1 & e3) == 0 && r3++, r3;
        }, a.prototype.bitLength = function() {
          var t2 = this.words[this.length - 1], e3 = this._countBits(t2);
          return 26 * (this.length - 1) + e3;
        }, a.prototype.zeroBits = function() {
          if (this.isZero())
            return 0;
          for (var t2 = 0, e3 = 0; e3 < this.length; e3++) {
            var r3 = this._zeroBits(this.words[e3]);
            if (t2 += r3, r3 !== 26)
              break;
          }
          return t2;
        }, a.prototype.byteLength = function() {
          return Math.ceil(this.bitLength() / 8);
        }, a.prototype.toTwos = function(t2) {
          return this.negative !== 0 ? this.abs().inotn(t2).iaddn(1) : this.clone();
        }, a.prototype.fromTwos = function(t2) {
          return this.testn(t2 - 1) ? this.notn(t2).iaddn(1).ineg() : this.clone();
        }, a.prototype.isNeg = function() {
          return this.negative !== 0;
        }, a.prototype.neg = function() {
          return this.clone().ineg();
        }, a.prototype.ineg = function() {
          return this.isZero() || (this.negative ^= 1), this;
        }, a.prototype.iuor = function(t2) {
          for (; this.length < t2.length; )
            this.words[this.length++] = 0;
          for (var e3 = 0; e3 < t2.length; e3++)
            this.words[e3] = this.words[e3] | t2.words[e3];
          return this.strip();
        }, a.prototype.ior = function(t2) {
          return i((this.negative | t2.negative) == 0), this.iuor(t2);
        }, a.prototype.or = function(t2) {
          return this.length > t2.length ? this.clone().ior(t2) : t2.clone().ior(this);
        }, a.prototype.uor = function(t2) {
          return this.length > t2.length ? this.clone().iuor(t2) : t2.clone().iuor(this);
        }, a.prototype.iuand = function(t2) {
          var e3;
          e3 = this.length > t2.length ? t2 : this;
          for (var r3 = 0; r3 < e3.length; r3++)
            this.words[r3] = this.words[r3] & t2.words[r3];
          return this.length = e3.length, this.strip();
        }, a.prototype.iand = function(t2) {
          return i((this.negative | t2.negative) == 0), this.iuand(t2);
        }, a.prototype.and = function(t2) {
          return this.length > t2.length ? this.clone().iand(t2) : t2.clone().iand(this);
        }, a.prototype.uand = function(t2) {
          return this.length > t2.length ? this.clone().iuand(t2) : t2.clone().iuand(this);
        }, a.prototype.iuxor = function(t2) {
          var e3, r3;
          this.length > t2.length ? (e3 = this, r3 = t2) : (e3 = t2, r3 = this);
          for (var n2 = 0; n2 < r3.length; n2++)
            this.words[n2] = e3.words[n2] ^ r3.words[n2];
          if (this !== e3)
            for (; n2 < e3.length; n2++)
              this.words[n2] = e3.words[n2];
          return this.length = e3.length, this.strip();
        }, a.prototype.ixor = function(t2) {
          return i((this.negative | t2.negative) == 0), this.iuxor(t2);
        }, a.prototype.xor = function(t2) {
          return this.length > t2.length ? this.clone().ixor(t2) : t2.clone().ixor(this);
        }, a.prototype.uxor = function(t2) {
          return this.length > t2.length ? this.clone().iuxor(t2) : t2.clone().iuxor(this);
        }, a.prototype.inotn = function(t2) {
          i(typeof t2 == "number" && t2 >= 0);
          var e3 = 0 | Math.ceil(t2 / 26), r3 = t2 % 26;
          this._expand(e3), r3 > 0 && e3--;
          for (var n2 = 0; n2 < e3; n2++)
            this.words[n2] = 67108863 & ~this.words[n2];
          return r3 > 0 && (this.words[n2] = ~this.words[n2] & 67108863 >> 26 - r3), this.strip();
        }, a.prototype.notn = function(t2) {
          return this.clone().inotn(t2);
        }, a.prototype.setn = function(t2, e3) {
          i(typeof t2 == "number" && t2 >= 0);
          var r3 = t2 / 26 | 0, n2 = t2 % 26;
          return this._expand(r3 + 1), this.words[r3] = e3 ? this.words[r3] | 1 << n2 : this.words[r3] & ~(1 << n2), this.strip();
        }, a.prototype.iadd = function(t2) {
          var e3, r3, n2;
          if (this.negative !== 0 && t2.negative === 0)
            return this.negative = 0, e3 = this.isub(t2), this.negative ^= 1, this._normSign();
          if (this.negative === 0 && t2.negative !== 0)
            return t2.negative = 0, e3 = this.isub(t2), t2.negative = 1, e3._normSign();
          this.length > t2.length ? (r3 = this, n2 = t2) : (r3 = t2, n2 = this);
          for (var i2 = 0, o2 = 0; o2 < n2.length; o2++)
            e3 = (0 | r3.words[o2]) + (0 | n2.words[o2]) + i2, this.words[o2] = 67108863 & e3, i2 = e3 >>> 26;
          for (; i2 !== 0 && o2 < r3.length; o2++)
            e3 = (0 | r3.words[o2]) + i2, this.words[o2] = 67108863 & e3, i2 = e3 >>> 26;
          if (this.length = r3.length, i2 !== 0)
            this.words[this.length] = i2, this.length++;
          else if (r3 !== this)
            for (; o2 < r3.length; o2++)
              this.words[o2] = r3.words[o2];
          return this;
        }, a.prototype.add = function(t2) {
          var e3;
          return t2.negative !== 0 && this.negative === 0 ? (t2.negative = 0, e3 = this.sub(t2), t2.negative ^= 1, e3) : t2.negative === 0 && this.negative !== 0 ? (this.negative = 0, e3 = t2.sub(this), this.negative = 1, e3) : this.length > t2.length ? this.clone().iadd(t2) : t2.clone().iadd(this);
        }, a.prototype.isub = function(t2) {
          if (t2.negative !== 0) {
            t2.negative = 0;
            var e3 = this.iadd(t2);
            return t2.negative = 1, e3._normSign();
          }
          if (this.negative !== 0)
            return this.negative = 0, this.iadd(t2), this.negative = 1, this._normSign();
          var r3, n2, i2 = this.cmp(t2);
          if (i2 === 0)
            return this.negative = 0, this.length = 1, this.words[0] = 0, this;
          i2 > 0 ? (r3 = this, n2 = t2) : (r3 = t2, n2 = this);
          for (var o2 = 0, a2 = 0; a2 < n2.length; a2++)
            o2 = (e3 = (0 | r3.words[a2]) - (0 | n2.words[a2]) + o2) >> 26, this.words[a2] = 67108863 & e3;
          for (; o2 !== 0 && a2 < r3.length; a2++)
            o2 = (e3 = (0 | r3.words[a2]) + o2) >> 26, this.words[a2] = 67108863 & e3;
          if (o2 === 0 && a2 < r3.length && r3 !== this)
            for (; a2 < r3.length; a2++)
              this.words[a2] = r3.words[a2];
          return this.length = Math.max(this.length, a2), r3 !== this && (this.negative = 1), this.strip();
        }, a.prototype.sub = function(t2) {
          return this.clone().isub(t2);
        };
        var p = function(t2, e3, r3) {
          var n2, i2, o2, a2 = t2.words, s2 = e3.words, u2 = r3.words, c2 = 0, f2 = 0 | a2[0], l2 = 8191 & f2, h2 = f2 >>> 13, d2 = 0 | a2[1], p2 = 8191 & d2, m2 = d2 >>> 13, y2 = 0 | a2[2], b2 = 8191 & y2, v2 = y2 >>> 13, g2 = 0 | a2[3], w2 = 8191 & g2, _2 = g2 >>> 13, k2 = 0 | a2[4], x2 = 8191 & k2, S2 = k2 >>> 13, O = 0 | a2[5], j = 8191 & O, E = O >>> 13, R = 0 | a2[6], T = 8191 & R, C = R >>> 13, P = 0 | a2[7], M = 8191 & P, A = P >>> 13, I = 0 | a2[8], N = 8191 & I, D = I >>> 13, B = 0 | a2[9], F = 8191 & B, L = B >>> 13, z = 0 | s2[0], U = 8191 & z, H = z >>> 13, V = 0 | s2[1], q = 8191 & V, W = V >>> 13, $ = 0 | s2[2], X = 8191 & $, K = $ >>> 13, Z = 0 | s2[3], Y = 8191 & Z, G = Z >>> 13, J = 0 | s2[4], Q = 8191 & J, tt = J >>> 13, et = 0 | s2[5], rt = 8191 & et, nt = et >>> 13, it = 0 | s2[6], ot = 8191 & it, at = it >>> 13, st = 0 | s2[7], ut = 8191 & st, ct = st >>> 13, ft = 0 | s2[8], lt = 8191 & ft, ht = ft >>> 13, dt = 0 | s2[9], pt = 8191 & dt, mt = dt >>> 13;
          r3.negative = t2.negative ^ e3.negative, r3.length = 19;
          var yt = (c2 + (n2 = Math.imul(l2, U)) | 0) + ((8191 & (i2 = (i2 = Math.imul(l2, H)) + Math.imul(h2, U) | 0)) << 13) | 0;
          c2 = ((o2 = Math.imul(h2, H)) + (i2 >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, n2 = Math.imul(p2, U), i2 = (i2 = Math.imul(p2, H)) + Math.imul(m2, U) | 0, o2 = Math.imul(m2, H);
          var bt = (c2 + (n2 = n2 + Math.imul(l2, q) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(l2, W) | 0) + Math.imul(h2, q) | 0)) << 13) | 0;
          c2 = ((o2 = o2 + Math.imul(h2, W) | 0) + (i2 >>> 13) | 0) + (bt >>> 26) | 0, bt &= 67108863, n2 = Math.imul(b2, U), i2 = (i2 = Math.imul(b2, H)) + Math.imul(v2, U) | 0, o2 = Math.imul(v2, H), n2 = n2 + Math.imul(p2, q) | 0, i2 = (i2 = i2 + Math.imul(p2, W) | 0) + Math.imul(m2, q) | 0, o2 = o2 + Math.imul(m2, W) | 0;
          var vt = (c2 + (n2 = n2 + Math.imul(l2, X) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(l2, K) | 0) + Math.imul(h2, X) | 0)) << 13) | 0;
          c2 = ((o2 = o2 + Math.imul(h2, K) | 0) + (i2 >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, n2 = Math.imul(w2, U), i2 = (i2 = Math.imul(w2, H)) + Math.imul(_2, U) | 0, o2 = Math.imul(_2, H), n2 = n2 + Math.imul(b2, q) | 0, i2 = (i2 = i2 + Math.imul(b2, W) | 0) + Math.imul(v2, q) | 0, o2 = o2 + Math.imul(v2, W) | 0, n2 = n2 + Math.imul(p2, X) | 0, i2 = (i2 = i2 + Math.imul(p2, K) | 0) + Math.imul(m2, X) | 0, o2 = o2 + Math.imul(m2, K) | 0;
          var gt = (c2 + (n2 = n2 + Math.imul(l2, Y) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(l2, G) | 0) + Math.imul(h2, Y) | 0)) << 13) | 0;
          c2 = ((o2 = o2 + Math.imul(h2, G) | 0) + (i2 >>> 13) | 0) + (gt >>> 26) | 0, gt &= 67108863, n2 = Math.imul(x2, U), i2 = (i2 = Math.imul(x2, H)) + Math.imul(S2, U) | 0, o2 = Math.imul(S2, H), n2 = n2 + Math.imul(w2, q) | 0, i2 = (i2 = i2 + Math.imul(w2, W) | 0) + Math.imul(_2, q) | 0, o2 = o2 + Math.imul(_2, W) | 0, n2 = n2 + Math.imul(b2, X) | 0, i2 = (i2 = i2 + Math.imul(b2, K) | 0) + Math.imul(v2, X) | 0, o2 = o2 + Math.imul(v2, K) | 0, n2 = n2 + Math.imul(p2, Y) | 0, i2 = (i2 = i2 + Math.imul(p2, G) | 0) + Math.imul(m2, Y) | 0, o2 = o2 + Math.imul(m2, G) | 0;
          var wt = (c2 + (n2 = n2 + Math.imul(l2, Q) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(l2, tt) | 0) + Math.imul(h2, Q) | 0)) << 13) | 0;
          c2 = ((o2 = o2 + Math.imul(h2, tt) | 0) + (i2 >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, n2 = Math.imul(j, U), i2 = (i2 = Math.imul(j, H)) + Math.imul(E, U) | 0, o2 = Math.imul(E, H), n2 = n2 + Math.imul(x2, q) | 0, i2 = (i2 = i2 + Math.imul(x2, W) | 0) + Math.imul(S2, q) | 0, o2 = o2 + Math.imul(S2, W) | 0, n2 = n2 + Math.imul(w2, X) | 0, i2 = (i2 = i2 + Math.imul(w2, K) | 0) + Math.imul(_2, X) | 0, o2 = o2 + Math.imul(_2, K) | 0, n2 = n2 + Math.imul(b2, Y) | 0, i2 = (i2 = i2 + Math.imul(b2, G) | 0) + Math.imul(v2, Y) | 0, o2 = o2 + Math.imul(v2, G) | 0, n2 = n2 + Math.imul(p2, Q) | 0, i2 = (i2 = i2 + Math.imul(p2, tt) | 0) + Math.imul(m2, Q) | 0, o2 = o2 + Math.imul(m2, tt) | 0;
          var _t = (c2 + (n2 = n2 + Math.imul(l2, rt) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(l2, nt) | 0) + Math.imul(h2, rt) | 0)) << 13) | 0;
          c2 = ((o2 = o2 + Math.imul(h2, nt) | 0) + (i2 >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, n2 = Math.imul(T, U), i2 = (i2 = Math.imul(T, H)) + Math.imul(C, U) | 0, o2 = Math.imul(C, H), n2 = n2 + Math.imul(j, q) | 0, i2 = (i2 = i2 + Math.imul(j, W) | 0) + Math.imul(E, q) | 0, o2 = o2 + Math.imul(E, W) | 0, n2 = n2 + Math.imul(x2, X) | 0, i2 = (i2 = i2 + Math.imul(x2, K) | 0) + Math.imul(S2, X) | 0, o2 = o2 + Math.imul(S2, K) | 0, n2 = n2 + Math.imul(w2, Y) | 0, i2 = (i2 = i2 + Math.imul(w2, G) | 0) + Math.imul(_2, Y) | 0, o2 = o2 + Math.imul(_2, G) | 0, n2 = n2 + Math.imul(b2, Q) | 0, i2 = (i2 = i2 + Math.imul(b2, tt) | 0) + Math.imul(v2, Q) | 0, o2 = o2 + Math.imul(v2, tt) | 0, n2 = n2 + Math.imul(p2, rt) | 0, i2 = (i2 = i2 + Math.imul(p2, nt) | 0) + Math.imul(m2, rt) | 0, o2 = o2 + Math.imul(m2, nt) | 0;
          var kt = (c2 + (n2 = n2 + Math.imul(l2, ot) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(l2, at) | 0) + Math.imul(h2, ot) | 0)) << 13) | 0;
          c2 = ((o2 = o2 + Math.imul(h2, at) | 0) + (i2 >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, n2 = Math.imul(M, U), i2 = (i2 = Math.imul(M, H)) + Math.imul(A, U) | 0, o2 = Math.imul(A, H), n2 = n2 + Math.imul(T, q) | 0, i2 = (i2 = i2 + Math.imul(T, W) | 0) + Math.imul(C, q) | 0, o2 = o2 + Math.imul(C, W) | 0, n2 = n2 + Math.imul(j, X) | 0, i2 = (i2 = i2 + Math.imul(j, K) | 0) + Math.imul(E, X) | 0, o2 = o2 + Math.imul(E, K) | 0, n2 = n2 + Math.imul(x2, Y) | 0, i2 = (i2 = i2 + Math.imul(x2, G) | 0) + Math.imul(S2, Y) | 0, o2 = o2 + Math.imul(S2, G) | 0, n2 = n2 + Math.imul(w2, Q) | 0, i2 = (i2 = i2 + Math.imul(w2, tt) | 0) + Math.imul(_2, Q) | 0, o2 = o2 + Math.imul(_2, tt) | 0, n2 = n2 + Math.imul(b2, rt) | 0, i2 = (i2 = i2 + Math.imul(b2, nt) | 0) + Math.imul(v2, rt) | 0, o2 = o2 + Math.imul(v2, nt) | 0, n2 = n2 + Math.imul(p2, ot) | 0, i2 = (i2 = i2 + Math.imul(p2, at) | 0) + Math.imul(m2, ot) | 0, o2 = o2 + Math.imul(m2, at) | 0;
          var xt = (c2 + (n2 = n2 + Math.imul(l2, ut) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(l2, ct) | 0) + Math.imul(h2, ut) | 0)) << 13) | 0;
          c2 = ((o2 = o2 + Math.imul(h2, ct) | 0) + (i2 >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, n2 = Math.imul(N, U), i2 = (i2 = Math.imul(N, H)) + Math.imul(D, U) | 0, o2 = Math.imul(D, H), n2 = n2 + Math.imul(M, q) | 0, i2 = (i2 = i2 + Math.imul(M, W) | 0) + Math.imul(A, q) | 0, o2 = o2 + Math.imul(A, W) | 0, n2 = n2 + Math.imul(T, X) | 0, i2 = (i2 = i2 + Math.imul(T, K) | 0) + Math.imul(C, X) | 0, o2 = o2 + Math.imul(C, K) | 0, n2 = n2 + Math.imul(j, Y) | 0, i2 = (i2 = i2 + Math.imul(j, G) | 0) + Math.imul(E, Y) | 0, o2 = o2 + Math.imul(E, G) | 0, n2 = n2 + Math.imul(x2, Q) | 0, i2 = (i2 = i2 + Math.imul(x2, tt) | 0) + Math.imul(S2, Q) | 0, o2 = o2 + Math.imul(S2, tt) | 0, n2 = n2 + Math.imul(w2, rt) | 0, i2 = (i2 = i2 + Math.imul(w2, nt) | 0) + Math.imul(_2, rt) | 0, o2 = o2 + Math.imul(_2, nt) | 0, n2 = n2 + Math.imul(b2, ot) | 0, i2 = (i2 = i2 + Math.imul(b2, at) | 0) + Math.imul(v2, ot) | 0, o2 = o2 + Math.imul(v2, at) | 0, n2 = n2 + Math.imul(p2, ut) | 0, i2 = (i2 = i2 + Math.imul(p2, ct) | 0) + Math.imul(m2, ut) | 0, o2 = o2 + Math.imul(m2, ct) | 0;
          var St = (c2 + (n2 = n2 + Math.imul(l2, lt) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(l2, ht) | 0) + Math.imul(h2, lt) | 0)) << 13) | 0;
          c2 = ((o2 = o2 + Math.imul(h2, ht) | 0) + (i2 >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, n2 = Math.imul(F, U), i2 = (i2 = Math.imul(F, H)) + Math.imul(L, U) | 0, o2 = Math.imul(L, H), n2 = n2 + Math.imul(N, q) | 0, i2 = (i2 = i2 + Math.imul(N, W) | 0) + Math.imul(D, q) | 0, o2 = o2 + Math.imul(D, W) | 0, n2 = n2 + Math.imul(M, X) | 0, i2 = (i2 = i2 + Math.imul(M, K) | 0) + Math.imul(A, X) | 0, o2 = o2 + Math.imul(A, K) | 0, n2 = n2 + Math.imul(T, Y) | 0, i2 = (i2 = i2 + Math.imul(T, G) | 0) + Math.imul(C, Y) | 0, o2 = o2 + Math.imul(C, G) | 0, n2 = n2 + Math.imul(j, Q) | 0, i2 = (i2 = i2 + Math.imul(j, tt) | 0) + Math.imul(E, Q) | 0, o2 = o2 + Math.imul(E, tt) | 0, n2 = n2 + Math.imul(x2, rt) | 0, i2 = (i2 = i2 + Math.imul(x2, nt) | 0) + Math.imul(S2, rt) | 0, o2 = o2 + Math.imul(S2, nt) | 0, n2 = n2 + Math.imul(w2, ot) | 0, i2 = (i2 = i2 + Math.imul(w2, at) | 0) + Math.imul(_2, ot) | 0, o2 = o2 + Math.imul(_2, at) | 0, n2 = n2 + Math.imul(b2, ut) | 0, i2 = (i2 = i2 + Math.imul(b2, ct) | 0) + Math.imul(v2, ut) | 0, o2 = o2 + Math.imul(v2, ct) | 0, n2 = n2 + Math.imul(p2, lt) | 0, i2 = (i2 = i2 + Math.imul(p2, ht) | 0) + Math.imul(m2, lt) | 0, o2 = o2 + Math.imul(m2, ht) | 0;
          var Ot = (c2 + (n2 = n2 + Math.imul(l2, pt) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(l2, mt) | 0) + Math.imul(h2, pt) | 0)) << 13) | 0;
          c2 = ((o2 = o2 + Math.imul(h2, mt) | 0) + (i2 >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, n2 = Math.imul(F, q), i2 = (i2 = Math.imul(F, W)) + Math.imul(L, q) | 0, o2 = Math.imul(L, W), n2 = n2 + Math.imul(N, X) | 0, i2 = (i2 = i2 + Math.imul(N, K) | 0) + Math.imul(D, X) | 0, o2 = o2 + Math.imul(D, K) | 0, n2 = n2 + Math.imul(M, Y) | 0, i2 = (i2 = i2 + Math.imul(M, G) | 0) + Math.imul(A, Y) | 0, o2 = o2 + Math.imul(A, G) | 0, n2 = n2 + Math.imul(T, Q) | 0, i2 = (i2 = i2 + Math.imul(T, tt) | 0) + Math.imul(C, Q) | 0, o2 = o2 + Math.imul(C, tt) | 0, n2 = n2 + Math.imul(j, rt) | 0, i2 = (i2 = i2 + Math.imul(j, nt) | 0) + Math.imul(E, rt) | 0, o2 = o2 + Math.imul(E, nt) | 0, n2 = n2 + Math.imul(x2, ot) | 0, i2 = (i2 = i2 + Math.imul(x2, at) | 0) + Math.imul(S2, ot) | 0, o2 = o2 + Math.imul(S2, at) | 0, n2 = n2 + Math.imul(w2, ut) | 0, i2 = (i2 = i2 + Math.imul(w2, ct) | 0) + Math.imul(_2, ut) | 0, o2 = o2 + Math.imul(_2, ct) | 0, n2 = n2 + Math.imul(b2, lt) | 0, i2 = (i2 = i2 + Math.imul(b2, ht) | 0) + Math.imul(v2, lt) | 0, o2 = o2 + Math.imul(v2, ht) | 0;
          var jt = (c2 + (n2 = n2 + Math.imul(p2, pt) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(p2, mt) | 0) + Math.imul(m2, pt) | 0)) << 13) | 0;
          c2 = ((o2 = o2 + Math.imul(m2, mt) | 0) + (i2 >>> 13) | 0) + (jt >>> 26) | 0, jt &= 67108863, n2 = Math.imul(F, X), i2 = (i2 = Math.imul(F, K)) + Math.imul(L, X) | 0, o2 = Math.imul(L, K), n2 = n2 + Math.imul(N, Y) | 0, i2 = (i2 = i2 + Math.imul(N, G) | 0) + Math.imul(D, Y) | 0, o2 = o2 + Math.imul(D, G) | 0, n2 = n2 + Math.imul(M, Q) | 0, i2 = (i2 = i2 + Math.imul(M, tt) | 0) + Math.imul(A, Q) | 0, o2 = o2 + Math.imul(A, tt) | 0, n2 = n2 + Math.imul(T, rt) | 0, i2 = (i2 = i2 + Math.imul(T, nt) | 0) + Math.imul(C, rt) | 0, o2 = o2 + Math.imul(C, nt) | 0, n2 = n2 + Math.imul(j, ot) | 0, i2 = (i2 = i2 + Math.imul(j, at) | 0) + Math.imul(E, ot) | 0, o2 = o2 + Math.imul(E, at) | 0, n2 = n2 + Math.imul(x2, ut) | 0, i2 = (i2 = i2 + Math.imul(x2, ct) | 0) + Math.imul(S2, ut) | 0, o2 = o2 + Math.imul(S2, ct) | 0, n2 = n2 + Math.imul(w2, lt) | 0, i2 = (i2 = i2 + Math.imul(w2, ht) | 0) + Math.imul(_2, lt) | 0, o2 = o2 + Math.imul(_2, ht) | 0;
          var Et = (c2 + (n2 = n2 + Math.imul(b2, pt) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(b2, mt) | 0) + Math.imul(v2, pt) | 0)) << 13) | 0;
          c2 = ((o2 = o2 + Math.imul(v2, mt) | 0) + (i2 >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, n2 = Math.imul(F, Y), i2 = (i2 = Math.imul(F, G)) + Math.imul(L, Y) | 0, o2 = Math.imul(L, G), n2 = n2 + Math.imul(N, Q) | 0, i2 = (i2 = i2 + Math.imul(N, tt) | 0) + Math.imul(D, Q) | 0, o2 = o2 + Math.imul(D, tt) | 0, n2 = n2 + Math.imul(M, rt) | 0, i2 = (i2 = i2 + Math.imul(M, nt) | 0) + Math.imul(A, rt) | 0, o2 = o2 + Math.imul(A, nt) | 0, n2 = n2 + Math.imul(T, ot) | 0, i2 = (i2 = i2 + Math.imul(T, at) | 0) + Math.imul(C, ot) | 0, o2 = o2 + Math.imul(C, at) | 0, n2 = n2 + Math.imul(j, ut) | 0, i2 = (i2 = i2 + Math.imul(j, ct) | 0) + Math.imul(E, ut) | 0, o2 = o2 + Math.imul(E, ct) | 0, n2 = n2 + Math.imul(x2, lt) | 0, i2 = (i2 = i2 + Math.imul(x2, ht) | 0) + Math.imul(S2, lt) | 0, o2 = o2 + Math.imul(S2, ht) | 0;
          var Rt = (c2 + (n2 = n2 + Math.imul(w2, pt) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(w2, mt) | 0) + Math.imul(_2, pt) | 0)) << 13) | 0;
          c2 = ((o2 = o2 + Math.imul(_2, mt) | 0) + (i2 >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, n2 = Math.imul(F, Q), i2 = (i2 = Math.imul(F, tt)) + Math.imul(L, Q) | 0, o2 = Math.imul(L, tt), n2 = n2 + Math.imul(N, rt) | 0, i2 = (i2 = i2 + Math.imul(N, nt) | 0) + Math.imul(D, rt) | 0, o2 = o2 + Math.imul(D, nt) | 0, n2 = n2 + Math.imul(M, ot) | 0, i2 = (i2 = i2 + Math.imul(M, at) | 0) + Math.imul(A, ot) | 0, o2 = o2 + Math.imul(A, at) | 0, n2 = n2 + Math.imul(T, ut) | 0, i2 = (i2 = i2 + Math.imul(T, ct) | 0) + Math.imul(C, ut) | 0, o2 = o2 + Math.imul(C, ct) | 0, n2 = n2 + Math.imul(j, lt) | 0, i2 = (i2 = i2 + Math.imul(j, ht) | 0) + Math.imul(E, lt) | 0, o2 = o2 + Math.imul(E, ht) | 0;
          var Tt = (c2 + (n2 = n2 + Math.imul(x2, pt) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(x2, mt) | 0) + Math.imul(S2, pt) | 0)) << 13) | 0;
          c2 = ((o2 = o2 + Math.imul(S2, mt) | 0) + (i2 >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, n2 = Math.imul(F, rt), i2 = (i2 = Math.imul(F, nt)) + Math.imul(L, rt) | 0, o2 = Math.imul(L, nt), n2 = n2 + Math.imul(N, ot) | 0, i2 = (i2 = i2 + Math.imul(N, at) | 0) + Math.imul(D, ot) | 0, o2 = o2 + Math.imul(D, at) | 0, n2 = n2 + Math.imul(M, ut) | 0, i2 = (i2 = i2 + Math.imul(M, ct) | 0) + Math.imul(A, ut) | 0, o2 = o2 + Math.imul(A, ct) | 0, n2 = n2 + Math.imul(T, lt) | 0, i2 = (i2 = i2 + Math.imul(T, ht) | 0) + Math.imul(C, lt) | 0, o2 = o2 + Math.imul(C, ht) | 0;
          var Ct = (c2 + (n2 = n2 + Math.imul(j, pt) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(j, mt) | 0) + Math.imul(E, pt) | 0)) << 13) | 0;
          c2 = ((o2 = o2 + Math.imul(E, mt) | 0) + (i2 >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863, n2 = Math.imul(F, ot), i2 = (i2 = Math.imul(F, at)) + Math.imul(L, ot) | 0, o2 = Math.imul(L, at), n2 = n2 + Math.imul(N, ut) | 0, i2 = (i2 = i2 + Math.imul(N, ct) | 0) + Math.imul(D, ut) | 0, o2 = o2 + Math.imul(D, ct) | 0, n2 = n2 + Math.imul(M, lt) | 0, i2 = (i2 = i2 + Math.imul(M, ht) | 0) + Math.imul(A, lt) | 0, o2 = o2 + Math.imul(A, ht) | 0;
          var Pt = (c2 + (n2 = n2 + Math.imul(T, pt) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(T, mt) | 0) + Math.imul(C, pt) | 0)) << 13) | 0;
          c2 = ((o2 = o2 + Math.imul(C, mt) | 0) + (i2 >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, n2 = Math.imul(F, ut), i2 = (i2 = Math.imul(F, ct)) + Math.imul(L, ut) | 0, o2 = Math.imul(L, ct), n2 = n2 + Math.imul(N, lt) | 0, i2 = (i2 = i2 + Math.imul(N, ht) | 0) + Math.imul(D, lt) | 0, o2 = o2 + Math.imul(D, ht) | 0;
          var Mt = (c2 + (n2 = n2 + Math.imul(M, pt) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(M, mt) | 0) + Math.imul(A, pt) | 0)) << 13) | 0;
          c2 = ((o2 = o2 + Math.imul(A, mt) | 0) + (i2 >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, n2 = Math.imul(F, lt), i2 = (i2 = Math.imul(F, ht)) + Math.imul(L, lt) | 0, o2 = Math.imul(L, ht);
          var At = (c2 + (n2 = n2 + Math.imul(N, pt) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(N, mt) | 0) + Math.imul(D, pt) | 0)) << 13) | 0;
          c2 = ((o2 = o2 + Math.imul(D, mt) | 0) + (i2 >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863;
          var It = (c2 + (n2 = Math.imul(F, pt)) | 0) + ((8191 & (i2 = (i2 = Math.imul(F, mt)) + Math.imul(L, pt) | 0)) << 13) | 0;
          return c2 = ((o2 = Math.imul(L, mt)) + (i2 >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, u2[0] = yt, u2[1] = bt, u2[2] = vt, u2[3] = gt, u2[4] = wt, u2[5] = _t, u2[6] = kt, u2[7] = xt, u2[8] = St, u2[9] = Ot, u2[10] = jt, u2[11] = Et, u2[12] = Rt, u2[13] = Tt, u2[14] = Ct, u2[15] = Pt, u2[16] = Mt, u2[17] = At, u2[18] = It, c2 !== 0 && (u2[19] = c2, r3.length++), r3;
        };
        function m(t2, e3, r3) {
          return new y().mulp(t2, e3, r3);
        }
        function y(t2, e3) {
          this.x = t2, this.y = e3;
        }
        Math.imul || (p = d), a.prototype.mulTo = function(t2, e3) {
          var r3 = this.length + t2.length;
          return this.length === 10 && t2.length === 10 ? p(this, t2, e3) : r3 < 63 ? d(this, t2, e3) : r3 < 1024 ? function(t3, e4, r4) {
            r4.negative = e4.negative ^ t3.negative, r4.length = t3.length + e4.length;
            for (var n2 = 0, i2 = 0, o2 = 0; o2 < r4.length - 1; o2++) {
              var a2 = i2;
              i2 = 0;
              for (var s2 = 67108863 & n2, u2 = Math.min(o2, e4.length - 1), c2 = Math.max(0, o2 - t3.length + 1); c2 <= u2; c2++) {
                var f2 = o2 - c2, l2 = (0 | t3.words[f2]) * (0 | e4.words[c2]), h2 = 67108863 & l2;
                s2 = 67108863 & (h2 = h2 + s2 | 0), i2 += (a2 = (a2 = a2 + (l2 / 67108864 | 0) | 0) + (h2 >>> 26) | 0) >>> 26, a2 &= 67108863;
              }
              r4.words[o2] = s2, n2 = a2, a2 = i2;
            }
            return n2 !== 0 ? r4.words[o2] = n2 : r4.length--, r4.strip();
          }(this, t2, e3) : m(this, t2, e3);
        }, y.prototype.makeRBT = function(t2) {
          for (var e3 = new Array(t2), r3 = a.prototype._countBits(t2) - 1, n2 = 0; n2 < t2; n2++)
            e3[n2] = this.revBin(n2, r3, t2);
          return e3;
        }, y.prototype.revBin = function(t2, e3, r3) {
          if (t2 === 0 || t2 === r3 - 1)
            return t2;
          for (var n2 = 0, i2 = 0; i2 < e3; i2++)
            n2 |= (1 & t2) << e3 - i2 - 1, t2 >>= 1;
          return n2;
        }, y.prototype.permute = function(t2, e3, r3, n2, i2, o2) {
          for (var a2 = 0; a2 < o2; a2++)
            n2[a2] = e3[t2[a2]], i2[a2] = r3[t2[a2]];
        }, y.prototype.transform = function(t2, e3, r3, n2, i2, o2) {
          this.permute(o2, t2, e3, r3, n2, i2);
          for (var a2 = 1; a2 < i2; a2 <<= 1)
            for (var s2 = a2 << 1, u2 = Math.cos(2 * Math.PI / s2), c2 = Math.sin(2 * Math.PI / s2), f2 = 0; f2 < i2; f2 += s2)
              for (var l2 = u2, h2 = c2, d2 = 0; d2 < a2; d2++) {
                var p2 = r3[f2 + d2], m2 = n2[f2 + d2], y2 = r3[f2 + d2 + a2], b2 = n2[f2 + d2 + a2], v2 = l2 * y2 - h2 * b2;
                b2 = l2 * b2 + h2 * y2, y2 = v2, r3[f2 + d2] = p2 + y2, n2[f2 + d2] = m2 + b2, r3[f2 + d2 + a2] = p2 - y2, n2[f2 + d2 + a2] = m2 - b2, d2 !== s2 && (v2 = u2 * l2 - c2 * h2, h2 = u2 * h2 + c2 * l2, l2 = v2);
              }
        }, y.prototype.guessLen13b = function(t2, e3) {
          var r3 = 1 | Math.max(e3, t2), n2 = 1 & r3, i2 = 0;
          for (r3 = r3 / 2 | 0; r3; r3 >>>= 1)
            i2++;
          return 1 << i2 + 1 + n2;
        }, y.prototype.conjugate = function(t2, e3, r3) {
          if (!(r3 <= 1))
            for (var n2 = 0; n2 < r3 / 2; n2++) {
              var i2 = t2[n2];
              t2[n2] = t2[r3 - n2 - 1], t2[r3 - n2 - 1] = i2, i2 = e3[n2], e3[n2] = -e3[r3 - n2 - 1], e3[r3 - n2 - 1] = -i2;
            }
        }, y.prototype.normalize13b = function(t2, e3) {
          for (var r3 = 0, n2 = 0; n2 < e3 / 2; n2++) {
            var i2 = 8192 * Math.round(t2[2 * n2 + 1] / e3) + Math.round(t2[2 * n2] / e3) + r3;
            t2[n2] = 67108863 & i2, r3 = i2 < 67108864 ? 0 : i2 / 67108864 | 0;
          }
          return t2;
        }, y.prototype.convert13b = function(t2, e3, r3, n2) {
          for (var o2 = 0, a2 = 0; a2 < e3; a2++)
            o2 += 0 | t2[a2], r3[2 * a2] = 8191 & o2, o2 >>>= 13, r3[2 * a2 + 1] = 8191 & o2, o2 >>>= 13;
          for (a2 = 2 * e3; a2 < n2; ++a2)
            r3[a2] = 0;
          i(o2 === 0), i((-8192 & o2) == 0);
        }, y.prototype.stub = function(t2) {
          for (var e3 = new Array(t2), r3 = 0; r3 < t2; r3++)
            e3[r3] = 0;
          return e3;
        }, y.prototype.mulp = function(t2, e3, r3) {
          var n2 = 2 * this.guessLen13b(t2.length, e3.length), i2 = this.makeRBT(n2), o2 = this.stub(n2), a2 = new Array(n2), s2 = new Array(n2), u2 = new Array(n2), c2 = new Array(n2), f2 = new Array(n2), l2 = new Array(n2), h2 = r3.words;
          h2.length = n2, this.convert13b(t2.words, t2.length, a2, n2), this.convert13b(e3.words, e3.length, c2, n2), this.transform(a2, o2, s2, u2, n2, i2), this.transform(c2, o2, f2, l2, n2, i2);
          for (var d2 = 0; d2 < n2; d2++) {
            var p2 = s2[d2] * f2[d2] - u2[d2] * l2[d2];
            u2[d2] = s2[d2] * l2[d2] + u2[d2] * f2[d2], s2[d2] = p2;
          }
          return this.conjugate(s2, u2, n2), this.transform(s2, u2, h2, o2, n2, i2), this.conjugate(h2, o2, n2), this.normalize13b(h2, n2), r3.negative = t2.negative ^ e3.negative, r3.length = t2.length + e3.length, r3.strip();
        }, a.prototype.mul = function(t2) {
          var e3 = new a(null);
          return e3.words = new Array(this.length + t2.length), this.mulTo(t2, e3);
        }, a.prototype.mulf = function(t2) {
          var e3 = new a(null);
          return e3.words = new Array(this.length + t2.length), m(this, t2, e3);
        }, a.prototype.imul = function(t2) {
          return this.clone().mulTo(t2, this);
        }, a.prototype.imuln = function(t2) {
          i(typeof t2 == "number"), i(t2 < 67108864);
          for (var e3 = 0, r3 = 0; r3 < this.length; r3++) {
            var n2 = (0 | this.words[r3]) * t2, o2 = (67108863 & n2) + (67108863 & e3);
            e3 >>= 26, e3 += n2 / 67108864 | 0, e3 += o2 >>> 26, this.words[r3] = 67108863 & o2;
          }
          return e3 !== 0 && (this.words[r3] = e3, this.length++), this;
        }, a.prototype.muln = function(t2) {
          return this.clone().imuln(t2);
        }, a.prototype.sqr = function() {
          return this.mul(this);
        }, a.prototype.isqr = function() {
          return this.imul(this.clone());
        }, a.prototype.pow = function(t2) {
          var e3 = function(t3) {
            for (var e4 = new Array(t3.bitLength()), r4 = 0; r4 < e4.length; r4++) {
              var n3 = r4 / 26 | 0, i3 = r4 % 26;
              e4[r4] = (t3.words[n3] & 1 << i3) >>> i3;
            }
            return e4;
          }(t2);
          if (e3.length === 0)
            return new a(1);
          for (var r3 = this, n2 = 0; n2 < e3.length && e3[n2] === 0; n2++, r3 = r3.sqr())
            ;
          if (++n2 < e3.length)
            for (var i2 = r3.sqr(); n2 < e3.length; n2++, i2 = i2.sqr())
              e3[n2] !== 0 && (r3 = r3.mul(i2));
          return r3;
        }, a.prototype.iushln = function(t2) {
          i(typeof t2 == "number" && t2 >= 0);
          var e3, r3 = t2 % 26, n2 = (t2 - r3) / 26, o2 = 67108863 >>> 26 - r3 << 26 - r3;
          if (r3 !== 0) {
            var a2 = 0;
            for (e3 = 0; e3 < this.length; e3++) {
              var s2 = this.words[e3] & o2, u2 = (0 | this.words[e3]) - s2 << r3;
              this.words[e3] = u2 | a2, a2 = s2 >>> 26 - r3;
            }
            a2 && (this.words[e3] = a2, this.length++);
          }
          if (n2 !== 0) {
            for (e3 = this.length - 1; e3 >= 0; e3--)
              this.words[e3 + n2] = this.words[e3];
            for (e3 = 0; e3 < n2; e3++)
              this.words[e3] = 0;
            this.length += n2;
          }
          return this.strip();
        }, a.prototype.ishln = function(t2) {
          return i(this.negative === 0), this.iushln(t2);
        }, a.prototype.iushrn = function(t2, e3, r3) {
          var n2;
          i(typeof t2 == "number" && t2 >= 0), n2 = e3 ? (e3 - e3 % 26) / 26 : 0;
          var o2 = t2 % 26, a2 = Math.min((t2 - o2) / 26, this.length), s2 = 67108863 ^ 67108863 >>> o2 << o2, u2 = r3;
          if (n2 -= a2, n2 = Math.max(0, n2), u2) {
            for (var c2 = 0; c2 < a2; c2++)
              u2.words[c2] = this.words[c2];
            u2.length = a2;
          }
          if (a2 === 0)
            ;
          else if (this.length > a2)
            for (this.length -= a2, c2 = 0; c2 < this.length; c2++)
              this.words[c2] = this.words[c2 + a2];
          else
            this.words[0] = 0, this.length = 1;
          var f2 = 0;
          for (c2 = this.length - 1; c2 >= 0 && (f2 !== 0 || c2 >= n2); c2--) {
            var l2 = 0 | this.words[c2];
            this.words[c2] = f2 << 26 - o2 | l2 >>> o2, f2 = l2 & s2;
          }
          return u2 && f2 !== 0 && (u2.words[u2.length++] = f2), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
        }, a.prototype.ishrn = function(t2, e3, r3) {
          return i(this.negative === 0), this.iushrn(t2, e3, r3);
        }, a.prototype.shln = function(t2) {
          return this.clone().ishln(t2);
        }, a.prototype.ushln = function(t2) {
          return this.clone().iushln(t2);
        }, a.prototype.shrn = function(t2) {
          return this.clone().ishrn(t2);
        }, a.prototype.ushrn = function(t2) {
          return this.clone().iushrn(t2);
        }, a.prototype.testn = function(t2) {
          i(typeof t2 == "number" && t2 >= 0);
          var e3 = t2 % 26, r3 = (t2 - e3) / 26, n2 = 1 << e3;
          return !(this.length <= r3) && !!(this.words[r3] & n2);
        }, a.prototype.imaskn = function(t2) {
          i(typeof t2 == "number" && t2 >= 0);
          var e3 = t2 % 26, r3 = (t2 - e3) / 26;
          if (i(this.negative === 0, "imaskn works only with positive numbers"), this.length <= r3)
            return this;
          if (e3 !== 0 && r3++, this.length = Math.min(r3, this.length), e3 !== 0) {
            var n2 = 67108863 ^ 67108863 >>> e3 << e3;
            this.words[this.length - 1] &= n2;
          }
          return this.strip();
        }, a.prototype.maskn = function(t2) {
          return this.clone().imaskn(t2);
        }, a.prototype.iaddn = function(t2) {
          return i(typeof t2 == "number"), i(t2 < 67108864), t2 < 0 ? this.isubn(-t2) : this.negative !== 0 ? this.length === 1 && (0 | this.words[0]) < t2 ? (this.words[0] = t2 - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(t2), this.negative = 1, this) : this._iaddn(t2);
        }, a.prototype._iaddn = function(t2) {
          this.words[0] += t2;
          for (var e3 = 0; e3 < this.length && this.words[e3] >= 67108864; e3++)
            this.words[e3] -= 67108864, e3 === this.length - 1 ? this.words[e3 + 1] = 1 : this.words[e3 + 1]++;
          return this.length = Math.max(this.length, e3 + 1), this;
        }, a.prototype.isubn = function(t2) {
          if (i(typeof t2 == "number"), i(t2 < 67108864), t2 < 0)
            return this.iaddn(-t2);
          if (this.negative !== 0)
            return this.negative = 0, this.iaddn(t2), this.negative = 1, this;
          if (this.words[0] -= t2, this.length === 1 && this.words[0] < 0)
            this.words[0] = -this.words[0], this.negative = 1;
          else
            for (var e3 = 0; e3 < this.length && this.words[e3] < 0; e3++)
              this.words[e3] += 67108864, this.words[e3 + 1] -= 1;
          return this.strip();
        }, a.prototype.addn = function(t2) {
          return this.clone().iaddn(t2);
        }, a.prototype.subn = function(t2) {
          return this.clone().isubn(t2);
        }, a.prototype.iabs = function() {
          return this.negative = 0, this;
        }, a.prototype.abs = function() {
          return this.clone().iabs();
        }, a.prototype._ishlnsubmul = function(t2, e3, r3) {
          var n2, o2, a2 = t2.length + r3;
          this._expand(a2);
          var s2 = 0;
          for (n2 = 0; n2 < t2.length; n2++) {
            o2 = (0 | this.words[n2 + r3]) + s2;
            var u2 = (0 | t2.words[n2]) * e3;
            s2 = ((o2 -= 67108863 & u2) >> 26) - (u2 / 67108864 | 0), this.words[n2 + r3] = 67108863 & o2;
          }
          for (; n2 < this.length - r3; n2++)
            s2 = (o2 = (0 | this.words[n2 + r3]) + s2) >> 26, this.words[n2 + r3] = 67108863 & o2;
          if (s2 === 0)
            return this.strip();
          for (i(s2 === -1), s2 = 0, n2 = 0; n2 < this.length; n2++)
            s2 = (o2 = -(0 | this.words[n2]) + s2) >> 26, this.words[n2] = 67108863 & o2;
          return this.negative = 1, this.strip();
        }, a.prototype._wordDiv = function(t2, e3) {
          var r3 = (this.length, t2.length), n2 = this.clone(), i2 = t2, o2 = 0 | i2.words[i2.length - 1];
          (r3 = 26 - this._countBits(o2)) !== 0 && (i2 = i2.ushln(r3), n2.iushln(r3), o2 = 0 | i2.words[i2.length - 1]);
          var s2, u2 = n2.length - i2.length;
          if (e3 !== "mod") {
            (s2 = new a(null)).length = u2 + 1, s2.words = new Array(s2.length);
            for (var c2 = 0; c2 < s2.length; c2++)
              s2.words[c2] = 0;
          }
          var f2 = n2.clone()._ishlnsubmul(i2, 1, u2);
          f2.negative === 0 && (n2 = f2, s2 && (s2.words[u2] = 1));
          for (var l2 = u2 - 1; l2 >= 0; l2--) {
            var h2 = 67108864 * (0 | n2.words[i2.length + l2]) + (0 | n2.words[i2.length + l2 - 1]);
            for (h2 = Math.min(h2 / o2 | 0, 67108863), n2._ishlnsubmul(i2, h2, l2); n2.negative !== 0; )
              h2--, n2.negative = 0, n2._ishlnsubmul(i2, 1, l2), n2.isZero() || (n2.negative ^= 1);
            s2 && (s2.words[l2] = h2);
          }
          return s2 && s2.strip(), n2.strip(), e3 !== "div" && r3 !== 0 && n2.iushrn(r3), { div: s2 || null, mod: n2 };
        }, a.prototype.divmod = function(t2, e3, r3) {
          return i(!t2.isZero()), this.isZero() ? { div: new a(0), mod: new a(0) } : this.negative !== 0 && t2.negative === 0 ? (s2 = this.neg().divmod(t2, e3), e3 !== "mod" && (n2 = s2.div.neg()), e3 !== "div" && (o2 = s2.mod.neg(), r3 && o2.negative !== 0 && o2.iadd(t2)), { div: n2, mod: o2 }) : this.negative === 0 && t2.negative !== 0 ? (s2 = this.divmod(t2.neg(), e3), e3 !== "mod" && (n2 = s2.div.neg()), { div: n2, mod: s2.mod }) : (this.negative & t2.negative) != 0 ? (s2 = this.neg().divmod(t2.neg(), e3), e3 !== "div" && (o2 = s2.mod.neg(), r3 && o2.negative !== 0 && o2.isub(t2)), { div: s2.div, mod: o2 }) : t2.length > this.length || this.cmp(t2) < 0 ? { div: new a(0), mod: this } : t2.length === 1 ? e3 === "div" ? { div: this.divn(t2.words[0]), mod: null } : e3 === "mod" ? { div: null, mod: new a(this.modn(t2.words[0])) } : { div: this.divn(t2.words[0]), mod: new a(this.modn(t2.words[0])) } : this._wordDiv(t2, e3);
          var n2, o2, s2;
        }, a.prototype.div = function(t2) {
          return this.divmod(t2, "div", false).div;
        }, a.prototype.mod = function(t2) {
          return this.divmod(t2, "mod", false).mod;
        }, a.prototype.umod = function(t2) {
          return this.divmod(t2, "mod", true).mod;
        }, a.prototype.divRound = function(t2) {
          var e3 = this.divmod(t2);
          if (e3.mod.isZero())
            return e3.div;
          var r3 = e3.div.negative !== 0 ? e3.mod.isub(t2) : e3.mod, n2 = t2.ushrn(1), i2 = t2.andln(1), o2 = r3.cmp(n2);
          return o2 < 0 || i2 === 1 && o2 === 0 ? e3.div : e3.div.negative !== 0 ? e3.div.isubn(1) : e3.div.iaddn(1);
        }, a.prototype.modn = function(t2) {
          i(t2 <= 67108863);
          for (var e3 = (1 << 26) % t2, r3 = 0, n2 = this.length - 1; n2 >= 0; n2--)
            r3 = (e3 * r3 + (0 | this.words[n2])) % t2;
          return r3;
        }, a.prototype.idivn = function(t2) {
          i(t2 <= 67108863);
          for (var e3 = 0, r3 = this.length - 1; r3 >= 0; r3--) {
            var n2 = (0 | this.words[r3]) + 67108864 * e3;
            this.words[r3] = n2 / t2 | 0, e3 = n2 % t2;
          }
          return this.strip();
        }, a.prototype.divn = function(t2) {
          return this.clone().idivn(t2);
        }, a.prototype.egcd = function(t2) {
          i(t2.negative === 0), i(!t2.isZero());
          var e3 = this, r3 = t2.clone();
          e3 = e3.negative !== 0 ? e3.umod(t2) : e3.clone();
          for (var n2 = new a(1), o2 = new a(0), s2 = new a(0), u2 = new a(1), c2 = 0; e3.isEven() && r3.isEven(); )
            e3.iushrn(1), r3.iushrn(1), ++c2;
          for (var f2 = r3.clone(), l2 = e3.clone(); !e3.isZero(); ) {
            for (var h2 = 0, d2 = 1; (e3.words[0] & d2) == 0 && h2 < 26; ++h2, d2 <<= 1)
              ;
            if (h2 > 0)
              for (e3.iushrn(h2); h2-- > 0; )
                (n2.isOdd() || o2.isOdd()) && (n2.iadd(f2), o2.isub(l2)), n2.iushrn(1), o2.iushrn(1);
            for (var p2 = 0, m2 = 1; (r3.words[0] & m2) == 0 && p2 < 26; ++p2, m2 <<= 1)
              ;
            if (p2 > 0)
              for (r3.iushrn(p2); p2-- > 0; )
                (s2.isOdd() || u2.isOdd()) && (s2.iadd(f2), u2.isub(l2)), s2.iushrn(1), u2.iushrn(1);
            e3.cmp(r3) >= 0 ? (e3.isub(r3), n2.isub(s2), o2.isub(u2)) : (r3.isub(e3), s2.isub(n2), u2.isub(o2));
          }
          return { a: s2, b: u2, gcd: r3.iushln(c2) };
        }, a.prototype._invmp = function(t2) {
          i(t2.negative === 0), i(!t2.isZero());
          var e3 = this, r3 = t2.clone();
          e3 = e3.negative !== 0 ? e3.umod(t2) : e3.clone();
          for (var n2, o2 = new a(1), s2 = new a(0), u2 = r3.clone(); e3.cmpn(1) > 0 && r3.cmpn(1) > 0; ) {
            for (var c2 = 0, f2 = 1; (e3.words[0] & f2) == 0 && c2 < 26; ++c2, f2 <<= 1)
              ;
            if (c2 > 0)
              for (e3.iushrn(c2); c2-- > 0; )
                o2.isOdd() && o2.iadd(u2), o2.iushrn(1);
            for (var l2 = 0, h2 = 1; (r3.words[0] & h2) == 0 && l2 < 26; ++l2, h2 <<= 1)
              ;
            if (l2 > 0)
              for (r3.iushrn(l2); l2-- > 0; )
                s2.isOdd() && s2.iadd(u2), s2.iushrn(1);
            e3.cmp(r3) >= 0 ? (e3.isub(r3), o2.isub(s2)) : (r3.isub(e3), s2.isub(o2));
          }
          return (n2 = e3.cmpn(1) === 0 ? o2 : s2).cmpn(0) < 0 && n2.iadd(t2), n2;
        }, a.prototype.gcd = function(t2) {
          if (this.isZero())
            return t2.abs();
          if (t2.isZero())
            return this.abs();
          var e3 = this.clone(), r3 = t2.clone();
          e3.negative = 0, r3.negative = 0;
          for (var n2 = 0; e3.isEven() && r3.isEven(); n2++)
            e3.iushrn(1), r3.iushrn(1);
          for (; ; ) {
            for (; e3.isEven(); )
              e3.iushrn(1);
            for (; r3.isEven(); )
              r3.iushrn(1);
            var i2 = e3.cmp(r3);
            if (i2 < 0) {
              var o2 = e3;
              e3 = r3, r3 = o2;
            } else if (i2 === 0 || r3.cmpn(1) === 0)
              break;
            e3.isub(r3);
          }
          return r3.iushln(n2);
        }, a.prototype.invm = function(t2) {
          return this.egcd(t2).a.umod(t2);
        }, a.prototype.isEven = function() {
          return (1 & this.words[0]) == 0;
        }, a.prototype.isOdd = function() {
          return (1 & this.words[0]) == 1;
        }, a.prototype.andln = function(t2) {
          return this.words[0] & t2;
        }, a.prototype.bincn = function(t2) {
          i(typeof t2 == "number");
          var e3 = t2 % 26, r3 = (t2 - e3) / 26, n2 = 1 << e3;
          if (this.length <= r3)
            return this._expand(r3 + 1), this.words[r3] |= n2, this;
          for (var o2 = n2, a2 = r3; o2 !== 0 && a2 < this.length; a2++) {
            var s2 = 0 | this.words[a2];
            o2 = (s2 += o2) >>> 26, s2 &= 67108863, this.words[a2] = s2;
          }
          return o2 !== 0 && (this.words[a2] = o2, this.length++), this;
        }, a.prototype.isZero = function() {
          return this.length === 1 && this.words[0] === 0;
        }, a.prototype.cmpn = function(t2) {
          var e3, r3 = t2 < 0;
          if (this.negative !== 0 && !r3)
            return -1;
          if (this.negative === 0 && r3)
            return 1;
          if (this.strip(), this.length > 1)
            e3 = 1;
          else {
            r3 && (t2 = -t2), i(t2 <= 67108863, "Number is too big");
            var n2 = 0 | this.words[0];
            e3 = n2 === t2 ? 0 : n2 < t2 ? -1 : 1;
          }
          return this.negative !== 0 ? 0 | -e3 : e3;
        }, a.prototype.cmp = function(t2) {
          if (this.negative !== 0 && t2.negative === 0)
            return -1;
          if (this.negative === 0 && t2.negative !== 0)
            return 1;
          var e3 = this.ucmp(t2);
          return this.negative !== 0 ? 0 | -e3 : e3;
        }, a.prototype.ucmp = function(t2) {
          if (this.length > t2.length)
            return 1;
          if (this.length < t2.length)
            return -1;
          for (var e3 = 0, r3 = this.length - 1; r3 >= 0; r3--) {
            var n2 = 0 | this.words[r3], i2 = 0 | t2.words[r3];
            if (n2 !== i2) {
              n2 < i2 ? e3 = -1 : n2 > i2 && (e3 = 1);
              break;
            }
          }
          return e3;
        }, a.prototype.gtn = function(t2) {
          return this.cmpn(t2) === 1;
        }, a.prototype.gt = function(t2) {
          return this.cmp(t2) === 1;
        }, a.prototype.gten = function(t2) {
          return this.cmpn(t2) >= 0;
        }, a.prototype.gte = function(t2) {
          return this.cmp(t2) >= 0;
        }, a.prototype.ltn = function(t2) {
          return this.cmpn(t2) === -1;
        }, a.prototype.lt = function(t2) {
          return this.cmp(t2) === -1;
        }, a.prototype.lten = function(t2) {
          return this.cmpn(t2) <= 0;
        }, a.prototype.lte = function(t2) {
          return this.cmp(t2) <= 0;
        }, a.prototype.eqn = function(t2) {
          return this.cmpn(t2) === 0;
        }, a.prototype.eq = function(t2) {
          return this.cmp(t2) === 0;
        }, a.red = function(t2) {
          return new x(t2);
        }, a.prototype.toRed = function(t2) {
          return i(!this.red, "Already a number in reduction context"), i(this.negative === 0, "red works only with positives"), t2.convertTo(this)._forceRed(t2);
        }, a.prototype.fromRed = function() {
          return i(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
        }, a.prototype._forceRed = function(t2) {
          return this.red = t2, this;
        }, a.prototype.forceRed = function(t2) {
          return i(!this.red, "Already a number in reduction context"), this._forceRed(t2);
        }, a.prototype.redAdd = function(t2) {
          return i(this.red, "redAdd works only with red numbers"), this.red.add(this, t2);
        }, a.prototype.redIAdd = function(t2) {
          return i(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, t2);
        }, a.prototype.redSub = function(t2) {
          return i(this.red, "redSub works only with red numbers"), this.red.sub(this, t2);
        }, a.prototype.redISub = function(t2) {
          return i(this.red, "redISub works only with red numbers"), this.red.isub(this, t2);
        }, a.prototype.redShl = function(t2) {
          return i(this.red, "redShl works only with red numbers"), this.red.shl(this, t2);
        }, a.prototype.redMul = function(t2) {
          return i(this.red, "redMul works only with red numbers"), this.red._verify2(this, t2), this.red.mul(this, t2);
        }, a.prototype.redIMul = function(t2) {
          return i(this.red, "redMul works only with red numbers"), this.red._verify2(this, t2), this.red.imul(this, t2);
        }, a.prototype.redSqr = function() {
          return i(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
        }, a.prototype.redISqr = function() {
          return i(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
        }, a.prototype.redSqrt = function() {
          return i(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
        }, a.prototype.redInvm = function() {
          return i(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
        }, a.prototype.redNeg = function() {
          return i(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
        }, a.prototype.redPow = function(t2) {
          return i(this.red && !t2.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, t2);
        };
        var b = { k256: null, p224: null, p192: null, p25519: null };
        function v(t2, e3) {
          this.name = t2, this.p = new a(e3, 16), this.n = this.p.bitLength(), this.k = new a(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
        }
        function g() {
          v.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
        }
        function w() {
          v.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
        }
        function _() {
          v.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
        }
        function k() {
          v.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
        }
        function x(t2) {
          if (typeof t2 == "string") {
            var e3 = a._prime(t2);
            this.m = e3.p, this.prime = e3;
          } else
            i(t2.gtn(1), "modulus must be greater than 1"), this.m = t2, this.prime = null;
        }
        function S(t2) {
          x.call(this, t2), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new a(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
        }
        v.prototype._tmp = function() {
          var t2 = new a(null);
          return t2.words = new Array(Math.ceil(this.n / 13)), t2;
        }, v.prototype.ireduce = function(t2) {
          var e3, r3 = t2;
          do {
            this.split(r3, this.tmp), e3 = (r3 = (r3 = this.imulK(r3)).iadd(this.tmp)).bitLength();
          } while (e3 > this.n);
          var n2 = e3 < this.n ? -1 : r3.ucmp(this.p);
          return n2 === 0 ? (r3.words[0] = 0, r3.length = 1) : n2 > 0 ? r3.isub(this.p) : r3.strip !== void 0 ? r3.strip() : r3._strip(), r3;
        }, v.prototype.split = function(t2, e3) {
          t2.iushrn(this.n, 0, e3);
        }, v.prototype.imulK = function(t2) {
          return t2.imul(this.k);
        }, o(g, v), g.prototype.split = function(t2, e3) {
          for (var r3 = Math.min(t2.length, 9), n2 = 0; n2 < r3; n2++)
            e3.words[n2] = t2.words[n2];
          if (e3.length = r3, t2.length <= 9)
            return t2.words[0] = 0, void (t2.length = 1);
          var i2 = t2.words[9];
          for (e3.words[e3.length++] = 4194303 & i2, n2 = 10; n2 < t2.length; n2++) {
            var o2 = 0 | t2.words[n2];
            t2.words[n2 - 10] = (4194303 & o2) << 4 | i2 >>> 22, i2 = o2;
          }
          i2 >>>= 22, t2.words[n2 - 10] = i2, i2 === 0 && t2.length > 10 ? t2.length -= 10 : t2.length -= 9;
        }, g.prototype.imulK = function(t2) {
          t2.words[t2.length] = 0, t2.words[t2.length + 1] = 0, t2.length += 2;
          for (var e3 = 0, r3 = 0; r3 < t2.length; r3++) {
            var n2 = 0 | t2.words[r3];
            e3 += 977 * n2, t2.words[r3] = 67108863 & e3, e3 = 64 * n2 + (e3 / 67108864 | 0);
          }
          return t2.words[t2.length - 1] === 0 && (t2.length--, t2.words[t2.length - 1] === 0 && t2.length--), t2;
        }, o(w, v), o(_, v), o(k, v), k.prototype.imulK = function(t2) {
          for (var e3 = 0, r3 = 0; r3 < t2.length; r3++) {
            var n2 = 19 * (0 | t2.words[r3]) + e3, i2 = 67108863 & n2;
            n2 >>>= 26, t2.words[r3] = i2, e3 = n2;
          }
          return e3 !== 0 && (t2.words[t2.length++] = e3), t2;
        }, a._prime = function(t2) {
          if (b[t2])
            return b[t2];
          var e3;
          if (t2 === "k256")
            e3 = new g();
          else if (t2 === "p224")
            e3 = new w();
          else if (t2 === "p192")
            e3 = new _();
          else {
            if (t2 !== "p25519")
              throw new Error("Unknown prime " + t2);
            e3 = new k();
          }
          return b[t2] = e3, e3;
        }, x.prototype._verify1 = function(t2) {
          i(t2.negative === 0, "red works only with positives"), i(t2.red, "red works only with red numbers");
        }, x.prototype._verify2 = function(t2, e3) {
          i((t2.negative | e3.negative) == 0, "red works only with positives"), i(t2.red && t2.red === e3.red, "red works only with red numbers");
        }, x.prototype.imod = function(t2) {
          return this.prime ? this.prime.ireduce(t2)._forceRed(this) : t2.umod(this.m)._forceRed(this);
        }, x.prototype.neg = function(t2) {
          return t2.isZero() ? t2.clone() : this.m.sub(t2)._forceRed(this);
        }, x.prototype.add = function(t2, e3) {
          this._verify2(t2, e3);
          var r3 = t2.add(e3);
          return r3.cmp(this.m) >= 0 && r3.isub(this.m), r3._forceRed(this);
        }, x.prototype.iadd = function(t2, e3) {
          this._verify2(t2, e3);
          var r3 = t2.iadd(e3);
          return r3.cmp(this.m) >= 0 && r3.isub(this.m), r3;
        }, x.prototype.sub = function(t2, e3) {
          this._verify2(t2, e3);
          var r3 = t2.sub(e3);
          return r3.cmpn(0) < 0 && r3.iadd(this.m), r3._forceRed(this);
        }, x.prototype.isub = function(t2, e3) {
          this._verify2(t2, e3);
          var r3 = t2.isub(e3);
          return r3.cmpn(0) < 0 && r3.iadd(this.m), r3;
        }, x.prototype.shl = function(t2, e3) {
          return this._verify1(t2), this.imod(t2.ushln(e3));
        }, x.prototype.imul = function(t2, e3) {
          return this._verify2(t2, e3), this.imod(t2.imul(e3));
        }, x.prototype.mul = function(t2, e3) {
          return this._verify2(t2, e3), this.imod(t2.mul(e3));
        }, x.prototype.isqr = function(t2) {
          return this.imul(t2, t2.clone());
        }, x.prototype.sqr = function(t2) {
          return this.mul(t2, t2);
        }, x.prototype.sqrt = function(t2) {
          if (t2.isZero())
            return t2.clone();
          var e3 = this.m.andln(3);
          if (i(e3 % 2 == 1), e3 === 3) {
            var r3 = this.m.add(new a(1)).iushrn(2);
            return this.pow(t2, r3);
          }
          for (var n2 = this.m.subn(1), o2 = 0; !n2.isZero() && n2.andln(1) === 0; )
            o2++, n2.iushrn(1);
          i(!n2.isZero());
          var s2 = new a(1).toRed(this), u2 = s2.redNeg(), c2 = this.m.subn(1).iushrn(1), f2 = this.m.bitLength();
          for (f2 = new a(2 * f2 * f2).toRed(this); this.pow(f2, c2).cmp(u2) !== 0; )
            f2.redIAdd(u2);
          for (var l2 = this.pow(f2, n2), h2 = this.pow(t2, n2.addn(1).iushrn(1)), d2 = this.pow(t2, n2), p2 = o2; d2.cmp(s2) !== 0; ) {
            for (var m2 = d2, y2 = 0; m2.cmp(s2) !== 0; y2++)
              m2 = m2.redSqr();
            i(y2 < p2);
            var b2 = this.pow(l2, new a(1).iushln(p2 - y2 - 1));
            h2 = h2.redMul(b2), l2 = b2.redSqr(), d2 = d2.redMul(l2), p2 = y2;
          }
          return h2;
        }, x.prototype.invm = function(t2) {
          var e3 = t2._invmp(this.m);
          return e3.negative !== 0 ? (e3.negative = 0, this.imod(e3).redNeg()) : this.imod(e3);
        }, x.prototype.pow = function(t2, e3) {
          if (e3.isZero())
            return new a(1).toRed(this);
          if (e3.cmpn(1) === 0)
            return t2.clone();
          var r3 = new Array(16);
          r3[0] = new a(1).toRed(this), r3[1] = t2;
          for (var n2 = 2; n2 < r3.length; n2++)
            r3[n2] = this.mul(r3[n2 - 1], t2);
          var i2 = r3[0], o2 = 0, s2 = 0, u2 = e3.bitLength() % 26;
          for (u2 === 0 && (u2 = 26), n2 = e3.length - 1; n2 >= 0; n2--) {
            for (var c2 = e3.words[n2], f2 = u2 - 1; f2 >= 0; f2--) {
              var l2 = c2 >> f2 & 1;
              i2 !== r3[0] && (i2 = this.sqr(i2)), l2 !== 0 || o2 !== 0 ? (o2 <<= 1, o2 |= l2, (++s2 === 4 || n2 === 0 && f2 === 0) && (i2 = this.mul(i2, r3[o2]), s2 = 0, o2 = 0)) : s2 = 0;
            }
            u2 = 26;
          }
          return i2;
        }, x.prototype.convertTo = function(t2) {
          var e3 = t2.umod(this.m);
          return e3 === t2 ? e3.clone() : e3;
        }, x.prototype.convertFrom = function(t2) {
          var e3 = t2.clone();
          return e3.red = null, e3;
        }, a.mont = function(t2) {
          return new S(t2);
        }, o(S, x), S.prototype.convertTo = function(t2) {
          return this.imod(t2.ushln(this.shift));
        }, S.prototype.convertFrom = function(t2) {
          var e3 = this.imod(t2.mul(this.rinv));
          return e3.red = null, e3;
        }, S.prototype.imul = function(t2, e3) {
          if (t2.isZero() || e3.isZero())
            return t2.words[0] = 0, t2.length = 1, t2;
          var r3 = t2.imul(e3), n2 = r3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), i2 = r3.isub(n2).iushrn(this.shift), o2 = i2;
          return i2.cmp(this.m) >= 0 ? o2 = i2.isub(this.m) : i2.cmpn(0) < 0 && (o2 = i2.iadd(this.m)), o2._forceRed(this);
        }, S.prototype.mul = function(t2, e3) {
          if (t2.isZero() || e3.isZero())
            return new a(0)._forceRed(this);
          var r3 = t2.mul(e3), n2 = r3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), i2 = r3.isub(n2).iushrn(this.shift), o2 = i2;
          return i2.cmp(this.m) >= 0 ? o2 = i2.isub(this.m) : i2.cmpn(0) < 0 && (o2 = i2.iadd(this.m)), o2._forceRed(this);
        }, S.prototype.invm = function(t2) {
          return this.imod(t2._invmp(this.m).mul(this.r2))._forceRed(this);
        };
      }(e === void 0 || e);
    }, { buffer: 185 }], 182: [function(t, e, r) {
      r.byteLength = function(t2) {
        var e2 = c(t2), r2 = e2[0], n2 = e2[1];
        return 3 * (r2 + n2) / 4 - n2;
      }, r.toByteArray = function(t2) {
        var e2, r2, n2 = c(t2), a2 = n2[0], s2 = n2[1], u2 = new o(function(t3, e3, r3) {
          return 3 * (e3 + r3) / 4 - r3;
        }(0, a2, s2)), f2 = 0, l = s2 > 0 ? a2 - 4 : a2;
        for (r2 = 0; r2 < l; r2 += 4)
          e2 = i[t2.charCodeAt(r2)] << 18 | i[t2.charCodeAt(r2 + 1)] << 12 | i[t2.charCodeAt(r2 + 2)] << 6 | i[t2.charCodeAt(r2 + 3)], u2[f2++] = e2 >> 16 & 255, u2[f2++] = e2 >> 8 & 255, u2[f2++] = 255 & e2;
        s2 === 2 && (e2 = i[t2.charCodeAt(r2)] << 2 | i[t2.charCodeAt(r2 + 1)] >> 4, u2[f2++] = 255 & e2);
        s2 === 1 && (e2 = i[t2.charCodeAt(r2)] << 10 | i[t2.charCodeAt(r2 + 1)] << 4 | i[t2.charCodeAt(r2 + 2)] >> 2, u2[f2++] = e2 >> 8 & 255, u2[f2++] = 255 & e2);
        return u2;
      }, r.fromByteArray = function(t2) {
        for (var e2, r2 = t2.length, i2 = r2 % 3, o2 = [], a2 = 0, s2 = r2 - i2; a2 < s2; a2 += 16383)
          o2.push(f(t2, a2, a2 + 16383 > s2 ? s2 : a2 + 16383));
        i2 === 1 ? (e2 = t2[r2 - 1], o2.push(n[e2 >> 2] + n[e2 << 4 & 63] + "==")) : i2 === 2 && (e2 = (t2[r2 - 2] << 8) + t2[r2 - 1], o2.push(n[e2 >> 10] + n[e2 >> 4 & 63] + n[e2 << 2 & 63] + "="));
        return o2.join("");
      };
      for (var n = [], i = [], o = typeof Uint8Array != "undefined" ? Uint8Array : Array, a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = 0, u = a.length; s < u; ++s)
        n[s] = a[s], i[a.charCodeAt(s)] = s;
      function c(t2) {
        var e2 = t2.length;
        if (e2 % 4 > 0)
          throw new Error("Invalid string. Length must be a multiple of 4");
        var r2 = t2.indexOf("=");
        return r2 === -1 && (r2 = e2), [r2, r2 === e2 ? 0 : 4 - r2 % 4];
      }
      function f(t2, e2, r2) {
        for (var i2, o2, a2 = [], s2 = e2; s2 < r2; s2 += 3)
          i2 = (t2[s2] << 16 & 16711680) + (t2[s2 + 1] << 8 & 65280) + (255 & t2[s2 + 2]), a2.push(n[(o2 = i2) >> 18 & 63] + n[o2 >> 12 & 63] + n[o2 >> 6 & 63] + n[63 & o2]);
        return a2.join("");
      }
      i["-".charCodeAt(0)] = 62, i["_".charCodeAt(0)] = 63;
    }, {}], 183: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      !function(e2, r2) {
        function i(t2, e3) {
          if (!t2)
            throw new Error(e3 || "Assertion failed");
        }
        function o(t2, e3) {
          t2.super_ = e3;
          var r3 = function() {
          };
          r3.prototype = e3.prototype, t2.prototype = new r3(), t2.prototype.constructor = t2;
        }
        function a(t2, e3, r3) {
          if (a.isBN(t2))
            return t2;
          this.negative = 0, this.words = null, this.length = 0, this.red = null, t2 !== null && (e3 !== "le" && e3 !== "be" || (r3 = e3, e3 = 10), this._init(t2 || 0, e3 || 10, r3 || "be"));
        }
        var s;
        n(e2) === "object" ? e2.exports = a : (void 0).BN = a, a.BN = a, a.wordSize = 26;
        try {
          s = t("buffer").Buffer;
        } catch (t2) {
        }
        function u(t2, e3, r3) {
          for (var n2 = 0, o2 = Math.min(t2.length, r3), a2 = 0, s2 = e3; s2 < o2; s2++) {
            var u2, c2 = t2.charCodeAt(s2) - 48;
            n2 <<= 4, n2 |= u2 = c2 >= 49 && c2 <= 54 ? c2 - 49 + 10 : c2 >= 17 && c2 <= 22 ? c2 - 17 + 10 : c2, a2 |= u2;
          }
          return i(!(240 & a2), "Invalid character in " + t2), n2;
        }
        function c(t2, e3, r3, n2) {
          for (var o2 = 0, a2 = 0, s2 = Math.min(t2.length, r3), u2 = e3; u2 < s2; u2++) {
            var c2 = t2.charCodeAt(u2) - 48;
            o2 *= n2, a2 = c2 >= 49 ? c2 - 49 + 10 : c2 >= 17 ? c2 - 17 + 10 : c2, i(c2 >= 0 && a2 < n2, "Invalid character"), o2 += a2;
          }
          return o2;
        }
        function f(t2, e3) {
          t2.words = e3.words, t2.length = e3.length, t2.negative = e3.negative, t2.red = e3.red;
        }
        if (a.isBN = function(t2) {
          return t2 instanceof a || t2 !== null && n(t2) === "object" && t2.constructor.wordSize === a.wordSize && Array.isArray(t2.words);
        }, a.max = function(t2, e3) {
          return t2.cmp(e3) > 0 ? t2 : e3;
        }, a.min = function(t2, e3) {
          return t2.cmp(e3) < 0 ? t2 : e3;
        }, a.prototype._init = function(t2, e3, r3) {
          if (typeof t2 == "number")
            return this._initNumber(t2, e3, r3);
          if (n(t2) === "object")
            return this._initArray(t2, e3, r3);
          e3 === "hex" && (e3 = 16), i(e3 === (0 | e3) && e3 >= 2 && e3 <= 36);
          var o2 = 0;
          (t2 = t2.toString().replace(/\s+/g, ""))[0] === "-" && o2++, e3 === 16 ? this._parseHex(t2, o2) : this._parseBase(t2, e3, o2), t2[0] === "-" && (this.negative = 1), this._strip(), r3 === "le" && this._initArray(this.toArray(), e3, r3);
        }, a.prototype._initNumber = function(t2, e3, r3) {
          t2 < 0 && (this.negative = 1, t2 = -t2), t2 < 67108864 ? (this.words = [67108863 & t2], this.length = 1) : t2 < 4503599627370496 ? (this.words = [67108863 & t2, t2 / 67108864 & 67108863], this.length = 2) : (i(t2 < 9007199254740992), this.words = [67108863 & t2, t2 / 67108864 & 67108863, 1], this.length = 3), r3 === "le" && this._initArray(this.toArray(), e3, r3);
        }, a.prototype._initArray = function(t2, e3, r3) {
          if (i(typeof t2.length == "number"), t2.length <= 0)
            return this.words = [0], this.length = 1, this;
          this.length = Math.ceil(t2.length / 3), this.words = new Array(this.length);
          for (var n2 = 0; n2 < this.length; n2++)
            this.words[n2] = 0;
          var o2, a2, s2 = 0;
          if (r3 === "be")
            for (n2 = t2.length - 1, o2 = 0; n2 >= 0; n2 -= 3)
              a2 = t2[n2] | t2[n2 - 1] << 8 | t2[n2 - 2] << 16, this.words[o2] |= a2 << s2 & 67108863, this.words[o2 + 1] = a2 >>> 26 - s2 & 67108863, (s2 += 24) >= 26 && (s2 -= 26, o2++);
          else if (r3 === "le")
            for (n2 = 0, o2 = 0; n2 < t2.length; n2 += 3)
              a2 = t2[n2] | t2[n2 + 1] << 8 | t2[n2 + 2] << 16, this.words[o2] |= a2 << s2 & 67108863, this.words[o2 + 1] = a2 >>> 26 - s2 & 67108863, (s2 += 24) >= 26 && (s2 -= 26, o2++);
          return this._strip();
        }, a.prototype._parseHex = function(t2, e3) {
          this.length = Math.ceil((t2.length - e3) / 6), this.words = new Array(this.length);
          for (var r3 = 0; r3 < this.length; r3++)
            this.words[r3] = 0;
          var n2, i2, o2 = 0;
          for (r3 = t2.length - 6, n2 = 0; r3 >= e3; r3 -= 6)
            i2 = u(t2, r3, r3 + 6), this.words[n2] |= i2 << o2 & 67108863, this.words[n2 + 1] |= i2 >>> 26 - o2 & 4194303, (o2 += 24) >= 26 && (o2 -= 26, n2++);
          r3 + 6 !== e3 && (i2 = u(t2, e3, r3 + 6), this.words[n2] |= i2 << o2 & 67108863, this.words[n2 + 1] |= i2 >>> 26 - o2 & 4194303), this._strip();
        }, a.prototype._parseBase = function(t2, e3, r3) {
          this.words = [0], this.length = 1;
          for (var n2 = 0, i2 = 1; i2 <= 67108863; i2 *= e3)
            n2++;
          n2--, i2 = i2 / e3 | 0;
          for (var o2 = t2.length - r3, a2 = o2 % n2, s2 = Math.min(o2, o2 - a2) + r3, u2 = 0, f2 = r3; f2 < s2; f2 += n2)
            u2 = c(t2, f2, f2 + n2, e3), this.imuln(i2), this.words[0] + u2 < 67108864 ? this.words[0] += u2 : this._iaddn(u2);
          if (a2 !== 0) {
            var l2 = 1;
            for (u2 = c(t2, f2, t2.length, e3), f2 = 0; f2 < a2; f2++)
              l2 *= e3;
            this.imuln(l2), this.words[0] + u2 < 67108864 ? this.words[0] += u2 : this._iaddn(u2);
          }
        }, a.prototype.copy = function(t2) {
          t2.words = new Array(this.length);
          for (var e3 = 0; e3 < this.length; e3++)
            t2.words[e3] = this.words[e3];
          t2.length = this.length, t2.negative = this.negative, t2.red = this.red;
        }, a.prototype._move = function(t2) {
          f(t2, this);
        }, a.prototype.clone = function() {
          var t2 = new a(null);
          return this.copy(t2), t2;
        }, a.prototype._expand = function(t2) {
          for (; this.length < t2; )
            this.words[this.length++] = 0;
          return this;
        }, a.prototype._strip = function() {
          for (; this.length > 1 && this.words[this.length - 1] === 0; )
            this.length--;
          return this._normSign();
        }, a.prototype._normSign = function() {
          return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
        }, typeof Symbol != "undefined" && typeof Symbol.for == "function")
          try {
            a.prototype[Symbol.for("nodejs.util.inspect.custom")] = l;
          } catch (t2) {
            a.prototype.inspect = l;
          }
        else
          a.prototype.inspect = l;
        function l() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        }
        var h = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], d = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], p = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        a.prototype.toString = function(t2, e3) {
          var r3;
          if (e3 = 0 | e3 || 1, (t2 = t2 || 10) === 16 || t2 === "hex") {
            r3 = "";
            for (var n2 = 0, o2 = 0, a2 = 0; a2 < this.length; a2++) {
              var s2 = this.words[a2], u2 = (16777215 & (s2 << n2 | o2)).toString(16);
              r3 = (o2 = s2 >>> 24 - n2 & 16777215) !== 0 || a2 !== this.length - 1 ? h[6 - u2.length] + u2 + r3 : u2 + r3, (n2 += 2) >= 26 && (n2 -= 26, a2--);
            }
            for (o2 !== 0 && (r3 = o2.toString(16) + r3); r3.length % e3 != 0; )
              r3 = "0" + r3;
            return this.negative !== 0 && (r3 = "-" + r3), r3;
          }
          if (t2 === (0 | t2) && t2 >= 2 && t2 <= 36) {
            var c2 = d[t2], f2 = p[t2];
            r3 = "";
            var l2 = this.clone();
            for (l2.negative = 0; !l2.isZero(); ) {
              var m2 = l2.modrn(f2).toString(t2);
              r3 = (l2 = l2.idivn(f2)).isZero() ? m2 + r3 : h[c2 - m2.length] + m2 + r3;
            }
            for (this.isZero() && (r3 = "0" + r3); r3.length % e3 != 0; )
              r3 = "0" + r3;
            return this.negative !== 0 && (r3 = "-" + r3), r3;
          }
          i(false, "Base should be between 2 and 36");
        }, a.prototype.toNumber = function() {
          var t2 = this.words[0];
          return this.length === 2 ? t2 += 67108864 * this.words[1] : this.length === 3 && this.words[2] === 1 ? t2 += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && i(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -t2 : t2;
        }, a.prototype.toJSON = function() {
          return this.toString(16, 2);
        }, s && (a.prototype.toBuffer = function(t2, e3) {
          return this.toArrayLike(s, t2, e3);
        }), a.prototype.toArray = function(t2, e3) {
          return this.toArrayLike(Array, t2, e3);
        };
        function m(t2, e3, r3) {
          r3.negative = e3.negative ^ t2.negative;
          var n2 = t2.length + e3.length | 0;
          r3.length = n2, n2 = n2 - 1 | 0;
          var i2 = 0 | t2.words[0], o2 = 0 | e3.words[0], a2 = i2 * o2, s2 = 67108863 & a2, u2 = a2 / 67108864 | 0;
          r3.words[0] = s2;
          for (var c2 = 1; c2 < n2; c2++) {
            for (var f2 = u2 >>> 26, l2 = 67108863 & u2, h2 = Math.min(c2, e3.length - 1), d2 = Math.max(0, c2 - t2.length + 1); d2 <= h2; d2++) {
              var p2 = c2 - d2 | 0;
              f2 += (a2 = (i2 = 0 | t2.words[p2]) * (o2 = 0 | e3.words[d2]) + l2) / 67108864 | 0, l2 = 67108863 & a2;
            }
            r3.words[c2] = 0 | l2, u2 = 0 | f2;
          }
          return u2 !== 0 ? r3.words[c2] = 0 | u2 : r3.length--, r3._strip();
        }
        a.prototype.toArrayLike = function(t2, e3, r3) {
          this._strip();
          var n2 = this.byteLength(), o2 = r3 || Math.max(1, n2);
          i(n2 <= o2, "byte array longer than desired length"), i(o2 > 0, "Requested array length <= 0");
          var a2 = function(t3, e4) {
            return t3.allocUnsafe ? t3.allocUnsafe(e4) : new t3(e4);
          }(t2, o2);
          return this["_toArrayLike" + (e3 === "le" ? "LE" : "BE")](a2, n2), a2;
        }, a.prototype._toArrayLikeLE = function(t2, e3) {
          for (var r3 = 0, n2 = 0, i2 = 0, o2 = 0; i2 < this.length; i2++) {
            var a2 = this.words[i2] << o2 | n2;
            t2[r3++] = 255 & a2, r3 < t2.length && (t2[r3++] = a2 >> 8 & 255), r3 < t2.length && (t2[r3++] = a2 >> 16 & 255), o2 === 6 ? (r3 < t2.length && (t2[r3++] = a2 >> 24 & 255), n2 = 0, o2 = 0) : (n2 = a2 >>> 24, o2 += 2);
          }
          if (r3 < t2.length)
            for (t2[r3++] = n2; r3 < t2.length; )
              t2[r3++] = 0;
        }, a.prototype._toArrayLikeBE = function(t2, e3) {
          for (var r3 = t2.length - 1, n2 = 0, i2 = 0, o2 = 0; i2 < this.length; i2++) {
            var a2 = this.words[i2] << o2 | n2;
            t2[r3--] = 255 & a2, r3 >= 0 && (t2[r3--] = a2 >> 8 & 255), r3 >= 0 && (t2[r3--] = a2 >> 16 & 255), o2 === 6 ? (r3 >= 0 && (t2[r3--] = a2 >> 24 & 255), n2 = 0, o2 = 0) : (n2 = a2 >>> 24, o2 += 2);
          }
          if (r3 >= 0)
            for (t2[r3--] = n2; r3 >= 0; )
              t2[r3--] = 0;
        }, Math.clz32 ? a.prototype._countBits = function(t2) {
          return 32 - Math.clz32(t2);
        } : a.prototype._countBits = function(t2) {
          var e3 = t2, r3 = 0;
          return e3 >= 4096 && (r3 += 13, e3 >>>= 13), e3 >= 64 && (r3 += 7, e3 >>>= 7), e3 >= 8 && (r3 += 4, e3 >>>= 4), e3 >= 2 && (r3 += 2, e3 >>>= 2), r3 + e3;
        }, a.prototype._zeroBits = function(t2) {
          if (t2 === 0)
            return 26;
          var e3 = t2, r3 = 0;
          return (8191 & e3) == 0 && (r3 += 13, e3 >>>= 13), (127 & e3) == 0 && (r3 += 7, e3 >>>= 7), (15 & e3) == 0 && (r3 += 4, e3 >>>= 4), (3 & e3) == 0 && (r3 += 2, e3 >>>= 2), (1 & e3) == 0 && r3++, r3;
        }, a.prototype.bitLength = function() {
          var t2 = this.words[this.length - 1], e3 = this._countBits(t2);
          return 26 * (this.length - 1) + e3;
        }, a.prototype.zeroBits = function() {
          if (this.isZero())
            return 0;
          for (var t2 = 0, e3 = 0; e3 < this.length; e3++) {
            var r3 = this._zeroBits(this.words[e3]);
            if (t2 += r3, r3 !== 26)
              break;
          }
          return t2;
        }, a.prototype.byteLength = function() {
          return Math.ceil(this.bitLength() / 8);
        }, a.prototype.toTwos = function(t2) {
          return this.negative !== 0 ? this.abs().inotn(t2).iaddn(1) : this.clone();
        }, a.prototype.fromTwos = function(t2) {
          return this.testn(t2 - 1) ? this.notn(t2).iaddn(1).ineg() : this.clone();
        }, a.prototype.isNeg = function() {
          return this.negative !== 0;
        }, a.prototype.neg = function() {
          return this.clone().ineg();
        }, a.prototype.ineg = function() {
          return this.isZero() || (this.negative ^= 1), this;
        }, a.prototype.iuor = function(t2) {
          for (; this.length < t2.length; )
            this.words[this.length++] = 0;
          for (var e3 = 0; e3 < t2.length; e3++)
            this.words[e3] = this.words[e3] | t2.words[e3];
          return this._strip();
        }, a.prototype.ior = function(t2) {
          return i((this.negative | t2.negative) == 0), this.iuor(t2);
        }, a.prototype.or = function(t2) {
          return this.length > t2.length ? this.clone().ior(t2) : t2.clone().ior(this);
        }, a.prototype.uor = function(t2) {
          return this.length > t2.length ? this.clone().iuor(t2) : t2.clone().iuor(this);
        }, a.prototype.iuand = function(t2) {
          var e3;
          e3 = this.length > t2.length ? t2 : this;
          for (var r3 = 0; r3 < e3.length; r3++)
            this.words[r3] = this.words[r3] & t2.words[r3];
          return this.length = e3.length, this._strip();
        }, a.prototype.iand = function(t2) {
          return i((this.negative | t2.negative) == 0), this.iuand(t2);
        }, a.prototype.and = function(t2) {
          return this.length > t2.length ? this.clone().iand(t2) : t2.clone().iand(this);
        }, a.prototype.uand = function(t2) {
          return this.length > t2.length ? this.clone().iuand(t2) : t2.clone().iuand(this);
        }, a.prototype.iuxor = function(t2) {
          var e3, r3;
          this.length > t2.length ? (e3 = this, r3 = t2) : (e3 = t2, r3 = this);
          for (var n2 = 0; n2 < r3.length; n2++)
            this.words[n2] = e3.words[n2] ^ r3.words[n2];
          if (this !== e3)
            for (; n2 < e3.length; n2++)
              this.words[n2] = e3.words[n2];
          return this.length = e3.length, this._strip();
        }, a.prototype.ixor = function(t2) {
          return i((this.negative | t2.negative) == 0), this.iuxor(t2);
        }, a.prototype.xor = function(t2) {
          return this.length > t2.length ? this.clone().ixor(t2) : t2.clone().ixor(this);
        }, a.prototype.uxor = function(t2) {
          return this.length > t2.length ? this.clone().iuxor(t2) : t2.clone().iuxor(this);
        }, a.prototype.inotn = function(t2) {
          i(typeof t2 == "number" && t2 >= 0);
          var e3 = 0 | Math.ceil(t2 / 26), r3 = t2 % 26;
          this._expand(e3), r3 > 0 && e3--;
          for (var n2 = 0; n2 < e3; n2++)
            this.words[n2] = 67108863 & ~this.words[n2];
          return r3 > 0 && (this.words[n2] = ~this.words[n2] & 67108863 >> 26 - r3), this._strip();
        }, a.prototype.notn = function(t2) {
          return this.clone().inotn(t2);
        }, a.prototype.setn = function(t2, e3) {
          i(typeof t2 == "number" && t2 >= 0);
          var r3 = t2 / 26 | 0, n2 = t2 % 26;
          return this._expand(r3 + 1), this.words[r3] = e3 ? this.words[r3] | 1 << n2 : this.words[r3] & ~(1 << n2), this._strip();
        }, a.prototype.iadd = function(t2) {
          var e3, r3, n2;
          if (this.negative !== 0 && t2.negative === 0)
            return this.negative = 0, e3 = this.isub(t2), this.negative ^= 1, this._normSign();
          if (this.negative === 0 && t2.negative !== 0)
            return t2.negative = 0, e3 = this.isub(t2), t2.negative = 1, e3._normSign();
          this.length > t2.length ? (r3 = this, n2 = t2) : (r3 = t2, n2 = this);
          for (var i2 = 0, o2 = 0; o2 < n2.length; o2++)
            e3 = (0 | r3.words[o2]) + (0 | n2.words[o2]) + i2, this.words[o2] = 67108863 & e3, i2 = e3 >>> 26;
          for (; i2 !== 0 && o2 < r3.length; o2++)
            e3 = (0 | r3.words[o2]) + i2, this.words[o2] = 67108863 & e3, i2 = e3 >>> 26;
          if (this.length = r3.length, i2 !== 0)
            this.words[this.length] = i2, this.length++;
          else if (r3 !== this)
            for (; o2 < r3.length; o2++)
              this.words[o2] = r3.words[o2];
          return this;
        }, a.prototype.add = function(t2) {
          var e3;
          return t2.negative !== 0 && this.negative === 0 ? (t2.negative = 0, e3 = this.sub(t2), t2.negative ^= 1, e3) : t2.negative === 0 && this.negative !== 0 ? (this.negative = 0, e3 = t2.sub(this), this.negative = 1, e3) : this.length > t2.length ? this.clone().iadd(t2) : t2.clone().iadd(this);
        }, a.prototype.isub = function(t2) {
          if (t2.negative !== 0) {
            t2.negative = 0;
            var e3 = this.iadd(t2);
            return t2.negative = 1, e3._normSign();
          }
          if (this.negative !== 0)
            return this.negative = 0, this.iadd(t2), this.negative = 1, this._normSign();
          var r3, n2, i2 = this.cmp(t2);
          if (i2 === 0)
            return this.negative = 0, this.length = 1, this.words[0] = 0, this;
          i2 > 0 ? (r3 = this, n2 = t2) : (r3 = t2, n2 = this);
          for (var o2 = 0, a2 = 0; a2 < n2.length; a2++)
            o2 = (e3 = (0 | r3.words[a2]) - (0 | n2.words[a2]) + o2) >> 26, this.words[a2] = 67108863 & e3;
          for (; o2 !== 0 && a2 < r3.length; a2++)
            o2 = (e3 = (0 | r3.words[a2]) + o2) >> 26, this.words[a2] = 67108863 & e3;
          if (o2 === 0 && a2 < r3.length && r3 !== this)
            for (; a2 < r3.length; a2++)
              this.words[a2] = r3.words[a2];
          return this.length = Math.max(this.length, a2), r3 !== this && (this.negative = 1), this._strip();
        }, a.prototype.sub = function(t2) {
          return this.clone().isub(t2);
        };
        var y = function(t2, e3, r3) {
          var n2, i2, o2, a2 = t2.words, s2 = e3.words, u2 = r3.words, c2 = 0, f2 = 0 | a2[0], l2 = 8191 & f2, h2 = f2 >>> 13, d2 = 0 | a2[1], p2 = 8191 & d2, m2 = d2 >>> 13, y2 = 0 | a2[2], b2 = 8191 & y2, v2 = y2 >>> 13, g2 = 0 | a2[3], w2 = 8191 & g2, _2 = g2 >>> 13, k2 = 0 | a2[4], x2 = 8191 & k2, S2 = k2 >>> 13, O2 = 0 | a2[5], j2 = 8191 & O2, E2 = O2 >>> 13, R = 0 | a2[6], T = 8191 & R, C = R >>> 13, P = 0 | a2[7], M = 8191 & P, A = P >>> 13, I = 0 | a2[8], N = 8191 & I, D = I >>> 13, B = 0 | a2[9], F = 8191 & B, L = B >>> 13, z = 0 | s2[0], U = 8191 & z, H = z >>> 13, V = 0 | s2[1], q = 8191 & V, W = V >>> 13, $ = 0 | s2[2], X = 8191 & $, K = $ >>> 13, Z = 0 | s2[3], Y = 8191 & Z, G = Z >>> 13, J = 0 | s2[4], Q = 8191 & J, tt = J >>> 13, et = 0 | s2[5], rt = 8191 & et, nt = et >>> 13, it = 0 | s2[6], ot = 8191 & it, at = it >>> 13, st = 0 | s2[7], ut = 8191 & st, ct = st >>> 13, ft = 0 | s2[8], lt = 8191 & ft, ht = ft >>> 13, dt = 0 | s2[9], pt = 8191 & dt, mt = dt >>> 13;
          r3.negative = t2.negative ^ e3.negative, r3.length = 19;
          var yt = (c2 + (n2 = Math.imul(l2, U)) | 0) + ((8191 & (i2 = (i2 = Math.imul(l2, H)) + Math.imul(h2, U) | 0)) << 13) | 0;
          c2 = ((o2 = Math.imul(h2, H)) + (i2 >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, n2 = Math.imul(p2, U), i2 = (i2 = Math.imul(p2, H)) + Math.imul(m2, U) | 0, o2 = Math.imul(m2, H);
          var bt = (c2 + (n2 = n2 + Math.imul(l2, q) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(l2, W) | 0) + Math.imul(h2, q) | 0)) << 13) | 0;
          c2 = ((o2 = o2 + Math.imul(h2, W) | 0) + (i2 >>> 13) | 0) + (bt >>> 26) | 0, bt &= 67108863, n2 = Math.imul(b2, U), i2 = (i2 = Math.imul(b2, H)) + Math.imul(v2, U) | 0, o2 = Math.imul(v2, H), n2 = n2 + Math.imul(p2, q) | 0, i2 = (i2 = i2 + Math.imul(p2, W) | 0) + Math.imul(m2, q) | 0, o2 = o2 + Math.imul(m2, W) | 0;
          var vt = (c2 + (n2 = n2 + Math.imul(l2, X) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(l2, K) | 0) + Math.imul(h2, X) | 0)) << 13) | 0;
          c2 = ((o2 = o2 + Math.imul(h2, K) | 0) + (i2 >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, n2 = Math.imul(w2, U), i2 = (i2 = Math.imul(w2, H)) + Math.imul(_2, U) | 0, o2 = Math.imul(_2, H), n2 = n2 + Math.imul(b2, q) | 0, i2 = (i2 = i2 + Math.imul(b2, W) | 0) + Math.imul(v2, q) | 0, o2 = o2 + Math.imul(v2, W) | 0, n2 = n2 + Math.imul(p2, X) | 0, i2 = (i2 = i2 + Math.imul(p2, K) | 0) + Math.imul(m2, X) | 0, o2 = o2 + Math.imul(m2, K) | 0;
          var gt = (c2 + (n2 = n2 + Math.imul(l2, Y) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(l2, G) | 0) + Math.imul(h2, Y) | 0)) << 13) | 0;
          c2 = ((o2 = o2 + Math.imul(h2, G) | 0) + (i2 >>> 13) | 0) + (gt >>> 26) | 0, gt &= 67108863, n2 = Math.imul(x2, U), i2 = (i2 = Math.imul(x2, H)) + Math.imul(S2, U) | 0, o2 = Math.imul(S2, H), n2 = n2 + Math.imul(w2, q) | 0, i2 = (i2 = i2 + Math.imul(w2, W) | 0) + Math.imul(_2, q) | 0, o2 = o2 + Math.imul(_2, W) | 0, n2 = n2 + Math.imul(b2, X) | 0, i2 = (i2 = i2 + Math.imul(b2, K) | 0) + Math.imul(v2, X) | 0, o2 = o2 + Math.imul(v2, K) | 0, n2 = n2 + Math.imul(p2, Y) | 0, i2 = (i2 = i2 + Math.imul(p2, G) | 0) + Math.imul(m2, Y) | 0, o2 = o2 + Math.imul(m2, G) | 0;
          var wt = (c2 + (n2 = n2 + Math.imul(l2, Q) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(l2, tt) | 0) + Math.imul(h2, Q) | 0)) << 13) | 0;
          c2 = ((o2 = o2 + Math.imul(h2, tt) | 0) + (i2 >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, n2 = Math.imul(j2, U), i2 = (i2 = Math.imul(j2, H)) + Math.imul(E2, U) | 0, o2 = Math.imul(E2, H), n2 = n2 + Math.imul(x2, q) | 0, i2 = (i2 = i2 + Math.imul(x2, W) | 0) + Math.imul(S2, q) | 0, o2 = o2 + Math.imul(S2, W) | 0, n2 = n2 + Math.imul(w2, X) | 0, i2 = (i2 = i2 + Math.imul(w2, K) | 0) + Math.imul(_2, X) | 0, o2 = o2 + Math.imul(_2, K) | 0, n2 = n2 + Math.imul(b2, Y) | 0, i2 = (i2 = i2 + Math.imul(b2, G) | 0) + Math.imul(v2, Y) | 0, o2 = o2 + Math.imul(v2, G) | 0, n2 = n2 + Math.imul(p2, Q) | 0, i2 = (i2 = i2 + Math.imul(p2, tt) | 0) + Math.imul(m2, Q) | 0, o2 = o2 + Math.imul(m2, tt) | 0;
          var _t = (c2 + (n2 = n2 + Math.imul(l2, rt) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(l2, nt) | 0) + Math.imul(h2, rt) | 0)) << 13) | 0;
          c2 = ((o2 = o2 + Math.imul(h2, nt) | 0) + (i2 >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, n2 = Math.imul(T, U), i2 = (i2 = Math.imul(T, H)) + Math.imul(C, U) | 0, o2 = Math.imul(C, H), n2 = n2 + Math.imul(j2, q) | 0, i2 = (i2 = i2 + Math.imul(j2, W) | 0) + Math.imul(E2, q) | 0, o2 = o2 + Math.imul(E2, W) | 0, n2 = n2 + Math.imul(x2, X) | 0, i2 = (i2 = i2 + Math.imul(x2, K) | 0) + Math.imul(S2, X) | 0, o2 = o2 + Math.imul(S2, K) | 0, n2 = n2 + Math.imul(w2, Y) | 0, i2 = (i2 = i2 + Math.imul(w2, G) | 0) + Math.imul(_2, Y) | 0, o2 = o2 + Math.imul(_2, G) | 0, n2 = n2 + Math.imul(b2, Q) | 0, i2 = (i2 = i2 + Math.imul(b2, tt) | 0) + Math.imul(v2, Q) | 0, o2 = o2 + Math.imul(v2, tt) | 0, n2 = n2 + Math.imul(p2, rt) | 0, i2 = (i2 = i2 + Math.imul(p2, nt) | 0) + Math.imul(m2, rt) | 0, o2 = o2 + Math.imul(m2, nt) | 0;
          var kt = (c2 + (n2 = n2 + Math.imul(l2, ot) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(l2, at) | 0) + Math.imul(h2, ot) | 0)) << 13) | 0;
          c2 = ((o2 = o2 + Math.imul(h2, at) | 0) + (i2 >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, n2 = Math.imul(M, U), i2 = (i2 = Math.imul(M, H)) + Math.imul(A, U) | 0, o2 = Math.imul(A, H), n2 = n2 + Math.imul(T, q) | 0, i2 = (i2 = i2 + Math.imul(T, W) | 0) + Math.imul(C, q) | 0, o2 = o2 + Math.imul(C, W) | 0, n2 = n2 + Math.imul(j2, X) | 0, i2 = (i2 = i2 + Math.imul(j2, K) | 0) + Math.imul(E2, X) | 0, o2 = o2 + Math.imul(E2, K) | 0, n2 = n2 + Math.imul(x2, Y) | 0, i2 = (i2 = i2 + Math.imul(x2, G) | 0) + Math.imul(S2, Y) | 0, o2 = o2 + Math.imul(S2, G) | 0, n2 = n2 + Math.imul(w2, Q) | 0, i2 = (i2 = i2 + Math.imul(w2, tt) | 0) + Math.imul(_2, Q) | 0, o2 = o2 + Math.imul(_2, tt) | 0, n2 = n2 + Math.imul(b2, rt) | 0, i2 = (i2 = i2 + Math.imul(b2, nt) | 0) + Math.imul(v2, rt) | 0, o2 = o2 + Math.imul(v2, nt) | 0, n2 = n2 + Math.imul(p2, ot) | 0, i2 = (i2 = i2 + Math.imul(p2, at) | 0) + Math.imul(m2, ot) | 0, o2 = o2 + Math.imul(m2, at) | 0;
          var xt = (c2 + (n2 = n2 + Math.imul(l2, ut) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(l2, ct) | 0) + Math.imul(h2, ut) | 0)) << 13) | 0;
          c2 = ((o2 = o2 + Math.imul(h2, ct) | 0) + (i2 >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, n2 = Math.imul(N, U), i2 = (i2 = Math.imul(N, H)) + Math.imul(D, U) | 0, o2 = Math.imul(D, H), n2 = n2 + Math.imul(M, q) | 0, i2 = (i2 = i2 + Math.imul(M, W) | 0) + Math.imul(A, q) | 0, o2 = o2 + Math.imul(A, W) | 0, n2 = n2 + Math.imul(T, X) | 0, i2 = (i2 = i2 + Math.imul(T, K) | 0) + Math.imul(C, X) | 0, o2 = o2 + Math.imul(C, K) | 0, n2 = n2 + Math.imul(j2, Y) | 0, i2 = (i2 = i2 + Math.imul(j2, G) | 0) + Math.imul(E2, Y) | 0, o2 = o2 + Math.imul(E2, G) | 0, n2 = n2 + Math.imul(x2, Q) | 0, i2 = (i2 = i2 + Math.imul(x2, tt) | 0) + Math.imul(S2, Q) | 0, o2 = o2 + Math.imul(S2, tt) | 0, n2 = n2 + Math.imul(w2, rt) | 0, i2 = (i2 = i2 + Math.imul(w2, nt) | 0) + Math.imul(_2, rt) | 0, o2 = o2 + Math.imul(_2, nt) | 0, n2 = n2 + Math.imul(b2, ot) | 0, i2 = (i2 = i2 + Math.imul(b2, at) | 0) + Math.imul(v2, ot) | 0, o2 = o2 + Math.imul(v2, at) | 0, n2 = n2 + Math.imul(p2, ut) | 0, i2 = (i2 = i2 + Math.imul(p2, ct) | 0) + Math.imul(m2, ut) | 0, o2 = o2 + Math.imul(m2, ct) | 0;
          var St = (c2 + (n2 = n2 + Math.imul(l2, lt) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(l2, ht) | 0) + Math.imul(h2, lt) | 0)) << 13) | 0;
          c2 = ((o2 = o2 + Math.imul(h2, ht) | 0) + (i2 >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, n2 = Math.imul(F, U), i2 = (i2 = Math.imul(F, H)) + Math.imul(L, U) | 0, o2 = Math.imul(L, H), n2 = n2 + Math.imul(N, q) | 0, i2 = (i2 = i2 + Math.imul(N, W) | 0) + Math.imul(D, q) | 0, o2 = o2 + Math.imul(D, W) | 0, n2 = n2 + Math.imul(M, X) | 0, i2 = (i2 = i2 + Math.imul(M, K) | 0) + Math.imul(A, X) | 0, o2 = o2 + Math.imul(A, K) | 0, n2 = n2 + Math.imul(T, Y) | 0, i2 = (i2 = i2 + Math.imul(T, G) | 0) + Math.imul(C, Y) | 0, o2 = o2 + Math.imul(C, G) | 0, n2 = n2 + Math.imul(j2, Q) | 0, i2 = (i2 = i2 + Math.imul(j2, tt) | 0) + Math.imul(E2, Q) | 0, o2 = o2 + Math.imul(E2, tt) | 0, n2 = n2 + Math.imul(x2, rt) | 0, i2 = (i2 = i2 + Math.imul(x2, nt) | 0) + Math.imul(S2, rt) | 0, o2 = o2 + Math.imul(S2, nt) | 0, n2 = n2 + Math.imul(w2, ot) | 0, i2 = (i2 = i2 + Math.imul(w2, at) | 0) + Math.imul(_2, ot) | 0, o2 = o2 + Math.imul(_2, at) | 0, n2 = n2 + Math.imul(b2, ut) | 0, i2 = (i2 = i2 + Math.imul(b2, ct) | 0) + Math.imul(v2, ut) | 0, o2 = o2 + Math.imul(v2, ct) | 0, n2 = n2 + Math.imul(p2, lt) | 0, i2 = (i2 = i2 + Math.imul(p2, ht) | 0) + Math.imul(m2, lt) | 0, o2 = o2 + Math.imul(m2, ht) | 0;
          var Ot = (c2 + (n2 = n2 + Math.imul(l2, pt) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(l2, mt) | 0) + Math.imul(h2, pt) | 0)) << 13) | 0;
          c2 = ((o2 = o2 + Math.imul(h2, mt) | 0) + (i2 >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, n2 = Math.imul(F, q), i2 = (i2 = Math.imul(F, W)) + Math.imul(L, q) | 0, o2 = Math.imul(L, W), n2 = n2 + Math.imul(N, X) | 0, i2 = (i2 = i2 + Math.imul(N, K) | 0) + Math.imul(D, X) | 0, o2 = o2 + Math.imul(D, K) | 0, n2 = n2 + Math.imul(M, Y) | 0, i2 = (i2 = i2 + Math.imul(M, G) | 0) + Math.imul(A, Y) | 0, o2 = o2 + Math.imul(A, G) | 0, n2 = n2 + Math.imul(T, Q) | 0, i2 = (i2 = i2 + Math.imul(T, tt) | 0) + Math.imul(C, Q) | 0, o2 = o2 + Math.imul(C, tt) | 0, n2 = n2 + Math.imul(j2, rt) | 0, i2 = (i2 = i2 + Math.imul(j2, nt) | 0) + Math.imul(E2, rt) | 0, o2 = o2 + Math.imul(E2, nt) | 0, n2 = n2 + Math.imul(x2, ot) | 0, i2 = (i2 = i2 + Math.imul(x2, at) | 0) + Math.imul(S2, ot) | 0, o2 = o2 + Math.imul(S2, at) | 0, n2 = n2 + Math.imul(w2, ut) | 0, i2 = (i2 = i2 + Math.imul(w2, ct) | 0) + Math.imul(_2, ut) | 0, o2 = o2 + Math.imul(_2, ct) | 0, n2 = n2 + Math.imul(b2, lt) | 0, i2 = (i2 = i2 + Math.imul(b2, ht) | 0) + Math.imul(v2, lt) | 0, o2 = o2 + Math.imul(v2, ht) | 0;
          var jt = (c2 + (n2 = n2 + Math.imul(p2, pt) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(p2, mt) | 0) + Math.imul(m2, pt) | 0)) << 13) | 0;
          c2 = ((o2 = o2 + Math.imul(m2, mt) | 0) + (i2 >>> 13) | 0) + (jt >>> 26) | 0, jt &= 67108863, n2 = Math.imul(F, X), i2 = (i2 = Math.imul(F, K)) + Math.imul(L, X) | 0, o2 = Math.imul(L, K), n2 = n2 + Math.imul(N, Y) | 0, i2 = (i2 = i2 + Math.imul(N, G) | 0) + Math.imul(D, Y) | 0, o2 = o2 + Math.imul(D, G) | 0, n2 = n2 + Math.imul(M, Q) | 0, i2 = (i2 = i2 + Math.imul(M, tt) | 0) + Math.imul(A, Q) | 0, o2 = o2 + Math.imul(A, tt) | 0, n2 = n2 + Math.imul(T, rt) | 0, i2 = (i2 = i2 + Math.imul(T, nt) | 0) + Math.imul(C, rt) | 0, o2 = o2 + Math.imul(C, nt) | 0, n2 = n2 + Math.imul(j2, ot) | 0, i2 = (i2 = i2 + Math.imul(j2, at) | 0) + Math.imul(E2, ot) | 0, o2 = o2 + Math.imul(E2, at) | 0, n2 = n2 + Math.imul(x2, ut) | 0, i2 = (i2 = i2 + Math.imul(x2, ct) | 0) + Math.imul(S2, ut) | 0, o2 = o2 + Math.imul(S2, ct) | 0, n2 = n2 + Math.imul(w2, lt) | 0, i2 = (i2 = i2 + Math.imul(w2, ht) | 0) + Math.imul(_2, lt) | 0, o2 = o2 + Math.imul(_2, ht) | 0;
          var Et = (c2 + (n2 = n2 + Math.imul(b2, pt) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(b2, mt) | 0) + Math.imul(v2, pt) | 0)) << 13) | 0;
          c2 = ((o2 = o2 + Math.imul(v2, mt) | 0) + (i2 >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, n2 = Math.imul(F, Y), i2 = (i2 = Math.imul(F, G)) + Math.imul(L, Y) | 0, o2 = Math.imul(L, G), n2 = n2 + Math.imul(N, Q) | 0, i2 = (i2 = i2 + Math.imul(N, tt) | 0) + Math.imul(D, Q) | 0, o2 = o2 + Math.imul(D, tt) | 0, n2 = n2 + Math.imul(M, rt) | 0, i2 = (i2 = i2 + Math.imul(M, nt) | 0) + Math.imul(A, rt) | 0, o2 = o2 + Math.imul(A, nt) | 0, n2 = n2 + Math.imul(T, ot) | 0, i2 = (i2 = i2 + Math.imul(T, at) | 0) + Math.imul(C, ot) | 0, o2 = o2 + Math.imul(C, at) | 0, n2 = n2 + Math.imul(j2, ut) | 0, i2 = (i2 = i2 + Math.imul(j2, ct) | 0) + Math.imul(E2, ut) | 0, o2 = o2 + Math.imul(E2, ct) | 0, n2 = n2 + Math.imul(x2, lt) | 0, i2 = (i2 = i2 + Math.imul(x2, ht) | 0) + Math.imul(S2, lt) | 0, o2 = o2 + Math.imul(S2, ht) | 0;
          var Rt = (c2 + (n2 = n2 + Math.imul(w2, pt) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(w2, mt) | 0) + Math.imul(_2, pt) | 0)) << 13) | 0;
          c2 = ((o2 = o2 + Math.imul(_2, mt) | 0) + (i2 >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, n2 = Math.imul(F, Q), i2 = (i2 = Math.imul(F, tt)) + Math.imul(L, Q) | 0, o2 = Math.imul(L, tt), n2 = n2 + Math.imul(N, rt) | 0, i2 = (i2 = i2 + Math.imul(N, nt) | 0) + Math.imul(D, rt) | 0, o2 = o2 + Math.imul(D, nt) | 0, n2 = n2 + Math.imul(M, ot) | 0, i2 = (i2 = i2 + Math.imul(M, at) | 0) + Math.imul(A, ot) | 0, o2 = o2 + Math.imul(A, at) | 0, n2 = n2 + Math.imul(T, ut) | 0, i2 = (i2 = i2 + Math.imul(T, ct) | 0) + Math.imul(C, ut) | 0, o2 = o2 + Math.imul(C, ct) | 0, n2 = n2 + Math.imul(j2, lt) | 0, i2 = (i2 = i2 + Math.imul(j2, ht) | 0) + Math.imul(E2, lt) | 0, o2 = o2 + Math.imul(E2, ht) | 0;
          var Tt = (c2 + (n2 = n2 + Math.imul(x2, pt) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(x2, mt) | 0) + Math.imul(S2, pt) | 0)) << 13) | 0;
          c2 = ((o2 = o2 + Math.imul(S2, mt) | 0) + (i2 >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, n2 = Math.imul(F, rt), i2 = (i2 = Math.imul(F, nt)) + Math.imul(L, rt) | 0, o2 = Math.imul(L, nt), n2 = n2 + Math.imul(N, ot) | 0, i2 = (i2 = i2 + Math.imul(N, at) | 0) + Math.imul(D, ot) | 0, o2 = o2 + Math.imul(D, at) | 0, n2 = n2 + Math.imul(M, ut) | 0, i2 = (i2 = i2 + Math.imul(M, ct) | 0) + Math.imul(A, ut) | 0, o2 = o2 + Math.imul(A, ct) | 0, n2 = n2 + Math.imul(T, lt) | 0, i2 = (i2 = i2 + Math.imul(T, ht) | 0) + Math.imul(C, lt) | 0, o2 = o2 + Math.imul(C, ht) | 0;
          var Ct = (c2 + (n2 = n2 + Math.imul(j2, pt) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(j2, mt) | 0) + Math.imul(E2, pt) | 0)) << 13) | 0;
          c2 = ((o2 = o2 + Math.imul(E2, mt) | 0) + (i2 >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863, n2 = Math.imul(F, ot), i2 = (i2 = Math.imul(F, at)) + Math.imul(L, ot) | 0, o2 = Math.imul(L, at), n2 = n2 + Math.imul(N, ut) | 0, i2 = (i2 = i2 + Math.imul(N, ct) | 0) + Math.imul(D, ut) | 0, o2 = o2 + Math.imul(D, ct) | 0, n2 = n2 + Math.imul(M, lt) | 0, i2 = (i2 = i2 + Math.imul(M, ht) | 0) + Math.imul(A, lt) | 0, o2 = o2 + Math.imul(A, ht) | 0;
          var Pt = (c2 + (n2 = n2 + Math.imul(T, pt) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(T, mt) | 0) + Math.imul(C, pt) | 0)) << 13) | 0;
          c2 = ((o2 = o2 + Math.imul(C, mt) | 0) + (i2 >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, n2 = Math.imul(F, ut), i2 = (i2 = Math.imul(F, ct)) + Math.imul(L, ut) | 0, o2 = Math.imul(L, ct), n2 = n2 + Math.imul(N, lt) | 0, i2 = (i2 = i2 + Math.imul(N, ht) | 0) + Math.imul(D, lt) | 0, o2 = o2 + Math.imul(D, ht) | 0;
          var Mt = (c2 + (n2 = n2 + Math.imul(M, pt) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(M, mt) | 0) + Math.imul(A, pt) | 0)) << 13) | 0;
          c2 = ((o2 = o2 + Math.imul(A, mt) | 0) + (i2 >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, n2 = Math.imul(F, lt), i2 = (i2 = Math.imul(F, ht)) + Math.imul(L, lt) | 0, o2 = Math.imul(L, ht);
          var At = (c2 + (n2 = n2 + Math.imul(N, pt) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(N, mt) | 0) + Math.imul(D, pt) | 0)) << 13) | 0;
          c2 = ((o2 = o2 + Math.imul(D, mt) | 0) + (i2 >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863;
          var It = (c2 + (n2 = Math.imul(F, pt)) | 0) + ((8191 & (i2 = (i2 = Math.imul(F, mt)) + Math.imul(L, pt) | 0)) << 13) | 0;
          return c2 = ((o2 = Math.imul(L, mt)) + (i2 >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, u2[0] = yt, u2[1] = bt, u2[2] = vt, u2[3] = gt, u2[4] = wt, u2[5] = _t, u2[6] = kt, u2[7] = xt, u2[8] = St, u2[9] = Ot, u2[10] = jt, u2[11] = Et, u2[12] = Rt, u2[13] = Tt, u2[14] = Ct, u2[15] = Pt, u2[16] = Mt, u2[17] = At, u2[18] = It, c2 !== 0 && (u2[19] = c2, r3.length++), r3;
        };
        function b(t2, e3, r3) {
          r3.negative = e3.negative ^ t2.negative, r3.length = t2.length + e3.length;
          for (var n2 = 0, i2 = 0, o2 = 0; o2 < r3.length - 1; o2++) {
            var a2 = i2;
            i2 = 0;
            for (var s2 = 67108863 & n2, u2 = Math.min(o2, e3.length - 1), c2 = Math.max(0, o2 - t2.length + 1); c2 <= u2; c2++) {
              var f2 = o2 - c2, l2 = (0 | t2.words[f2]) * (0 | e3.words[c2]), h2 = 67108863 & l2;
              s2 = 67108863 & (h2 = h2 + s2 | 0), i2 += (a2 = (a2 = a2 + (l2 / 67108864 | 0) | 0) + (h2 >>> 26) | 0) >>> 26, a2 &= 67108863;
            }
            r3.words[o2] = s2, n2 = a2, a2 = i2;
          }
          return n2 !== 0 ? r3.words[o2] = n2 : r3.length--, r3._strip();
        }
        function v(t2, e3, r3) {
          return b(t2, e3, r3);
        }
        Math.imul || (y = m), a.prototype.mulTo = function(t2, e3) {
          var r3 = this.length + t2.length;
          return this.length === 10 && t2.length === 10 ? y(this, t2, e3) : r3 < 63 ? m(this, t2, e3) : r3 < 1024 ? b(this, t2, e3) : v(this, t2, e3);
        }, a.prototype.mul = function(t2) {
          var e3 = new a(null);
          return e3.words = new Array(this.length + t2.length), this.mulTo(t2, e3);
        }, a.prototype.mulf = function(t2) {
          var e3 = new a(null);
          return e3.words = new Array(this.length + t2.length), v(this, t2, e3);
        }, a.prototype.imul = function(t2) {
          return this.clone().mulTo(t2, this);
        }, a.prototype.imuln = function(t2) {
          var e3 = t2 < 0;
          e3 && (t2 = -t2), i(typeof t2 == "number"), i(t2 < 67108864);
          for (var r3 = 0, n2 = 0; n2 < this.length; n2++) {
            var o2 = (0 | this.words[n2]) * t2, a2 = (67108863 & o2) + (67108863 & r3);
            r3 >>= 26, r3 += o2 / 67108864 | 0, r3 += a2 >>> 26, this.words[n2] = 67108863 & a2;
          }
          return r3 !== 0 && (this.words[n2] = r3, this.length++), e3 ? this.ineg() : this;
        }, a.prototype.muln = function(t2) {
          return this.clone().imuln(t2);
        }, a.prototype.sqr = function() {
          return this.mul(this);
        }, a.prototype.isqr = function() {
          return this.imul(this.clone());
        }, a.prototype.pow = function(t2) {
          var e3 = function(t3) {
            for (var e4 = new Array(t3.bitLength()), r4 = 0; r4 < e4.length; r4++) {
              var n3 = r4 / 26 | 0, i3 = r4 % 26;
              e4[r4] = t3.words[n3] >>> i3 & 1;
            }
            return e4;
          }(t2);
          if (e3.length === 0)
            return new a(1);
          for (var r3 = this, n2 = 0; n2 < e3.length && e3[n2] === 0; n2++, r3 = r3.sqr())
            ;
          if (++n2 < e3.length)
            for (var i2 = r3.sqr(); n2 < e3.length; n2++, i2 = i2.sqr())
              e3[n2] !== 0 && (r3 = r3.mul(i2));
          return r3;
        }, a.prototype.iushln = function(t2) {
          i(typeof t2 == "number" && t2 >= 0);
          var e3, r3 = t2 % 26, n2 = (t2 - r3) / 26, o2 = 67108863 >>> 26 - r3 << 26 - r3;
          if (r3 !== 0) {
            var a2 = 0;
            for (e3 = 0; e3 < this.length; e3++) {
              var s2 = this.words[e3] & o2, u2 = (0 | this.words[e3]) - s2 << r3;
              this.words[e3] = u2 | a2, a2 = s2 >>> 26 - r3;
            }
            a2 && (this.words[e3] = a2, this.length++);
          }
          if (n2 !== 0) {
            for (e3 = this.length - 1; e3 >= 0; e3--)
              this.words[e3 + n2] = this.words[e3];
            for (e3 = 0; e3 < n2; e3++)
              this.words[e3] = 0;
            this.length += n2;
          }
          return this._strip();
        }, a.prototype.ishln = function(t2) {
          return i(this.negative === 0), this.iushln(t2);
        }, a.prototype.iushrn = function(t2, e3, r3) {
          var n2;
          i(typeof t2 == "number" && t2 >= 0), n2 = e3 ? (e3 - e3 % 26) / 26 : 0;
          var o2 = t2 % 26, a2 = Math.min((t2 - o2) / 26, this.length), s2 = 67108863 ^ 67108863 >>> o2 << o2, u2 = r3;
          if (n2 -= a2, n2 = Math.max(0, n2), u2) {
            for (var c2 = 0; c2 < a2; c2++)
              u2.words[c2] = this.words[c2];
            u2.length = a2;
          }
          if (a2 === 0)
            ;
          else if (this.length > a2)
            for (this.length -= a2, c2 = 0; c2 < this.length; c2++)
              this.words[c2] = this.words[c2 + a2];
          else
            this.words[0] = 0, this.length = 1;
          var f2 = 0;
          for (c2 = this.length - 1; c2 >= 0 && (f2 !== 0 || c2 >= n2); c2--) {
            var l2 = 0 | this.words[c2];
            this.words[c2] = f2 << 26 - o2 | l2 >>> o2, f2 = l2 & s2;
          }
          return u2 && f2 !== 0 && (u2.words[u2.length++] = f2), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
        }, a.prototype.ishrn = function(t2, e3, r3) {
          return i(this.negative === 0), this.iushrn(t2, e3, r3);
        }, a.prototype.shln = function(t2) {
          return this.clone().ishln(t2);
        }, a.prototype.ushln = function(t2) {
          return this.clone().iushln(t2);
        }, a.prototype.shrn = function(t2) {
          return this.clone().ishrn(t2);
        }, a.prototype.ushrn = function(t2) {
          return this.clone().iushrn(t2);
        }, a.prototype.testn = function(t2) {
          i(typeof t2 == "number" && t2 >= 0);
          var e3 = t2 % 26, r3 = (t2 - e3) / 26, n2 = 1 << e3;
          return !(this.length <= r3) && !!(this.words[r3] & n2);
        }, a.prototype.imaskn = function(t2) {
          i(typeof t2 == "number" && t2 >= 0);
          var e3 = t2 % 26, r3 = (t2 - e3) / 26;
          if (i(this.negative === 0, "imaskn works only with positive numbers"), this.length <= r3)
            return this;
          if (e3 !== 0 && r3++, this.length = Math.min(r3, this.length), e3 !== 0) {
            var n2 = 67108863 ^ 67108863 >>> e3 << e3;
            this.words[this.length - 1] &= n2;
          }
          return this._strip();
        }, a.prototype.maskn = function(t2) {
          return this.clone().imaskn(t2);
        }, a.prototype.iaddn = function(t2) {
          return i(typeof t2 == "number"), i(t2 < 67108864), t2 < 0 ? this.isubn(-t2) : this.negative !== 0 ? this.length === 1 && (0 | this.words[0]) <= t2 ? (this.words[0] = t2 - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(t2), this.negative = 1, this) : this._iaddn(t2);
        }, a.prototype._iaddn = function(t2) {
          this.words[0] += t2;
          for (var e3 = 0; e3 < this.length && this.words[e3] >= 67108864; e3++)
            this.words[e3] -= 67108864, e3 === this.length - 1 ? this.words[e3 + 1] = 1 : this.words[e3 + 1]++;
          return this.length = Math.max(this.length, e3 + 1), this;
        }, a.prototype.isubn = function(t2) {
          if (i(typeof t2 == "number"), i(t2 < 67108864), t2 < 0)
            return this.iaddn(-t2);
          if (this.negative !== 0)
            return this.negative = 0, this.iaddn(t2), this.negative = 1, this;
          if (this.words[0] -= t2, this.length === 1 && this.words[0] < 0)
            this.words[0] = -this.words[0], this.negative = 1;
          else
            for (var e3 = 0; e3 < this.length && this.words[e3] < 0; e3++)
              this.words[e3] += 67108864, this.words[e3 + 1] -= 1;
          return this._strip();
        }, a.prototype.addn = function(t2) {
          return this.clone().iaddn(t2);
        }, a.prototype.subn = function(t2) {
          return this.clone().isubn(t2);
        }, a.prototype.iabs = function() {
          return this.negative = 0, this;
        }, a.prototype.abs = function() {
          return this.clone().iabs();
        }, a.prototype._ishlnsubmul = function(t2, e3, r3) {
          var n2, o2, a2 = t2.length + r3;
          this._expand(a2);
          var s2 = 0;
          for (n2 = 0; n2 < t2.length; n2++) {
            o2 = (0 | this.words[n2 + r3]) + s2;
            var u2 = (0 | t2.words[n2]) * e3;
            s2 = ((o2 -= 67108863 & u2) >> 26) - (u2 / 67108864 | 0), this.words[n2 + r3] = 67108863 & o2;
          }
          for (; n2 < this.length - r3; n2++)
            s2 = (o2 = (0 | this.words[n2 + r3]) + s2) >> 26, this.words[n2 + r3] = 67108863 & o2;
          if (s2 === 0)
            return this._strip();
          for (i(s2 === -1), s2 = 0, n2 = 0; n2 < this.length; n2++)
            s2 = (o2 = -(0 | this.words[n2]) + s2) >> 26, this.words[n2] = 67108863 & o2;
          return this.negative = 1, this._strip();
        }, a.prototype._wordDiv = function(t2, e3) {
          var r3 = (this.length, t2.length), n2 = this.clone(), i2 = t2, o2 = 0 | i2.words[i2.length - 1];
          (r3 = 26 - this._countBits(o2)) !== 0 && (i2 = i2.ushln(r3), n2.iushln(r3), o2 = 0 | i2.words[i2.length - 1]);
          var s2, u2 = n2.length - i2.length;
          if (e3 !== "mod") {
            (s2 = new a(null)).length = u2 + 1, s2.words = new Array(s2.length);
            for (var c2 = 0; c2 < s2.length; c2++)
              s2.words[c2] = 0;
          }
          var f2 = n2.clone()._ishlnsubmul(i2, 1, u2);
          f2.negative === 0 && (n2 = f2, s2 && (s2.words[u2] = 1));
          for (var l2 = u2 - 1; l2 >= 0; l2--) {
            var h2 = 67108864 * (0 | n2.words[i2.length + l2]) + (0 | n2.words[i2.length + l2 - 1]);
            for (h2 = Math.min(h2 / o2 | 0, 67108863), n2._ishlnsubmul(i2, h2, l2); n2.negative !== 0; )
              h2--, n2.negative = 0, n2._ishlnsubmul(i2, 1, l2), n2.isZero() || (n2.negative ^= 1);
            s2 && (s2.words[l2] = h2);
          }
          return s2 && s2._strip(), n2._strip(), e3 !== "div" && r3 !== 0 && n2.iushrn(r3), { div: s2 || null, mod: n2 };
        }, a.prototype.divmod = function(t2, e3, r3) {
          return i(!t2.isZero()), this.isZero() ? { div: new a(0), mod: new a(0) } : this.negative !== 0 && t2.negative === 0 ? (s2 = this.neg().divmod(t2, e3), e3 !== "mod" && (n2 = s2.div.neg()), e3 !== "div" && (o2 = s2.mod.neg(), r3 && o2.negative !== 0 && o2.iadd(t2)), { div: n2, mod: o2 }) : this.negative === 0 && t2.negative !== 0 ? (s2 = this.divmod(t2.neg(), e3), e3 !== "mod" && (n2 = s2.div.neg()), { div: n2, mod: s2.mod }) : (this.negative & t2.negative) != 0 ? (s2 = this.neg().divmod(t2.neg(), e3), e3 !== "div" && (o2 = s2.mod.neg(), r3 && o2.negative !== 0 && o2.isub(t2)), { div: s2.div, mod: o2 }) : t2.length > this.length || this.cmp(t2) < 0 ? { div: new a(0), mod: this } : t2.length === 1 ? e3 === "div" ? { div: this.divn(t2.words[0]), mod: null } : e3 === "mod" ? { div: null, mod: new a(this.modrn(t2.words[0])) } : { div: this.divn(t2.words[0]), mod: new a(this.modrn(t2.words[0])) } : this._wordDiv(t2, e3);
          var n2, o2, s2;
        }, a.prototype.div = function(t2) {
          return this.divmod(t2, "div", false).div;
        }, a.prototype.mod = function(t2) {
          return this.divmod(t2, "mod", false).mod;
        }, a.prototype.umod = function(t2) {
          return this.divmod(t2, "mod", true).mod;
        }, a.prototype.divRound = function(t2) {
          var e3 = this.divmod(t2);
          if (e3.mod.isZero())
            return e3.div;
          var r3 = e3.div.negative !== 0 ? e3.mod.isub(t2) : e3.mod, n2 = t2.ushrn(1), i2 = t2.andln(1), o2 = r3.cmp(n2);
          return o2 < 0 || i2 === 1 && o2 === 0 ? e3.div : e3.div.negative !== 0 ? e3.div.isubn(1) : e3.div.iaddn(1);
        }, a.prototype.modrn = function(t2) {
          var e3 = t2 < 0;
          e3 && (t2 = -t2), i(t2 <= 67108863);
          for (var r3 = (1 << 26) % t2, n2 = 0, o2 = this.length - 1; o2 >= 0; o2--)
            n2 = (r3 * n2 + (0 | this.words[o2])) % t2;
          return e3 ? -n2 : n2;
        }, a.prototype.modn = function(t2) {
          return this.modrn(t2);
        }, a.prototype.idivn = function(t2) {
          var e3 = t2 < 0;
          e3 && (t2 = -t2), i(t2 <= 67108863);
          for (var r3 = 0, n2 = this.length - 1; n2 >= 0; n2--) {
            var o2 = (0 | this.words[n2]) + 67108864 * r3;
            this.words[n2] = o2 / t2 | 0, r3 = o2 % t2;
          }
          return this._strip(), e3 ? this.ineg() : this;
        }, a.prototype.divn = function(t2) {
          return this.clone().idivn(t2);
        }, a.prototype.egcd = function(t2) {
          i(t2.negative === 0), i(!t2.isZero());
          var e3 = this, r3 = t2.clone();
          e3 = e3.negative !== 0 ? e3.umod(t2) : e3.clone();
          for (var n2 = new a(1), o2 = new a(0), s2 = new a(0), u2 = new a(1), c2 = 0; e3.isEven() && r3.isEven(); )
            e3.iushrn(1), r3.iushrn(1), ++c2;
          for (var f2 = r3.clone(), l2 = e3.clone(); !e3.isZero(); ) {
            for (var h2 = 0, d2 = 1; (e3.words[0] & d2) == 0 && h2 < 26; ++h2, d2 <<= 1)
              ;
            if (h2 > 0)
              for (e3.iushrn(h2); h2-- > 0; )
                (n2.isOdd() || o2.isOdd()) && (n2.iadd(f2), o2.isub(l2)), n2.iushrn(1), o2.iushrn(1);
            for (var p2 = 0, m2 = 1; (r3.words[0] & m2) == 0 && p2 < 26; ++p2, m2 <<= 1)
              ;
            if (p2 > 0)
              for (r3.iushrn(p2); p2-- > 0; )
                (s2.isOdd() || u2.isOdd()) && (s2.iadd(f2), u2.isub(l2)), s2.iushrn(1), u2.iushrn(1);
            e3.cmp(r3) >= 0 ? (e3.isub(r3), n2.isub(s2), o2.isub(u2)) : (r3.isub(e3), s2.isub(n2), u2.isub(o2));
          }
          return { a: s2, b: u2, gcd: r3.iushln(c2) };
        }, a.prototype._invmp = function(t2) {
          i(t2.negative === 0), i(!t2.isZero());
          var e3 = this, r3 = t2.clone();
          e3 = e3.negative !== 0 ? e3.umod(t2) : e3.clone();
          for (var n2, o2 = new a(1), s2 = new a(0), u2 = r3.clone(); e3.cmpn(1) > 0 && r3.cmpn(1) > 0; ) {
            for (var c2 = 0, f2 = 1; (e3.words[0] & f2) == 0 && c2 < 26; ++c2, f2 <<= 1)
              ;
            if (c2 > 0)
              for (e3.iushrn(c2); c2-- > 0; )
                o2.isOdd() && o2.iadd(u2), o2.iushrn(1);
            for (var l2 = 0, h2 = 1; (r3.words[0] & h2) == 0 && l2 < 26; ++l2, h2 <<= 1)
              ;
            if (l2 > 0)
              for (r3.iushrn(l2); l2-- > 0; )
                s2.isOdd() && s2.iadd(u2), s2.iushrn(1);
            e3.cmp(r3) >= 0 ? (e3.isub(r3), o2.isub(s2)) : (r3.isub(e3), s2.isub(o2));
          }
          return (n2 = e3.cmpn(1) === 0 ? o2 : s2).cmpn(0) < 0 && n2.iadd(t2), n2;
        }, a.prototype.gcd = function(t2) {
          if (this.isZero())
            return t2.abs();
          if (t2.isZero())
            return this.abs();
          var e3 = this.clone(), r3 = t2.clone();
          e3.negative = 0, r3.negative = 0;
          for (var n2 = 0; e3.isEven() && r3.isEven(); n2++)
            e3.iushrn(1), r3.iushrn(1);
          for (; ; ) {
            for (; e3.isEven(); )
              e3.iushrn(1);
            for (; r3.isEven(); )
              r3.iushrn(1);
            var i2 = e3.cmp(r3);
            if (i2 < 0) {
              var o2 = e3;
              e3 = r3, r3 = o2;
            } else if (i2 === 0 || r3.cmpn(1) === 0)
              break;
            e3.isub(r3);
          }
          return r3.iushln(n2);
        }, a.prototype.invm = function(t2) {
          return this.egcd(t2).a.umod(t2);
        }, a.prototype.isEven = function() {
          return (1 & this.words[0]) == 0;
        }, a.prototype.isOdd = function() {
          return (1 & this.words[0]) == 1;
        }, a.prototype.andln = function(t2) {
          return this.words[0] & t2;
        }, a.prototype.bincn = function(t2) {
          i(typeof t2 == "number");
          var e3 = t2 % 26, r3 = (t2 - e3) / 26, n2 = 1 << e3;
          if (this.length <= r3)
            return this._expand(r3 + 1), this.words[r3] |= n2, this;
          for (var o2 = n2, a2 = r3; o2 !== 0 && a2 < this.length; a2++) {
            var s2 = 0 | this.words[a2];
            o2 = (s2 += o2) >>> 26, s2 &= 67108863, this.words[a2] = s2;
          }
          return o2 !== 0 && (this.words[a2] = o2, this.length++), this;
        }, a.prototype.isZero = function() {
          return this.length === 1 && this.words[0] === 0;
        }, a.prototype.cmpn = function(t2) {
          var e3, r3 = t2 < 0;
          if (this.negative !== 0 && !r3)
            return -1;
          if (this.negative === 0 && r3)
            return 1;
          if (this._strip(), this.length > 1)
            e3 = 1;
          else {
            r3 && (t2 = -t2), i(t2 <= 67108863, "Number is too big");
            var n2 = 0 | this.words[0];
            e3 = n2 === t2 ? 0 : n2 < t2 ? -1 : 1;
          }
          return this.negative !== 0 ? 0 | -e3 : e3;
        }, a.prototype.cmp = function(t2) {
          if (this.negative !== 0 && t2.negative === 0)
            return -1;
          if (this.negative === 0 && t2.negative !== 0)
            return 1;
          var e3 = this.ucmp(t2);
          return this.negative !== 0 ? 0 | -e3 : e3;
        }, a.prototype.ucmp = function(t2) {
          if (this.length > t2.length)
            return 1;
          if (this.length < t2.length)
            return -1;
          for (var e3 = 0, r3 = this.length - 1; r3 >= 0; r3--) {
            var n2 = 0 | this.words[r3], i2 = 0 | t2.words[r3];
            if (n2 !== i2) {
              n2 < i2 ? e3 = -1 : n2 > i2 && (e3 = 1);
              break;
            }
          }
          return e3;
        }, a.prototype.gtn = function(t2) {
          return this.cmpn(t2) === 1;
        }, a.prototype.gt = function(t2) {
          return this.cmp(t2) === 1;
        }, a.prototype.gten = function(t2) {
          return this.cmpn(t2) >= 0;
        }, a.prototype.gte = function(t2) {
          return this.cmp(t2) >= 0;
        }, a.prototype.ltn = function(t2) {
          return this.cmpn(t2) === -1;
        }, a.prototype.lt = function(t2) {
          return this.cmp(t2) === -1;
        }, a.prototype.lten = function(t2) {
          return this.cmpn(t2) <= 0;
        }, a.prototype.lte = function(t2) {
          return this.cmp(t2) <= 0;
        }, a.prototype.eqn = function(t2) {
          return this.cmpn(t2) === 0;
        }, a.prototype.eq = function(t2) {
          return this.cmp(t2) === 0;
        }, a.red = function(t2) {
          return new j(t2);
        }, a.prototype.toRed = function(t2) {
          return i(!this.red, "Already a number in reduction context"), i(this.negative === 0, "red works only with positives"), t2.convertTo(this)._forceRed(t2);
        }, a.prototype.fromRed = function() {
          return i(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
        }, a.prototype._forceRed = function(t2) {
          return this.red = t2, this;
        }, a.prototype.forceRed = function(t2) {
          return i(!this.red, "Already a number in reduction context"), this._forceRed(t2);
        }, a.prototype.redAdd = function(t2) {
          return i(this.red, "redAdd works only with red numbers"), this.red.add(this, t2);
        }, a.prototype.redIAdd = function(t2) {
          return i(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, t2);
        }, a.prototype.redSub = function(t2) {
          return i(this.red, "redSub works only with red numbers"), this.red.sub(this, t2);
        }, a.prototype.redISub = function(t2) {
          return i(this.red, "redISub works only with red numbers"), this.red.isub(this, t2);
        }, a.prototype.redShl = function(t2) {
          return i(this.red, "redShl works only with red numbers"), this.red.shl(this, t2);
        }, a.prototype.redMul = function(t2) {
          return i(this.red, "redMul works only with red numbers"), this.red._verify2(this, t2), this.red.mul(this, t2);
        }, a.prototype.redIMul = function(t2) {
          return i(this.red, "redMul works only with red numbers"), this.red._verify2(this, t2), this.red.imul(this, t2);
        }, a.prototype.redSqr = function() {
          return i(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
        }, a.prototype.redISqr = function() {
          return i(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
        }, a.prototype.redSqrt = function() {
          return i(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
        }, a.prototype.redInvm = function() {
          return i(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
        }, a.prototype.redNeg = function() {
          return i(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
        }, a.prototype.redPow = function(t2) {
          return i(this.red && !t2.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, t2);
        };
        var w = { k256: null, p224: null, p192: null, p25519: null };
        function _(t2, e3) {
          this.name = t2, this.p = new a(e3, 16), this.n = this.p.bitLength(), this.k = new a(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
        }
        function k() {
          _.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
        }
        function x() {
          _.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
        }
        function S() {
          _.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
        }
        function O() {
          _.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
        }
        function j(t2) {
          if (typeof t2 == "string") {
            var e3 = a._prime(t2);
            this.m = e3.p, this.prime = e3;
          } else
            i(t2.gtn(1), "modulus must be greater than 1"), this.m = t2, this.prime = null;
        }
        function E(t2) {
          j.call(this, t2), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new a(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
        }
        _.prototype._tmp = function() {
          var t2 = new a(null);
          return t2.words = new Array(Math.ceil(this.n / 13)), t2;
        }, _.prototype.ireduce = function(t2) {
          var e3, r3 = t2;
          do {
            this.split(r3, this.tmp), e3 = (r3 = (r3 = this.imulK(r3)).iadd(this.tmp)).bitLength();
          } while (e3 > this.n);
          var n2 = e3 < this.n ? -1 : r3.ucmp(this.p);
          return n2 === 0 ? (r3.words[0] = 0, r3.length = 1) : n2 > 0 ? r3.isub(this.p) : r3.strip !== void 0 ? r3.strip() : r3._strip(), r3;
        }, _.prototype.split = function(t2, e3) {
          t2.iushrn(this.n, 0, e3);
        }, _.prototype.imulK = function(t2) {
          return t2.imul(this.k);
        }, o(k, _), k.prototype.split = function(t2, e3) {
          for (var r3 = Math.min(t2.length, 9), n2 = 0; n2 < r3; n2++)
            e3.words[n2] = t2.words[n2];
          if (e3.length = r3, t2.length <= 9)
            return t2.words[0] = 0, void (t2.length = 1);
          var i2 = t2.words[9];
          for (e3.words[e3.length++] = 4194303 & i2, n2 = 10; n2 < t2.length; n2++) {
            var o2 = 0 | t2.words[n2];
            t2.words[n2 - 10] = (4194303 & o2) << 4 | i2 >>> 22, i2 = o2;
          }
          i2 >>>= 22, t2.words[n2 - 10] = i2, i2 === 0 && t2.length > 10 ? t2.length -= 10 : t2.length -= 9;
        }, k.prototype.imulK = function(t2) {
          t2.words[t2.length] = 0, t2.words[t2.length + 1] = 0, t2.length += 2;
          for (var e3 = 0, r3 = 0; r3 < t2.length; r3++) {
            var n2 = 0 | t2.words[r3];
            e3 += 977 * n2, t2.words[r3] = 67108863 & e3, e3 = 64 * n2 + (e3 / 67108864 | 0);
          }
          return t2.words[t2.length - 1] === 0 && (t2.length--, t2.words[t2.length - 1] === 0 && t2.length--), t2;
        }, o(x, _), o(S, _), o(O, _), O.prototype.imulK = function(t2) {
          for (var e3 = 0, r3 = 0; r3 < t2.length; r3++) {
            var n2 = 19 * (0 | t2.words[r3]) + e3, i2 = 67108863 & n2;
            n2 >>>= 26, t2.words[r3] = i2, e3 = n2;
          }
          return e3 !== 0 && (t2.words[t2.length++] = e3), t2;
        }, a._prime = function(t2) {
          if (w[t2])
            return w[t2];
          var e3;
          if (t2 === "k256")
            e3 = new k();
          else if (t2 === "p224")
            e3 = new x();
          else if (t2 === "p192")
            e3 = new S();
          else {
            if (t2 !== "p25519")
              throw new Error("Unknown prime " + t2);
            e3 = new O();
          }
          return w[t2] = e3, e3;
        }, j.prototype._verify1 = function(t2) {
          i(t2.negative === 0, "red works only with positives"), i(t2.red, "red works only with red numbers");
        }, j.prototype._verify2 = function(t2, e3) {
          i((t2.negative | e3.negative) == 0, "red works only with positives"), i(t2.red && t2.red === e3.red, "red works only with red numbers");
        }, j.prototype.imod = function(t2) {
          return this.prime ? this.prime.ireduce(t2)._forceRed(this) : (f(t2, t2.umod(this.m)._forceRed(this)), t2);
        }, j.prototype.neg = function(t2) {
          return t2.isZero() ? t2.clone() : this.m.sub(t2)._forceRed(this);
        }, j.prototype.add = function(t2, e3) {
          this._verify2(t2, e3);
          var r3 = t2.add(e3);
          return r3.cmp(this.m) >= 0 && r3.isub(this.m), r3._forceRed(this);
        }, j.prototype.iadd = function(t2, e3) {
          this._verify2(t2, e3);
          var r3 = t2.iadd(e3);
          return r3.cmp(this.m) >= 0 && r3.isub(this.m), r3;
        }, j.prototype.sub = function(t2, e3) {
          this._verify2(t2, e3);
          var r3 = t2.sub(e3);
          return r3.cmpn(0) < 0 && r3.iadd(this.m), r3._forceRed(this);
        }, j.prototype.isub = function(t2, e3) {
          this._verify2(t2, e3);
          var r3 = t2.isub(e3);
          return r3.cmpn(0) < 0 && r3.iadd(this.m), r3;
        }, j.prototype.shl = function(t2, e3) {
          return this._verify1(t2), this.imod(t2.ushln(e3));
        }, j.prototype.imul = function(t2, e3) {
          return this._verify2(t2, e3), this.imod(t2.imul(e3));
        }, j.prototype.mul = function(t2, e3) {
          return this._verify2(t2, e3), this.imod(t2.mul(e3));
        }, j.prototype.isqr = function(t2) {
          return this.imul(t2, t2.clone());
        }, j.prototype.sqr = function(t2) {
          return this.mul(t2, t2);
        }, j.prototype.sqrt = function(t2) {
          if (t2.isZero())
            return t2.clone();
          var e3 = this.m.andln(3);
          if (i(e3 % 2 == 1), e3 === 3) {
            var r3 = this.m.add(new a(1)).iushrn(2);
            return this.pow(t2, r3);
          }
          for (var n2 = this.m.subn(1), o2 = 0; !n2.isZero() && n2.andln(1) === 0; )
            o2++, n2.iushrn(1);
          i(!n2.isZero());
          var s2 = new a(1).toRed(this), u2 = s2.redNeg(), c2 = this.m.subn(1).iushrn(1), f2 = this.m.bitLength();
          for (f2 = new a(2 * f2 * f2).toRed(this); this.pow(f2, c2).cmp(u2) !== 0; )
            f2.redIAdd(u2);
          for (var l2 = this.pow(f2, n2), h2 = this.pow(t2, n2.addn(1).iushrn(1)), d2 = this.pow(t2, n2), p2 = o2; d2.cmp(s2) !== 0; ) {
            for (var m2 = d2, y2 = 0; m2.cmp(s2) !== 0; y2++)
              m2 = m2.redSqr();
            i(y2 < p2);
            var b2 = this.pow(l2, new a(1).iushln(p2 - y2 - 1));
            h2 = h2.redMul(b2), l2 = b2.redSqr(), d2 = d2.redMul(l2), p2 = y2;
          }
          return h2;
        }, j.prototype.invm = function(t2) {
          var e3 = t2._invmp(this.m);
          return e3.negative !== 0 ? (e3.negative = 0, this.imod(e3).redNeg()) : this.imod(e3);
        }, j.prototype.pow = function(t2, e3) {
          if (e3.isZero())
            return new a(1).toRed(this);
          if (e3.cmpn(1) === 0)
            return t2.clone();
          var r3 = new Array(16);
          r3[0] = new a(1).toRed(this), r3[1] = t2;
          for (var n2 = 2; n2 < r3.length; n2++)
            r3[n2] = this.mul(r3[n2 - 1], t2);
          var i2 = r3[0], o2 = 0, s2 = 0, u2 = e3.bitLength() % 26;
          for (u2 === 0 && (u2 = 26), n2 = e3.length - 1; n2 >= 0; n2--) {
            for (var c2 = e3.words[n2], f2 = u2 - 1; f2 >= 0; f2--) {
              var l2 = c2 >> f2 & 1;
              i2 !== r3[0] && (i2 = this.sqr(i2)), l2 !== 0 || o2 !== 0 ? (o2 <<= 1, o2 |= l2, (++s2 === 4 || n2 === 0 && f2 === 0) && (i2 = this.mul(i2, r3[o2]), s2 = 0, o2 = 0)) : s2 = 0;
            }
            u2 = 26;
          }
          return i2;
        }, j.prototype.convertTo = function(t2) {
          var e3 = t2.umod(this.m);
          return e3 === t2 ? e3.clone() : e3;
        }, j.prototype.convertFrom = function(t2) {
          var e3 = t2.clone();
          return e3.red = null, e3;
        }, a.mont = function(t2) {
          return new E(t2);
        }, o(E, j), E.prototype.convertTo = function(t2) {
          return this.imod(t2.ushln(this.shift));
        }, E.prototype.convertFrom = function(t2) {
          var e3 = this.imod(t2.mul(this.rinv));
          return e3.red = null, e3;
        }, E.prototype.imul = function(t2, e3) {
          if (t2.isZero() || e3.isZero())
            return t2.words[0] = 0, t2.length = 1, t2;
          var r3 = t2.imul(e3), n2 = r3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), i2 = r3.isub(n2).iushrn(this.shift), o2 = i2;
          return i2.cmp(this.m) >= 0 ? o2 = i2.isub(this.m) : i2.cmpn(0) < 0 && (o2 = i2.iadd(this.m)), o2._forceRed(this);
        }, E.prototype.mul = function(t2, e3) {
          if (t2.isZero() || e3.isZero())
            return new a(0)._forceRed(this);
          var r3 = t2.mul(e3), n2 = r3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), i2 = r3.isub(n2).iushrn(this.shift), o2 = i2;
          return i2.cmp(this.m) >= 0 ? o2 = i2.isub(this.m) : i2.cmpn(0) < 0 && (o2 = i2.iadd(this.m)), o2._forceRed(this);
        }, E.prototype.invm = function(t2) {
          return this.imod(t2._invmp(this.m).mul(this.r2))._forceRed(this);
        };
      }(e === void 0 || e);
    }, { buffer: 185 }], 184: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      var i;
      function o(t2) {
        this.rand = t2;
      }
      if (e.exports = function(t2) {
        return i || (i = new o(null)), i.generate(t2);
      }, e.exports.Rand = o, o.prototype.generate = function(t2) {
        return this._rand(t2);
      }, o.prototype._rand = function(t2) {
        if (this.rand.getBytes)
          return this.rand.getBytes(t2);
        for (var e2 = new Uint8Array(t2), r2 = 0; r2 < e2.length; r2++)
          e2[r2] = this.rand.getByte();
        return e2;
      }, (typeof self == "undefined" ? "undefined" : n(self)) === "object")
        self.crypto && self.crypto.getRandomValues ? o.prototype._rand = function(t2) {
          var e2 = new Uint8Array(t2);
          return self.crypto.getRandomValues(e2), e2;
        } : self.msCrypto && self.msCrypto.getRandomValues ? o.prototype._rand = function(t2) {
          var e2 = new Uint8Array(t2);
          return self.msCrypto.getRandomValues(e2), e2;
        } : (typeof window == "undefined" ? "undefined" : n(window)) === "object" && (o.prototype._rand = function() {
          throw new Error("Not implemented yet");
        });
      else
        try {
          var a = t("crypto");
          if (typeof a.randomBytes != "function")
            throw new Error("Not supported");
          o.prototype._rand = function(t2) {
            return a.randomBytes(t2);
          };
        } catch (t2) {
        }
    }, { crypto: 185 }], 185: [function(t, e, r) {
    }, {}], 186: [function(t, e, r) {
      var n = t("safe-buffer").Buffer;
      function i(t2) {
        n.isBuffer(t2) || (t2 = n.from(t2));
        for (var e2 = t2.length / 4 | 0, r2 = new Array(e2), i2 = 0; i2 < e2; i2++)
          r2[i2] = t2.readUInt32BE(4 * i2);
        return r2;
      }
      function o(t2) {
        for (; 0 < t2.length; t2++)
          t2[0] = 0;
      }
      function a(t2, e2, r2, n2, i2) {
        for (var o2, a2, s2, u2, c2 = r2[0], f = r2[1], l = r2[2], h = r2[3], d = t2[0] ^ e2[0], p = t2[1] ^ e2[1], m = t2[2] ^ e2[2], y = t2[3] ^ e2[3], b = 4, v = 1; v < i2; v++)
          o2 = c2[d >>> 24] ^ f[p >>> 16 & 255] ^ l[m >>> 8 & 255] ^ h[255 & y] ^ e2[b++], a2 = c2[p >>> 24] ^ f[m >>> 16 & 255] ^ l[y >>> 8 & 255] ^ h[255 & d] ^ e2[b++], s2 = c2[m >>> 24] ^ f[y >>> 16 & 255] ^ l[d >>> 8 & 255] ^ h[255 & p] ^ e2[b++], u2 = c2[y >>> 24] ^ f[d >>> 16 & 255] ^ l[p >>> 8 & 255] ^ h[255 & m] ^ e2[b++], d = o2, p = a2, m = s2, y = u2;
        return o2 = (n2[d >>> 24] << 24 | n2[p >>> 16 & 255] << 16 | n2[m >>> 8 & 255] << 8 | n2[255 & y]) ^ e2[b++], a2 = (n2[p >>> 24] << 24 | n2[m >>> 16 & 255] << 16 | n2[y >>> 8 & 255] << 8 | n2[255 & d]) ^ e2[b++], s2 = (n2[m >>> 24] << 24 | n2[y >>> 16 & 255] << 16 | n2[d >>> 8 & 255] << 8 | n2[255 & p]) ^ e2[b++], u2 = (n2[y >>> 24] << 24 | n2[d >>> 16 & 255] << 16 | n2[p >>> 8 & 255] << 8 | n2[255 & m]) ^ e2[b++], [o2 >>>= 0, a2 >>>= 0, s2 >>>= 0, u2 >>>= 0];
      }
      var s = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], u = function() {
        for (var t2 = new Array(256), e2 = 0; e2 < 256; e2++)
          t2[e2] = e2 < 128 ? e2 << 1 : e2 << 1 ^ 283;
        for (var r2 = [], n2 = [], i2 = [[], [], [], []], o2 = [[], [], [], []], a2 = 0, s2 = 0, u2 = 0; u2 < 256; ++u2) {
          var c2 = s2 ^ s2 << 1 ^ s2 << 2 ^ s2 << 3 ^ s2 << 4;
          c2 = c2 >>> 8 ^ 255 & c2 ^ 99, r2[a2] = c2, n2[c2] = a2;
          var f = t2[a2], l = t2[f], h = t2[l], d = 257 * t2[c2] ^ 16843008 * c2;
          i2[0][a2] = d << 24 | d >>> 8, i2[1][a2] = d << 16 | d >>> 16, i2[2][a2] = d << 8 | d >>> 24, i2[3][a2] = d, d = 16843009 * h ^ 65537 * l ^ 257 * f ^ 16843008 * a2, o2[0][c2] = d << 24 | d >>> 8, o2[1][c2] = d << 16 | d >>> 16, o2[2][c2] = d << 8 | d >>> 24, o2[3][c2] = d, a2 === 0 ? a2 = s2 = 1 : (a2 = f ^ t2[t2[t2[h ^ f]]], s2 ^= t2[t2[s2]]);
        }
        return { SBOX: r2, INV_SBOX: n2, SUB_MIX: i2, INV_SUB_MIX: o2 };
      }();
      function c(t2) {
        this._key = i(t2), this._reset();
      }
      c.blockSize = 16, c.keySize = 32, c.prototype.blockSize = c.blockSize, c.prototype.keySize = c.keySize, c.prototype._reset = function() {
        for (var t2 = this._key, e2 = t2.length, r2 = e2 + 6, n2 = 4 * (r2 + 1), i2 = [], o2 = 0; o2 < e2; o2++)
          i2[o2] = t2[o2];
        for (o2 = e2; o2 < n2; o2++) {
          var a2 = i2[o2 - 1];
          o2 % e2 == 0 ? (a2 = a2 << 8 | a2 >>> 24, a2 = u.SBOX[a2 >>> 24] << 24 | u.SBOX[a2 >>> 16 & 255] << 16 | u.SBOX[a2 >>> 8 & 255] << 8 | u.SBOX[255 & a2], a2 ^= s[o2 / e2 | 0] << 24) : e2 > 6 && o2 % e2 == 4 && (a2 = u.SBOX[a2 >>> 24] << 24 | u.SBOX[a2 >>> 16 & 255] << 16 | u.SBOX[a2 >>> 8 & 255] << 8 | u.SBOX[255 & a2]), i2[o2] = i2[o2 - e2] ^ a2;
        }
        for (var c2 = [], f = 0; f < n2; f++) {
          var l = n2 - f, h = i2[l - (f % 4 ? 0 : 4)];
          c2[f] = f < 4 || l <= 4 ? h : u.INV_SUB_MIX[0][u.SBOX[h >>> 24]] ^ u.INV_SUB_MIX[1][u.SBOX[h >>> 16 & 255]] ^ u.INV_SUB_MIX[2][u.SBOX[h >>> 8 & 255]] ^ u.INV_SUB_MIX[3][u.SBOX[255 & h]];
        }
        this._nRounds = r2, this._keySchedule = i2, this._invKeySchedule = c2;
      }, c.prototype.encryptBlockRaw = function(t2) {
        return a(t2 = i(t2), this._keySchedule, u.SUB_MIX, u.SBOX, this._nRounds);
      }, c.prototype.encryptBlock = function(t2) {
        var e2 = this.encryptBlockRaw(t2), r2 = n.allocUnsafe(16);
        return r2.writeUInt32BE(e2[0], 0), r2.writeUInt32BE(e2[1], 4), r2.writeUInt32BE(e2[2], 8), r2.writeUInt32BE(e2[3], 12), r2;
      }, c.prototype.decryptBlock = function(t2) {
        var e2 = (t2 = i(t2))[1];
        t2[1] = t2[3], t2[3] = e2;
        var r2 = a(t2, this._invKeySchedule, u.INV_SUB_MIX, u.INV_SBOX, this._nRounds), o2 = n.allocUnsafe(16);
        return o2.writeUInt32BE(r2[0], 0), o2.writeUInt32BE(r2[3], 4), o2.writeUInt32BE(r2[2], 8), o2.writeUInt32BE(r2[1], 12), o2;
      }, c.prototype.scrub = function() {
        o(this._keySchedule), o(this._invKeySchedule), o(this._key);
      }, e.exports.AES = c;
    }, { "safe-buffer": 494 }], 187: [function(t, e, r) {
      var n = t("./aes"), i = t("safe-buffer").Buffer, o = t("cipher-base"), a = t("inherits"), s = t("./ghash"), u = t("buffer-xor"), c = t("./incr32");
      function f(t2, e2, r2, a2) {
        o.call(this);
        var u2 = i.alloc(4, 0);
        this._cipher = new n.AES(e2);
        var f2 = this._cipher.encryptBlock(u2);
        this._ghash = new s(f2), r2 = function(t3, e3, r3) {
          if (e3.length === 12)
            return t3._finID = i.concat([e3, i.from([0, 0, 0, 1])]), i.concat([e3, i.from([0, 0, 0, 2])]);
          var n2 = new s(r3), o2 = e3.length, a3 = o2 % 16;
          n2.update(e3), a3 && (a3 = 16 - a3, n2.update(i.alloc(a3, 0))), n2.update(i.alloc(8, 0));
          var u3 = 8 * o2, f3 = i.alloc(8);
          f3.writeUIntBE(u3, 0, 8), n2.update(f3), t3._finID = n2.state;
          var l = i.from(t3._finID);
          return c(l), l;
        }(this, r2, f2), this._prev = i.from(r2), this._cache = i.allocUnsafe(0), this._secCache = i.allocUnsafe(0), this._decrypt = a2, this._alen = 0, this._len = 0, this._mode = t2, this._authTag = null, this._called = false;
      }
      a(f, o), f.prototype._update = function(t2) {
        if (!this._called && this._alen) {
          var e2 = 16 - this._alen % 16;
          e2 < 16 && (e2 = i.alloc(e2, 0), this._ghash.update(e2));
        }
        this._called = true;
        var r2 = this._mode.encrypt(this, t2);
        return this._decrypt ? this._ghash.update(t2) : this._ghash.update(r2), this._len += t2.length, r2;
      }, f.prototype._final = function() {
        if (this._decrypt && !this._authTag)
          throw new Error("Unsupported state or unable to authenticate data");
        var t2 = u(this._ghash.final(8 * this._alen, 8 * this._len), this._cipher.encryptBlock(this._finID));
        if (this._decrypt && function(t3, e2) {
          var r2 = 0;
          t3.length !== e2.length && r2++;
          for (var n2 = Math.min(t3.length, e2.length), i2 = 0; i2 < n2; ++i2)
            r2 += t3[i2] ^ e2[i2];
          return r2;
        }(t2, this._authTag))
          throw new Error("Unsupported state or unable to authenticate data");
        this._authTag = t2, this._cipher.scrub();
      }, f.prototype.getAuthTag = function() {
        if (this._decrypt || !i.isBuffer(this._authTag))
          throw new Error("Attempting to get auth tag in unsupported state");
        return this._authTag;
      }, f.prototype.setAuthTag = function(t2) {
        if (!this._decrypt)
          throw new Error("Attempting to set auth tag in unsupported state");
        this._authTag = t2;
      }, f.prototype.setAAD = function(t2) {
        if (this._called)
          throw new Error("Attempting to set AAD in unsupported state");
        this._ghash.update(t2), this._alen += t2.length;
      }, e.exports = f;
    }, { "./aes": 186, "./ghash": 191, "./incr32": 192, "buffer-xor": 217, "cipher-base": 218, inherits: 387, "safe-buffer": 494 }], 188: [function(t, e, r) {
      var n = t("./encrypter"), i = t("./decrypter"), o = t("./modes/list.json");
      r.createCipher = r.Cipher = n.createCipher, r.createCipheriv = r.Cipheriv = n.createCipheriv, r.createDecipher = r.Decipher = i.createDecipher, r.createDecipheriv = r.Decipheriv = i.createDecipheriv, r.listCiphers = r.getCiphers = function() {
        return Object.keys(o);
      };
    }, { "./decrypter": 189, "./encrypter": 190, "./modes/list.json": 200 }], 189: [function(t, e, r) {
      var n = t("./authCipher"), i = t("safe-buffer").Buffer, o = t("./modes"), a = t("./streamCipher"), s = t("cipher-base"), u = t("./aes"), c = t("evp_bytestokey");
      function f(t2, e2, r2) {
        s.call(this), this._cache = new l(), this._last = void 0, this._cipher = new u.AES(e2), this._prev = i.from(r2), this._mode = t2, this._autopadding = true;
      }
      function l() {
        this.cache = i.allocUnsafe(0);
      }
      function h(t2, e2, r2) {
        var s2 = o[t2.toLowerCase()];
        if (!s2)
          throw new TypeError("invalid suite type");
        if (typeof r2 == "string" && (r2 = i.from(r2)), s2.mode !== "GCM" && r2.length !== s2.iv)
          throw new TypeError("invalid iv length " + r2.length);
        if (typeof e2 == "string" && (e2 = i.from(e2)), e2.length !== s2.key / 8)
          throw new TypeError("invalid key length " + e2.length);
        return s2.type === "stream" ? new a(s2.module, e2, r2, true) : s2.type === "auth" ? new n(s2.module, e2, r2, true) : new f(s2.module, e2, r2);
      }
      t("inherits")(f, s), f.prototype._update = function(t2) {
        var e2, r2;
        this._cache.add(t2);
        for (var n2 = []; e2 = this._cache.get(this._autopadding); )
          r2 = this._mode.decrypt(this, e2), n2.push(r2);
        return i.concat(n2);
      }, f.prototype._final = function() {
        var t2 = this._cache.flush();
        if (this._autopadding)
          return function(t3) {
            var e2 = t3[15];
            if (e2 < 1 || e2 > 16)
              throw new Error("unable to decrypt data");
            var r2 = -1;
            for (; ++r2 < e2; )
              if (t3[r2 + (16 - e2)] !== e2)
                throw new Error("unable to decrypt data");
            if (e2 === 16)
              return;
            return t3.slice(0, 16 - e2);
          }(this._mode.decrypt(this, t2));
        if (t2)
          throw new Error("data not multiple of block length");
      }, f.prototype.setAutoPadding = function(t2) {
        return this._autopadding = !!t2, this;
      }, l.prototype.add = function(t2) {
        this.cache = i.concat([this.cache, t2]);
      }, l.prototype.get = function(t2) {
        var e2;
        if (t2) {
          if (this.cache.length > 16)
            return e2 = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e2;
        } else if (this.cache.length >= 16)
          return e2 = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e2;
        return null;
      }, l.prototype.flush = function() {
        if (this.cache.length)
          return this.cache;
      }, r.createDecipher = function(t2, e2) {
        var r2 = o[t2.toLowerCase()];
        if (!r2)
          throw new TypeError("invalid suite type");
        var n2 = c(e2, false, r2.key, r2.iv);
        return h(t2, n2.key, n2.iv);
      }, r.createDecipheriv = h;
    }, { "./aes": 186, "./authCipher": 187, "./modes": 199, "./streamCipher": 202, "cipher-base": 218, evp_bytestokey: 368, inherits: 387, "safe-buffer": 494 }], 190: [function(t, e, r) {
      var n = t("./modes"), i = t("./authCipher"), o = t("safe-buffer").Buffer, a = t("./streamCipher"), s = t("cipher-base"), u = t("./aes"), c = t("evp_bytestokey");
      function f(t2, e2, r2) {
        s.call(this), this._cache = new h(), this._cipher = new u.AES(e2), this._prev = o.from(r2), this._mode = t2, this._autopadding = true;
      }
      t("inherits")(f, s), f.prototype._update = function(t2) {
        var e2, r2;
        this._cache.add(t2);
        for (var n2 = []; e2 = this._cache.get(); )
          r2 = this._mode.encrypt(this, e2), n2.push(r2);
        return o.concat(n2);
      };
      var l = o.alloc(16, 16);
      function h() {
        this.cache = o.allocUnsafe(0);
      }
      function d(t2, e2, r2) {
        var s2 = n[t2.toLowerCase()];
        if (!s2)
          throw new TypeError("invalid suite type");
        if (typeof e2 == "string" && (e2 = o.from(e2)), e2.length !== s2.key / 8)
          throw new TypeError("invalid key length " + e2.length);
        if (typeof r2 == "string" && (r2 = o.from(r2)), s2.mode !== "GCM" && r2.length !== s2.iv)
          throw new TypeError("invalid iv length " + r2.length);
        return s2.type === "stream" ? new a(s2.module, e2, r2) : s2.type === "auth" ? new i(s2.module, e2, r2) : new f(s2.module, e2, r2);
      }
      f.prototype._final = function() {
        var t2 = this._cache.flush();
        if (this._autopadding)
          return t2 = this._mode.encrypt(this, t2), this._cipher.scrub(), t2;
        if (!t2.equals(l))
          throw this._cipher.scrub(), new Error("data not multiple of block length");
      }, f.prototype.setAutoPadding = function(t2) {
        return this._autopadding = !!t2, this;
      }, h.prototype.add = function(t2) {
        this.cache = o.concat([this.cache, t2]);
      }, h.prototype.get = function() {
        if (this.cache.length > 15) {
          var t2 = this.cache.slice(0, 16);
          return this.cache = this.cache.slice(16), t2;
        }
        return null;
      }, h.prototype.flush = function() {
        for (var t2 = 16 - this.cache.length, e2 = o.allocUnsafe(t2), r2 = -1; ++r2 < t2; )
          e2.writeUInt8(t2, r2);
        return o.concat([this.cache, e2]);
      }, r.createCipheriv = d, r.createCipher = function(t2, e2) {
        var r2 = n[t2.toLowerCase()];
        if (!r2)
          throw new TypeError("invalid suite type");
        var i2 = c(e2, false, r2.key, r2.iv);
        return d(t2, i2.key, i2.iv);
      };
    }, { "./aes": 186, "./authCipher": 187, "./modes": 199, "./streamCipher": 202, "cipher-base": 218, evp_bytestokey: 368, inherits: 387, "safe-buffer": 494 }], 191: [function(t, e, r) {
      var n = t("safe-buffer").Buffer, i = n.alloc(16, 0);
      function o(t2) {
        var e2 = n.allocUnsafe(16);
        return e2.writeUInt32BE(t2[0] >>> 0, 0), e2.writeUInt32BE(t2[1] >>> 0, 4), e2.writeUInt32BE(t2[2] >>> 0, 8), e2.writeUInt32BE(t2[3] >>> 0, 12), e2;
      }
      function a(t2) {
        this.h = t2, this.state = n.alloc(16, 0), this.cache = n.allocUnsafe(0);
      }
      a.prototype.ghash = function(t2) {
        for (var e2 = -1; ++e2 < t2.length; )
          this.state[e2] ^= t2[e2];
        this._multiply();
      }, a.prototype._multiply = function() {
        for (var t2, e2, r2, n2 = [(t2 = this.h).readUInt32BE(0), t2.readUInt32BE(4), t2.readUInt32BE(8), t2.readUInt32BE(12)], i2 = [0, 0, 0, 0], a2 = -1; ++a2 < 128; ) {
          for ((this.state[~~(a2 / 8)] & 1 << 7 - a2 % 8) != 0 && (i2[0] ^= n2[0], i2[1] ^= n2[1], i2[2] ^= n2[2], i2[3] ^= n2[3]), r2 = (1 & n2[3]) != 0, e2 = 3; e2 > 0; e2--)
            n2[e2] = n2[e2] >>> 1 | (1 & n2[e2 - 1]) << 31;
          n2[0] = n2[0] >>> 1, r2 && (n2[0] = n2[0] ^ 225 << 24);
        }
        this.state = o(i2);
      }, a.prototype.update = function(t2) {
        var e2;
        for (this.cache = n.concat([this.cache, t2]); this.cache.length >= 16; )
          e2 = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(e2);
      }, a.prototype.final = function(t2, e2) {
        return this.cache.length && this.ghash(n.concat([this.cache, i], 16)), this.ghash(o([0, t2, 0, e2])), this.state;
      }, e.exports = a;
    }, { "safe-buffer": 494 }], 192: [function(t, e, r) {
      e.exports = function(t2) {
        for (var e2, r2 = t2.length; r2--; ) {
          if ((e2 = t2.readUInt8(r2)) !== 255) {
            e2++, t2.writeUInt8(e2, r2);
            break;
          }
          t2.writeUInt8(0, r2);
        }
      };
    }, {}], 193: [function(t, e, r) {
      var n = t("buffer-xor");
      r.encrypt = function(t2, e2) {
        var r2 = n(e2, t2._prev);
        return t2._prev = t2._cipher.encryptBlock(r2), t2._prev;
      }, r.decrypt = function(t2, e2) {
        var r2 = t2._prev;
        t2._prev = e2;
        var i = t2._cipher.decryptBlock(e2);
        return n(i, r2);
      };
    }, { "buffer-xor": 217 }], 194: [function(t, e, r) {
      var n = t("safe-buffer").Buffer, i = t("buffer-xor");
      function o(t2, e2, r2) {
        var o2 = e2.length, a = i(e2, t2._cache);
        return t2._cache = t2._cache.slice(o2), t2._prev = n.concat([t2._prev, r2 ? e2 : a]), a;
      }
      r.encrypt = function(t2, e2, r2) {
        for (var i2, a = n.allocUnsafe(0); e2.length; ) {
          if (t2._cache.length === 0 && (t2._cache = t2._cipher.encryptBlock(t2._prev), t2._prev = n.allocUnsafe(0)), !(t2._cache.length <= e2.length)) {
            a = n.concat([a, o(t2, e2, r2)]);
            break;
          }
          i2 = t2._cache.length, a = n.concat([a, o(t2, e2.slice(0, i2), r2)]), e2 = e2.slice(i2);
        }
        return a;
      };
    }, { "buffer-xor": 217, "safe-buffer": 494 }], 195: [function(t, e, r) {
      var n = t("safe-buffer").Buffer;
      function i(t2, e2, r2) {
        for (var n2, i2, a = -1, s = 0; ++a < 8; )
          n2 = e2 & 1 << 7 - a ? 128 : 0, s += (128 & (i2 = t2._cipher.encryptBlock(t2._prev)[0] ^ n2)) >> a % 8, t2._prev = o(t2._prev, r2 ? n2 : i2);
        return s;
      }
      function o(t2, e2) {
        var r2 = t2.length, i2 = -1, o2 = n.allocUnsafe(t2.length);
        for (t2 = n.concat([t2, n.from([e2])]); ++i2 < r2; )
          o2[i2] = t2[i2] << 1 | t2[i2 + 1] >> 7;
        return o2;
      }
      r.encrypt = function(t2, e2, r2) {
        for (var o2 = e2.length, a = n.allocUnsafe(o2), s = -1; ++s < o2; )
          a[s] = i(t2, e2[s], r2);
        return a;
      };
    }, { "safe-buffer": 494 }], 196: [function(t, e, r) {
      var n = t("safe-buffer").Buffer;
      function i(t2, e2, r2) {
        var i2 = t2._cipher.encryptBlock(t2._prev)[0] ^ e2;
        return t2._prev = n.concat([t2._prev.slice(1), n.from([r2 ? e2 : i2])]), i2;
      }
      r.encrypt = function(t2, e2, r2) {
        for (var o = e2.length, a = n.allocUnsafe(o), s = -1; ++s < o; )
          a[s] = i(t2, e2[s], r2);
        return a;
      };
    }, { "safe-buffer": 494 }], 197: [function(t, e, r) {
      var n = t("buffer-xor"), i = t("safe-buffer").Buffer, o = t("../incr32");
      function a(t2) {
        var e2 = t2._cipher.encryptBlockRaw(t2._prev);
        return o(t2._prev), e2;
      }
      r.encrypt = function(t2, e2) {
        var r2 = Math.ceil(e2.length / 16), o2 = t2._cache.length;
        t2._cache = i.concat([t2._cache, i.allocUnsafe(16 * r2)]);
        for (var s = 0; s < r2; s++) {
          var u = a(t2), c = o2 + 16 * s;
          t2._cache.writeUInt32BE(u[0], c + 0), t2._cache.writeUInt32BE(u[1], c + 4), t2._cache.writeUInt32BE(u[2], c + 8), t2._cache.writeUInt32BE(u[3], c + 12);
        }
        var f = t2._cache.slice(0, e2.length);
        return t2._cache = t2._cache.slice(e2.length), n(e2, f);
      };
    }, { "../incr32": 192, "buffer-xor": 217, "safe-buffer": 494 }], 198: [function(t, e, r) {
      r.encrypt = function(t2, e2) {
        return t2._cipher.encryptBlock(e2);
      }, r.decrypt = function(t2, e2) {
        return t2._cipher.decryptBlock(e2);
      };
    }, {}], 199: [function(t, e, r) {
      var n = { ECB: t("./ecb"), CBC: t("./cbc"), CFB: t("./cfb"), CFB8: t("./cfb8"), CFB1: t("./cfb1"), OFB: t("./ofb"), CTR: t("./ctr"), GCM: t("./ctr") }, i = t("./list.json");
      for (var o in i)
        i[o].module = n[i[o].mode];
      e.exports = i;
    }, { "./cbc": 193, "./cfb": 194, "./cfb1": 195, "./cfb8": 196, "./ctr": 197, "./ecb": 198, "./list.json": 200, "./ofb": 201 }], 200: [function(t, e, r) {
      e.exports = { "aes-128-ecb": { cipher: "AES", key: 128, iv: 0, mode: "ECB", type: "block" }, "aes-192-ecb": { cipher: "AES", key: 192, iv: 0, mode: "ECB", type: "block" }, "aes-256-ecb": { cipher: "AES", key: 256, iv: 0, mode: "ECB", type: "block" }, "aes-128-cbc": { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, "aes-192-cbc": { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, "aes-256-cbc": { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, aes128: { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, aes192: { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, aes256: { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, "aes-128-cfb": { cipher: "AES", key: 128, iv: 16, mode: "CFB", type: "stream" }, "aes-192-cfb": { cipher: "AES", key: 192, iv: 16, mode: "CFB", type: "stream" }, "aes-256-cfb": { cipher: "AES", key: 256, iv: 16, mode: "CFB", type: "stream" }, "aes-128-cfb8": { cipher: "AES", key: 128, iv: 16, mode: "CFB8", type: "stream" }, "aes-192-cfb8": { cipher: "AES", key: 192, iv: 16, mode: "CFB8", type: "stream" }, "aes-256-cfb8": { cipher: "AES", key: 256, iv: 16, mode: "CFB8", type: "stream" }, "aes-128-cfb1": { cipher: "AES", key: 128, iv: 16, mode: "CFB1", type: "stream" }, "aes-192-cfb1": { cipher: "AES", key: 192, iv: 16, mode: "CFB1", type: "stream" }, "aes-256-cfb1": { cipher: "AES", key: 256, iv: 16, mode: "CFB1", type: "stream" }, "aes-128-ofb": { cipher: "AES", key: 128, iv: 16, mode: "OFB", type: "stream" }, "aes-192-ofb": { cipher: "AES", key: 192, iv: 16, mode: "OFB", type: "stream" }, "aes-256-ofb": { cipher: "AES", key: 256, iv: 16, mode: "OFB", type: "stream" }, "aes-128-ctr": { cipher: "AES", key: 128, iv: 16, mode: "CTR", type: "stream" }, "aes-192-ctr": { cipher: "AES", key: 192, iv: 16, mode: "CTR", type: "stream" }, "aes-256-ctr": { cipher: "AES", key: 256, iv: 16, mode: "CTR", type: "stream" }, "aes-128-gcm": { cipher: "AES", key: 128, iv: 12, mode: "GCM", type: "auth" }, "aes-192-gcm": { cipher: "AES", key: 192, iv: 12, mode: "GCM", type: "auth" }, "aes-256-gcm": { cipher: "AES", key: 256, iv: 12, mode: "GCM", type: "auth" } };
    }, {}], 201: [function(t, e, r) {
      (function(e2) {
        var n = t("buffer-xor");
        function i(t2) {
          return t2._prev = t2._cipher.encryptBlock(t2._prev), t2._prev;
        }
        r.encrypt = function(t2, r2) {
          for (; t2._cache.length < r2.length; )
            t2._cache = e2.concat([t2._cache, i(t2)]);
          var o = t2._cache.slice(0, r2.length);
          return t2._cache = t2._cache.slice(r2.length), n(r2, o);
        };
      }).call(this, t("buffer").Buffer);
    }, { buffer: 216, "buffer-xor": 217 }], 202: [function(t, e, r) {
      var n = t("./aes"), i = t("safe-buffer").Buffer, o = t("cipher-base");
      function a(t2, e2, r2, a2) {
        o.call(this), this._cipher = new n.AES(e2), this._prev = i.from(r2), this._cache = i.allocUnsafe(0), this._secCache = i.allocUnsafe(0), this._decrypt = a2, this._mode = t2;
      }
      t("inherits")(a, o), a.prototype._update = function(t2) {
        return this._mode.encrypt(this, t2, this._decrypt);
      }, a.prototype._final = function() {
        this._cipher.scrub();
      }, e.exports = a;
    }, { "./aes": 186, "cipher-base": 218, inherits: 387, "safe-buffer": 494 }], 203: [function(t, e, r) {
      var n = t("browserify-des"), i = t("browserify-aes/browser"), o = t("browserify-aes/modes"), a = t("browserify-des/modes"), s = t("evp_bytestokey");
      function u(t2, e2, r2) {
        if (t2 = t2.toLowerCase(), o[t2])
          return i.createCipheriv(t2, e2, r2);
        if (a[t2])
          return new n({ key: e2, iv: r2, mode: t2 });
        throw new TypeError("invalid suite type");
      }
      function c(t2, e2, r2) {
        if (t2 = t2.toLowerCase(), o[t2])
          return i.createDecipheriv(t2, e2, r2);
        if (a[t2])
          return new n({ key: e2, iv: r2, mode: t2, decrypt: true });
        throw new TypeError("invalid suite type");
      }
      r.createCipher = r.Cipher = function(t2, e2) {
        var r2, n2;
        if (t2 = t2.toLowerCase(), o[t2])
          r2 = o[t2].key, n2 = o[t2].iv;
        else {
          if (!a[t2])
            throw new TypeError("invalid suite type");
          r2 = 8 * a[t2].key, n2 = a[t2].iv;
        }
        var i2 = s(e2, false, r2, n2);
        return u(t2, i2.key, i2.iv);
      }, r.createCipheriv = r.Cipheriv = u, r.createDecipher = r.Decipher = function(t2, e2) {
        var r2, n2;
        if (t2 = t2.toLowerCase(), o[t2])
          r2 = o[t2].key, n2 = o[t2].iv;
        else {
          if (!a[t2])
            throw new TypeError("invalid suite type");
          r2 = 8 * a[t2].key, n2 = a[t2].iv;
        }
        var i2 = s(e2, false, r2, n2);
        return c(t2, i2.key, i2.iv);
      }, r.createDecipheriv = r.Decipheriv = c, r.listCiphers = r.getCiphers = function() {
        return Object.keys(a).concat(i.getCiphers());
      };
    }, { "browserify-aes/browser": 188, "browserify-aes/modes": 199, "browserify-des": 204, "browserify-des/modes": 205, evp_bytestokey: 368 }], 204: [function(t, e, r) {
      var n = t("cipher-base"), i = t("des.js"), o = t("inherits"), a = t("safe-buffer").Buffer, s = { "des-ede3-cbc": i.CBC.instantiate(i.EDE), "des-ede3": i.EDE, "des-ede-cbc": i.CBC.instantiate(i.EDE), "des-ede": i.EDE, "des-cbc": i.CBC.instantiate(i.DES), "des-ecb": i.DES };
      function u(t2) {
        n.call(this);
        var e2, r2 = t2.mode.toLowerCase(), i2 = s[r2];
        e2 = t2.decrypt ? "decrypt" : "encrypt";
        var o2 = t2.key;
        a.isBuffer(o2) || (o2 = a.from(o2)), r2 !== "des-ede" && r2 !== "des-ede-cbc" || (o2 = a.concat([o2, o2.slice(0, 8)]));
        var u2 = t2.iv;
        a.isBuffer(u2) || (u2 = a.from(u2)), this._des = i2.create({ key: o2, iv: u2, type: e2 });
      }
      s.des = s["des-cbc"], s.des3 = s["des-ede3-cbc"], e.exports = u, o(u, n), u.prototype._update = function(t2) {
        return a.from(this._des.update(t2));
      }, u.prototype._final = function() {
        return a.from(this._des.final());
      };
    }, { "cipher-base": 218, "des.js": 339, inherits: 387, "safe-buffer": 494 }], 205: [function(t, e, r) {
      r["des-ecb"] = { key: 8, iv: 0 }, r["des-cbc"] = r.des = { key: 8, iv: 8 }, r["des-ede3-cbc"] = r.des3 = { key: 24, iv: 8 }, r["des-ede3"] = { key: 24, iv: 0 }, r["des-ede-cbc"] = { key: 16, iv: 8 }, r["des-ede"] = { key: 16, iv: 0 };
    }, {}], 206: [function(t, e, r) {
      (function(r2) {
        var n = t("bn.js"), i = t("randombytes");
        function o(t2, e2) {
          var i2 = function(t3) {
            var e3 = a(t3);
            return { blinder: e3.toRed(n.mont(t3.modulus)).redPow(new n(t3.publicExponent)).fromRed(), unblinder: e3.invm(t3.modulus) };
          }(e2), o2 = e2.modulus.byteLength(), s = (n.mont(e2.modulus), new n(t2).mul(i2.blinder).umod(e2.modulus)), u = s.toRed(n.mont(e2.prime1)), c = s.toRed(n.mont(e2.prime2)), f = e2.coefficient, l = e2.prime1, h = e2.prime2, d = u.redPow(e2.exponent1), p = c.redPow(e2.exponent2);
          d = d.fromRed(), p = p.fromRed();
          var m = d.isub(p).imul(f).umod(l);
          return m.imul(h), p.iadd(m), new r2(p.imul(i2.unblinder).umod(e2.modulus).toArray(false, o2));
        }
        function a(t2) {
          for (var e2 = t2.modulus.byteLength(), r3 = new n(i(e2)); r3.cmp(t2.modulus) >= 0 || !r3.umod(t2.prime1) || !r3.umod(t2.prime2); )
            r3 = new n(i(e2));
          return r3;
        }
        e.exports = o, o.getr = a;
      }).call(this, t("buffer").Buffer);
    }, { "bn.js": 207, buffer: 216, randombytes: 475 }], 207: [function(t, e, r) {
      arguments[4][181][0].apply(r, arguments);
    }, { buffer: 185, dup: 181 }], 208: [function(t, e, r) {
      e.exports = t("./browser/algorithms.json");
    }, { "./browser/algorithms.json": 209 }], 209: [function(t, e, r) {
      e.exports = { sha224WithRSAEncryption: { sign: "rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, "RSA-SHA224": { sign: "ecdsa/rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, sha256WithRSAEncryption: { sign: "rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, "RSA-SHA256": { sign: "ecdsa/rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, sha384WithRSAEncryption: { sign: "rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, "RSA-SHA384": { sign: "ecdsa/rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, sha512WithRSAEncryption: { sign: "rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA512": { sign: "ecdsa/rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA1": { sign: "rsa", hash: "sha1", id: "3021300906052b0e03021a05000414" }, "ecdsa-with-SHA1": { sign: "ecdsa", hash: "sha1", id: "" }, sha256: { sign: "ecdsa", hash: "sha256", id: "" }, sha224: { sign: "ecdsa", hash: "sha224", id: "" }, sha384: { sign: "ecdsa", hash: "sha384", id: "" }, sha512: { sign: "ecdsa", hash: "sha512", id: "" }, "DSA-SHA": { sign: "dsa", hash: "sha1", id: "" }, "DSA-SHA1": { sign: "dsa", hash: "sha1", id: "" }, DSA: { sign: "dsa", hash: "sha1", id: "" }, "DSA-WITH-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-WITH-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-WITH-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-WITH-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-RIPEMD160": { sign: "dsa", hash: "rmd160", id: "" }, ripemd160WithRSA: { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, "RSA-RIPEMD160": { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, md5WithRSAEncryption: { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" }, "RSA-MD5": { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" } };
    }, {}], 210: [function(t, e, r) {
      e.exports = { "1.3.132.0.10": "secp256k1", "1.3.132.0.33": "p224", "1.2.840.10045.3.1.1": "p192", "1.2.840.10045.3.1.7": "p256", "1.3.132.0.34": "p384", "1.3.132.0.35": "p521" };
    }, {}], 211: [function(t, e, r) {
      var n = t("safe-buffer").Buffer, i = t("create-hash"), o = t("readable-stream"), a = t("inherits"), s = t("./sign"), u = t("./verify"), c = t("./algorithms.json");
      function f(t2) {
        o.Writable.call(this);
        var e2 = c[t2];
        if (!e2)
          throw new Error("Unknown message digest");
        this._hashType = e2.hash, this._hash = i(e2.hash), this._tag = e2.id, this._signType = e2.sign;
      }
      function l(t2) {
        o.Writable.call(this);
        var e2 = c[t2];
        if (!e2)
          throw new Error("Unknown message digest");
        this._hash = i(e2.hash), this._tag = e2.id, this._signType = e2.sign;
      }
      function h(t2) {
        return new f(t2);
      }
      function d(t2) {
        return new l(t2);
      }
      Object.keys(c).forEach(function(t2) {
        c[t2].id = n.from(c[t2].id, "hex"), c[t2.toLowerCase()] = c[t2];
      }), a(f, o.Writable), f.prototype._write = function(t2, e2, r2) {
        this._hash.update(t2), r2();
      }, f.prototype.update = function(t2, e2) {
        return typeof t2 == "string" && (t2 = n.from(t2, e2)), this._hash.update(t2), this;
      }, f.prototype.sign = function(t2, e2) {
        this.end();
        var r2 = this._hash.digest(), n2 = s(r2, t2, this._hashType, this._signType, this._tag);
        return e2 ? n2.toString(e2) : n2;
      }, a(l, o.Writable), l.prototype._write = function(t2, e2, r2) {
        this._hash.update(t2), r2();
      }, l.prototype.update = function(t2, e2) {
        return typeof t2 == "string" && (t2 = n.from(t2, e2)), this._hash.update(t2), this;
      }, l.prototype.verify = function(t2, e2, r2) {
        typeof e2 == "string" && (e2 = n.from(e2, r2)), this.end();
        var i2 = this._hash.digest();
        return u(e2, i2, t2, this._signType, this._tag);
      }, e.exports = { Sign: h, Verify: d, createSign: h, createVerify: d };
    }, { "./algorithms.json": 209, "./sign": 212, "./verify": 213, "create-hash": 331, inherits: 387, "readable-stream": 491, "safe-buffer": 214 }], 212: [function(t, e, r) {
      var n = t("safe-buffer").Buffer, i = t("create-hmac"), o = t("browserify-rsa"), a = t("elliptic").ec, s = t("bn.js"), u = t("parse-asn1"), c = t("./curves.json");
      function f(t2, e2, r2, o2) {
        if ((t2 = n.from(t2.toArray())).length < e2.byteLength()) {
          var a2 = n.alloc(e2.byteLength() - t2.length);
          t2 = n.concat([a2, t2]);
        }
        var s2 = r2.length, u2 = function(t3, e3) {
          t3 = (t3 = l(t3, e3)).mod(e3);
          var r3 = n.from(t3.toArray());
          if (r3.length < e3.byteLength()) {
            var i2 = n.alloc(e3.byteLength() - r3.length);
            r3 = n.concat([i2, r3]);
          }
          return r3;
        }(r2, e2), c2 = n.alloc(s2);
        c2.fill(1);
        var f2 = n.alloc(s2);
        return f2 = i(o2, f2).update(c2).update(n.from([0])).update(t2).update(u2).digest(), c2 = i(o2, f2).update(c2).digest(), { k: f2 = i(o2, f2).update(c2).update(n.from([1])).update(t2).update(u2).digest(), v: c2 = i(o2, f2).update(c2).digest() };
      }
      function l(t2, e2) {
        var r2 = new s(t2), n2 = (t2.length << 3) - e2.bitLength();
        return n2 > 0 && r2.ishrn(n2), r2;
      }
      function h(t2, e2, r2) {
        var o2, a2;
        do {
          for (o2 = n.alloc(0); 8 * o2.length < t2.bitLength(); )
            e2.v = i(r2, e2.k).update(e2.v).digest(), o2 = n.concat([o2, e2.v]);
          a2 = l(o2, t2), e2.k = i(r2, e2.k).update(e2.v).update(n.from([0])).digest(), e2.v = i(r2, e2.k).update(e2.v).digest();
        } while (a2.cmp(t2) !== -1);
        return a2;
      }
      function d(t2, e2, r2, n2) {
        return t2.toRed(s.mont(r2)).redPow(e2).fromRed().mod(n2);
      }
      e.exports = function(t2, e2, r2, i2, p) {
        var m = u(e2);
        if (m.curve) {
          if (i2 !== "ecdsa" && i2 !== "ecdsa/rsa")
            throw new Error("wrong private key type");
          return function(t3, e3) {
            var r3 = c[e3.curve.join(".")];
            if (!r3)
              throw new Error("unknown curve " + e3.curve.join("."));
            var i3 = new a(r3).keyFromPrivate(e3.privateKey).sign(t3);
            return n.from(i3.toDER());
          }(t2, m);
        }
        if (m.type === "dsa") {
          if (i2 !== "dsa")
            throw new Error("wrong private key type");
          return function(t3, e3, r3) {
            var i3, o2 = e3.params.priv_key, a2 = e3.params.p, u2 = e3.params.q, c2 = e3.params.g, p2 = new s(0), m2 = l(t3, u2).mod(u2), y2 = false, b2 = f(o2, u2, t3, r3);
            for (; y2 === false; )
              i3 = h(u2, b2, r3), p2 = d(c2, i3, a2, u2), (y2 = i3.invm(u2).imul(m2.add(o2.mul(p2))).mod(u2)).cmpn(0) === 0 && (y2 = false, p2 = new s(0));
            return function(t4, e4) {
              t4 = t4.toArray(), e4 = e4.toArray(), 128 & t4[0] && (t4 = [0].concat(t4));
              128 & e4[0] && (e4 = [0].concat(e4));
              var r4 = [48, t4.length + e4.length + 4, 2, t4.length];
              return r4 = r4.concat(t4, [2, e4.length], e4), n.from(r4);
            }(p2, y2);
          }(t2, m, r2);
        }
        if (i2 !== "rsa" && i2 !== "ecdsa/rsa")
          throw new Error("wrong private key type");
        t2 = n.concat([p, t2]);
        for (var y = m.modulus.byteLength(), b = [0, 1]; t2.length + b.length + 1 < y; )
          b.push(255);
        b.push(0);
        for (var v = -1; ++v < t2.length; )
          b.push(t2[v]);
        return o(b, m);
      }, e.exports.getKey = f, e.exports.makeKey = h;
    }, { "./curves.json": 210, "bn.js": 183, "browserify-rsa": 206, "create-hmac": 333, elliptic: 350, "parse-asn1": 459, "safe-buffer": 214 }], 213: [function(t, e, r) {
      var n = t("safe-buffer").Buffer, i = t("bn.js"), o = t("elliptic").ec, a = t("parse-asn1"), s = t("./curves.json");
      function u(t2, e2) {
        if (t2.cmpn(0) <= 0)
          throw new Error("invalid sig");
        if (t2.cmp(e2) >= e2)
          throw new Error("invalid sig");
      }
      e.exports = function(t2, e2, r2, c, f) {
        var l = a(r2);
        if (l.type === "ec") {
          if (c !== "ecdsa" && c !== "ecdsa/rsa")
            throw new Error("wrong public key type");
          return function(t3, e3, r3) {
            var n2 = s[r3.data.algorithm.curve.join(".")];
            if (!n2)
              throw new Error("unknown curve " + r3.data.algorithm.curve.join("."));
            var i2 = new o(n2), a2 = r3.data.subjectPrivateKey.data;
            return i2.verify(e3, t3, a2);
          }(t2, e2, l);
        }
        if (l.type === "dsa") {
          if (c !== "dsa")
            throw new Error("wrong public key type");
          return function(t3, e3, r3) {
            var n2 = r3.data.p, o2 = r3.data.q, s2 = r3.data.g, c2 = r3.data.pub_key, f2 = a.signature.decode(t3, "der"), l2 = f2.s, h2 = f2.r;
            u(l2, o2), u(h2, o2);
            var d2 = i.mont(n2), p2 = l2.invm(o2);
            return s2.toRed(d2).redPow(new i(e3).mul(p2).mod(o2)).fromRed().mul(c2.toRed(d2).redPow(h2.mul(p2).mod(o2)).fromRed()).mod(n2).mod(o2).cmp(h2) === 0;
          }(t2, e2, l);
        }
        if (c !== "rsa" && c !== "ecdsa/rsa")
          throw new Error("wrong public key type");
        e2 = n.concat([f, e2]);
        for (var h = l.modulus.byteLength(), d = [1], p = 0; e2.length + d.length + 2 < h; )
          d.push(255), p++;
        d.push(0);
        for (var m = -1; ++m < e2.length; )
          d.push(e2[m]);
        d = n.from(d);
        var y = i.mont(l.modulus);
        t2 = (t2 = new i(t2).toRed(y)).redPow(new i(l.publicExponent)), t2 = n.from(t2.fromRed().toArray());
        var b = p < 8 ? 1 : 0;
        for (h = Math.min(t2.length, d.length), t2.length !== d.length && (b = 1), m = -1; ++m < h; )
          b |= t2[m] ^ d[m];
        return b === 0;
      };
    }, { "./curves.json": 210, "bn.js": 183, elliptic: 350, "parse-asn1": 459, "safe-buffer": 214 }], 214: [function(t, e, r) {
      /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
      var n = t("buffer"), i = n.Buffer;
      function o(t2, e2) {
        for (var r2 in t2)
          e2[r2] = t2[r2];
      }
      function a(t2, e2, r2) {
        return i(t2, e2, r2);
      }
      i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? e.exports = n : (o(n, r), r.Buffer = a), a.prototype = Object.create(i.prototype), o(i, a), a.from = function(t2, e2, r2) {
        if (typeof t2 == "number")
          throw new TypeError("Argument must not be a number");
        return i(t2, e2, r2);
      }, a.alloc = function(t2, e2, r2) {
        if (typeof t2 != "number")
          throw new TypeError("Argument must be a number");
        var n2 = i(t2);
        return e2 !== void 0 ? typeof r2 == "string" ? n2.fill(e2, r2) : n2.fill(e2) : n2.fill(0), n2;
      }, a.allocUnsafe = function(t2) {
        if (typeof t2 != "number")
          throw new TypeError("Argument must be a number");
        return i(t2);
      }, a.allocUnsafeSlow = function(t2) {
        if (typeof t2 != "number")
          throw new TypeError("Argument must be a number");
        return n.SlowBuffer(t2);
      };
    }, { buffer: 216 }], 215: [function(t, e, r) {
      arguments[4][185][0].apply(r, arguments);
    }, { dup: 185 }], 216: [function(t, e, r) {
      (function(e2) {
        function n(t2) {
          return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
            return typeof t3;
          } : function(t3) {
            return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
          })(t2);
        }
        var i = t("base64-js"), o = t("ieee754");
        r.Buffer = e2, r.SlowBuffer = function(t2) {
          +t2 != t2 && (t2 = 0);
          return e2.alloc(+t2);
        }, r.INSPECT_MAX_BYTES = 50;
        function a(t2) {
          if (t2 > 2147483647)
            throw new RangeError('The value "' + t2 + '" is invalid for option "size"');
          var r2 = new Uint8Array(t2);
          return r2.__proto__ = e2.prototype, r2;
        }
        function e2(t2, e3, r2) {
          if (typeof t2 == "number") {
            if (typeof e3 == "string")
              throw new TypeError('The "string" argument must be of type string. Received type number');
            return c(t2);
          }
          return s(t2, e3, r2);
        }
        function s(t2, r2, i2) {
          if (typeof t2 == "string")
            return function(t3, r3) {
              typeof r3 == "string" && r3 !== "" || (r3 = "utf8");
              if (!e2.isEncoding(r3))
                throw new TypeError("Unknown encoding: " + r3);
              var n2 = 0 | h(t3, r3), i3 = a(n2), o3 = i3.write(t3, r3);
              o3 !== n2 && (i3 = i3.slice(0, o3));
              return i3;
            }(t2, r2);
          if (ArrayBuffer.isView(t2))
            return f(t2);
          if (t2 == null)
            throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + n(t2));
          if (L(t2, ArrayBuffer) || t2 && L(t2.buffer, ArrayBuffer))
            return function(t3, r3, n2) {
              if (r3 < 0 || t3.byteLength < r3)
                throw new RangeError('"offset" is outside of buffer bounds');
              if (t3.byteLength < r3 + (n2 || 0))
                throw new RangeError('"length" is outside of buffer bounds');
              var i3;
              i3 = r3 === void 0 && n2 === void 0 ? new Uint8Array(t3) : n2 === void 0 ? new Uint8Array(t3, r3) : new Uint8Array(t3, r3, n2);
              return i3.__proto__ = e2.prototype, i3;
            }(t2, r2, i2);
          if (typeof t2 == "number")
            throw new TypeError('The "value" argument must not be of type number. Received type number');
          var o2 = t2.valueOf && t2.valueOf();
          if (o2 != null && o2 !== t2)
            return e2.from(o2, r2, i2);
          var s2 = function(t3) {
            if (e2.isBuffer(t3)) {
              var r3 = 0 | l(t3.length), n2 = a(r3);
              return n2.length === 0 || t3.copy(n2, 0, 0, r3), n2;
            }
            if (t3.length !== void 0)
              return typeof t3.length != "number" || z(t3.length) ? a(0) : f(t3);
            if (t3.type === "Buffer" && Array.isArray(t3.data))
              return f(t3.data);
          }(t2);
          if (s2)
            return s2;
          if (typeof Symbol != "undefined" && Symbol.toPrimitive != null && typeof t2[Symbol.toPrimitive] == "function")
            return e2.from(t2[Symbol.toPrimitive]("string"), r2, i2);
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + n(t2));
        }
        function u(t2) {
          if (typeof t2 != "number")
            throw new TypeError('"size" argument must be of type number');
          if (t2 < 0)
            throw new RangeError('The value "' + t2 + '" is invalid for option "size"');
        }
        function c(t2) {
          return u(t2), a(t2 < 0 ? 0 : 0 | l(t2));
        }
        function f(t2) {
          for (var e3 = t2.length < 0 ? 0 : 0 | l(t2.length), r2 = a(e3), n2 = 0; n2 < e3; n2 += 1)
            r2[n2] = 255 & t2[n2];
          return r2;
        }
        function l(t2) {
          if (t2 >= 2147483647)
            throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647 .toString(16) + " bytes");
          return 0 | t2;
        }
        function h(t2, r2) {
          if (e2.isBuffer(t2))
            return t2.length;
          if (ArrayBuffer.isView(t2) || L(t2, ArrayBuffer))
            return t2.byteLength;
          if (typeof t2 != "string")
            throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + n(t2));
          var i2 = t2.length, o2 = arguments.length > 2 && arguments[2] === true;
          if (!o2 && i2 === 0)
            return 0;
          for (var a2 = false; ; )
            switch (r2) {
              case "ascii":
              case "latin1":
              case "binary":
                return i2;
              case "utf8":
              case "utf-8":
                return D(t2).length;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return 2 * i2;
              case "hex":
                return i2 >>> 1;
              case "base64":
                return B(t2).length;
              default:
                if (a2)
                  return o2 ? -1 : D(t2).length;
                r2 = ("" + r2).toLowerCase(), a2 = true;
            }
        }
        function d(t2, e3, r2) {
          var n2 = false;
          if ((e3 === void 0 || e3 < 0) && (e3 = 0), e3 > this.length)
            return "";
          if ((r2 === void 0 || r2 > this.length) && (r2 = this.length), r2 <= 0)
            return "";
          if ((r2 >>>= 0) <= (e3 >>>= 0))
            return "";
          for (t2 || (t2 = "utf8"); ; )
            switch (t2) {
              case "hex":
                return E(this, e3, r2);
              case "utf8":
              case "utf-8":
                return S(this, e3, r2);
              case "ascii":
                return O(this, e3, r2);
              case "latin1":
              case "binary":
                return j(this, e3, r2);
              case "base64":
                return x(this, e3, r2);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return R(this, e3, r2);
              default:
                if (n2)
                  throw new TypeError("Unknown encoding: " + t2);
                t2 = (t2 + "").toLowerCase(), n2 = true;
            }
        }
        function p(t2, e3, r2) {
          var n2 = t2[e3];
          t2[e3] = t2[r2], t2[r2] = n2;
        }
        function m(t2, r2, n2, i2, o2) {
          if (t2.length === 0)
            return -1;
          if (typeof n2 == "string" ? (i2 = n2, n2 = 0) : n2 > 2147483647 ? n2 = 2147483647 : n2 < -2147483648 && (n2 = -2147483648), z(n2 = +n2) && (n2 = o2 ? 0 : t2.length - 1), n2 < 0 && (n2 = t2.length + n2), n2 >= t2.length) {
            if (o2)
              return -1;
            n2 = t2.length - 1;
          } else if (n2 < 0) {
            if (!o2)
              return -1;
            n2 = 0;
          }
          if (typeof r2 == "string" && (r2 = e2.from(r2, i2)), e2.isBuffer(r2))
            return r2.length === 0 ? -1 : y(t2, r2, n2, i2, o2);
          if (typeof r2 == "number")
            return r2 &= 255, typeof Uint8Array.prototype.indexOf == "function" ? o2 ? Uint8Array.prototype.indexOf.call(t2, r2, n2) : Uint8Array.prototype.lastIndexOf.call(t2, r2, n2) : y(t2, [r2], n2, i2, o2);
          throw new TypeError("val must be string, number or Buffer");
        }
        function y(t2, e3, r2, n2, i2) {
          var o2, a2 = 1, s2 = t2.length, u2 = e3.length;
          if (n2 !== void 0 && ((n2 = String(n2).toLowerCase()) === "ucs2" || n2 === "ucs-2" || n2 === "utf16le" || n2 === "utf-16le")) {
            if (t2.length < 2 || e3.length < 2)
              return -1;
            a2 = 2, s2 /= 2, u2 /= 2, r2 /= 2;
          }
          function c2(t3, e4) {
            return a2 === 1 ? t3[e4] : t3.readUInt16BE(e4 * a2);
          }
          if (i2) {
            var f2 = -1;
            for (o2 = r2; o2 < s2; o2++)
              if (c2(t2, o2) === c2(e3, f2 === -1 ? 0 : o2 - f2)) {
                if (f2 === -1 && (f2 = o2), o2 - f2 + 1 === u2)
                  return f2 * a2;
              } else
                f2 !== -1 && (o2 -= o2 - f2), f2 = -1;
          } else
            for (r2 + u2 > s2 && (r2 = s2 - u2), o2 = r2; o2 >= 0; o2--) {
              for (var l2 = true, h2 = 0; h2 < u2; h2++)
                if (c2(t2, o2 + h2) !== c2(e3, h2)) {
                  l2 = false;
                  break;
                }
              if (l2)
                return o2;
            }
          return -1;
        }
        function b(t2, e3, r2, n2) {
          r2 = Number(r2) || 0;
          var i2 = t2.length - r2;
          n2 ? (n2 = Number(n2)) > i2 && (n2 = i2) : n2 = i2;
          var o2 = e3.length;
          n2 > o2 / 2 && (n2 = o2 / 2);
          for (var a2 = 0; a2 < n2; ++a2) {
            var s2 = parseInt(e3.substr(2 * a2, 2), 16);
            if (z(s2))
              return a2;
            t2[r2 + a2] = s2;
          }
          return a2;
        }
        function v(t2, e3, r2, n2) {
          return F(D(e3, t2.length - r2), t2, r2, n2);
        }
        function g(t2, e3, r2, n2) {
          return F(function(t3) {
            for (var e4 = [], r3 = 0; r3 < t3.length; ++r3)
              e4.push(255 & t3.charCodeAt(r3));
            return e4;
          }(e3), t2, r2, n2);
        }
        function w(t2, e3, r2, n2) {
          return g(t2, e3, r2, n2);
        }
        function _(t2, e3, r2, n2) {
          return F(B(e3), t2, r2, n2);
        }
        function k(t2, e3, r2, n2) {
          return F(function(t3, e4) {
            for (var r3, n3, i2, o2 = [], a2 = 0; a2 < t3.length && !((e4 -= 2) < 0); ++a2)
              r3 = t3.charCodeAt(a2), n3 = r3 >> 8, i2 = r3 % 256, o2.push(i2), o2.push(n3);
            return o2;
          }(e3, t2.length - r2), t2, r2, n2);
        }
        function x(t2, e3, r2) {
          return e3 === 0 && r2 === t2.length ? i.fromByteArray(t2) : i.fromByteArray(t2.slice(e3, r2));
        }
        function S(t2, e3, r2) {
          r2 = Math.min(t2.length, r2);
          for (var n2 = [], i2 = e3; i2 < r2; ) {
            var o2, a2, s2, u2, c2 = t2[i2], f2 = null, l2 = c2 > 239 ? 4 : c2 > 223 ? 3 : c2 > 191 ? 2 : 1;
            if (i2 + l2 <= r2)
              switch (l2) {
                case 1:
                  c2 < 128 && (f2 = c2);
                  break;
                case 2:
                  (192 & (o2 = t2[i2 + 1])) == 128 && (u2 = (31 & c2) << 6 | 63 & o2) > 127 && (f2 = u2);
                  break;
                case 3:
                  o2 = t2[i2 + 1], a2 = t2[i2 + 2], (192 & o2) == 128 && (192 & a2) == 128 && (u2 = (15 & c2) << 12 | (63 & o2) << 6 | 63 & a2) > 2047 && (u2 < 55296 || u2 > 57343) && (f2 = u2);
                  break;
                case 4:
                  o2 = t2[i2 + 1], a2 = t2[i2 + 2], s2 = t2[i2 + 3], (192 & o2) == 128 && (192 & a2) == 128 && (192 & s2) == 128 && (u2 = (15 & c2) << 18 | (63 & o2) << 12 | (63 & a2) << 6 | 63 & s2) > 65535 && u2 < 1114112 && (f2 = u2);
              }
            f2 === null ? (f2 = 65533, l2 = 1) : f2 > 65535 && (f2 -= 65536, n2.push(f2 >>> 10 & 1023 | 55296), f2 = 56320 | 1023 & f2), n2.push(f2), i2 += l2;
          }
          return function(t3) {
            var e4 = t3.length;
            if (e4 <= 4096)
              return String.fromCharCode.apply(String, t3);
            var r3 = "", n3 = 0;
            for (; n3 < e4; )
              r3 += String.fromCharCode.apply(String, t3.slice(n3, n3 += 4096));
            return r3;
          }(n2);
        }
        r.kMaxLength = 2147483647, e2.TYPED_ARRAY_SUPPORT = function() {
          try {
            var t2 = new Uint8Array(1);
            return t2.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
              return 42;
            } }, t2.foo() === 42;
          } catch (t3) {
            return false;
          }
        }(), e2.TYPED_ARRAY_SUPPORT || typeof console == "undefined" || typeof console.error != "function" || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(e2.prototype, "parent", { enumerable: true, get: function() {
          if (e2.isBuffer(this))
            return this.buffer;
        } }), Object.defineProperty(e2.prototype, "offset", { enumerable: true, get: function() {
          if (e2.isBuffer(this))
            return this.byteOffset;
        } }), typeof Symbol != "undefined" && Symbol.species != null && e2[Symbol.species] === e2 && Object.defineProperty(e2, Symbol.species, { value: null, configurable: true, enumerable: false, writable: false }), e2.poolSize = 8192, e2.from = function(t2, e3, r2) {
          return s(t2, e3, r2);
        }, e2.prototype.__proto__ = Uint8Array.prototype, e2.__proto__ = Uint8Array, e2.alloc = function(t2, e3, r2) {
          return function(t3, e4, r3) {
            return u(t3), t3 <= 0 ? a(t3) : e4 !== void 0 ? typeof r3 == "string" ? a(t3).fill(e4, r3) : a(t3).fill(e4) : a(t3);
          }(t2, e3, r2);
        }, e2.allocUnsafe = function(t2) {
          return c(t2);
        }, e2.allocUnsafeSlow = function(t2) {
          return c(t2);
        }, e2.isBuffer = function(t2) {
          return t2 != null && t2._isBuffer === true && t2 !== e2.prototype;
        }, e2.compare = function(t2, r2) {
          if (L(t2, Uint8Array) && (t2 = e2.from(t2, t2.offset, t2.byteLength)), L(r2, Uint8Array) && (r2 = e2.from(r2, r2.offset, r2.byteLength)), !e2.isBuffer(t2) || !e2.isBuffer(r2))
            throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
          if (t2 === r2)
            return 0;
          for (var n2 = t2.length, i2 = r2.length, o2 = 0, a2 = Math.min(n2, i2); o2 < a2; ++o2)
            if (t2[o2] !== r2[o2]) {
              n2 = t2[o2], i2 = r2[o2];
              break;
            }
          return n2 < i2 ? -1 : i2 < n2 ? 1 : 0;
        }, e2.isEncoding = function(t2) {
          switch (String(t2).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return true;
            default:
              return false;
          }
        }, e2.concat = function(t2, r2) {
          if (!Array.isArray(t2))
            throw new TypeError('"list" argument must be an Array of Buffers');
          if (t2.length === 0)
            return e2.alloc(0);
          var n2;
          if (r2 === void 0)
            for (r2 = 0, n2 = 0; n2 < t2.length; ++n2)
              r2 += t2[n2].length;
          var i2 = e2.allocUnsafe(r2), o2 = 0;
          for (n2 = 0; n2 < t2.length; ++n2) {
            var a2 = t2[n2];
            if (L(a2, Uint8Array) && (a2 = e2.from(a2)), !e2.isBuffer(a2))
              throw new TypeError('"list" argument must be an Array of Buffers');
            a2.copy(i2, o2), o2 += a2.length;
          }
          return i2;
        }, e2.byteLength = h, e2.prototype._isBuffer = true, e2.prototype.swap16 = function() {
          var t2 = this.length;
          if (t2 % 2 != 0)
            throw new RangeError("Buffer size must be a multiple of 16-bits");
          for (var e3 = 0; e3 < t2; e3 += 2)
            p(this, e3, e3 + 1);
          return this;
        }, e2.prototype.swap32 = function() {
          var t2 = this.length;
          if (t2 % 4 != 0)
            throw new RangeError("Buffer size must be a multiple of 32-bits");
          for (var e3 = 0; e3 < t2; e3 += 4)
            p(this, e3, e3 + 3), p(this, e3 + 1, e3 + 2);
          return this;
        }, e2.prototype.swap64 = function() {
          var t2 = this.length;
          if (t2 % 8 != 0)
            throw new RangeError("Buffer size must be a multiple of 64-bits");
          for (var e3 = 0; e3 < t2; e3 += 8)
            p(this, e3, e3 + 7), p(this, e3 + 1, e3 + 6), p(this, e3 + 2, e3 + 5), p(this, e3 + 3, e3 + 4);
          return this;
        }, e2.prototype.toString = function() {
          var t2 = this.length;
          return t2 === 0 ? "" : arguments.length === 0 ? S(this, 0, t2) : d.apply(this, arguments);
        }, e2.prototype.toLocaleString = e2.prototype.toString, e2.prototype.equals = function(t2) {
          if (!e2.isBuffer(t2))
            throw new TypeError("Argument must be a Buffer");
          return this === t2 || e2.compare(this, t2) === 0;
        }, e2.prototype.inspect = function() {
          var t2 = "", e3 = r.INSPECT_MAX_BYTES;
          return t2 = this.toString("hex", 0, e3).replace(/(.{2})/g, "$1 ").trim(), this.length > e3 && (t2 += " ... "), "<Buffer " + t2 + ">";
        }, e2.prototype.compare = function(t2, r2, i2, o2, a2) {
          if (L(t2, Uint8Array) && (t2 = e2.from(t2, t2.offset, t2.byteLength)), !e2.isBuffer(t2))
            throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + n(t2));
          if (r2 === void 0 && (r2 = 0), i2 === void 0 && (i2 = t2 ? t2.length : 0), o2 === void 0 && (o2 = 0), a2 === void 0 && (a2 = this.length), r2 < 0 || i2 > t2.length || o2 < 0 || a2 > this.length)
            throw new RangeError("out of range index");
          if (o2 >= a2 && r2 >= i2)
            return 0;
          if (o2 >= a2)
            return -1;
          if (r2 >= i2)
            return 1;
          if (this === t2)
            return 0;
          for (var s2 = (a2 >>>= 0) - (o2 >>>= 0), u2 = (i2 >>>= 0) - (r2 >>>= 0), c2 = Math.min(s2, u2), f2 = this.slice(o2, a2), l2 = t2.slice(r2, i2), h2 = 0; h2 < c2; ++h2)
            if (f2[h2] !== l2[h2]) {
              s2 = f2[h2], u2 = l2[h2];
              break;
            }
          return s2 < u2 ? -1 : u2 < s2 ? 1 : 0;
        }, e2.prototype.includes = function(t2, e3, r2) {
          return this.indexOf(t2, e3, r2) !== -1;
        }, e2.prototype.indexOf = function(t2, e3, r2) {
          return m(this, t2, e3, r2, true);
        }, e2.prototype.lastIndexOf = function(t2, e3, r2) {
          return m(this, t2, e3, r2, false);
        }, e2.prototype.write = function(t2, e3, r2, n2) {
          if (e3 === void 0)
            n2 = "utf8", r2 = this.length, e3 = 0;
          else if (r2 === void 0 && typeof e3 == "string")
            n2 = e3, r2 = this.length, e3 = 0;
          else {
            if (!isFinite(e3))
              throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            e3 >>>= 0, isFinite(r2) ? (r2 >>>= 0, n2 === void 0 && (n2 = "utf8")) : (n2 = r2, r2 = void 0);
          }
          var i2 = this.length - e3;
          if ((r2 === void 0 || r2 > i2) && (r2 = i2), t2.length > 0 && (r2 < 0 || e3 < 0) || e3 > this.length)
            throw new RangeError("Attempt to write outside buffer bounds");
          n2 || (n2 = "utf8");
          for (var o2 = false; ; )
            switch (n2) {
              case "hex":
                return b(this, t2, e3, r2);
              case "utf8":
              case "utf-8":
                return v(this, t2, e3, r2);
              case "ascii":
                return g(this, t2, e3, r2);
              case "latin1":
              case "binary":
                return w(this, t2, e3, r2);
              case "base64":
                return _(this, t2, e3, r2);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return k(this, t2, e3, r2);
              default:
                if (o2)
                  throw new TypeError("Unknown encoding: " + n2);
                n2 = ("" + n2).toLowerCase(), o2 = true;
            }
        }, e2.prototype.toJSON = function() {
          return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
        };
        function O(t2, e3, r2) {
          var n2 = "";
          r2 = Math.min(t2.length, r2);
          for (var i2 = e3; i2 < r2; ++i2)
            n2 += String.fromCharCode(127 & t2[i2]);
          return n2;
        }
        function j(t2, e3, r2) {
          var n2 = "";
          r2 = Math.min(t2.length, r2);
          for (var i2 = e3; i2 < r2; ++i2)
            n2 += String.fromCharCode(t2[i2]);
          return n2;
        }
        function E(t2, e3, r2) {
          var n2 = t2.length;
          (!e3 || e3 < 0) && (e3 = 0), (!r2 || r2 < 0 || r2 > n2) && (r2 = n2);
          for (var i2 = "", o2 = e3; o2 < r2; ++o2)
            i2 += N(t2[o2]);
          return i2;
        }
        function R(t2, e3, r2) {
          for (var n2 = t2.slice(e3, r2), i2 = "", o2 = 0; o2 < n2.length; o2 += 2)
            i2 += String.fromCharCode(n2[o2] + 256 * n2[o2 + 1]);
          return i2;
        }
        function T(t2, e3, r2) {
          if (t2 % 1 != 0 || t2 < 0)
            throw new RangeError("offset is not uint");
          if (t2 + e3 > r2)
            throw new RangeError("Trying to access beyond buffer length");
        }
        function C(t2, r2, n2, i2, o2, a2) {
          if (!e2.isBuffer(t2))
            throw new TypeError('"buffer" argument must be a Buffer instance');
          if (r2 > o2 || r2 < a2)
            throw new RangeError('"value" argument is out of bounds');
          if (n2 + i2 > t2.length)
            throw new RangeError("Index out of range");
        }
        function P(t2, e3, r2, n2, i2, o2) {
          if (r2 + n2 > t2.length)
            throw new RangeError("Index out of range");
          if (r2 < 0)
            throw new RangeError("Index out of range");
        }
        function M(t2, e3, r2, n2, i2) {
          return e3 = +e3, r2 >>>= 0, i2 || P(t2, 0, r2, 4), o.write(t2, e3, r2, n2, 23, 4), r2 + 4;
        }
        function A(t2, e3, r2, n2, i2) {
          return e3 = +e3, r2 >>>= 0, i2 || P(t2, 0, r2, 8), o.write(t2, e3, r2, n2, 52, 8), r2 + 8;
        }
        e2.prototype.slice = function(t2, r2) {
          var n2 = this.length;
          (t2 = ~~t2) < 0 ? (t2 += n2) < 0 && (t2 = 0) : t2 > n2 && (t2 = n2), (r2 = r2 === void 0 ? n2 : ~~r2) < 0 ? (r2 += n2) < 0 && (r2 = 0) : r2 > n2 && (r2 = n2), r2 < t2 && (r2 = t2);
          var i2 = this.subarray(t2, r2);
          return i2.__proto__ = e2.prototype, i2;
        }, e2.prototype.readUIntLE = function(t2, e3, r2) {
          t2 >>>= 0, e3 >>>= 0, r2 || T(t2, e3, this.length);
          for (var n2 = this[t2], i2 = 1, o2 = 0; ++o2 < e3 && (i2 *= 256); )
            n2 += this[t2 + o2] * i2;
          return n2;
        }, e2.prototype.readUIntBE = function(t2, e3, r2) {
          t2 >>>= 0, e3 >>>= 0, r2 || T(t2, e3, this.length);
          for (var n2 = this[t2 + --e3], i2 = 1; e3 > 0 && (i2 *= 256); )
            n2 += this[t2 + --e3] * i2;
          return n2;
        }, e2.prototype.readUInt8 = function(t2, e3) {
          return t2 >>>= 0, e3 || T(t2, 1, this.length), this[t2];
        }, e2.prototype.readUInt16LE = function(t2, e3) {
          return t2 >>>= 0, e3 || T(t2, 2, this.length), this[t2] | this[t2 + 1] << 8;
        }, e2.prototype.readUInt16BE = function(t2, e3) {
          return t2 >>>= 0, e3 || T(t2, 2, this.length), this[t2] << 8 | this[t2 + 1];
        }, e2.prototype.readUInt32LE = function(t2, e3) {
          return t2 >>>= 0, e3 || T(t2, 4, this.length), (this[t2] | this[t2 + 1] << 8 | this[t2 + 2] << 16) + 16777216 * this[t2 + 3];
        }, e2.prototype.readUInt32BE = function(t2, e3) {
          return t2 >>>= 0, e3 || T(t2, 4, this.length), 16777216 * this[t2] + (this[t2 + 1] << 16 | this[t2 + 2] << 8 | this[t2 + 3]);
        }, e2.prototype.readIntLE = function(t2, e3, r2) {
          t2 >>>= 0, e3 >>>= 0, r2 || T(t2, e3, this.length);
          for (var n2 = this[t2], i2 = 1, o2 = 0; ++o2 < e3 && (i2 *= 256); )
            n2 += this[t2 + o2] * i2;
          return n2 >= (i2 *= 128) && (n2 -= Math.pow(2, 8 * e3)), n2;
        }, e2.prototype.readIntBE = function(t2, e3, r2) {
          t2 >>>= 0, e3 >>>= 0, r2 || T(t2, e3, this.length);
          for (var n2 = e3, i2 = 1, o2 = this[t2 + --n2]; n2 > 0 && (i2 *= 256); )
            o2 += this[t2 + --n2] * i2;
          return o2 >= (i2 *= 128) && (o2 -= Math.pow(2, 8 * e3)), o2;
        }, e2.prototype.readInt8 = function(t2, e3) {
          return t2 >>>= 0, e3 || T(t2, 1, this.length), 128 & this[t2] ? -1 * (255 - this[t2] + 1) : this[t2];
        }, e2.prototype.readInt16LE = function(t2, e3) {
          t2 >>>= 0, e3 || T(t2, 2, this.length);
          var r2 = this[t2] | this[t2 + 1] << 8;
          return 32768 & r2 ? 4294901760 | r2 : r2;
        }, e2.prototype.readInt16BE = function(t2, e3) {
          t2 >>>= 0, e3 || T(t2, 2, this.length);
          var r2 = this[t2 + 1] | this[t2] << 8;
          return 32768 & r2 ? 4294901760 | r2 : r2;
        }, e2.prototype.readInt32LE = function(t2, e3) {
          return t2 >>>= 0, e3 || T(t2, 4, this.length), this[t2] | this[t2 + 1] << 8 | this[t2 + 2] << 16 | this[t2 + 3] << 24;
        }, e2.prototype.readInt32BE = function(t2, e3) {
          return t2 >>>= 0, e3 || T(t2, 4, this.length), this[t2] << 24 | this[t2 + 1] << 16 | this[t2 + 2] << 8 | this[t2 + 3];
        }, e2.prototype.readFloatLE = function(t2, e3) {
          return t2 >>>= 0, e3 || T(t2, 4, this.length), o.read(this, t2, true, 23, 4);
        }, e2.prototype.readFloatBE = function(t2, e3) {
          return t2 >>>= 0, e3 || T(t2, 4, this.length), o.read(this, t2, false, 23, 4);
        }, e2.prototype.readDoubleLE = function(t2, e3) {
          return t2 >>>= 0, e3 || T(t2, 8, this.length), o.read(this, t2, true, 52, 8);
        }, e2.prototype.readDoubleBE = function(t2, e3) {
          return t2 >>>= 0, e3 || T(t2, 8, this.length), o.read(this, t2, false, 52, 8);
        }, e2.prototype.writeUIntLE = function(t2, e3, r2, n2) {
          (t2 = +t2, e3 >>>= 0, r2 >>>= 0, n2) || C(this, t2, e3, r2, Math.pow(2, 8 * r2) - 1, 0);
          var i2 = 1, o2 = 0;
          for (this[e3] = 255 & t2; ++o2 < r2 && (i2 *= 256); )
            this[e3 + o2] = t2 / i2 & 255;
          return e3 + r2;
        }, e2.prototype.writeUIntBE = function(t2, e3, r2, n2) {
          (t2 = +t2, e3 >>>= 0, r2 >>>= 0, n2) || C(this, t2, e3, r2, Math.pow(2, 8 * r2) - 1, 0);
          var i2 = r2 - 1, o2 = 1;
          for (this[e3 + i2] = 255 & t2; --i2 >= 0 && (o2 *= 256); )
            this[e3 + i2] = t2 / o2 & 255;
          return e3 + r2;
        }, e2.prototype.writeUInt8 = function(t2, e3, r2) {
          return t2 = +t2, e3 >>>= 0, r2 || C(this, t2, e3, 1, 255, 0), this[e3] = 255 & t2, e3 + 1;
        }, e2.prototype.writeUInt16LE = function(t2, e3, r2) {
          return t2 = +t2, e3 >>>= 0, r2 || C(this, t2, e3, 2, 65535, 0), this[e3] = 255 & t2, this[e3 + 1] = t2 >>> 8, e3 + 2;
        }, e2.prototype.writeUInt16BE = function(t2, e3, r2) {
          return t2 = +t2, e3 >>>= 0, r2 || C(this, t2, e3, 2, 65535, 0), this[e3] = t2 >>> 8, this[e3 + 1] = 255 & t2, e3 + 2;
        }, e2.prototype.writeUInt32LE = function(t2, e3, r2) {
          return t2 = +t2, e3 >>>= 0, r2 || C(this, t2, e3, 4, 4294967295, 0), this[e3 + 3] = t2 >>> 24, this[e3 + 2] = t2 >>> 16, this[e3 + 1] = t2 >>> 8, this[e3] = 255 & t2, e3 + 4;
        }, e2.prototype.writeUInt32BE = function(t2, e3, r2) {
          return t2 = +t2, e3 >>>= 0, r2 || C(this, t2, e3, 4, 4294967295, 0), this[e3] = t2 >>> 24, this[e3 + 1] = t2 >>> 16, this[e3 + 2] = t2 >>> 8, this[e3 + 3] = 255 & t2, e3 + 4;
        }, e2.prototype.writeIntLE = function(t2, e3, r2, n2) {
          if (t2 = +t2, e3 >>>= 0, !n2) {
            var i2 = Math.pow(2, 8 * r2 - 1);
            C(this, t2, e3, r2, i2 - 1, -i2);
          }
          var o2 = 0, a2 = 1, s2 = 0;
          for (this[e3] = 255 & t2; ++o2 < r2 && (a2 *= 256); )
            t2 < 0 && s2 === 0 && this[e3 + o2 - 1] !== 0 && (s2 = 1), this[e3 + o2] = (t2 / a2 >> 0) - s2 & 255;
          return e3 + r2;
        }, e2.prototype.writeIntBE = function(t2, e3, r2, n2) {
          if (t2 = +t2, e3 >>>= 0, !n2) {
            var i2 = Math.pow(2, 8 * r2 - 1);
            C(this, t2, e3, r2, i2 - 1, -i2);
          }
          var o2 = r2 - 1, a2 = 1, s2 = 0;
          for (this[e3 + o2] = 255 & t2; --o2 >= 0 && (a2 *= 256); )
            t2 < 0 && s2 === 0 && this[e3 + o2 + 1] !== 0 && (s2 = 1), this[e3 + o2] = (t2 / a2 >> 0) - s2 & 255;
          return e3 + r2;
        }, e2.prototype.writeInt8 = function(t2, e3, r2) {
          return t2 = +t2, e3 >>>= 0, r2 || C(this, t2, e3, 1, 127, -128), t2 < 0 && (t2 = 255 + t2 + 1), this[e3] = 255 & t2, e3 + 1;
        }, e2.prototype.writeInt16LE = function(t2, e3, r2) {
          return t2 = +t2, e3 >>>= 0, r2 || C(this, t2, e3, 2, 32767, -32768), this[e3] = 255 & t2, this[e3 + 1] = t2 >>> 8, e3 + 2;
        }, e2.prototype.writeInt16BE = function(t2, e3, r2) {
          return t2 = +t2, e3 >>>= 0, r2 || C(this, t2, e3, 2, 32767, -32768), this[e3] = t2 >>> 8, this[e3 + 1] = 255 & t2, e3 + 2;
        }, e2.prototype.writeInt32LE = function(t2, e3, r2) {
          return t2 = +t2, e3 >>>= 0, r2 || C(this, t2, e3, 4, 2147483647, -2147483648), this[e3] = 255 & t2, this[e3 + 1] = t2 >>> 8, this[e3 + 2] = t2 >>> 16, this[e3 + 3] = t2 >>> 24, e3 + 4;
        }, e2.prototype.writeInt32BE = function(t2, e3, r2) {
          return t2 = +t2, e3 >>>= 0, r2 || C(this, t2, e3, 4, 2147483647, -2147483648), t2 < 0 && (t2 = 4294967295 + t2 + 1), this[e3] = t2 >>> 24, this[e3 + 1] = t2 >>> 16, this[e3 + 2] = t2 >>> 8, this[e3 + 3] = 255 & t2, e3 + 4;
        }, e2.prototype.writeFloatLE = function(t2, e3, r2) {
          return M(this, t2, e3, true, r2);
        }, e2.prototype.writeFloatBE = function(t2, e3, r2) {
          return M(this, t2, e3, false, r2);
        }, e2.prototype.writeDoubleLE = function(t2, e3, r2) {
          return A(this, t2, e3, true, r2);
        }, e2.prototype.writeDoubleBE = function(t2, e3, r2) {
          return A(this, t2, e3, false, r2);
        }, e2.prototype.copy = function(t2, r2, n2, i2) {
          if (!e2.isBuffer(t2))
            throw new TypeError("argument should be a Buffer");
          if (n2 || (n2 = 0), i2 || i2 === 0 || (i2 = this.length), r2 >= t2.length && (r2 = t2.length), r2 || (r2 = 0), i2 > 0 && i2 < n2 && (i2 = n2), i2 === n2)
            return 0;
          if (t2.length === 0 || this.length === 0)
            return 0;
          if (r2 < 0)
            throw new RangeError("targetStart out of bounds");
          if (n2 < 0 || n2 >= this.length)
            throw new RangeError("Index out of range");
          if (i2 < 0)
            throw new RangeError("sourceEnd out of bounds");
          i2 > this.length && (i2 = this.length), t2.length - r2 < i2 - n2 && (i2 = t2.length - r2 + n2);
          var o2 = i2 - n2;
          if (this === t2 && typeof Uint8Array.prototype.copyWithin == "function")
            this.copyWithin(r2, n2, i2);
          else if (this === t2 && n2 < r2 && r2 < i2)
            for (var a2 = o2 - 1; a2 >= 0; --a2)
              t2[a2 + r2] = this[a2 + n2];
          else
            Uint8Array.prototype.set.call(t2, this.subarray(n2, i2), r2);
          return o2;
        }, e2.prototype.fill = function(t2, r2, n2, i2) {
          if (typeof t2 == "string") {
            if (typeof r2 == "string" ? (i2 = r2, r2 = 0, n2 = this.length) : typeof n2 == "string" && (i2 = n2, n2 = this.length), i2 !== void 0 && typeof i2 != "string")
              throw new TypeError("encoding must be a string");
            if (typeof i2 == "string" && !e2.isEncoding(i2))
              throw new TypeError("Unknown encoding: " + i2);
            if (t2.length === 1) {
              var o2 = t2.charCodeAt(0);
              (i2 === "utf8" && o2 < 128 || i2 === "latin1") && (t2 = o2);
            }
          } else
            typeof t2 == "number" && (t2 &= 255);
          if (r2 < 0 || this.length < r2 || this.length < n2)
            throw new RangeError("Out of range index");
          if (n2 <= r2)
            return this;
          var a2;
          if (r2 >>>= 0, n2 = n2 === void 0 ? this.length : n2 >>> 0, t2 || (t2 = 0), typeof t2 == "number")
            for (a2 = r2; a2 < n2; ++a2)
              this[a2] = t2;
          else {
            var s2 = e2.isBuffer(t2) ? t2 : e2.from(t2, i2), u2 = s2.length;
            if (u2 === 0)
              throw new TypeError('The value "' + t2 + '" is invalid for argument "value"');
            for (a2 = 0; a2 < n2 - r2; ++a2)
              this[a2 + r2] = s2[a2 % u2];
          }
          return this;
        };
        var I = /[^+/0-9A-Za-z-_]/g;
        function N(t2) {
          return t2 < 16 ? "0" + t2.toString(16) : t2.toString(16);
        }
        function D(t2, e3) {
          var r2;
          e3 = e3 || 1 / 0;
          for (var n2 = t2.length, i2 = null, o2 = [], a2 = 0; a2 < n2; ++a2) {
            if ((r2 = t2.charCodeAt(a2)) > 55295 && r2 < 57344) {
              if (!i2) {
                if (r2 > 56319) {
                  (e3 -= 3) > -1 && o2.push(239, 191, 189);
                  continue;
                }
                if (a2 + 1 === n2) {
                  (e3 -= 3) > -1 && o2.push(239, 191, 189);
                  continue;
                }
                i2 = r2;
                continue;
              }
              if (r2 < 56320) {
                (e3 -= 3) > -1 && o2.push(239, 191, 189), i2 = r2;
                continue;
              }
              r2 = 65536 + (i2 - 55296 << 10 | r2 - 56320);
            } else
              i2 && (e3 -= 3) > -1 && o2.push(239, 191, 189);
            if (i2 = null, r2 < 128) {
              if ((e3 -= 1) < 0)
                break;
              o2.push(r2);
            } else if (r2 < 2048) {
              if ((e3 -= 2) < 0)
                break;
              o2.push(r2 >> 6 | 192, 63 & r2 | 128);
            } else if (r2 < 65536) {
              if ((e3 -= 3) < 0)
                break;
              o2.push(r2 >> 12 | 224, r2 >> 6 & 63 | 128, 63 & r2 | 128);
            } else {
              if (!(r2 < 1114112))
                throw new Error("Invalid code point");
              if ((e3 -= 4) < 0)
                break;
              o2.push(r2 >> 18 | 240, r2 >> 12 & 63 | 128, r2 >> 6 & 63 | 128, 63 & r2 | 128);
            }
          }
          return o2;
        }
        function B(t2) {
          return i.toByteArray(function(t3) {
            if ((t3 = (t3 = t3.split("=")[0]).trim().replace(I, "")).length < 2)
              return "";
            for (; t3.length % 4 != 0; )
              t3 += "=";
            return t3;
          }(t2));
        }
        function F(t2, e3, r2, n2) {
          for (var i2 = 0; i2 < n2 && !(i2 + r2 >= e3.length || i2 >= t2.length); ++i2)
            e3[i2 + r2] = t2[i2];
          return i2;
        }
        function L(t2, e3) {
          return t2 instanceof e3 || t2 != null && t2.constructor != null && t2.constructor.name != null && t2.constructor.name === e3.name;
        }
        function z(t2) {
          return t2 != t2;
        }
      }).call(this, t("buffer").Buffer);
    }, { "base64-js": 182, buffer: 216, ieee754: 385 }], 217: [function(t, e, r) {
      (function(t2) {
        e.exports = function(e2, r2) {
          for (var n = Math.min(e2.length, r2.length), i = new t2(n), o = 0; o < n; ++o)
            i[o] = e2[o] ^ r2[o];
          return i;
        };
      }).call(this, t("buffer").Buffer);
    }, { buffer: 216 }], 218: [function(t, e, r) {
      var n = t("safe-buffer").Buffer, i = t("stream").Transform, o = t("string_decoder").StringDecoder;
      function a(t2) {
        i.call(this), this.hashMode = typeof t2 == "string", this.hashMode ? this[t2] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
      }
      t("inherits")(a, i), a.prototype.update = function(t2, e2, r2) {
        typeof t2 == "string" && (t2 = n.from(t2, e2));
        var i2 = this._update(t2);
        return this.hashMode ? this : (r2 && (i2 = this._toString(i2, r2)), i2);
      }, a.prototype.setAutoPadding = function() {
      }, a.prototype.getAuthTag = function() {
        throw new Error("trying to get auth tag in unsupported state");
      }, a.prototype.setAuthTag = function() {
        throw new Error("trying to set auth tag in unsupported state");
      }, a.prototype.setAAD = function() {
        throw new Error("trying to set aad in unsupported state");
      }, a.prototype._transform = function(t2, e2, r2) {
        var n2;
        try {
          this.hashMode ? this._update(t2) : this.push(this._update(t2));
        } catch (t3) {
          n2 = t3;
        } finally {
          r2(n2);
        }
      }, a.prototype._flush = function(t2) {
        var e2;
        try {
          this.push(this.__final());
        } catch (t3) {
          e2 = t3;
        }
        t2(e2);
      }, a.prototype._finalOrDigest = function(t2) {
        var e2 = this.__final() || n.alloc(0);
        return t2 && (e2 = this._toString(e2, t2, true)), e2;
      }, a.prototype._toString = function(t2, e2, r2) {
        if (this._decoder || (this._decoder = new o(e2), this._encoding = e2), this._encoding !== e2)
          throw new Error("can't switch encodings");
        var n2 = this._decoder.write(t2);
        return r2 && (n2 += this._decoder.end()), n2;
      }, e.exports = a;
    }, { inherits: 387, "safe-buffer": 494, stream: 506, string_decoder: 520 }], 219: [function(t, e, r) {
      e.exports = function(t2) {
        if (typeof t2 != "function")
          throw TypeError(String(t2) + " is not a function");
        return t2;
      };
    }, {}], 220: [function(t, e, r) {
      var n = t("../internals/is-object");
      e.exports = function(t2) {
        if (!n(t2) && t2 !== null)
          throw TypeError("Can't set " + String(t2) + " as a prototype");
        return t2;
      };
    }, { "../internals/is-object": 263 }], 221: [function(t, e, r) {
      var n = t("../internals/well-known-symbol"), i = t("../internals/object-create"), o = t("../internals/object-define-property"), a = n("unscopables"), s = Array.prototype;
      s[a] == null && o.f(s, a, { configurable: true, value: i(null) }), e.exports = function(t2) {
        s[a][t2] = true;
      };
    }, { "../internals/object-create": 276, "../internals/object-define-property": 278, "../internals/well-known-symbol": 314 }], 222: [function(t, e, r) {
      e.exports = function(t2, e2, r2) {
        if (!(t2 instanceof e2))
          throw TypeError("Incorrect " + (r2 ? r2 + " " : "") + "invocation");
        return t2;
      };
    }, {}], 223: [function(t, e, r) {
      var n = t("../internals/is-object");
      e.exports = function(t2) {
        if (!n(t2))
          throw TypeError(String(t2) + " is not an object");
        return t2;
      };
    }, { "../internals/is-object": 263 }], 224: [function(t, e, r) {
      var n = t("../internals/to-indexed-object"), i = t("../internals/to-length"), o = t("../internals/to-absolute-index"), a = function(t2) {
        return function(e2, r2, a2) {
          var s, u = n(e2), c = i(u.length), f = o(a2, c);
          if (t2 && r2 != r2) {
            for (; c > f; )
              if ((s = u[f++]) != s)
                return true;
          } else
            for (; c > f; f++)
              if ((t2 || f in u) && u[f] === r2)
                return t2 || f || 0;
          return !t2 && -1;
        };
      };
      e.exports = { includes: a(true), indexOf: a(false) };
    }, { "../internals/to-absolute-index": 304, "../internals/to-indexed-object": 305, "../internals/to-length": 307 }], 225: [function(t, e, r) {
      var n = t("../internals/function-bind-context"), i = t("../internals/indexed-object"), o = t("../internals/to-object"), a = t("../internals/to-length"), s = t("../internals/array-species-create"), u = [].push, c = function(t2) {
        var e2 = t2 == 1, r2 = t2 == 2, c2 = t2 == 3, f = t2 == 4, l = t2 == 6, h = t2 == 5 || l;
        return function(d, p, m, y) {
          for (var b, v, g = o(d), w = i(g), _ = n(p, m, 3), k = a(w.length), x = 0, S = y || s, O = e2 ? S(d, k) : r2 ? S(d, 0) : void 0; k > x; x++)
            if ((h || x in w) && (v = _(b = w[x], x, g), t2)) {
              if (e2)
                O[x] = v;
              else if (v)
                switch (t2) {
                  case 3:
                    return true;
                  case 5:
                    return b;
                  case 6:
                    return x;
                  case 2:
                    u.call(O, b);
                }
              else if (f)
                return false;
            }
          return l ? -1 : c2 || f ? f : O;
        };
      };
      e.exports = { forEach: c(0), map: c(1), filter: c(2), some: c(3), every: c(4), find: c(5), findIndex: c(6) };
    }, { "../internals/array-species-create": 227, "../internals/function-bind-context": 248, "../internals/indexed-object": 257, "../internals/to-length": 307, "../internals/to-object": 308 }], 226: [function(t, e, r) {
      var n = t("../internals/descriptors"), i = t("../internals/fails"), o = t("../internals/has"), a = Object.defineProperty, s = {}, u = function(t2) {
        throw t2;
      };
      e.exports = function(t2, e2) {
        if (o(s, t2))
          return s[t2];
        e2 || (e2 = {});
        var r2 = [][t2], c = !!o(e2, "ACCESSORS") && e2.ACCESSORS, f = o(e2, 0) ? e2[0] : u, l = o(e2, 1) ? e2[1] : void 0;
        return s[t2] = !!r2 && !i(function() {
          if (c && !n)
            return true;
          var t3 = { length: -1 };
          c ? a(t3, 1, { enumerable: true, get: u }) : t3[1] = 1, r2.call(t3, f, l);
        });
      };
    }, { "../internals/descriptors": 240, "../internals/fails": 247, "../internals/has": 252 }], 227: [function(t, e, r) {
      var n = t("../internals/is-object"), i = t("../internals/is-array"), o = t("../internals/well-known-symbol")("species");
      e.exports = function(t2, e2) {
        var r2;
        return i(t2) && (typeof (r2 = t2.constructor) != "function" || r2 !== Array && !i(r2.prototype) ? n(r2) && (r2 = r2[o]) === null && (r2 = void 0) : r2 = void 0), new (r2 === void 0 ? Array : r2)(e2 === 0 ? 0 : e2);
      };
    }, { "../internals/is-array": 261, "../internals/is-object": 263, "../internals/well-known-symbol": 314 }], 228: [function(t, e, r) {
      var n = t("../internals/an-object");
      e.exports = function(t2, e2, r2, i) {
        try {
          return i ? e2(n(r2)[0], r2[1]) : e2(r2);
        } catch (e3) {
          var o = t2.return;
          throw o !== void 0 && n(o.call(t2)), e3;
        }
      };
    }, { "../internals/an-object": 223 }], 229: [function(t, e, r) {
      var n = t("../internals/well-known-symbol")("iterator"), i = false;
      try {
        var o = 0, a = { next: function() {
          return { done: !!o++ };
        }, return: function() {
          i = true;
        } };
        a[n] = function() {
          return this;
        }, Array.from(a, function() {
          throw 2;
        });
      } catch (t2) {
      }
      e.exports = function(t2, e2) {
        if (!e2 && !i)
          return false;
        var r2 = false;
        try {
          var o2 = {};
          o2[n] = function() {
            return { next: function() {
              return { done: r2 = true };
            } };
          }, t2(o2);
        } catch (t3) {
        }
        return r2;
      };
    }, { "../internals/well-known-symbol": 314 }], 230: [function(t, e, r) {
      var n = {}.toString;
      e.exports = function(t2) {
        return n.call(t2).slice(8, -1);
      };
    }, {}], 231: [function(t, e, r) {
      var n = t("../internals/to-string-tag-support"), i = t("../internals/classof-raw"), o = t("../internals/well-known-symbol")("toStringTag"), a = i(function() {
        return arguments;
      }()) == "Arguments";
      e.exports = n ? i : function(t2) {
        var e2, r2, n2;
        return t2 === void 0 ? "Undefined" : t2 === null ? "Null" : typeof (r2 = function(t3, e3) {
          try {
            return t3[e3];
          } catch (t4) {
          }
        }(e2 = Object(t2), o)) == "string" ? r2 : a ? i(e2) : (n2 = i(e2)) == "Object" && typeof e2.callee == "function" ? "Arguments" : n2;
      };
    }, { "../internals/classof-raw": 230, "../internals/to-string-tag-support": 310, "../internals/well-known-symbol": 314 }], 232: [function(t, e, r) {
      var n = t("../internals/has"), i = t("../internals/own-keys"), o = t("../internals/object-get-own-property-descriptor"), a = t("../internals/object-define-property");
      e.exports = function(t2, e2) {
        for (var r2 = i(e2), s = a.f, u = o.f, c = 0; c < r2.length; c++) {
          var f = r2[c];
          n(t2, f) || s(t2, f, u(e2, f));
        }
      };
    }, { "../internals/has": 252, "../internals/object-define-property": 278, "../internals/object-get-own-property-descriptor": 279, "../internals/own-keys": 289 }], 233: [function(t, e, r) {
      var n = t("../internals/well-known-symbol")("match");
      e.exports = function(t2) {
        var e2 = /./;
        try {
          "/./"[t2](e2);
        } catch (r2) {
          try {
            return e2[n] = false, "/./"[t2](e2);
          } catch (t3) {
          }
        }
        return false;
      };
    }, { "../internals/well-known-symbol": 314 }], 234: [function(t, e, r) {
      var n = t("../internals/fails");
      e.exports = !n(function() {
        function t2() {
        }
        return t2.prototype.constructor = null, Object.getPrototypeOf(new t2()) !== t2.prototype;
      });
    }, { "../internals/fails": 247 }], 235: [function(t, e, r) {
      var n = t("../internals/iterators-core").IteratorPrototype, i = t("../internals/object-create"), o = t("../internals/create-property-descriptor"), a = t("../internals/set-to-string-tag"), s = t("../internals/iterators"), u = function() {
        return this;
      };
      e.exports = function(t2, e2, r2) {
        var c = e2 + " Iterator";
        return t2.prototype = i(n, { next: o(1, r2) }), a(t2, c, false, true), s[c] = u, t2;
      };
    }, { "../internals/create-property-descriptor": 237, "../internals/iterators": 268, "../internals/iterators-core": 267, "../internals/object-create": 276, "../internals/set-to-string-tag": 298 }], 236: [function(t, e, r) {
      var n = t("../internals/descriptors"), i = t("../internals/object-define-property"), o = t("../internals/create-property-descriptor");
      e.exports = n ? function(t2, e2, r2) {
        return i.f(t2, e2, o(1, r2));
      } : function(t2, e2, r2) {
        return t2[e2] = r2, t2;
      };
    }, { "../internals/create-property-descriptor": 237, "../internals/descriptors": 240, "../internals/object-define-property": 278 }], 237: [function(t, e, r) {
      e.exports = function(t2, e2) {
        return { enumerable: !(1 & t2), configurable: !(2 & t2), writable: !(4 & t2), value: e2 };
      };
    }, {}], 238: [function(t, e, r) {
      var n = t("../internals/export"), i = t("../internals/create-iterator-constructor"), o = t("../internals/object-get-prototype-of"), a = t("../internals/object-set-prototype-of"), s = t("../internals/set-to-string-tag"), u = t("../internals/create-non-enumerable-property"), c = t("../internals/redefine"), f = t("../internals/well-known-symbol"), l = t("../internals/is-pure"), h = t("../internals/iterators"), d = t("../internals/iterators-core"), p = d.IteratorPrototype, m = d.BUGGY_SAFARI_ITERATORS, y = f("iterator"), b = function() {
        return this;
      };
      e.exports = function(t2, e2, r2, f2, d2, v, g) {
        i(r2, e2, f2);
        var w, _, k, x = function(t3) {
          if (t3 === d2 && R)
            return R;
          if (!m && t3 in j)
            return j[t3];
          switch (t3) {
            case "keys":
            case "values":
            case "entries":
              return function() {
                return new r2(this, t3);
              };
          }
          return function() {
            return new r2(this);
          };
        }, S = e2 + " Iterator", O = false, j = t2.prototype, E = j[y] || j["@@iterator"] || d2 && j[d2], R = !m && E || x(d2), T = e2 == "Array" && j.entries || E;
        if (T && (w = o(T.call(new t2())), p !== Object.prototype && w.next && (l || o(w) === p || (a ? a(w, p) : typeof w[y] != "function" && u(w, y, b)), s(w, S, true, true), l && (h[S] = b))), d2 == "values" && E && E.name !== "values" && (O = true, R = function() {
          return E.call(this);
        }), l && !g || j[y] === R || u(j, y, R), h[e2] = R, d2)
          if (_ = { values: x("values"), keys: v ? R : x("keys"), entries: x("entries") }, g)
            for (k in _)
              (m || O || !(k in j)) && c(j, k, _[k]);
          else
            n({ target: e2, proto: true, forced: m || O }, _);
        return _;
      };
    }, { "../internals/create-iterator-constructor": 235, "../internals/create-non-enumerable-property": 236, "../internals/export": 246, "../internals/is-pure": 264, "../internals/iterators": 268, "../internals/iterators-core": 267, "../internals/object-get-prototype-of": 283, "../internals/object-set-prototype-of": 287, "../internals/redefine": 294, "../internals/set-to-string-tag": 298, "../internals/well-known-symbol": 314 }], 239: [function(t, e, r) {
      var n = t("../internals/path"), i = t("../internals/has"), o = t("../internals/well-known-symbol-wrapped"), a = t("../internals/object-define-property").f;
      e.exports = function(t2) {
        var e2 = n.Symbol || (n.Symbol = {});
        i(e2, t2) || a(e2, t2, { value: o.f(t2) });
      };
    }, { "../internals/has": 252, "../internals/object-define-property": 278, "../internals/path": 290, "../internals/well-known-symbol-wrapped": 313 }], 240: [function(t, e, r) {
      var n = t("../internals/fails");
      e.exports = !n(function() {
        return Object.defineProperty({}, 1, { get: function() {
          return 7;
        } })[1] != 7;
      });
    }, { "../internals/fails": 247 }], 241: [function(t, e, r) {
      var n = t("../internals/global"), i = t("../internals/is-object"), o = n.document, a = i(o) && i(o.createElement);
      e.exports = function(t2) {
        return a ? o.createElement(t2) : {};
      };
    }, { "../internals/global": 251, "../internals/is-object": 263 }], 242: [function(t, e, r) {
      var n = t("../internals/engine-user-agent");
      e.exports = /(iphone|ipod|ipad).*applewebkit/i.test(n);
    }, { "../internals/engine-user-agent": 243 }], 243: [function(t, e, r) {
      var n = t("../internals/get-built-in");
      e.exports = n("navigator", "userAgent") || "";
    }, { "../internals/get-built-in": 249 }], 244: [function(t, e, r) {
      var n, i, o = t("../internals/global"), a = t("../internals/engine-user-agent"), s = o.process, u = s && s.versions, c = u && u.v8;
      c ? i = (n = c.split("."))[0] + n[1] : a && (!(n = a.match(/Edge\/(\d+)/)) || n[1] >= 74) && (n = a.match(/Chrome\/(\d+)/)) && (i = n[1]), e.exports = i && +i;
    }, { "../internals/engine-user-agent": 243, "../internals/global": 251 }], 245: [function(t, e, r) {
      e.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
    }, {}], 246: [function(t, e, r) {
      var n = t("../internals/global"), i = t("../internals/object-get-own-property-descriptor").f, o = t("../internals/create-non-enumerable-property"), a = t("../internals/redefine"), s = t("../internals/set-global"), u = t("../internals/copy-constructor-properties"), c = t("../internals/is-forced");
      e.exports = function(t2, e2) {
        var r2, f, l, h, d, p = t2.target, m = t2.global, y = t2.stat;
        if (r2 = m ? n : y ? n[p] || s(p, {}) : (n[p] || {}).prototype)
          for (f in e2) {
            if (h = e2[f], l = t2.noTargetGet ? (d = i(r2, f)) && d.value : r2[f], !c(m ? f : p + (y ? "." : "#") + f, t2.forced) && l !== void 0) {
              if (typeof h == typeof l)
                continue;
              u(h, l);
            }
            (t2.sham || l && l.sham) && o(h, "sham", true), a(r2, f, h, t2);
          }
      };
    }, { "../internals/copy-constructor-properties": 232, "../internals/create-non-enumerable-property": 236, "../internals/global": 251, "../internals/is-forced": 262, "../internals/object-get-own-property-descriptor": 279, "../internals/redefine": 294, "../internals/set-global": 296 }], 247: [function(t, e, r) {
      e.exports = function(t2) {
        try {
          return !!t2();
        } catch (t3) {
          return true;
        }
      };
    }, {}], 248: [function(t, e, r) {
      var n = t("../internals/a-function");
      e.exports = function(t2, e2, r2) {
        if (n(t2), e2 === void 0)
          return t2;
        switch (r2) {
          case 0:
            return function() {
              return t2.call(e2);
            };
          case 1:
            return function(r3) {
              return t2.call(e2, r3);
            };
          case 2:
            return function(r3, n2) {
              return t2.call(e2, r3, n2);
            };
          case 3:
            return function(r3, n2, i) {
              return t2.call(e2, r3, n2, i);
            };
        }
        return function() {
          return t2.apply(e2, arguments);
        };
      };
    }, { "../internals/a-function": 219 }], 249: [function(t, e, r) {
      var n = t("../internals/path"), i = t("../internals/global"), o = function(t2) {
        return typeof t2 == "function" ? t2 : void 0;
      };
      e.exports = function(t2, e2) {
        return arguments.length < 2 ? o(n[t2]) || o(i[t2]) : n[t2] && n[t2][e2] || i[t2] && i[t2][e2];
      };
    }, { "../internals/global": 251, "../internals/path": 290 }], 250: [function(t, e, r) {
      var n = t("../internals/classof"), i = t("../internals/iterators"), o = t("../internals/well-known-symbol")("iterator");
      e.exports = function(t2) {
        if (t2 != null)
          return t2[o] || t2["@@iterator"] || i[n(t2)];
      };
    }, { "../internals/classof": 231, "../internals/iterators": 268, "../internals/well-known-symbol": 314 }], 251: [function(t, e, r) {
      (function(t2) {
        var r2 = function(t3) {
          return t3 && t3.Math == Math && t3;
        };
        e.exports = r2(typeof globalThis == "object" && globalThis) || r2(typeof window == "object" && window) || r2(typeof self == "object" && self) || r2(typeof t2 == "object" && t2) || Function("return this")();
      }).call(this, typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, {}], 252: [function(t, e, r) {
      var n = {}.hasOwnProperty;
      e.exports = function(t2, e2) {
        return n.call(t2, e2);
      };
    }, {}], 253: [function(t, e, r) {
      e.exports = {};
    }, {}], 254: [function(t, e, r) {
      var n = t("../internals/global");
      e.exports = function(t2, e2) {
        var r2 = n.console;
        r2 && r2.error && (arguments.length === 1 ? r2.error(t2) : r2.error(t2, e2));
      };
    }, { "../internals/global": 251 }], 255: [function(t, e, r) {
      var n = t("../internals/get-built-in");
      e.exports = n("document", "documentElement");
    }, { "../internals/get-built-in": 249 }], 256: [function(t, e, r) {
      var n = t("../internals/descriptors"), i = t("../internals/fails"), o = t("../internals/document-create-element");
      e.exports = !n && !i(function() {
        return Object.defineProperty(o("div"), "a", { get: function() {
          return 7;
        } }).a != 7;
      });
    }, { "../internals/descriptors": 240, "../internals/document-create-element": 241, "../internals/fails": 247 }], 257: [function(t, e, r) {
      var n = t("../internals/fails"), i = t("../internals/classof-raw"), o = "".split;
      e.exports = n(function() {
        return !Object("z").propertyIsEnumerable(0);
      }) ? function(t2) {
        return i(t2) == "String" ? o.call(t2, "") : Object(t2);
      } : Object;
    }, { "../internals/classof-raw": 230, "../internals/fails": 247 }], 258: [function(t, e, r) {
      var n = t("../internals/shared-store"), i = Function.toString;
      typeof n.inspectSource != "function" && (n.inspectSource = function(t2) {
        return i.call(t2);
      }), e.exports = n.inspectSource;
    }, { "../internals/shared-store": 300 }], 259: [function(t, e, r) {
      var n, i, o, a = t("../internals/native-weak-map"), s = t("../internals/global"), u = t("../internals/is-object"), c = t("../internals/create-non-enumerable-property"), f = t("../internals/has"), l = t("../internals/shared-key"), h = t("../internals/hidden-keys"), d = s.WeakMap;
      if (a) {
        var p = new d(), m = p.get, y = p.has, b = p.set;
        n = function(t2, e2) {
          return b.call(p, t2, e2), e2;
        }, i = function(t2) {
          return m.call(p, t2) || {};
        }, o = function(t2) {
          return y.call(p, t2);
        };
      } else {
        var v = l("state");
        h[v] = true, n = function(t2, e2) {
          return c(t2, v, e2), e2;
        }, i = function(t2) {
          return f(t2, v) ? t2[v] : {};
        }, o = function(t2) {
          return f(t2, v);
        };
      }
      e.exports = { set: n, get: i, has: o, enforce: function(t2) {
        return o(t2) ? i(t2) : n(t2, {});
      }, getterFor: function(t2) {
        return function(e2) {
          var r2;
          if (!u(e2) || (r2 = i(e2)).type !== t2)
            throw TypeError("Incompatible receiver, " + t2 + " required");
          return r2;
        };
      } };
    }, { "../internals/create-non-enumerable-property": 236, "../internals/global": 251, "../internals/has": 252, "../internals/hidden-keys": 253, "../internals/is-object": 263, "../internals/native-weak-map": 272, "../internals/shared-key": 299 }], 260: [function(t, e, r) {
      var n = t("../internals/well-known-symbol"), i = t("../internals/iterators"), o = n("iterator"), a = Array.prototype;
      e.exports = function(t2) {
        return t2 !== void 0 && (i.Array === t2 || a[o] === t2);
      };
    }, { "../internals/iterators": 268, "../internals/well-known-symbol": 314 }], 261: [function(t, e, r) {
      var n = t("../internals/classof-raw");
      e.exports = Array.isArray || function(t2) {
        return n(t2) == "Array";
      };
    }, { "../internals/classof-raw": 230 }], 262: [function(t, e, r) {
      var n = t("../internals/fails"), i = /#|\.prototype\./, o = function(t2, e2) {
        var r2 = s[a(t2)];
        return r2 == c || r2 != u && (typeof e2 == "function" ? n(e2) : !!e2);
      }, a = o.normalize = function(t2) {
        return String(t2).replace(i, ".").toLowerCase();
      }, s = o.data = {}, u = o.NATIVE = "N", c = o.POLYFILL = "P";
      e.exports = o;
    }, { "../internals/fails": 247 }], 263: [function(t, e, r) {
      e.exports = function(t2) {
        return typeof t2 == "object" ? t2 !== null : typeof t2 == "function";
      };
    }, {}], 264: [function(t, e, r) {
      e.exports = false;
    }, {}], 265: [function(t, e, r) {
      var n = t("../internals/is-object"), i = t("../internals/classof-raw"), o = t("../internals/well-known-symbol")("match");
      e.exports = function(t2) {
        var e2;
        return n(t2) && ((e2 = t2[o]) !== void 0 ? !!e2 : i(t2) == "RegExp");
      };
    }, { "../internals/classof-raw": 230, "../internals/is-object": 263, "../internals/well-known-symbol": 314 }], 266: [function(t, e, r) {
      var n = t("../internals/an-object"), i = t("../internals/is-array-iterator-method"), o = t("../internals/to-length"), a = t("../internals/function-bind-context"), s = t("../internals/get-iterator-method"), u = t("../internals/call-with-safe-iteration-closing"), c = function(t2, e2) {
        this.stopped = t2, this.result = e2;
      };
      (e.exports = function(t2, e2, r2, f, l) {
        var h, d, p, m, y, b, v, g = a(e2, r2, f ? 2 : 1);
        if (l)
          h = t2;
        else {
          if (typeof (d = s(t2)) != "function")
            throw TypeError("Target is not iterable");
          if (i(d)) {
            for (p = 0, m = o(t2.length); m > p; p++)
              if ((y = f ? g(n(v = t2[p])[0], v[1]) : g(t2[p])) && y instanceof c)
                return y;
            return new c(false);
          }
          h = d.call(t2);
        }
        for (b = h.next; !(v = b.call(h)).done; )
          if (typeof (y = u(h, g, v.value, f)) == "object" && y && y instanceof c)
            return y;
        return new c(false);
      }).stop = function(t2) {
        return new c(true, t2);
      };
    }, { "../internals/an-object": 223, "../internals/call-with-safe-iteration-closing": 228, "../internals/function-bind-context": 248, "../internals/get-iterator-method": 250, "../internals/is-array-iterator-method": 260, "../internals/to-length": 307 }], 267: [function(t, e, r) {
      var n, i, o, a = t("../internals/object-get-prototype-of"), s = t("../internals/create-non-enumerable-property"), u = t("../internals/has"), c = t("../internals/well-known-symbol"), f = t("../internals/is-pure"), l = c("iterator"), h = false;
      [].keys && ("next" in (o = [].keys()) ? (i = a(a(o))) !== Object.prototype && (n = i) : h = true), n == null && (n = {}), f || u(n, l) || s(n, l, function() {
        return this;
      }), e.exports = { IteratorPrototype: n, BUGGY_SAFARI_ITERATORS: h };
    }, { "../internals/create-non-enumerable-property": 236, "../internals/has": 252, "../internals/is-pure": 264, "../internals/object-get-prototype-of": 283, "../internals/well-known-symbol": 314 }], 268: [function(t, e, r) {
      arguments[4][253][0].apply(r, arguments);
    }, { dup: 253 }], 269: [function(t, e, r) {
      var n, i, o, a, s, u, c, f, l = t("../internals/global"), h = t("../internals/object-get-own-property-descriptor").f, d = t("../internals/classof-raw"), p = t("../internals/task").set, m = t("../internals/engine-is-ios"), y = l.MutationObserver || l.WebKitMutationObserver, b = l.process, v = l.Promise, g = d(b) == "process", w = h(l, "queueMicrotask"), _ = w && w.value;
      _ || (n = function() {
        var t2, e2;
        for (g && (t2 = b.domain) && t2.exit(); i; ) {
          e2 = i.fn, i = i.next;
          try {
            e2();
          } catch (t3) {
            throw i ? a() : o = void 0, t3;
          }
        }
        o = void 0, t2 && t2.enter();
      }, g ? a = function() {
        b.nextTick(n);
      } : y && !m ? (s = true, u = document.createTextNode(""), new y(n).observe(u, { characterData: true }), a = function() {
        u.data = s = !s;
      }) : v && v.resolve ? (c = v.resolve(void 0), f = c.then, a = function() {
        f.call(c, n);
      }) : a = function() {
        p.call(l, n);
      }), e.exports = _ || function(t2) {
        var e2 = { fn: t2, next: void 0 };
        o && (o.next = e2), i || (i = e2, a()), o = e2;
      };
    }, { "../internals/classof-raw": 230, "../internals/engine-is-ios": 242, "../internals/global": 251, "../internals/object-get-own-property-descriptor": 279, "../internals/task": 303 }], 270: [function(t, e, r) {
      var n = t("../internals/global");
      e.exports = n.Promise;
    }, { "../internals/global": 251 }], 271: [function(t, e, r) {
      var n = t("../internals/fails");
      e.exports = !!Object.getOwnPropertySymbols && !n(function() {
        return !String(Symbol());
      });
    }, { "../internals/fails": 247 }], 272: [function(t, e, r) {
      var n = t("../internals/global"), i = t("../internals/inspect-source"), o = n.WeakMap;
      e.exports = typeof o == "function" && /native code/.test(i(o));
    }, { "../internals/global": 251, "../internals/inspect-source": 258 }], 273: [function(t, e, r) {
      var n = t("../internals/a-function"), i = function(t2) {
        var e2, r2;
        this.promise = new t2(function(t3, n2) {
          if (e2 !== void 0 || r2 !== void 0)
            throw TypeError("Bad Promise constructor");
          e2 = t3, r2 = n2;
        }), this.resolve = n(e2), this.reject = n(r2);
      };
      e.exports.f = function(t2) {
        return new i(t2);
      };
    }, { "../internals/a-function": 219 }], 274: [function(t, e, r) {
      var n = t("../internals/is-regexp");
      e.exports = function(t2) {
        if (n(t2))
          throw TypeError("The method doesn't accept regular expressions");
        return t2;
      };
    }, { "../internals/is-regexp": 265 }], 275: [function(t, e, r) {
      var n = t("../internals/descriptors"), i = t("../internals/fails"), o = t("../internals/object-keys"), a = t("../internals/object-get-own-property-symbols"), s = t("../internals/object-property-is-enumerable"), u = t("../internals/to-object"), c = t("../internals/indexed-object"), f = Object.assign, l = Object.defineProperty;
      e.exports = !f || i(function() {
        if (n && f({ b: 1 }, f(l({}, "a", { enumerable: true, get: function() {
          l(this, "b", { value: 3, enumerable: false });
        } }), { b: 2 })).b !== 1)
          return true;
        var t2 = {}, e2 = {}, r2 = Symbol();
        return t2[r2] = 7, "abcdefghijklmnopqrst".split("").forEach(function(t3) {
          e2[t3] = t3;
        }), f({}, t2)[r2] != 7 || o(f({}, e2)).join("") != "abcdefghijklmnopqrst";
      }) ? function(t2, e2) {
        for (var r2 = u(t2), i2 = arguments.length, f2 = 1, l2 = a.f, h = s.f; i2 > f2; )
          for (var d, p = c(arguments[f2++]), m = l2 ? o(p).concat(l2(p)) : o(p), y = m.length, b = 0; y > b; )
            d = m[b++], n && !h.call(p, d) || (r2[d] = p[d]);
        return r2;
      } : f;
    }, { "../internals/descriptors": 240, "../internals/fails": 247, "../internals/indexed-object": 257, "../internals/object-get-own-property-symbols": 282, "../internals/object-keys": 285, "../internals/object-property-is-enumerable": 286, "../internals/to-object": 308 }], 276: [function(t, e, r) {
      var n, i = t("../internals/an-object"), o = t("../internals/object-define-properties"), a = t("../internals/enum-bug-keys"), s = t("../internals/hidden-keys"), u = t("../internals/html"), c = t("../internals/document-create-element"), f = t("../internals/shared-key"), l = f("IE_PROTO"), h = function() {
      }, d = function(t2) {
        return "<script>" + t2 + "<\/script>";
      }, p = function() {
        try {
          n = document.domain && new ActiveXObject("htmlfile");
        } catch (t3) {
        }
        var t2, e2;
        p = n ? function(t3) {
          t3.write(d("")), t3.close();
          var e3 = t3.parentWindow.Object;
          return t3 = null, e3;
        }(n) : ((e2 = c("iframe")).style.display = "none", u.appendChild(e2), e2.src = String("javascript:"), (t2 = e2.contentWindow.document).open(), t2.write(d("document.F=Object")), t2.close(), t2.F);
        for (var r2 = a.length; r2--; )
          delete p.prototype[a[r2]];
        return p();
      };
      s[l] = true, e.exports = Object.create || function(t2, e2) {
        var r2;
        return t2 !== null ? (h.prototype = i(t2), r2 = new h(), h.prototype = null, r2[l] = t2) : r2 = p(), e2 === void 0 ? r2 : o(r2, e2);
      };
    }, { "../internals/an-object": 223, "../internals/document-create-element": 241, "../internals/enum-bug-keys": 245, "../internals/hidden-keys": 253, "../internals/html": 255, "../internals/object-define-properties": 277, "../internals/shared-key": 299 }], 277: [function(t, e, r) {
      var n = t("../internals/descriptors"), i = t("../internals/object-define-property"), o = t("../internals/an-object"), a = t("../internals/object-keys");
      e.exports = n ? Object.defineProperties : function(t2, e2) {
        o(t2);
        for (var r2, n2 = a(e2), s = n2.length, u = 0; s > u; )
          i.f(t2, r2 = n2[u++], e2[r2]);
        return t2;
      };
    }, { "../internals/an-object": 223, "../internals/descriptors": 240, "../internals/object-define-property": 278, "../internals/object-keys": 285 }], 278: [function(t, e, r) {
      var n = t("../internals/descriptors"), i = t("../internals/ie8-dom-define"), o = t("../internals/an-object"), a = t("../internals/to-primitive"), s = Object.defineProperty;
      r.f = n ? s : function(t2, e2, r2) {
        if (o(t2), e2 = a(e2, true), o(r2), i)
          try {
            return s(t2, e2, r2);
          } catch (t3) {
          }
        if ("get" in r2 || "set" in r2)
          throw TypeError("Accessors not supported");
        return "value" in r2 && (t2[e2] = r2.value), t2;
      };
    }, { "../internals/an-object": 223, "../internals/descriptors": 240, "../internals/ie8-dom-define": 256, "../internals/to-primitive": 309 }], 279: [function(t, e, r) {
      var n = t("../internals/descriptors"), i = t("../internals/object-property-is-enumerable"), o = t("../internals/create-property-descriptor"), a = t("../internals/to-indexed-object"), s = t("../internals/to-primitive"), u = t("../internals/has"), c = t("../internals/ie8-dom-define"), f = Object.getOwnPropertyDescriptor;
      r.f = n ? f : function(t2, e2) {
        if (t2 = a(t2), e2 = s(e2, true), c)
          try {
            return f(t2, e2);
          } catch (t3) {
          }
        if (u(t2, e2))
          return o(!i.f.call(t2, e2), t2[e2]);
      };
    }, { "../internals/create-property-descriptor": 237, "../internals/descriptors": 240, "../internals/has": 252, "../internals/ie8-dom-define": 256, "../internals/object-property-is-enumerable": 286, "../internals/to-indexed-object": 305, "../internals/to-primitive": 309 }], 280: [function(t, e, r) {
      var n = t("../internals/to-indexed-object"), i = t("../internals/object-get-own-property-names").f, o = {}.toString, a = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
      e.exports.f = function(t2) {
        return a && o.call(t2) == "[object Window]" ? function(t3) {
          try {
            return i(t3);
          } catch (t4) {
            return a.slice();
          }
        }(t2) : i(n(t2));
      };
    }, { "../internals/object-get-own-property-names": 281, "../internals/to-indexed-object": 305 }], 281: [function(t, e, r) {
      var n = t("../internals/object-keys-internal"), i = t("../internals/enum-bug-keys").concat("length", "prototype");
      r.f = Object.getOwnPropertyNames || function(t2) {
        return n(t2, i);
      };
    }, { "../internals/enum-bug-keys": 245, "../internals/object-keys-internal": 284 }], 282: [function(t, e, r) {
      r.f = Object.getOwnPropertySymbols;
    }, {}], 283: [function(t, e, r) {
      var n = t("../internals/has"), i = t("../internals/to-object"), o = t("../internals/shared-key"), a = t("../internals/correct-prototype-getter"), s = o("IE_PROTO"), u = Object.prototype;
      e.exports = a ? Object.getPrototypeOf : function(t2) {
        return t2 = i(t2), n(t2, s) ? t2[s] : typeof t2.constructor == "function" && t2 instanceof t2.constructor ? t2.constructor.prototype : t2 instanceof Object ? u : null;
      };
    }, { "../internals/correct-prototype-getter": 234, "../internals/has": 252, "../internals/shared-key": 299, "../internals/to-object": 308 }], 284: [function(t, e, r) {
      var n = t("../internals/has"), i = t("../internals/to-indexed-object"), o = t("../internals/array-includes").indexOf, a = t("../internals/hidden-keys");
      e.exports = function(t2, e2) {
        var r2, s = i(t2), u = 0, c = [];
        for (r2 in s)
          !n(a, r2) && n(s, r2) && c.push(r2);
        for (; e2.length > u; )
          n(s, r2 = e2[u++]) && (~o(c, r2) || c.push(r2));
        return c;
      };
    }, { "../internals/array-includes": 224, "../internals/has": 252, "../internals/hidden-keys": 253, "../internals/to-indexed-object": 305 }], 285: [function(t, e, r) {
      var n = t("../internals/object-keys-internal"), i = t("../internals/enum-bug-keys");
      e.exports = Object.keys || function(t2) {
        return n(t2, i);
      };
    }, { "../internals/enum-bug-keys": 245, "../internals/object-keys-internal": 284 }], 286: [function(t, e, r) {
      var n = {}.propertyIsEnumerable, i = Object.getOwnPropertyDescriptor, o = i && !n.call({ 1: 2 }, 1);
      r.f = o ? function(t2) {
        var e2 = i(this, t2);
        return !!e2 && e2.enumerable;
      } : n;
    }, {}], 287: [function(t, e, r) {
      var n = t("../internals/an-object"), i = t("../internals/a-possible-prototype");
      e.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
        var t2, e2 = false, r2 = {};
        try {
          (t2 = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set).call(r2, []), e2 = r2 instanceof Array;
        } catch (t3) {
        }
        return function(r3, o) {
          return n(r3), i(o), e2 ? t2.call(r3, o) : r3.__proto__ = o, r3;
        };
      }() : void 0);
    }, { "../internals/a-possible-prototype": 220, "../internals/an-object": 223 }], 288: [function(t, e, r) {
      var n = t("../internals/descriptors"), i = t("../internals/object-keys"), o = t("../internals/to-indexed-object"), a = t("../internals/object-property-is-enumerable").f, s = function(t2) {
        return function(e2) {
          for (var r2, s2 = o(e2), u = i(s2), c = u.length, f = 0, l = []; c > f; )
            r2 = u[f++], n && !a.call(s2, r2) || l.push(t2 ? [r2, s2[r2]] : s2[r2]);
          return l;
        };
      };
      e.exports = { entries: s(true), values: s(false) };
    }, { "../internals/descriptors": 240, "../internals/object-keys": 285, "../internals/object-property-is-enumerable": 286, "../internals/to-indexed-object": 305 }], 289: [function(t, e, r) {
      var n = t("../internals/get-built-in"), i = t("../internals/object-get-own-property-names"), o = t("../internals/object-get-own-property-symbols"), a = t("../internals/an-object");
      e.exports = n("Reflect", "ownKeys") || function(t2) {
        var e2 = i.f(a(t2)), r2 = o.f;
        return r2 ? e2.concat(r2(t2)) : e2;
      };
    }, { "../internals/an-object": 223, "../internals/get-built-in": 249, "../internals/object-get-own-property-names": 281, "../internals/object-get-own-property-symbols": 282 }], 290: [function(t, e, r) {
      var n = t("../internals/global");
      e.exports = n;
    }, { "../internals/global": 251 }], 291: [function(t, e, r) {
      e.exports = function(t2) {
        try {
          return { error: false, value: t2() };
        } catch (t3) {
          return { error: true, value: t3 };
        }
      };
    }, {}], 292: [function(t, e, r) {
      var n = t("../internals/an-object"), i = t("../internals/is-object"), o = t("../internals/new-promise-capability");
      e.exports = function(t2, e2) {
        if (n(t2), i(e2) && e2.constructor === t2)
          return e2;
        var r2 = o.f(t2);
        return (0, r2.resolve)(e2), r2.promise;
      };
    }, { "../internals/an-object": 223, "../internals/is-object": 263, "../internals/new-promise-capability": 273 }], 293: [function(t, e, r) {
      var n = t("../internals/redefine");
      e.exports = function(t2, e2, r2) {
        for (var i in e2)
          n(t2, i, e2[i], r2);
        return t2;
      };
    }, { "../internals/redefine": 294 }], 294: [function(t, e, r) {
      var n = t("../internals/global"), i = t("../internals/create-non-enumerable-property"), o = t("../internals/has"), a = t("../internals/set-global"), s = t("../internals/inspect-source"), u = t("../internals/internal-state"), c = u.get, f = u.enforce, l = String(String).split("String");
      (e.exports = function(t2, e2, r2, s2) {
        var u2 = !!s2 && !!s2.unsafe, c2 = !!s2 && !!s2.enumerable, h = !!s2 && !!s2.noTargetGet;
        typeof r2 == "function" && (typeof e2 != "string" || o(r2, "name") || i(r2, "name", e2), f(r2).source = l.join(typeof e2 == "string" ? e2 : "")), t2 !== n ? (u2 ? !h && t2[e2] && (c2 = true) : delete t2[e2], c2 ? t2[e2] = r2 : i(t2, e2, r2)) : c2 ? t2[e2] = r2 : a(e2, r2);
      })(Function.prototype, "toString", function() {
        return typeof this == "function" && c(this).source || s(this);
      });
    }, { "../internals/create-non-enumerable-property": 236, "../internals/global": 251, "../internals/has": 252, "../internals/inspect-source": 258, "../internals/internal-state": 259, "../internals/set-global": 296 }], 295: [function(t, e, r) {
      e.exports = function(t2) {
        if (t2 == null)
          throw TypeError("Can't call method on " + t2);
        return t2;
      };
    }, {}], 296: [function(t, e, r) {
      var n = t("../internals/global"), i = t("../internals/create-non-enumerable-property");
      e.exports = function(t2, e2) {
        try {
          i(n, t2, e2);
        } catch (r2) {
          n[t2] = e2;
        }
        return e2;
      };
    }, { "../internals/create-non-enumerable-property": 236, "../internals/global": 251 }], 297: [function(t, e, r) {
      var n = t("../internals/get-built-in"), i = t("../internals/object-define-property"), o = t("../internals/well-known-symbol"), a = t("../internals/descriptors"), s = o("species");
      e.exports = function(t2) {
        var e2 = n(t2), r2 = i.f;
        a && e2 && !e2[s] && r2(e2, s, { configurable: true, get: function() {
          return this;
        } });
      };
    }, { "../internals/descriptors": 240, "../internals/get-built-in": 249, "../internals/object-define-property": 278, "../internals/well-known-symbol": 314 }], 298: [function(t, e, r) {
      var n = t("../internals/object-define-property").f, i = t("../internals/has"), o = t("../internals/well-known-symbol")("toStringTag");
      e.exports = function(t2, e2, r2) {
        t2 && !i(t2 = r2 ? t2 : t2.prototype, o) && n(t2, o, { configurable: true, value: e2 });
      };
    }, { "../internals/has": 252, "../internals/object-define-property": 278, "../internals/well-known-symbol": 314 }], 299: [function(t, e, r) {
      var n = t("../internals/shared"), i = t("../internals/uid"), o = n("keys");
      e.exports = function(t2) {
        return o[t2] || (o[t2] = i(t2));
      };
    }, { "../internals/shared": 301, "../internals/uid": 311 }], 300: [function(t, e, r) {
      var n = t("../internals/global"), i = t("../internals/set-global"), o = n["__core-js_shared__"] || i("__core-js_shared__", {});
      e.exports = o;
    }, { "../internals/global": 251, "../internals/set-global": 296 }], 301: [function(t, e, r) {
      var n = t("../internals/is-pure"), i = t("../internals/shared-store");
      (e.exports = function(t2, e2) {
        return i[t2] || (i[t2] = e2 !== void 0 ? e2 : {});
      })("versions", []).push({ version: "3.6.5", mode: n ? "pure" : "global", copyright: "\xA9 2020 Denis Pushkarev (zloirock.ru)" });
    }, { "../internals/is-pure": 264, "../internals/shared-store": 300 }], 302: [function(t, e, r) {
      var n = t("../internals/an-object"), i = t("../internals/a-function"), o = t("../internals/well-known-symbol")("species");
      e.exports = function(t2, e2) {
        var r2, a = n(t2).constructor;
        return a === void 0 || (r2 = n(a)[o]) == null ? e2 : i(r2);
      };
    }, { "../internals/a-function": 219, "../internals/an-object": 223, "../internals/well-known-symbol": 314 }], 303: [function(t, e, r) {
      var n, i, o, a = t("../internals/global"), s = t("../internals/fails"), u = t("../internals/classof-raw"), c = t("../internals/function-bind-context"), f = t("../internals/html"), l = t("../internals/document-create-element"), h = t("../internals/engine-is-ios"), d = a.location, p = a.setImmediate, m = a.clearImmediate, y = a.process, b = a.MessageChannel, v = a.Dispatch, g = 0, w = {}, _ = function(t2) {
        if (w.hasOwnProperty(t2)) {
          var e2 = w[t2];
          delete w[t2], e2();
        }
      }, k = function(t2) {
        return function() {
          _(t2);
        };
      }, x = function(t2) {
        _(t2.data);
      }, S = function(t2) {
        a.postMessage(t2 + "", d.protocol + "//" + d.host);
      };
      p && m || (p = function(t2) {
        for (var e2 = [], r2 = 1; arguments.length > r2; )
          e2.push(arguments[r2++]);
        return w[++g] = function() {
          (typeof t2 == "function" ? t2 : Function(t2)).apply(void 0, e2);
        }, n(g), g;
      }, m = function(t2) {
        delete w[t2];
      }, u(y) == "process" ? n = function(t2) {
        y.nextTick(k(t2));
      } : v && v.now ? n = function(t2) {
        v.now(k(t2));
      } : b && !h ? (o = (i = new b()).port2, i.port1.onmessage = x, n = c(o.postMessage, o, 1)) : !a.addEventListener || typeof postMessage != "function" || a.importScripts || s(S) || d.protocol === "file:" ? n = "onreadystatechange" in l("script") ? function(t2) {
        f.appendChild(l("script")).onreadystatechange = function() {
          f.removeChild(this), _(t2);
        };
      } : function(t2) {
        setTimeout(k(t2), 0);
      } : (n = S, a.addEventListener("message", x, false))), e.exports = { set: p, clear: m };
    }, { "../internals/classof-raw": 230, "../internals/document-create-element": 241, "../internals/engine-is-ios": 242, "../internals/fails": 247, "../internals/function-bind-context": 248, "../internals/global": 251, "../internals/html": 255 }], 304: [function(t, e, r) {
      var n = t("../internals/to-integer"), i = Math.max, o = Math.min;
      e.exports = function(t2, e2) {
        var r2 = n(t2);
        return r2 < 0 ? i(r2 + e2, 0) : o(r2, e2);
      };
    }, { "../internals/to-integer": 306 }], 305: [function(t, e, r) {
      var n = t("../internals/indexed-object"), i = t("../internals/require-object-coercible");
      e.exports = function(t2) {
        return n(i(t2));
      };
    }, { "../internals/indexed-object": 257, "../internals/require-object-coercible": 295 }], 306: [function(t, e, r) {
      var n = Math.ceil, i = Math.floor;
      e.exports = function(t2) {
        return isNaN(t2 = +t2) ? 0 : (t2 > 0 ? i : n)(t2);
      };
    }, {}], 307: [function(t, e, r) {
      var n = t("../internals/to-integer"), i = Math.min;
      e.exports = function(t2) {
        return t2 > 0 ? i(n(t2), 9007199254740991) : 0;
      };
    }, { "../internals/to-integer": 306 }], 308: [function(t, e, r) {
      var n = t("../internals/require-object-coercible");
      e.exports = function(t2) {
        return Object(n(t2));
      };
    }, { "../internals/require-object-coercible": 295 }], 309: [function(t, e, r) {
      var n = t("../internals/is-object");
      e.exports = function(t2, e2) {
        if (!n(t2))
          return t2;
        var r2, i;
        if (e2 && typeof (r2 = t2.toString) == "function" && !n(i = r2.call(t2)))
          return i;
        if (typeof (r2 = t2.valueOf) == "function" && !n(i = r2.call(t2)))
          return i;
        if (!e2 && typeof (r2 = t2.toString) == "function" && !n(i = r2.call(t2)))
          return i;
        throw TypeError("Can't convert object to primitive value");
      };
    }, { "../internals/is-object": 263 }], 310: [function(t, e, r) {
      var n = {};
      n[t("../internals/well-known-symbol")("toStringTag")] = "z", e.exports = String(n) === "[object z]";
    }, { "../internals/well-known-symbol": 314 }], 311: [function(t, e, r) {
      var n = 0, i = Math.random();
      e.exports = function(t2) {
        return "Symbol(" + String(t2 === void 0 ? "" : t2) + ")_" + (++n + i).toString(36);
      };
    }, {}], 312: [function(t, e, r) {
      var n = t("../internals/native-symbol");
      e.exports = n && !Symbol.sham && typeof Symbol.iterator == "symbol";
    }, { "../internals/native-symbol": 271 }], 313: [function(t, e, r) {
      var n = t("../internals/well-known-symbol");
      r.f = n;
    }, { "../internals/well-known-symbol": 314 }], 314: [function(t, e, r) {
      var n = t("../internals/global"), i = t("../internals/shared"), o = t("../internals/has"), a = t("../internals/uid"), s = t("../internals/native-symbol"), u = t("../internals/use-symbol-as-uid"), c = i("wks"), f = n.Symbol, l = u ? f : f && f.withoutSetter || a;
      e.exports = function(t2) {
        return o(c, t2) || (s && o(f, t2) ? c[t2] = f[t2] : c[t2] = l("Symbol." + t2)), c[t2];
      };
    }, { "../internals/global": 251, "../internals/has": 252, "../internals/native-symbol": 271, "../internals/shared": 301, "../internals/uid": 311, "../internals/use-symbol-as-uid": 312 }], 315: [function(t, e, r) {
      var n = t("../internals/export"), i = t("../internals/array-iteration").findIndex, o = t("../internals/add-to-unscopables"), a = t("../internals/array-method-uses-to-length"), s = true, u = a("findIndex");
      "findIndex" in [] && Array(1).findIndex(function() {
        s = false;
      }), n({ target: "Array", proto: true, forced: s || !u }, { findIndex: function(t2) {
        return i(this, t2, arguments.length > 1 ? arguments[1] : void 0);
      } }), o("findIndex");
    }, { "../internals/add-to-unscopables": 221, "../internals/array-iteration": 225, "../internals/array-method-uses-to-length": 226, "../internals/export": 246 }], 316: [function(t, e, r) {
      var n = t("../internals/export"), i = t("../internals/array-iteration").find, o = t("../internals/add-to-unscopables"), a = t("../internals/array-method-uses-to-length"), s = true, u = a("find");
      "find" in [] && Array(1).find(function() {
        s = false;
      }), n({ target: "Array", proto: true, forced: s || !u }, { find: function(t2) {
        return i(this, t2, arguments.length > 1 ? arguments[1] : void 0);
      } }), o("find");
    }, { "../internals/add-to-unscopables": 221, "../internals/array-iteration": 225, "../internals/array-method-uses-to-length": 226, "../internals/export": 246 }], 317: [function(t, e, r) {
      var n = t("../internals/export"), i = t("../internals/array-includes").includes, o = t("../internals/add-to-unscopables");
      n({ target: "Array", proto: true, forced: !t("../internals/array-method-uses-to-length")("indexOf", { ACCESSORS: true, 1: 0 }) }, { includes: function(t2) {
        return i(this, t2, arguments.length > 1 ? arguments[1] : void 0);
      } }), o("includes");
    }, { "../internals/add-to-unscopables": 221, "../internals/array-includes": 224, "../internals/array-method-uses-to-length": 226, "../internals/export": 246 }], 318: [function(t, e, r) {
      var n = t("../internals/to-indexed-object"), i = t("../internals/add-to-unscopables"), o = t("../internals/iterators"), a = t("../internals/internal-state"), s = t("../internals/define-iterator"), u = a.set, c = a.getterFor("Array Iterator");
      e.exports = s(Array, "Array", function(t2, e2) {
        u(this, { type: "Array Iterator", target: n(t2), index: 0, kind: e2 });
      }, function() {
        var t2 = c(this), e2 = t2.target, r2 = t2.kind, n2 = t2.index++;
        return !e2 || n2 >= e2.length ? (t2.target = void 0, { value: void 0, done: true }) : r2 == "keys" ? { value: n2, done: false } : r2 == "values" ? { value: e2[n2], done: false } : { value: [n2, e2[n2]], done: false };
      }, "values"), o.Arguments = o.Array, i("keys"), i("values"), i("entries");
    }, { "../internals/add-to-unscopables": 221, "../internals/define-iterator": 238, "../internals/internal-state": 259, "../internals/iterators": 268, "../internals/to-indexed-object": 305 }], 319: [function(t, e, r) {
      t("../internals/export")({ target: "Number", stat: true }, { isNaN: function(t2) {
        return t2 != t2;
      } });
    }, { "../internals/export": 246 }], 320: [function(t, e, r) {
      var n = t("../internals/export"), i = t("../internals/object-assign");
      n({ target: "Object", stat: true, forced: Object.assign !== i }, { assign: i });
    }, { "../internals/export": 246, "../internals/object-assign": 275 }], 321: [function(t, e, r) {
      var n = t("../internals/export"), i = t("../internals/to-object"), o = t("../internals/object-keys");
      n({ target: "Object", stat: true, forced: t("../internals/fails")(function() {
        o(1);
      }) }, { keys: function(t2) {
        return o(i(t2));
      } });
    }, { "../internals/export": 246, "../internals/fails": 247, "../internals/object-keys": 285, "../internals/to-object": 308 }], 322: [function(t, e, r) {
      var n = t("../internals/export"), i = t("../internals/object-to-array").values;
      n({ target: "Object", stat: true }, { values: function(t2) {
        return i(t2);
      } });
    }, { "../internals/export": 246, "../internals/object-to-array": 288 }], 323: [function(t, e, r) {
      var n, i, o, a, s = t("../internals/export"), u = t("../internals/is-pure"), c = t("../internals/global"), f = t("../internals/get-built-in"), l = t("../internals/native-promise-constructor"), h = t("../internals/redefine"), d = t("../internals/redefine-all"), p = t("../internals/set-to-string-tag"), m = t("../internals/set-species"), y = t("../internals/is-object"), b = t("../internals/a-function"), v = t("../internals/an-instance"), g = t("../internals/classof-raw"), w = t("../internals/inspect-source"), _ = t("../internals/iterate"), k = t("../internals/check-correctness-of-iteration"), x = t("../internals/species-constructor"), S = t("../internals/task").set, O = t("../internals/microtask"), j = t("../internals/promise-resolve"), E = t("../internals/host-report-errors"), R = t("../internals/new-promise-capability"), T = t("../internals/perform"), C = t("../internals/internal-state"), P = t("../internals/is-forced"), M = t("../internals/well-known-symbol"), A = t("../internals/engine-v8-version"), I = M("species"), N = "Promise", D = C.get, B = C.set, F = C.getterFor(N), L = l, z = c.TypeError, U = c.document, H = c.process, V = f("fetch"), q = R.f, W = q, $ = g(H) == "process", X = !!(U && U.createEvent && c.dispatchEvent), K = P(N, function() {
        if (!(w(L) !== String(L))) {
          if (A === 66)
            return true;
          if (!$ && typeof PromiseRejectionEvent != "function")
            return true;
        }
        if (u && !L.prototype.finally)
          return true;
        if (A >= 51 && /native code/.test(L))
          return false;
        var t2 = L.resolve(1), e2 = function(t3) {
          t3(function() {
          }, function() {
          });
        };
        return (t2.constructor = {})[I] = e2, !(t2.then(function() {
        }) instanceof e2);
      }), Z = K || !k(function(t2) {
        L.all(t2).catch(function() {
        });
      }), Y = function(t2) {
        var e2;
        return !(!y(t2) || typeof (e2 = t2.then) != "function") && e2;
      }, G = function(t2, e2, r2) {
        if (!e2.notified) {
          e2.notified = true;
          var n2 = e2.reactions;
          O(function() {
            for (var i2 = e2.value, o2 = e2.state == 1, a2 = 0; n2.length > a2; ) {
              var s2, u2, c2, f2 = n2[a2++], l2 = o2 ? f2.ok : f2.fail, h2 = f2.resolve, d2 = f2.reject, p2 = f2.domain;
              try {
                l2 ? (o2 || (e2.rejection === 2 && et(t2, e2), e2.rejection = 1), l2 === true ? s2 = i2 : (p2 && p2.enter(), s2 = l2(i2), p2 && (p2.exit(), c2 = true)), s2 === f2.promise ? d2(z("Promise-chain cycle")) : (u2 = Y(s2)) ? u2.call(s2, h2, d2) : h2(s2)) : d2(i2);
              } catch (t3) {
                p2 && !c2 && p2.exit(), d2(t3);
              }
            }
            e2.reactions = [], e2.notified = false, r2 && !e2.rejection && Q(t2, e2);
          });
        }
      }, J = function(t2, e2, r2) {
        var n2, i2;
        X ? ((n2 = U.createEvent("Event")).promise = e2, n2.reason = r2, n2.initEvent(t2, false, true), c.dispatchEvent(n2)) : n2 = { promise: e2, reason: r2 }, (i2 = c["on" + t2]) ? i2(n2) : t2 === "unhandledrejection" && E("Unhandled promise rejection", r2);
      }, Q = function(t2, e2) {
        S.call(c, function() {
          var r2, n2 = e2.value;
          if (tt(e2) && (r2 = T(function() {
            $ ? H.emit("unhandledRejection", n2, t2) : J("unhandledrejection", t2, n2);
          }), e2.rejection = $ || tt(e2) ? 2 : 1, r2.error))
            throw r2.value;
        });
      }, tt = function(t2) {
        return t2.rejection !== 1 && !t2.parent;
      }, et = function(t2, e2) {
        S.call(c, function() {
          $ ? H.emit("rejectionHandled", t2) : J("rejectionhandled", t2, e2.value);
        });
      }, rt = function(t2, e2, r2, n2) {
        return function(i2) {
          t2(e2, r2, i2, n2);
        };
      }, nt = function(t2, e2, r2, n2) {
        e2.done || (e2.done = true, n2 && (e2 = n2), e2.value = r2, e2.state = 2, G(t2, e2, true));
      }, it = function(t2, e2, r2, n2) {
        if (!e2.done) {
          e2.done = true, n2 && (e2 = n2);
          try {
            if (t2 === r2)
              throw z("Promise can't be resolved itself");
            var i2 = Y(r2);
            i2 ? O(function() {
              var n3 = { done: false };
              try {
                i2.call(r2, rt(it, t2, n3, e2), rt(nt, t2, n3, e2));
              } catch (r3) {
                nt(t2, n3, r3, e2);
              }
            }) : (e2.value = r2, e2.state = 1, G(t2, e2, false));
          } catch (r3) {
            nt(t2, { done: false }, r3, e2);
          }
        }
      };
      K && (L = function(t2) {
        v(this, L, N), b(t2), n.call(this);
        var e2 = D(this);
        try {
          t2(rt(it, this, e2), rt(nt, this, e2));
        } catch (t3) {
          nt(this, e2, t3);
        }
      }, (n = function(t2) {
        B(this, { type: N, done: false, notified: false, parent: false, reactions: [], rejection: false, state: 0, value: void 0 });
      }).prototype = d(L.prototype, { then: function(t2, e2) {
        var r2 = F(this), n2 = q(x(this, L));
        return n2.ok = typeof t2 != "function" || t2, n2.fail = typeof e2 == "function" && e2, n2.domain = $ ? H.domain : void 0, r2.parent = true, r2.reactions.push(n2), r2.state != 0 && G(this, r2, false), n2.promise;
      }, catch: function(t2) {
        return this.then(void 0, t2);
      } }), i = function() {
        var t2 = new n(), e2 = D(t2);
        this.promise = t2, this.resolve = rt(it, t2, e2), this.reject = rt(nt, t2, e2);
      }, R.f = q = function(t2) {
        return t2 === L || t2 === o ? new i(t2) : W(t2);
      }, u || typeof l != "function" || (a = l.prototype.then, h(l.prototype, "then", function(t2, e2) {
        var r2 = this;
        return new L(function(t3, e3) {
          a.call(r2, t3, e3);
        }).then(t2, e2);
      }, { unsafe: true }), typeof V == "function" && s({ global: true, enumerable: true, forced: true }, { fetch: function(t2) {
        return j(L, V.apply(c, arguments));
      } }))), s({ global: true, wrap: true, forced: K }, { Promise: L }), p(L, N, false, true), m(N), o = f(N), s({ target: N, stat: true, forced: K }, { reject: function(t2) {
        var e2 = q(this);
        return e2.reject.call(void 0, t2), e2.promise;
      } }), s({ target: N, stat: true, forced: u || K }, { resolve: function(t2) {
        return j(u && this === o ? L : this, t2);
      } }), s({ target: N, stat: true, forced: Z }, { all: function(t2) {
        var e2 = this, r2 = q(e2), n2 = r2.resolve, i2 = r2.reject, o2 = T(function() {
          var r3 = b(e2.resolve), o3 = [], a2 = 0, s2 = 1;
          _(t2, function(t3) {
            var u2 = a2++, c2 = false;
            o3.push(void 0), s2++, r3.call(e2, t3).then(function(t4) {
              c2 || (c2 = true, o3[u2] = t4, --s2 || n2(o3));
            }, i2);
          }), --s2 || n2(o3);
        });
        return o2.error && i2(o2.value), r2.promise;
      }, race: function(t2) {
        var e2 = this, r2 = q(e2), n2 = r2.reject, i2 = T(function() {
          var i3 = b(e2.resolve);
          _(t2, function(t3) {
            i3.call(e2, t3).then(r2.resolve, n2);
          });
        });
        return i2.error && n2(i2.value), r2.promise;
      } });
    }, { "../internals/a-function": 219, "../internals/an-instance": 222, "../internals/check-correctness-of-iteration": 229, "../internals/classof-raw": 230, "../internals/engine-v8-version": 244, "../internals/export": 246, "../internals/get-built-in": 249, "../internals/global": 251, "../internals/host-report-errors": 254, "../internals/inspect-source": 258, "../internals/internal-state": 259, "../internals/is-forced": 262, "../internals/is-object": 263, "../internals/is-pure": 264, "../internals/iterate": 266, "../internals/microtask": 269, "../internals/native-promise-constructor": 270, "../internals/new-promise-capability": 273, "../internals/perform": 291, "../internals/promise-resolve": 292, "../internals/redefine": 294, "../internals/redefine-all": 293, "../internals/set-species": 297, "../internals/set-to-string-tag": 298, "../internals/species-constructor": 302, "../internals/task": 303, "../internals/well-known-symbol": 314 }], 324: [function(t, e, r) {
      var n = t("../internals/export"), i = t("../internals/to-absolute-index"), o = String.fromCharCode, a = String.fromCodePoint;
      n({ target: "String", stat: true, forced: !!a && a.length != 1 }, { fromCodePoint: function(t2) {
        for (var e2, r2 = [], n2 = arguments.length, a2 = 0; n2 > a2; ) {
          if (e2 = +arguments[a2++], i(e2, 1114111) !== e2)
            throw RangeError(e2 + " is not a valid code point");
          r2.push(e2 < 65536 ? o(e2) : o(55296 + ((e2 -= 65536) >> 10), e2 % 1024 + 56320));
        }
        return r2.join("");
      } });
    }, { "../internals/export": 246, "../internals/to-absolute-index": 304 }], 325: [function(t, e, r) {
      var n = t("../internals/export"), i = t("../internals/not-a-regexp"), o = t("../internals/require-object-coercible");
      n({ target: "String", proto: true, forced: !t("../internals/correct-is-regexp-logic")("includes") }, { includes: function(t2) {
        return !!~String(o(this)).indexOf(i(t2), arguments.length > 1 ? arguments[1] : void 0);
      } });
    }, { "../internals/correct-is-regexp-logic": 233, "../internals/export": 246, "../internals/not-a-regexp": 274, "../internals/require-object-coercible": 295 }], 326: [function(t, e, r) {
      t("../internals/define-well-known-symbol")("asyncIterator");
    }, { "../internals/define-well-known-symbol": 239 }], 327: [function(t, e, r) {
      var n = t("../internals/export"), i = t("../internals/global"), o = t("../internals/get-built-in"), a = t("../internals/is-pure"), s = t("../internals/descriptors"), u = t("../internals/native-symbol"), c = t("../internals/use-symbol-as-uid"), f = t("../internals/fails"), l = t("../internals/has"), h = t("../internals/is-array"), d = t("../internals/is-object"), p = t("../internals/an-object"), m = t("../internals/to-object"), y = t("../internals/to-indexed-object"), b = t("../internals/to-primitive"), v = t("../internals/create-property-descriptor"), g = t("../internals/object-create"), w = t("../internals/object-keys"), _ = t("../internals/object-get-own-property-names"), k = t("../internals/object-get-own-property-names-external"), x = t("../internals/object-get-own-property-symbols"), S = t("../internals/object-get-own-property-descriptor"), O = t("../internals/object-define-property"), j = t("../internals/object-property-is-enumerable"), E = t("../internals/create-non-enumerable-property"), R = t("../internals/redefine"), T = t("../internals/shared"), C = t("../internals/shared-key"), P = t("../internals/hidden-keys"), M = t("../internals/uid"), A = t("../internals/well-known-symbol"), I = t("../internals/well-known-symbol-wrapped"), N = t("../internals/define-well-known-symbol"), D = t("../internals/set-to-string-tag"), B = t("../internals/internal-state"), F = t("../internals/array-iteration").forEach, L = C("hidden"), z = A("toPrimitive"), U = B.set, H = B.getterFor("Symbol"), V = Object.prototype, q = i.Symbol, W = o("JSON", "stringify"), $ = S.f, X = O.f, K = k.f, Z = j.f, Y = T("symbols"), G = T("op-symbols"), J = T("string-to-symbol-registry"), Q = T("symbol-to-string-registry"), tt = T("wks"), et = i.QObject, rt = !et || !et.prototype || !et.prototype.findChild, nt = s && f(function() {
        return g(X({}, "a", { get: function() {
          return X(this, "a", { value: 7 }).a;
        } })).a != 7;
      }) ? function(t2, e2, r2) {
        var n2 = $(V, e2);
        n2 && delete V[e2], X(t2, e2, r2), n2 && t2 !== V && X(V, e2, n2);
      } : X, it = function(t2, e2) {
        var r2 = Y[t2] = g(q.prototype);
        return U(r2, { type: "Symbol", tag: t2, description: e2 }), s || (r2.description = e2), r2;
      }, ot = c ? function(t2) {
        return typeof t2 == "symbol";
      } : function(t2) {
        return Object(t2) instanceof q;
      }, at = function(t2, e2, r2) {
        t2 === V && at(G, e2, r2), p(t2);
        var n2 = b(e2, true);
        return p(r2), l(Y, n2) ? (r2.enumerable ? (l(t2, L) && t2[L][n2] && (t2[L][n2] = false), r2 = g(r2, { enumerable: v(0, false) })) : (l(t2, L) || X(t2, L, v(1, {})), t2[L][n2] = true), nt(t2, n2, r2)) : X(t2, n2, r2);
      }, st = function(t2, e2) {
        p(t2);
        var r2 = y(e2), n2 = w(r2).concat(lt(r2));
        return F(n2, function(e3) {
          s && !ut.call(r2, e3) || at(t2, e3, r2[e3]);
        }), t2;
      }, ut = function(t2) {
        var e2 = b(t2, true), r2 = Z.call(this, e2);
        return !(this === V && l(Y, e2) && !l(G, e2)) && (!(r2 || !l(this, e2) || !l(Y, e2) || l(this, L) && this[L][e2]) || r2);
      }, ct = function(t2, e2) {
        var r2 = y(t2), n2 = b(e2, true);
        if (r2 !== V || !l(Y, n2) || l(G, n2)) {
          var i2 = $(r2, n2);
          return !i2 || !l(Y, n2) || l(r2, L) && r2[L][n2] || (i2.enumerable = true), i2;
        }
      }, ft = function(t2) {
        var e2 = K(y(t2)), r2 = [];
        return F(e2, function(t3) {
          l(Y, t3) || l(P, t3) || r2.push(t3);
        }), r2;
      }, lt = function(t2) {
        var e2 = t2 === V, r2 = K(e2 ? G : y(t2)), n2 = [];
        return F(r2, function(t3) {
          !l(Y, t3) || e2 && !l(V, t3) || n2.push(Y[t3]);
        }), n2;
      };
      (u || (R((q = function() {
        if (this instanceof q)
          throw TypeError("Symbol is not a constructor");
        var t2 = arguments.length && arguments[0] !== void 0 ? String(arguments[0]) : void 0, e2 = M(t2), r2 = function(t3) {
          this === V && r2.call(G, t3), l(this, L) && l(this[L], e2) && (this[L][e2] = false), nt(this, e2, v(1, t3));
        };
        return s && rt && nt(V, e2, { configurable: true, set: r2 }), it(e2, t2);
      }).prototype, "toString", function() {
        return H(this).tag;
      }), R(q, "withoutSetter", function(t2) {
        return it(M(t2), t2);
      }), j.f = ut, O.f = at, S.f = ct, _.f = k.f = ft, x.f = lt, I.f = function(t2) {
        return it(A(t2), t2);
      }, s && (X(q.prototype, "description", { configurable: true, get: function() {
        return H(this).description;
      } }), a || R(V, "propertyIsEnumerable", ut, { unsafe: true }))), n({ global: true, wrap: true, forced: !u, sham: !u }, { Symbol: q }), F(w(tt), function(t2) {
        N(t2);
      }), n({ target: "Symbol", stat: true, forced: !u }, { for: function(t2) {
        var e2 = String(t2);
        if (l(J, e2))
          return J[e2];
        var r2 = q(e2);
        return J[e2] = r2, Q[r2] = e2, r2;
      }, keyFor: function(t2) {
        if (!ot(t2))
          throw TypeError(t2 + " is not a symbol");
        if (l(Q, t2))
          return Q[t2];
      }, useSetter: function() {
        rt = true;
      }, useSimple: function() {
        rt = false;
      } }), n({ target: "Object", stat: true, forced: !u, sham: !s }, { create: function(t2, e2) {
        return e2 === void 0 ? g(t2) : st(g(t2), e2);
      }, defineProperty: at, defineProperties: st, getOwnPropertyDescriptor: ct }), n({ target: "Object", stat: true, forced: !u }, { getOwnPropertyNames: ft, getOwnPropertySymbols: lt }), n({ target: "Object", stat: true, forced: f(function() {
        x.f(1);
      }) }, { getOwnPropertySymbols: function(t2) {
        return x.f(m(t2));
      } }), W) && n({ target: "JSON", stat: true, forced: !u || f(function() {
        var t2 = q();
        return W([t2]) != "[null]" || W({ a: t2 }) != "{}" || W(Object(t2)) != "{}";
      }) }, { stringify: function(t2, e2, r2) {
        for (var n2, i2 = [t2], o2 = 1; arguments.length > o2; )
          i2.push(arguments[o2++]);
        if (n2 = e2, (d(e2) || t2 !== void 0) && !ot(t2))
          return h(e2) || (e2 = function(t3, e3) {
            if (typeof n2 == "function" && (e3 = n2.call(this, t3, e3)), !ot(e3))
              return e3;
          }), i2[1] = e2, W.apply(null, i2);
      } });
      q.prototype[z] || E(q.prototype, z, q.prototype.valueOf), D(q, "Symbol"), P[L] = true;
    }, { "../internals/an-object": 223, "../internals/array-iteration": 225, "../internals/create-non-enumerable-property": 236, "../internals/create-property-descriptor": 237, "../internals/define-well-known-symbol": 239, "../internals/descriptors": 240, "../internals/export": 246, "../internals/fails": 247, "../internals/get-built-in": 249, "../internals/global": 251, "../internals/has": 252, "../internals/hidden-keys": 253, "../internals/internal-state": 259, "../internals/is-array": 261, "../internals/is-object": 263, "../internals/is-pure": 264, "../internals/native-symbol": 271, "../internals/object-create": 276, "../internals/object-define-property": 278, "../internals/object-get-own-property-descriptor": 279, "../internals/object-get-own-property-names": 281, "../internals/object-get-own-property-names-external": 280, "../internals/object-get-own-property-symbols": 282, "../internals/object-keys": 285, "../internals/object-property-is-enumerable": 286, "../internals/redefine": 294, "../internals/set-to-string-tag": 298, "../internals/shared": 301, "../internals/shared-key": 299, "../internals/to-indexed-object": 305, "../internals/to-object": 308, "../internals/to-primitive": 309, "../internals/uid": 311, "../internals/use-symbol-as-uid": 312, "../internals/well-known-symbol": 314, "../internals/well-known-symbol-wrapped": 313 }], 328: [function(t, e, r) {
      (function(t2) {
        function e2(t3) {
          return (e2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && typeof Symbol == "function" && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        function n(t3) {
          return Object.prototype.toString.call(t3);
        }
        r.isArray = function(t3) {
          return Array.isArray ? Array.isArray(t3) : n(t3) === "[object Array]";
        }, r.isBoolean = function(t3) {
          return typeof t3 == "boolean";
        }, r.isNull = function(t3) {
          return t3 === null;
        }, r.isNullOrUndefined = function(t3) {
          return t3 == null;
        }, r.isNumber = function(t3) {
          return typeof t3 == "number";
        }, r.isString = function(t3) {
          return typeof t3 == "string";
        }, r.isSymbol = function(t3) {
          return e2(t3) === "symbol";
        }, r.isUndefined = function(t3) {
          return t3 === void 0;
        }, r.isRegExp = function(t3) {
          return n(t3) === "[object RegExp]";
        }, r.isObject = function(t3) {
          return e2(t3) === "object" && t3 !== null;
        }, r.isDate = function(t3) {
          return n(t3) === "[object Date]";
        }, r.isError = function(t3) {
          return n(t3) === "[object Error]" || t3 instanceof Error;
        }, r.isFunction = function(t3) {
          return typeof t3 == "function";
        }, r.isPrimitive = function(t3) {
          return t3 === null || typeof t3 == "boolean" || typeof t3 == "number" || typeof t3 == "string" || e2(t3) === "symbol" || t3 === void 0;
        }, r.isBuffer = t2.isBuffer;
      }).call(this, { isBuffer: t("../../is-buffer/index.js") });
    }, { "../../is-buffer/index.js": 388 }], 329: [function(t, e, r) {
      (function(r2) {
        var n = t("elliptic"), i = t("bn.js");
        e.exports = function(t2) {
          return new a(t2);
        };
        var o = { secp256k1: { name: "secp256k1", byteLength: 32 }, secp224r1: { name: "p224", byteLength: 28 }, prime256v1: { name: "p256", byteLength: 32 }, prime192v1: { name: "p192", byteLength: 24 }, ed25519: { name: "ed25519", byteLength: 32 }, secp384r1: { name: "p384", byteLength: 48 }, secp521r1: { name: "p521", byteLength: 66 } };
        function a(t2) {
          this.curveType = o[t2], this.curveType || (this.curveType = { name: t2 }), this.curve = new n.ec(this.curveType.name), this.keys = void 0;
        }
        function s(t2, e2, n2) {
          Array.isArray(t2) || (t2 = t2.toArray());
          var i2 = new r2(t2);
          if (n2 && i2.length < n2) {
            var o2 = new r2(n2 - i2.length);
            o2.fill(0), i2 = r2.concat([o2, i2]);
          }
          return e2 ? i2.toString(e2) : i2;
        }
        o.p224 = o.secp224r1, o.p256 = o.secp256r1 = o.prime256v1, o.p192 = o.secp192r1 = o.prime192v1, o.p384 = o.secp384r1, o.p521 = o.secp521r1, a.prototype.generateKeys = function(t2, e2) {
          return this.keys = this.curve.genKeyPair(), this.getPublicKey(t2, e2);
        }, a.prototype.computeSecret = function(t2, e2, n2) {
          return e2 = e2 || "utf8", r2.isBuffer(t2) || (t2 = new r2(t2, e2)), s(this.curve.keyFromPublic(t2).getPublic().mul(this.keys.getPrivate()).getX(), n2, this.curveType.byteLength);
        }, a.prototype.getPublicKey = function(t2, e2) {
          var r3 = this.keys.getPublic(e2 === "compressed", true);
          return e2 === "hybrid" && (r3[r3.length - 1] % 2 ? r3[0] = 7 : r3[0] = 6), s(r3, t2);
        }, a.prototype.getPrivateKey = function(t2) {
          return s(this.keys.getPrivate(), t2);
        }, a.prototype.setPublicKey = function(t2, e2) {
          return e2 = e2 || "utf8", r2.isBuffer(t2) || (t2 = new r2(t2, e2)), this.keys._importPublic(t2), this;
        }, a.prototype.setPrivateKey = function(t2, e2) {
          e2 = e2 || "utf8", r2.isBuffer(t2) || (t2 = new r2(t2, e2));
          var n2 = new i(t2);
          return n2 = n2.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(n2), this;
        };
      }).call(this, t("buffer").Buffer);
    }, { "bn.js": 330, buffer: 216, elliptic: 350 }], 330: [function(t, e, r) {
      arguments[4][181][0].apply(r, arguments);
    }, { buffer: 185, dup: 181 }], 331: [function(t, e, r) {
      var n = t("inherits"), i = t("md5.js"), o = t("ripemd160"), a = t("sha.js"), s = t("cipher-base");
      function u(t2) {
        s.call(this, "digest"), this._hash = t2;
      }
      n(u, s), u.prototype._update = function(t2) {
        this._hash.update(t2);
      }, u.prototype._final = function() {
        return this._hash.digest();
      }, e.exports = function(t2) {
        return (t2 = t2.toLowerCase()) === "md5" ? new i() : t2 === "rmd160" || t2 === "ripemd160" ? new o() : new u(a(t2));
      };
    }, { "cipher-base": 218, inherits: 387, "md5.js": 434, ripemd160: 493, "sha.js": 499 }], 332: [function(t, e, r) {
      var n = t("md5.js");
      e.exports = function(t2) {
        return new n().update(t2).digest();
      };
    }, { "md5.js": 434 }], 333: [function(t, e, r) {
      var n = t("inherits"), i = t("./legacy"), o = t("cipher-base"), a = t("safe-buffer").Buffer, s = t("create-hash/md5"), u = t("ripemd160"), c = t("sha.js"), f = a.alloc(128);
      function l(t2, e2) {
        o.call(this, "digest"), typeof e2 == "string" && (e2 = a.from(e2));
        var r2 = t2 === "sha512" || t2 === "sha384" ? 128 : 64;
        (this._alg = t2, this._key = e2, e2.length > r2) ? e2 = (t2 === "rmd160" ? new u() : c(t2)).update(e2).digest() : e2.length < r2 && (e2 = a.concat([e2, f], r2));
        for (var n2 = this._ipad = a.allocUnsafe(r2), i2 = this._opad = a.allocUnsafe(r2), s2 = 0; s2 < r2; s2++)
          n2[s2] = 54 ^ e2[s2], i2[s2] = 92 ^ e2[s2];
        this._hash = t2 === "rmd160" ? new u() : c(t2), this._hash.update(n2);
      }
      n(l, o), l.prototype._update = function(t2) {
        this._hash.update(t2);
      }, l.prototype._final = function() {
        var t2 = this._hash.digest();
        return (this._alg === "rmd160" ? new u() : c(this._alg)).update(this._opad).update(t2).digest();
      }, e.exports = function(t2, e2) {
        return (t2 = t2.toLowerCase()) === "rmd160" || t2 === "ripemd160" ? new l("rmd160", e2) : t2 === "md5" ? new i(s, e2) : new l(t2, e2);
      };
    }, { "./legacy": 334, "cipher-base": 218, "create-hash/md5": 332, inherits: 387, ripemd160: 493, "safe-buffer": 494, "sha.js": 499 }], 334: [function(t, e, r) {
      var n = t("inherits"), i = t("safe-buffer").Buffer, o = t("cipher-base"), a = i.alloc(128);
      function s(t2, e2) {
        o.call(this, "digest"), typeof e2 == "string" && (e2 = i.from(e2)), this._alg = t2, this._key = e2, e2.length > 64 ? e2 = t2(e2) : e2.length < 64 && (e2 = i.concat([e2, a], 64));
        for (var r2 = this._ipad = i.allocUnsafe(64), n2 = this._opad = i.allocUnsafe(64), s2 = 0; s2 < 64; s2++)
          r2[s2] = 54 ^ e2[s2], n2[s2] = 92 ^ e2[s2];
        this._hash = [r2];
      }
      n(s, o), s.prototype._update = function(t2) {
        this._hash.push(t2);
      }, s.prototype._final = function() {
        var t2 = this._alg(i.concat(this._hash));
        return this._alg(i.concat([this._opad, t2]));
      }, e.exports = s;
    }, { "cipher-base": 218, inherits: 387, "safe-buffer": 494 }], 335: [function(t, e, r) {
      r.randomBytes = r.rng = r.pseudoRandomBytes = r.prng = t("randombytes"), r.createHash = r.Hash = t("create-hash"), r.createHmac = r.Hmac = t("create-hmac");
      var n = t("browserify-sign/algos"), i = Object.keys(n), o = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(i);
      r.getHashes = function() {
        return o;
      };
      var a = t("pbkdf2");
      r.pbkdf2 = a.pbkdf2, r.pbkdf2Sync = a.pbkdf2Sync;
      var s = t("browserify-cipher");
      r.Cipher = s.Cipher, r.createCipher = s.createCipher, r.Cipheriv = s.Cipheriv, r.createCipheriv = s.createCipheriv, r.Decipher = s.Decipher, r.createDecipher = s.createDecipher, r.Decipheriv = s.Decipheriv, r.createDecipheriv = s.createDecipheriv, r.getCiphers = s.getCiphers, r.listCiphers = s.listCiphers;
      var u = t("diffie-hellman");
      r.DiffieHellmanGroup = u.DiffieHellmanGroup, r.createDiffieHellmanGroup = u.createDiffieHellmanGroup, r.getDiffieHellman = u.getDiffieHellman, r.createDiffieHellman = u.createDiffieHellman, r.DiffieHellman = u.DiffieHellman;
      var c = t("browserify-sign");
      r.createSign = c.createSign, r.Sign = c.Sign, r.createVerify = c.createVerify, r.Verify = c.Verify, r.createECDH = t("create-ecdh");
      var f = t("public-encrypt");
      r.publicEncrypt = f.publicEncrypt, r.privateEncrypt = f.privateEncrypt, r.publicDecrypt = f.publicDecrypt, r.privateDecrypt = f.privateDecrypt;
      var l = t("randomfill");
      r.randomFill = l.randomFill, r.randomFillSync = l.randomFillSync, r.createCredentials = function() {
        throw new Error(["sorry, createCredentials is not implemented yet", "we accept pull requests", "https://github.com/crypto-browserify/crypto-browserify"].join("\n"));
      }, r.constants = { DH_CHECK_P_NOT_SAFE_PRIME: 2, DH_CHECK_P_NOT_PRIME: 1, DH_UNABLE_TO_CHECK_GENERATOR: 4, DH_NOT_SUITABLE_GENERATOR: 8, NPN_ENABLED: 1, ALPN_ENABLED: 1, RSA_PKCS1_PADDING: 1, RSA_SSLV23_PADDING: 2, RSA_NO_PADDING: 3, RSA_PKCS1_OAEP_PADDING: 4, RSA_X931_PADDING: 5, RSA_PKCS1_PSS_PADDING: 6, POINT_CONVERSION_COMPRESSED: 2, POINT_CONVERSION_UNCOMPRESSED: 4, POINT_CONVERSION_HYBRID: 6 };
    }, { "browserify-cipher": 203, "browserify-sign": 211, "browserify-sign/algos": 208, "create-ecdh": 329, "create-hash": 331, "create-hmac": 333, "diffie-hellman": 345, pbkdf2: 460, "public-encrypt": 468, randombytes: 475, randomfill: 476 }], 336: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      !function(t2, i) {
        (r === void 0 ? "undefined" : n(r)) == "object" && e !== void 0 ? e.exports = i() : (void 0).dayjs = i();
      }(0, function() {
        var t2 = "millisecond", e2 = "second", r2 = "minute", i = "hour", o = "day", a = "week", s = "month", u = "quarter", c = "year", f = "date", l = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[^0-9]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?.?(\d+)?$/, h = /\[([^\]]+)]|Y{2,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, d = function(t3, e3, r3) {
          var n2 = String(t3);
          return !n2 || n2.length >= e3 ? t3 : "" + Array(e3 + 1 - n2.length).join(r3) + t3;
        }, p = { s: d, z: function(t3) {
          var e3 = -t3.utcOffset(), r3 = Math.abs(e3), n2 = Math.floor(r3 / 60), i2 = r3 % 60;
          return (e3 <= 0 ? "+" : "-") + d(n2, 2, "0") + ":" + d(i2, 2, "0");
        }, m: function t3(e3, r3) {
          if (e3.date() < r3.date())
            return -t3(r3, e3);
          var n2 = 12 * (r3.year() - e3.year()) + (r3.month() - e3.month()), i2 = e3.add(n2, s), o2 = r3 - i2 < 0, a2 = e3.add(n2 + (o2 ? -1 : 1), s);
          return +(-(n2 + (r3 - i2) / (o2 ? i2 - a2 : a2 - i2)) || 0);
        }, a: function(t3) {
          return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
        }, p: function(n2) {
          return { M: s, y: c, w: a, d: o, D: f, h: i, m: r2, s: e2, ms: t2, Q: u }[n2] || String(n2 || "").toLowerCase().replace(/s$/, "");
        }, u: function(t3) {
          return t3 === void 0;
        } }, m = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_") }, y = "en", b = {};
        b[y] = m;
        var v = function(t3) {
          return t3 instanceof k;
        }, g = function(t3, e3, r3) {
          var n2;
          if (!t3)
            return y;
          if (typeof t3 == "string")
            b[t3] && (n2 = t3), e3 && (b[t3] = e3, n2 = t3);
          else {
            var i2 = t3.name;
            b[i2] = t3, n2 = i2;
          }
          return !r3 && n2 && (y = n2), n2 || !r3 && y;
        }, w = function(t3, e3) {
          if (v(t3))
            return t3.clone();
          var r3 = n(e3) == "object" ? e3 : {};
          return r3.date = t3, r3.args = arguments, new k(r3);
        }, _ = p;
        _.l = g, _.i = v, _.w = function(t3, e3) {
          return w(t3, { locale: e3.$L, utc: e3.$u, $offset: e3.$offset });
        };
        var k = function() {
          function n2(t3) {
            this.$L = this.$L || g(t3.locale, null, true), this.parse(t3);
          }
          var d2 = n2.prototype;
          return d2.parse = function(t3) {
            this.$d = function(t4) {
              var e3 = t4.date, r3 = t4.utc;
              if (e3 === null)
                return new Date(NaN);
              if (_.u(e3))
                return new Date();
              if (e3 instanceof Date)
                return new Date(e3);
              if (typeof e3 == "string" && !/Z$/i.test(e3)) {
                var n3 = e3.match(l);
                if (n3) {
                  var i2 = n3[2] - 1 || 0, o2 = (n3[7] || "0").substring(0, 3);
                  return r3 ? new Date(Date.UTC(n3[1], i2, n3[3] || 1, n3[4] || 0, n3[5] || 0, n3[6] || 0, o2)) : new Date(n3[1], i2, n3[3] || 1, n3[4] || 0, n3[5] || 0, n3[6] || 0, o2);
                }
              }
              return new Date(e3);
            }(t3), this.init();
          }, d2.init = function() {
            var t3 = this.$d;
            this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
          }, d2.$utils = function() {
            return _;
          }, d2.isValid = function() {
            return !(this.$d.toString() === "Invalid Date");
          }, d2.isSame = function(t3, e3) {
            var r3 = w(t3);
            return this.startOf(e3) <= r3 && r3 <= this.endOf(e3);
          }, d2.isAfter = function(t3, e3) {
            return w(t3) < this.startOf(e3);
          }, d2.isBefore = function(t3, e3) {
            return this.endOf(e3) < w(t3);
          }, d2.$g = function(t3, e3, r3) {
            return _.u(t3) ? this[e3] : this.set(r3, t3);
          }, d2.unix = function() {
            return Math.floor(this.valueOf() / 1e3);
          }, d2.valueOf = function() {
            return this.$d.getTime();
          }, d2.startOf = function(t3, n3) {
            var u2 = this, l2 = !!_.u(n3) || n3, h2 = _.p(t3), d3 = function(t4, e3) {
              var r3 = _.w(u2.$u ? Date.UTC(u2.$y, e3, t4) : new Date(u2.$y, e3, t4), u2);
              return l2 ? r3 : r3.endOf(o);
            }, p2 = function(t4, e3) {
              return _.w(u2.toDate()[t4].apply(u2.toDate("s"), (l2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), u2);
            }, m2 = this.$W, y2 = this.$M, b2 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
            switch (h2) {
              case c:
                return l2 ? d3(1, 0) : d3(31, 11);
              case s:
                return l2 ? d3(1, y2) : d3(0, y2 + 1);
              case a:
                var g2 = this.$locale().weekStart || 0, w2 = (m2 < g2 ? m2 + 7 : m2) - g2;
                return d3(l2 ? b2 - w2 : b2 + (6 - w2), y2);
              case o:
              case f:
                return p2(v2 + "Hours", 0);
              case i:
                return p2(v2 + "Minutes", 1);
              case r2:
                return p2(v2 + "Seconds", 2);
              case e2:
                return p2(v2 + "Milliseconds", 3);
              default:
                return this.clone();
            }
          }, d2.endOf = function(t3) {
            return this.startOf(t3, false);
          }, d2.$set = function(n3, a2) {
            var u2, l2 = _.p(n3), h2 = "set" + (this.$u ? "UTC" : ""), d3 = (u2 = {}, u2[o] = h2 + "Date", u2[f] = h2 + "Date", u2[s] = h2 + "Month", u2[c] = h2 + "FullYear", u2[i] = h2 + "Hours", u2[r2] = h2 + "Minutes", u2[e2] = h2 + "Seconds", u2[t2] = h2 + "Milliseconds", u2)[l2], p2 = l2 === o ? this.$D + (a2 - this.$W) : a2;
            if (l2 === s || l2 === c) {
              var m2 = this.clone().set(f, 1);
              m2.$d[d3](p2), m2.init(), this.$d = m2.set(f, Math.min(this.$D, m2.daysInMonth())).$d;
            } else
              d3 && this.$d[d3](p2);
            return this.init(), this;
          }, d2.set = function(t3, e3) {
            return this.clone().$set(t3, e3);
          }, d2.get = function(t3) {
            return this[_.p(t3)]();
          }, d2.add = function(t3, n3) {
            var u2, f2 = this;
            t3 = Number(t3);
            var l2 = _.p(n3), h2 = function(e3) {
              var r3 = w(f2);
              return _.w(r3.date(r3.date() + Math.round(e3 * t3)), f2);
            };
            if (l2 === s)
              return this.set(s, this.$M + t3);
            if (l2 === c)
              return this.set(c, this.$y + t3);
            if (l2 === o)
              return h2(1);
            if (l2 === a)
              return h2(7);
            var d3 = (u2 = {}, u2[r2] = 6e4, u2[i] = 36e5, u2[e2] = 1e3, u2)[l2] || 1, p2 = this.$d.getTime() + t3 * d3;
            return _.w(p2, this);
          }, d2.subtract = function(t3, e3) {
            return this.add(-1 * t3, e3);
          }, d2.format = function(t3) {
            var e3 = this;
            if (!this.isValid())
              return "Invalid Date";
            var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", n3 = _.z(this), i2 = this.$locale(), o2 = this.$H, a2 = this.$m, s2 = this.$M, u2 = i2.weekdays, c2 = i2.months, f2 = function(t4, n4, i3, o3) {
              return t4 && (t4[n4] || t4(e3, r3)) || i3[n4].substr(0, o3);
            }, l2 = function(t4) {
              return _.s(o2 % 12 || 12, t4, "0");
            }, d3 = i2.meridiem || function(t4, e4, r4) {
              var n4 = t4 < 12 ? "AM" : "PM";
              return r4 ? n4.toLowerCase() : n4;
            }, p2 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: s2 + 1, MM: _.s(s2 + 1, 2, "0"), MMM: f2(i2.monthsShort, s2, c2, 3), MMMM: f2(c2, s2), D: this.$D, DD: _.s(this.$D, 2, "0"), d: String(this.$W), dd: f2(i2.weekdaysMin, this.$W, u2, 2), ddd: f2(i2.weekdaysShort, this.$W, u2, 3), dddd: u2[this.$W], H: String(o2), HH: _.s(o2, 2, "0"), h: l2(1), hh: l2(2), a: d3(o2, a2, true), A: d3(o2, a2, false), m: String(a2), mm: _.s(a2, 2, "0"), s: String(this.$s), ss: _.s(this.$s, 2, "0"), SSS: _.s(this.$ms, 3, "0"), Z: n3 };
            return r3.replace(h, function(t4, e4) {
              return e4 || p2[t4] || n3.replace(":", "");
            });
          }, d2.utcOffset = function() {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
          }, d2.diff = function(t3, n3, f2) {
            var l2, h2 = _.p(n3), d3 = w(t3), p2 = 6e4 * (d3.utcOffset() - this.utcOffset()), m2 = this - d3, y2 = _.m(this, d3);
            return y2 = (l2 = {}, l2[c] = y2 / 12, l2[s] = y2, l2[u] = y2 / 3, l2[a] = (m2 - p2) / 6048e5, l2[o] = (m2 - p2) / 864e5, l2[i] = m2 / 36e5, l2[r2] = m2 / 6e4, l2[e2] = m2 / 1e3, l2)[h2] || m2, f2 ? y2 : _.a(y2);
          }, d2.daysInMonth = function() {
            return this.endOf(s).$D;
          }, d2.$locale = function() {
            return b[this.$L];
          }, d2.locale = function(t3, e3) {
            if (!t3)
              return this.$L;
            var r3 = this.clone(), n3 = g(t3, e3, true);
            return n3 && (r3.$L = n3), r3;
          }, d2.clone = function() {
            return _.w(this.$d, this);
          }, d2.toDate = function() {
            return new Date(this.valueOf());
          }, d2.toJSON = function() {
            return this.isValid() ? this.toISOString() : null;
          }, d2.toISOString = function() {
            return this.$d.toISOString();
          }, d2.toString = function() {
            return this.$d.toUTCString();
          }, n2;
        }(), x = k.prototype;
        return w.prototype = x, [["$ms", t2], ["$s", e2], ["$m", r2], ["$H", i], ["$W", o], ["$M", s], ["$y", c], ["$D", f]].forEach(function(t3) {
          x[t3[1]] = function(e3) {
            return this.$g(e3, t3[0], t3[1]);
          };
        }), w.extend = function(t3, e3) {
          return t3(e3, k, w), w;
        }, w.locale = g, w.isDayjs = v, w.unix = function(t3) {
          return w(1e3 * t3);
        }, w.en = b[y], w.Ls = b, w;
      });
    }, {}], 337: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      !function(t2, i) {
        (r === void 0 ? "undefined" : n(r)) == "object" && e !== void 0 ? e.exports = i() : (void 0).dayjs_plugin_customParseFormat = i();
      }(0, function() {
        var t2, e2 = /(\[[^[]*\])|([-:/.()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, r2 = /\d\d/, n2 = /\d\d?/, i = /\d*[^\s\d-:/()]+/, o = function(t3) {
          return function(e3) {
            this[t3] = +e3;
          };
        }, a = [/[+-]\d\d:?\d\d/, function(t3) {
          var e3, r3;
          (this.zone || (this.zone = {})).offset = (r3 = 60 * (e3 = t3.match(/([+-]|\d\d)/g))[1] + +e3[2]) == 0 ? 0 : e3[0] === "+" ? -r3 : r3;
        }], s = function(e3) {
          var r3 = t2[e3];
          return r3 && (r3.indexOf ? r3 : r3.s.concat(r3.f));
        }, u = { A: [/[AP]M/, function(t3) {
          this.afternoon = t3 === "PM";
        }], a: [/[ap]m/, function(t3) {
          this.afternoon = t3 === "pm";
        }], S: [/\d/, function(t3) {
          this.milliseconds = 100 * +t3;
        }], SS: [r2, function(t3) {
          this.milliseconds = 10 * +t3;
        }], SSS: [/\d{3}/, function(t3) {
          this.milliseconds = +t3;
        }], s: [n2, o("seconds")], ss: [n2, o("seconds")], m: [n2, o("minutes")], mm: [n2, o("minutes")], H: [n2, o("hours")], h: [n2, o("hours")], HH: [n2, o("hours")], hh: [n2, o("hours")], D: [n2, o("day")], DD: [r2, o("day")], Do: [i, function(e3) {
          var r3 = t2.ordinal, n3 = e3.match(/\d+/);
          if (this.day = n3[0], r3)
            for (var i2 = 1; i2 <= 31; i2 += 1)
              r3(i2).replace(/\[|\]/g, "") === e3 && (this.day = i2);
        }], M: [n2, o("month")], MM: [r2, o("month")], MMM: [i, function(t3) {
          var e3 = s("months"), r3 = (s("monthsShort") || e3.map(function(t4) {
            return t4.substr(0, 3);
          })).indexOf(t3) + 1;
          if (r3 < 1)
            throw new Error();
          this.month = r3 % 12 || r3;
        }], MMMM: [i, function(t3) {
          var e3 = s("months").indexOf(t3) + 1;
          if (e3 < 1)
            throw new Error();
          this.month = e3 % 12 || e3;
        }], Y: [/[+-]?\d+/, o("year")], YY: [r2, function(t3) {
          t3 = +t3, this.year = t3 + (t3 > 68 ? 1900 : 2e3);
        }], YYYY: [/\d{4}/, o("year")], Z: a, ZZ: a }, c = function(t3, r3, n3) {
          try {
            var i2 = function(t4) {
              for (var r4 = t4.match(e2), n4 = r4.length, i3 = 0; i3 < n4; i3 += 1) {
                var o3 = r4[i3], a3 = u[o3], s3 = a3 && a3[0], c3 = a3 && a3[1];
                r4[i3] = c3 ? { regex: s3, parser: c3 } : o3.replace(/^\[|\]$/g, "");
              }
              return function(t5) {
                for (var e3 = {}, i4 = 0, o4 = 0; i4 < n4; i4 += 1) {
                  var a4 = r4[i4];
                  if (typeof a4 == "string")
                    o4 += a4.length;
                  else {
                    var s4 = a4.regex, u2 = a4.parser, c4 = t5.substr(o4), f2 = s4.exec(c4)[0];
                    u2.call(e3, f2), t5 = t5.replace(f2, "");
                  }
                }
                return function(t6) {
                  var e4 = t6.afternoon;
                  if (e4 !== void 0) {
                    var r5 = t6.hours;
                    e4 ? r5 < 12 && (t6.hours += 12) : r5 === 12 && (t6.hours = 0), delete t6.afternoon;
                  }
                }(e3), e3;
              };
            }(r3)(t3), o2 = i2.year, a2 = i2.month, s2 = i2.day, c2 = i2.hours, f = i2.minutes, l = i2.seconds, h = i2.milliseconds, d = i2.zone, p = new Date(), m = s2 || (o2 || a2 ? 1 : p.getDate()), y = o2 || p.getFullYear(), b = 0;
            o2 && !a2 || (b = a2 > 0 ? a2 - 1 : p.getMonth());
            var v = c2 || 0, g = f || 0, w = l || 0, _ = h || 0;
            return d ? new Date(Date.UTC(y, b, m, v, g, w, _ + 60 * d.offset * 1e3)) : n3 ? new Date(Date.UTC(y, b, m, v, g, w, _)) : new Date(y, b, m, v, g, w, _);
          } catch (t4) {
            return new Date("");
          }
        };
        return function(e3, r3, n3) {
          var i2 = r3.prototype, o2 = i2.parse;
          i2.parse = function(e4) {
            var r4 = e4.date, i3 = e4.utc, a2 = e4.args;
            this.$u = i3;
            var s2 = a2[1];
            if (typeof s2 == "string") {
              var u2 = a2[2] === true, f = a2[3] === true, l = u2 || f, h = a2[2];
              f && (h = a2[2]), u2 || (t2 = h ? n3.Ls[h] : this.$locale()), this.$d = c(r4, s2, i3), this.init(), h && h !== true && (this.$L = this.locale(h).$L), l && r4 !== this.format(s2) && (this.$d = new Date(""));
            } else if (s2 instanceof Array)
              for (var d = s2.length, p = 1; p <= d; p += 1) {
                a2[1] = s2[p - 1];
                var m = n3.apply(this, a2);
                if (m.isValid()) {
                  this.$d = m.$d, this.$L = m.$L, this.init();
                  break;
                }
                p === d && (this.$d = new Date(""));
              }
            else
              o2.call(this, e4);
          };
        };
      });
    }, {}], 338: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      var i;
      i = function() {
        return function(t2, e2, r2) {
          var n2 = new Date().getTimezoneOffset(), i2 = e2.prototype;
          r2.utc = function(t3) {
            return new e2({ date: t3, utc: true, args: arguments });
          }, i2.utc = function() {
            return r2(this.toDate(), { locale: this.$L, utc: true });
          }, i2.local = function() {
            return r2(this.toDate(), { locale: this.$L, utc: false });
          };
          var o = i2.parse;
          i2.parse = function(t3) {
            t3.utc && (this.$u = true), this.$utils().u(t3.$offset) || (this.$offset = t3.$offset), o.call(this, t3);
          };
          var a = i2.init;
          i2.init = function() {
            if (this.$u) {
              var t3 = this.$d;
              this.$y = t3.getUTCFullYear(), this.$M = t3.getUTCMonth(), this.$D = t3.getUTCDate(), this.$W = t3.getUTCDay(), this.$H = t3.getUTCHours(), this.$m = t3.getUTCMinutes(), this.$s = t3.getUTCSeconds(), this.$ms = t3.getUTCMilliseconds();
            } else
              a.call(this);
          };
          var s = i2.utcOffset;
          i2.utcOffset = function(t3, e3) {
            var r3 = this.$utils().u;
            if (r3(t3))
              return this.$u ? 0 : r3(this.$offset) ? s.call(this) : this.$offset;
            var i3 = Math.abs(t3) <= 16 ? 60 * t3 : t3, o2 = this;
            return e3 ? (o2.$offset = i3, o2.$u = t3 === 0, o2) : (t3 !== 0 ? (o2 = this.local().add(i3 + n2, "minute")).$offset = i3 : o2 = this.utc(), o2);
          };
          var u = i2.format;
          i2.format = function(t3) {
            var e3 = t3 || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
            return u.call(this, e3);
          }, i2.valueOf = function() {
            var t3 = this.$utils().u(this.$offset) ? 0 : this.$offset + n2;
            return this.$d.valueOf() - 6e4 * t3;
          }, i2.isUTC = function() {
            return !!this.$u;
          }, i2.toISOString = function() {
            return this.toDate().toISOString();
          }, i2.toString = function() {
            return this.toDate().toUTCString();
          };
          var c = i2.toDate;
          i2.toDate = function(t3) {
            return t3 === "s" && this.$offset ? r2(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : c.call(this);
          };
          var f = i2.diff;
          i2.diff = function(t3, e3, n3) {
            var i3 = this.local(), o2 = r2(t3).local();
            return f.call(i3, o2, e3, n3);
          };
        };
      }, (r === void 0 ? "undefined" : n(r)) == "object" && e !== void 0 ? e.exports = i() : (void 0).dayjs_plugin_utc = i();
    }, {}], 339: [function(t, e, r) {
      r.utils = t("./des/utils"), r.Cipher = t("./des/cipher"), r.DES = t("./des/des"), r.CBC = t("./des/cbc"), r.EDE = t("./des/ede");
    }, { "./des/cbc": 340, "./des/cipher": 341, "./des/des": 342, "./des/ede": 343, "./des/utils": 344 }], 340: [function(t, e, r) {
      var n = t("minimalistic-assert"), i = t("inherits"), o = {};
      function a(t2) {
        n.equal(t2.length, 8, "Invalid IV length"), this.iv = new Array(8);
        for (var e2 = 0; e2 < this.iv.length; e2++)
          this.iv[e2] = t2[e2];
      }
      r.instantiate = function(t2) {
        function e2(e3) {
          t2.call(this, e3), this._cbcInit();
        }
        i(e2, t2);
        for (var r2 = Object.keys(o), n2 = 0; n2 < r2.length; n2++) {
          var a2 = r2[n2];
          e2.prototype[a2] = o[a2];
        }
        return e2.create = function(t3) {
          return new e2(t3);
        }, e2;
      }, o._cbcInit = function() {
        var t2 = new a(this.options.iv);
        this._cbcState = t2;
      }, o._update = function(t2, e2, r2, n2) {
        var i2 = this._cbcState, o2 = this.constructor.super_.prototype, a2 = i2.iv;
        if (this.type === "encrypt") {
          for (var s = 0; s < this.blockSize; s++)
            a2[s] ^= t2[e2 + s];
          o2._update.call(this, a2, 0, r2, n2);
          for (s = 0; s < this.blockSize; s++)
            a2[s] = r2[n2 + s];
        } else {
          o2._update.call(this, t2, e2, r2, n2);
          for (s = 0; s < this.blockSize; s++)
            r2[n2 + s] ^= a2[s];
          for (s = 0; s < this.blockSize; s++)
            a2[s] = t2[e2 + s];
        }
      };
    }, { inherits: 387, "minimalistic-assert": 437 }], 341: [function(t, e, r) {
      var n = t("minimalistic-assert");
      function i(t2) {
        this.options = t2, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0;
      }
      e.exports = i, i.prototype._init = function() {
      }, i.prototype.update = function(t2) {
        return t2.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(t2) : this._updateEncrypt(t2);
      }, i.prototype._buffer = function(t2, e2) {
        for (var r2 = Math.min(this.buffer.length - this.bufferOff, t2.length - e2), n2 = 0; n2 < r2; n2++)
          this.buffer[this.bufferOff + n2] = t2[e2 + n2];
        return this.bufferOff += r2, r2;
      }, i.prototype._flushBuffer = function(t2, e2) {
        return this._update(this.buffer, 0, t2, e2), this.bufferOff = 0, this.blockSize;
      }, i.prototype._updateEncrypt = function(t2) {
        var e2 = 0, r2 = 0, n2 = (this.bufferOff + t2.length) / this.blockSize | 0, i2 = new Array(n2 * this.blockSize);
        this.bufferOff !== 0 && (e2 += this._buffer(t2, e2), this.bufferOff === this.buffer.length && (r2 += this._flushBuffer(i2, r2)));
        for (var o = t2.length - (t2.length - e2) % this.blockSize; e2 < o; e2 += this.blockSize)
          this._update(t2, e2, i2, r2), r2 += this.blockSize;
        for (; e2 < t2.length; e2++, this.bufferOff++)
          this.buffer[this.bufferOff] = t2[e2];
        return i2;
      }, i.prototype._updateDecrypt = function(t2) {
        for (var e2 = 0, r2 = 0, n2 = Math.ceil((this.bufferOff + t2.length) / this.blockSize) - 1, i2 = new Array(n2 * this.blockSize); n2 > 0; n2--)
          e2 += this._buffer(t2, e2), r2 += this._flushBuffer(i2, r2);
        return e2 += this._buffer(t2, e2), i2;
      }, i.prototype.final = function(t2) {
        var e2, r2;
        return t2 && (e2 = this.update(t2)), r2 = this.type === "encrypt" ? this._finalEncrypt() : this._finalDecrypt(), e2 ? e2.concat(r2) : r2;
      }, i.prototype._pad = function(t2, e2) {
        if (e2 === 0)
          return false;
        for (; e2 < t2.length; )
          t2[e2++] = 0;
        return true;
      }, i.prototype._finalEncrypt = function() {
        if (!this._pad(this.buffer, this.bufferOff))
          return [];
        var t2 = new Array(this.blockSize);
        return this._update(this.buffer, 0, t2, 0), t2;
      }, i.prototype._unpad = function(t2) {
        return t2;
      }, i.prototype._finalDecrypt = function() {
        n.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
        var t2 = new Array(this.blockSize);
        return this._flushBuffer(t2, 0), this._unpad(t2);
      };
    }, { "minimalistic-assert": 437 }], 342: [function(t, e, r) {
      var n = t("minimalistic-assert"), i = t("inherits"), o = t("./utils"), a = t("./cipher");
      function s() {
        this.tmp = new Array(2), this.keys = null;
      }
      function u(t2) {
        a.call(this, t2);
        var e2 = new s();
        this._desState = e2, this.deriveKeys(e2, t2.key);
      }
      i(u, a), e.exports = u, u.create = function(t2) {
        return new u(t2);
      };
      var c = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
      u.prototype.deriveKeys = function(t2, e2) {
        t2.keys = new Array(32), n.equal(e2.length, this.blockSize, "Invalid key length");
        var r2 = o.readUInt32BE(e2, 0), i2 = o.readUInt32BE(e2, 4);
        o.pc1(r2, i2, t2.tmp, 0), r2 = t2.tmp[0], i2 = t2.tmp[1];
        for (var a2 = 0; a2 < t2.keys.length; a2 += 2) {
          var s2 = c[a2 >>> 1];
          r2 = o.r28shl(r2, s2), i2 = o.r28shl(i2, s2), o.pc2(r2, i2, t2.keys, a2);
        }
      }, u.prototype._update = function(t2, e2, r2, n2) {
        var i2 = this._desState, a2 = o.readUInt32BE(t2, e2), s2 = o.readUInt32BE(t2, e2 + 4);
        o.ip(a2, s2, i2.tmp, 0), a2 = i2.tmp[0], s2 = i2.tmp[1], this.type === "encrypt" ? this._encrypt(i2, a2, s2, i2.tmp, 0) : this._decrypt(i2, a2, s2, i2.tmp, 0), a2 = i2.tmp[0], s2 = i2.tmp[1], o.writeUInt32BE(r2, a2, n2), o.writeUInt32BE(r2, s2, n2 + 4);
      }, u.prototype._pad = function(t2, e2) {
        for (var r2 = t2.length - e2, n2 = e2; n2 < t2.length; n2++)
          t2[n2] = r2;
        return true;
      }, u.prototype._unpad = function(t2) {
        for (var e2 = t2[t2.length - 1], r2 = t2.length - e2; r2 < t2.length; r2++)
          n.equal(t2[r2], e2);
        return t2.slice(0, t2.length - e2);
      }, u.prototype._encrypt = function(t2, e2, r2, n2, i2) {
        for (var a2 = e2, s2 = r2, u2 = 0; u2 < t2.keys.length; u2 += 2) {
          var c2 = t2.keys[u2], f = t2.keys[u2 + 1];
          o.expand(s2, t2.tmp, 0), c2 ^= t2.tmp[0], f ^= t2.tmp[1];
          var l = o.substitute(c2, f), h = s2;
          s2 = (a2 ^ o.permute(l)) >>> 0, a2 = h;
        }
        o.rip(s2, a2, n2, i2);
      }, u.prototype._decrypt = function(t2, e2, r2, n2, i2) {
        for (var a2 = r2, s2 = e2, u2 = t2.keys.length - 2; u2 >= 0; u2 -= 2) {
          var c2 = t2.keys[u2], f = t2.keys[u2 + 1];
          o.expand(a2, t2.tmp, 0), c2 ^= t2.tmp[0], f ^= t2.tmp[1];
          var l = o.substitute(c2, f), h = a2;
          a2 = (s2 ^ o.permute(l)) >>> 0, s2 = h;
        }
        o.rip(a2, s2, n2, i2);
      };
    }, { "./cipher": 341, "./utils": 344, inherits: 387, "minimalistic-assert": 437 }], 343: [function(t, e, r) {
      var n = t("minimalistic-assert"), i = t("inherits"), o = t("./cipher"), a = t("./des");
      function s(t2, e2) {
        n.equal(e2.length, 24, "Invalid key length");
        var r2 = e2.slice(0, 8), i2 = e2.slice(8, 16), o2 = e2.slice(16, 24);
        this.ciphers = t2 === "encrypt" ? [a.create({ type: "encrypt", key: r2 }), a.create({ type: "decrypt", key: i2 }), a.create({ type: "encrypt", key: o2 })] : [a.create({ type: "decrypt", key: o2 }), a.create({ type: "encrypt", key: i2 }), a.create({ type: "decrypt", key: r2 })];
      }
      function u(t2) {
        o.call(this, t2);
        var e2 = new s(this.type, this.options.key);
        this._edeState = e2;
      }
      i(u, o), e.exports = u, u.create = function(t2) {
        return new u(t2);
      }, u.prototype._update = function(t2, e2, r2, n2) {
        var i2 = this._edeState;
        i2.ciphers[0]._update(t2, e2, r2, n2), i2.ciphers[1]._update(r2, n2, r2, n2), i2.ciphers[2]._update(r2, n2, r2, n2);
      }, u.prototype._pad = a.prototype._pad, u.prototype._unpad = a.prototype._unpad;
    }, { "./cipher": 341, "./des": 342, inherits: 387, "minimalistic-assert": 437 }], 344: [function(t, e, r) {
      r.readUInt32BE = function(t2, e2) {
        return (t2[0 + e2] << 24 | t2[1 + e2] << 16 | t2[2 + e2] << 8 | t2[3 + e2]) >>> 0;
      }, r.writeUInt32BE = function(t2, e2, r2) {
        t2[0 + r2] = e2 >>> 24, t2[1 + r2] = e2 >>> 16 & 255, t2[2 + r2] = e2 >>> 8 & 255, t2[3 + r2] = 255 & e2;
      }, r.ip = function(t2, e2, r2, n2) {
        for (var i2 = 0, o2 = 0, a = 6; a >= 0; a -= 2) {
          for (var s = 0; s <= 24; s += 8)
            i2 <<= 1, i2 |= e2 >>> s + a & 1;
          for (s = 0; s <= 24; s += 8)
            i2 <<= 1, i2 |= t2 >>> s + a & 1;
        }
        for (a = 6; a >= 0; a -= 2) {
          for (s = 1; s <= 25; s += 8)
            o2 <<= 1, o2 |= e2 >>> s + a & 1;
          for (s = 1; s <= 25; s += 8)
            o2 <<= 1, o2 |= t2 >>> s + a & 1;
        }
        r2[n2 + 0] = i2 >>> 0, r2[n2 + 1] = o2 >>> 0;
      }, r.rip = function(t2, e2, r2, n2) {
        for (var i2 = 0, o2 = 0, a = 0; a < 4; a++)
          for (var s = 24; s >= 0; s -= 8)
            i2 <<= 1, i2 |= e2 >>> s + a & 1, i2 <<= 1, i2 |= t2 >>> s + a & 1;
        for (a = 4; a < 8; a++)
          for (s = 24; s >= 0; s -= 8)
            o2 <<= 1, o2 |= e2 >>> s + a & 1, o2 <<= 1, o2 |= t2 >>> s + a & 1;
        r2[n2 + 0] = i2 >>> 0, r2[n2 + 1] = o2 >>> 0;
      }, r.pc1 = function(t2, e2, r2, n2) {
        for (var i2 = 0, o2 = 0, a = 7; a >= 5; a--) {
          for (var s = 0; s <= 24; s += 8)
            i2 <<= 1, i2 |= e2 >> s + a & 1;
          for (s = 0; s <= 24; s += 8)
            i2 <<= 1, i2 |= t2 >> s + a & 1;
        }
        for (s = 0; s <= 24; s += 8)
          i2 <<= 1, i2 |= e2 >> s + a & 1;
        for (a = 1; a <= 3; a++) {
          for (s = 0; s <= 24; s += 8)
            o2 <<= 1, o2 |= e2 >> s + a & 1;
          for (s = 0; s <= 24; s += 8)
            o2 <<= 1, o2 |= t2 >> s + a & 1;
        }
        for (s = 0; s <= 24; s += 8)
          o2 <<= 1, o2 |= t2 >> s + a & 1;
        r2[n2 + 0] = i2 >>> 0, r2[n2 + 1] = o2 >>> 0;
      }, r.r28shl = function(t2, e2) {
        return t2 << e2 & 268435455 | t2 >>> 28 - e2;
      };
      var n = [14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24];
      r.pc2 = function(t2, e2, r2, i2) {
        for (var o2 = 0, a = 0, s = n.length >>> 1, u = 0; u < s; u++)
          o2 <<= 1, o2 |= t2 >>> n[u] & 1;
        for (u = s; u < n.length; u++)
          a <<= 1, a |= e2 >>> n[u] & 1;
        r2[i2 + 0] = o2 >>> 0, r2[i2 + 1] = a >>> 0;
      }, r.expand = function(t2, e2, r2) {
        var n2 = 0, i2 = 0;
        n2 = (1 & t2) << 5 | t2 >>> 27;
        for (var o2 = 23; o2 >= 15; o2 -= 4)
          n2 <<= 6, n2 |= t2 >>> o2 & 63;
        for (o2 = 11; o2 >= 3; o2 -= 4)
          i2 |= t2 >>> o2 & 63, i2 <<= 6;
        i2 |= (31 & t2) << 1 | t2 >>> 31, e2[r2 + 0] = n2 >>> 0, e2[r2 + 1] = i2 >>> 0;
      };
      var i = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];
      r.substitute = function(t2, e2) {
        for (var r2 = 0, n2 = 0; n2 < 4; n2++) {
          r2 <<= 4, r2 |= i[64 * n2 + (t2 >>> 18 - 6 * n2 & 63)];
        }
        for (n2 = 0; n2 < 4; n2++) {
          r2 <<= 4, r2 |= i[256 + 64 * n2 + (e2 >>> 18 - 6 * n2 & 63)];
        }
        return r2 >>> 0;
      };
      var o = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];
      r.permute = function(t2) {
        for (var e2 = 0, r2 = 0; r2 < o.length; r2++)
          e2 <<= 1, e2 |= t2 >>> o[r2] & 1;
        return e2 >>> 0;
      }, r.padSplit = function(t2, e2, r2) {
        for (var n2 = t2.toString(2); n2.length < e2; )
          n2 = "0" + n2;
        for (var i2 = [], o2 = 0; o2 < e2; o2 += r2)
          i2.push(n2.slice(o2, o2 + r2));
        return i2.join(" ");
      };
    }, {}], 345: [function(t, e, r) {
      (function(e2) {
        var n = t("./lib/generatePrime"), i = t("./lib/primes.json"), o = t("./lib/dh");
        var a = { binary: true, hex: true, base64: true };
        r.DiffieHellmanGroup = r.createDiffieHellmanGroup = r.getDiffieHellman = function(t2) {
          var r2 = new e2(i[t2].prime, "hex"), n2 = new e2(i[t2].gen, "hex");
          return new o(r2, n2);
        }, r.createDiffieHellman = r.DiffieHellman = function t2(r2, i2, s, u) {
          return e2.isBuffer(i2) || a[i2] === void 0 ? t2(r2, "binary", i2, s) : (i2 = i2 || "binary", u = u || "binary", s = s || new e2([2]), e2.isBuffer(s) || (s = new e2(s, u)), typeof r2 == "number" ? new o(n(r2, s), s, true) : (e2.isBuffer(r2) || (r2 = new e2(r2, i2)), new o(r2, s, true)));
        };
      }).call(this, t("buffer").Buffer);
    }, { "./lib/dh": 346, "./lib/generatePrime": 347, "./lib/primes.json": 348, buffer: 216 }], 346: [function(t, e, r) {
      (function(r2) {
        var n = t("bn.js"), i = new (t("miller-rabin"))(), o = new n(24), a = new n(11), s = new n(10), u = new n(3), c = new n(7), f = t("./generatePrime"), l = t("randombytes");
        function h(t2, e2) {
          return e2 = e2 || "utf8", r2.isBuffer(t2) || (t2 = new r2(t2, e2)), this._pub = new n(t2), this;
        }
        function d(t2, e2) {
          return e2 = e2 || "utf8", r2.isBuffer(t2) || (t2 = new r2(t2, e2)), this._priv = new n(t2), this;
        }
        e.exports = m;
        var p = {};
        function m(t2, e2, r3) {
          this.setGenerator(e2), this.__prime = new n(t2), this._prime = n.mont(this.__prime), this._primeLen = t2.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, r3 ? (this.setPublicKey = h, this.setPrivateKey = d) : this._primeCode = 8;
        }
        function y(t2, e2) {
          var n2 = new r2(t2.toArray());
          return e2 ? n2.toString(e2) : n2;
        }
        Object.defineProperty(m.prototype, "verifyError", { enumerable: true, get: function() {
          return typeof this._primeCode != "number" && (this._primeCode = function(t2, e2) {
            var r3 = e2.toString("hex"), n2 = [r3, t2.toString(16)].join("_");
            if (n2 in p)
              return p[n2];
            var l2, h2 = 0;
            if (t2.isEven() || !f.simpleSieve || !f.fermatTest(t2) || !i.test(t2))
              return h2 += 1, h2 += r3 === "02" || r3 === "05" ? 8 : 4, p[n2] = h2, h2;
            switch (i.test(t2.shrn(1)) || (h2 += 2), r3) {
              case "02":
                t2.mod(o).cmp(a) && (h2 += 8);
                break;
              case "05":
                (l2 = t2.mod(s)).cmp(u) && l2.cmp(c) && (h2 += 8);
                break;
              default:
                h2 += 4;
            }
            return p[n2] = h2, h2;
          }(this.__prime, this.__gen)), this._primeCode;
        } }), m.prototype.generateKeys = function() {
          return this._priv || (this._priv = new n(l(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
        }, m.prototype.computeSecret = function(t2) {
          var e2 = (t2 = (t2 = new n(t2)).toRed(this._prime)).redPow(this._priv).fromRed(), i2 = new r2(e2.toArray()), o2 = this.getPrime();
          if (i2.length < o2.length) {
            var a2 = new r2(o2.length - i2.length);
            a2.fill(0), i2 = r2.concat([a2, i2]);
          }
          return i2;
        }, m.prototype.getPublicKey = function(t2) {
          return y(this._pub, t2);
        }, m.prototype.getPrivateKey = function(t2) {
          return y(this._priv, t2);
        }, m.prototype.getPrime = function(t2) {
          return y(this.__prime, t2);
        }, m.prototype.getGenerator = function(t2) {
          return y(this._gen, t2);
        }, m.prototype.setGenerator = function(t2, e2) {
          return e2 = e2 || "utf8", r2.isBuffer(t2) || (t2 = new r2(t2, e2)), this.__gen = t2, this._gen = new n(t2), this;
        };
      }).call(this, t("buffer").Buffer);
    }, { "./generatePrime": 347, "bn.js": 349, buffer: 216, "miller-rabin": 435, randombytes: 475 }], 347: [function(t, e, r) {
      var n = t("randombytes");
      e.exports = v, v.simpleSieve = y, v.fermatTest = b;
      var i = t("bn.js"), o = new i(24), a = new (t("miller-rabin"))(), s = new i(1), u = new i(2), c = new i(5), f = (new i(16), new i(8), new i(10)), l = new i(3), h = (new i(7), new i(11)), d = new i(4), p = (new i(12), null);
      function m() {
        if (p !== null)
          return p;
        var t2 = [];
        t2[0] = 2;
        for (var e2 = 1, r2 = 3; r2 < 1048576; r2 += 2) {
          for (var n2 = Math.ceil(Math.sqrt(r2)), i2 = 0; i2 < e2 && t2[i2] <= n2 && r2 % t2[i2] != 0; i2++)
            ;
          e2 !== i2 && t2[i2] <= n2 || (t2[e2++] = r2);
        }
        return p = t2, t2;
      }
      function y(t2) {
        for (var e2 = m(), r2 = 0; r2 < e2.length; r2++)
          if (t2.modn(e2[r2]) === 0)
            return t2.cmpn(e2[r2]) === 0;
        return true;
      }
      function b(t2) {
        var e2 = i.mont(t2);
        return u.toRed(e2).redPow(t2.subn(1)).fromRed().cmpn(1) === 0;
      }
      function v(t2, e2) {
        if (t2 < 16)
          return new i(e2 === 2 || e2 === 5 ? [140, 123] : [140, 39]);
        var r2, p2;
        for (e2 = new i(e2); ; ) {
          for (r2 = new i(n(Math.ceil(t2 / 8))); r2.bitLength() > t2; )
            r2.ishrn(1);
          if (r2.isEven() && r2.iadd(s), r2.testn(1) || r2.iadd(u), e2.cmp(u)) {
            if (!e2.cmp(c))
              for (; r2.mod(f).cmp(l); )
                r2.iadd(d);
          } else
            for (; r2.mod(o).cmp(h); )
              r2.iadd(d);
          if (y(p2 = r2.shrn(1)) && y(r2) && b(p2) && b(r2) && a.test(p2) && a.test(r2))
            return r2;
        }
      }
    }, { "bn.js": 349, "miller-rabin": 435, randombytes: 475 }], 348: [function(t, e, r) {
      e.exports = { modp1: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff" }, modp2: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff" }, modp5: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff" }, modp14: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff" }, modp15: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff" }, modp16: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff" }, modp17: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff" }, modp18: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff" } };
    }, {}], 349: [function(t, e, r) {
      arguments[4][181][0].apply(r, arguments);
    }, { buffer: 185, dup: 181 }], 350: [function(t, e, r) {
      var n = r;
      n.version = t("../package.json").version, n.utils = t("./elliptic/utils"), n.rand = t("brorand"), n.curve = t("./elliptic/curve"), n.curves = t("./elliptic/curves"), n.ec = t("./elliptic/ec"), n.eddsa = t("./elliptic/eddsa");
    }, { "../package.json": 366, "./elliptic/curve": 353, "./elliptic/curves": 356, "./elliptic/ec": 357, "./elliptic/eddsa": 360, "./elliptic/utils": 364, brorand: 184 }], 351: [function(t, e, r) {
      var n = t("bn.js"), i = t("../utils"), o = i.getNAF, a = i.getJSF, s = i.assert;
      function u(t2, e2) {
        this.type = t2, this.p = new n(e2.p, 16), this.red = e2.prime ? n.red(e2.prime) : n.mont(this.p), this.zero = new n(0).toRed(this.red), this.one = new n(1).toRed(this.red), this.two = new n(2).toRed(this.red), this.n = e2.n && new n(e2.n, 16), this.g = e2.g && this.pointFromJSON(e2.g, e2.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
        var r2 = this.n && this.p.div(this.n);
        !r2 || r2.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = true, this.redN = this.n.toRed(this.red));
      }
      function c(t2, e2) {
        this.curve = t2, this.type = e2, this.precomputed = null;
      }
      e.exports = u, u.prototype.point = function() {
        throw new Error("Not implemented");
      }, u.prototype.validate = function() {
        throw new Error("Not implemented");
      }, u.prototype._fixedNafMul = function(t2, e2) {
        s(t2.precomputed);
        var r2 = t2._getDoubles(), n2 = o(e2, 1, this._bitLength), i2 = (1 << r2.step + 1) - (r2.step % 2 == 0 ? 2 : 1);
        i2 /= 3;
        for (var a2 = [], u2 = 0; u2 < n2.length; u2 += r2.step) {
          var c2 = 0;
          for (e2 = u2 + r2.step - 1; e2 >= u2; e2--)
            c2 = (c2 << 1) + n2[e2];
          a2.push(c2);
        }
        for (var f = this.jpoint(null, null, null), l = this.jpoint(null, null, null), h = i2; h > 0; h--) {
          for (u2 = 0; u2 < a2.length; u2++) {
            (c2 = a2[u2]) === h ? l = l.mixedAdd(r2.points[u2]) : c2 === -h && (l = l.mixedAdd(r2.points[u2].neg()));
          }
          f = f.add(l);
        }
        return f.toP();
      }, u.prototype._wnafMul = function(t2, e2) {
        var r2 = 4, n2 = t2._getNAFPoints(r2);
        r2 = n2.wnd;
        for (var i2 = n2.points, a2 = o(e2, r2, this._bitLength), u2 = this.jpoint(null, null, null), c2 = a2.length - 1; c2 >= 0; c2--) {
          for (e2 = 0; c2 >= 0 && a2[c2] === 0; c2--)
            e2++;
          if (c2 >= 0 && e2++, u2 = u2.dblp(e2), c2 < 0)
            break;
          var f = a2[c2];
          s(f !== 0), u2 = t2.type === "affine" ? f > 0 ? u2.mixedAdd(i2[f - 1 >> 1]) : u2.mixedAdd(i2[-f - 1 >> 1].neg()) : f > 0 ? u2.add(i2[f - 1 >> 1]) : u2.add(i2[-f - 1 >> 1].neg());
        }
        return t2.type === "affine" ? u2.toP() : u2;
      }, u.prototype._wnafMulAdd = function(t2, e2, r2, n2, i2) {
        for (var s2 = this._wnafT1, u2 = this._wnafT2, c2 = this._wnafT3, f = 0, l = 0; l < n2; l++) {
          var h = (O = e2[l])._getNAFPoints(t2);
          s2[l] = h.wnd, u2[l] = h.points;
        }
        for (l = n2 - 1; l >= 1; l -= 2) {
          var d = l - 1, p = l;
          if (s2[d] === 1 && s2[p] === 1) {
            var m = [e2[d], null, null, e2[p]];
            e2[d].y.cmp(e2[p].y) === 0 ? (m[1] = e2[d].add(e2[p]), m[2] = e2[d].toJ().mixedAdd(e2[p].neg())) : e2[d].y.cmp(e2[p].y.redNeg()) === 0 ? (m[1] = e2[d].toJ().mixedAdd(e2[p]), m[2] = e2[d].add(e2[p].neg())) : (m[1] = e2[d].toJ().mixedAdd(e2[p]), m[2] = e2[d].toJ().mixedAdd(e2[p].neg()));
            var y = [-3, -1, -5, -7, 0, 7, 5, 1, 3], b = a(r2[d], r2[p]);
            f = Math.max(b[0].length, f), c2[d] = new Array(f), c2[p] = new Array(f);
            for (var v = 0; v < f; v++) {
              var g = 0 | b[0][v], w = 0 | b[1][v];
              c2[d][v] = y[3 * (g + 1) + (w + 1)], c2[p][v] = 0, u2[d] = m;
            }
          } else
            c2[d] = o(r2[d], s2[d], this._bitLength), c2[p] = o(r2[p], s2[p], this._bitLength), f = Math.max(c2[d].length, f), f = Math.max(c2[p].length, f);
        }
        var _ = this.jpoint(null, null, null), k = this._wnafT4;
        for (l = f; l >= 0; l--) {
          for (var x = 0; l >= 0; ) {
            var S = true;
            for (v = 0; v < n2; v++)
              k[v] = 0 | c2[v][l], k[v] !== 0 && (S = false);
            if (!S)
              break;
            x++, l--;
          }
          if (l >= 0 && x++, _ = _.dblp(x), l < 0)
            break;
          for (v = 0; v < n2; v++) {
            var O, j = k[v];
            j !== 0 && (j > 0 ? O = u2[v][j - 1 >> 1] : j < 0 && (O = u2[v][-j - 1 >> 1].neg()), _ = O.type === "affine" ? _.mixedAdd(O) : _.add(O));
          }
        }
        for (l = 0; l < n2; l++)
          u2[l] = null;
        return i2 ? _ : _.toP();
      }, u.BasePoint = c, c.prototype.eq = function() {
        throw new Error("Not implemented");
      }, c.prototype.validate = function() {
        return this.curve.validate(this);
      }, u.prototype.decodePoint = function(t2, e2) {
        t2 = i.toArray(t2, e2);
        var r2 = this.p.byteLength();
        if ((t2[0] === 4 || t2[0] === 6 || t2[0] === 7) && t2.length - 1 == 2 * r2)
          return t2[0] === 6 ? s(t2[t2.length - 1] % 2 == 0) : t2[0] === 7 && s(t2[t2.length - 1] % 2 == 1), this.point(t2.slice(1, 1 + r2), t2.slice(1 + r2, 1 + 2 * r2));
        if ((t2[0] === 2 || t2[0] === 3) && t2.length - 1 === r2)
          return this.pointFromX(t2.slice(1, 1 + r2), t2[0] === 3);
        throw new Error("Unknown point format");
      }, c.prototype.encodeCompressed = function(t2) {
        return this.encode(t2, true);
      }, c.prototype._encode = function(t2) {
        var e2 = this.curve.p.byteLength(), r2 = this.getX().toArray("be", e2);
        return t2 ? [this.getY().isEven() ? 2 : 3].concat(r2) : [4].concat(r2, this.getY().toArray("be", e2));
      }, c.prototype.encode = function(t2, e2) {
        return i.encode(this._encode(e2), t2);
      }, c.prototype.precompute = function(t2) {
        if (this.precomputed)
          return this;
        var e2 = { doubles: null, naf: null, beta: null };
        return e2.naf = this._getNAFPoints(8), e2.doubles = this._getDoubles(4, t2), e2.beta = this._getBeta(), this.precomputed = e2, this;
      }, c.prototype._hasDoubles = function(t2) {
        if (!this.precomputed)
          return false;
        var e2 = this.precomputed.doubles;
        return !!e2 && e2.points.length >= Math.ceil((t2.bitLength() + 1) / e2.step);
      }, c.prototype._getDoubles = function(t2, e2) {
        if (this.precomputed && this.precomputed.doubles)
          return this.precomputed.doubles;
        for (var r2 = [this], n2 = this, i2 = 0; i2 < e2; i2 += t2) {
          for (var o2 = 0; o2 < t2; o2++)
            n2 = n2.dbl();
          r2.push(n2);
        }
        return { step: t2, points: r2 };
      }, c.prototype._getNAFPoints = function(t2) {
        if (this.precomputed && this.precomputed.naf)
          return this.precomputed.naf;
        for (var e2 = [this], r2 = (1 << t2) - 1, n2 = r2 === 1 ? null : this.dbl(), i2 = 1; i2 < r2; i2++)
          e2[i2] = e2[i2 - 1].add(n2);
        return { wnd: t2, points: e2 };
      }, c.prototype._getBeta = function() {
        return null;
      }, c.prototype.dblp = function(t2) {
        for (var e2 = this, r2 = 0; r2 < t2; r2++)
          e2 = e2.dbl();
        return e2;
      };
    }, { "../utils": 364, "bn.js": 365 }], 352: [function(t, e, r) {
      var n = t("../utils"), i = t("bn.js"), o = t("inherits"), a = t("./base"), s = n.assert;
      function u(t2) {
        this.twisted = (0 | t2.a) != 1, this.mOneA = this.twisted && (0 | t2.a) == -1, this.extended = this.mOneA, a.call(this, "edwards", t2), this.a = new i(t2.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new i(t2.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new i(t2.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), s(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (0 | t2.c) == 1;
      }
      function c(t2, e2, r2, n2, o2) {
        a.BasePoint.call(this, t2, "projective"), e2 === null && r2 === null && n2 === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = true) : (this.x = new i(e2, 16), this.y = new i(r2, 16), this.z = n2 ? new i(n2, 16) : this.curve.one, this.t = o2 && new i(o2, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
      }
      o(u, a), e.exports = u, u.prototype._mulA = function(t2) {
        return this.mOneA ? t2.redNeg() : this.a.redMul(t2);
      }, u.prototype._mulC = function(t2) {
        return this.oneC ? t2 : this.c.redMul(t2);
      }, u.prototype.jpoint = function(t2, e2, r2, n2) {
        return this.point(t2, e2, r2, n2);
      }, u.prototype.pointFromX = function(t2, e2) {
        (t2 = new i(t2, 16)).red || (t2 = t2.toRed(this.red));
        var r2 = t2.redSqr(), n2 = this.c2.redSub(this.a.redMul(r2)), o2 = this.one.redSub(this.c2.redMul(this.d).redMul(r2)), a2 = n2.redMul(o2.redInvm()), s2 = a2.redSqrt();
        if (s2.redSqr().redSub(a2).cmp(this.zero) !== 0)
          throw new Error("invalid point");
        var u2 = s2.fromRed().isOdd();
        return (e2 && !u2 || !e2 && u2) && (s2 = s2.redNeg()), this.point(t2, s2);
      }, u.prototype.pointFromY = function(t2, e2) {
        (t2 = new i(t2, 16)).red || (t2 = t2.toRed(this.red));
        var r2 = t2.redSqr(), n2 = r2.redSub(this.c2), o2 = r2.redMul(this.d).redMul(this.c2).redSub(this.a), a2 = n2.redMul(o2.redInvm());
        if (a2.cmp(this.zero) === 0) {
          if (e2)
            throw new Error("invalid point");
          return this.point(this.zero, t2);
        }
        var s2 = a2.redSqrt();
        if (s2.redSqr().redSub(a2).cmp(this.zero) !== 0)
          throw new Error("invalid point");
        return s2.fromRed().isOdd() !== e2 && (s2 = s2.redNeg()), this.point(s2, t2);
      }, u.prototype.validate = function(t2) {
        if (t2.isInfinity())
          return true;
        t2.normalize();
        var e2 = t2.x.redSqr(), r2 = t2.y.redSqr(), n2 = e2.redMul(this.a).redAdd(r2), i2 = this.c2.redMul(this.one.redAdd(this.d.redMul(e2).redMul(r2)));
        return n2.cmp(i2) === 0;
      }, o(c, a.BasePoint), u.prototype.pointFromJSON = function(t2) {
        return c.fromJSON(this, t2);
      }, u.prototype.point = function(t2, e2, r2, n2) {
        return new c(this, t2, e2, r2, n2);
      }, c.fromJSON = function(t2, e2) {
        return new c(t2, e2[0], e2[1], e2[2]);
      }, c.prototype.inspect = function() {
        return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
      }, c.prototype.isInfinity = function() {
        return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
      }, c.prototype._extDbl = function() {
        var t2 = this.x.redSqr(), e2 = this.y.redSqr(), r2 = this.z.redSqr();
        r2 = r2.redIAdd(r2);
        var n2 = this.curve._mulA(t2), i2 = this.x.redAdd(this.y).redSqr().redISub(t2).redISub(e2), o2 = n2.redAdd(e2), a2 = o2.redSub(r2), s2 = n2.redSub(e2), u2 = i2.redMul(a2), c2 = o2.redMul(s2), f = i2.redMul(s2), l = a2.redMul(o2);
        return this.curve.point(u2, c2, l, f);
      }, c.prototype._projDbl = function() {
        var t2, e2, r2, n2 = this.x.redAdd(this.y).redSqr(), i2 = this.x.redSqr(), o2 = this.y.redSqr();
        if (this.curve.twisted) {
          var a2 = (c2 = this.curve._mulA(i2)).redAdd(o2);
          if (this.zOne)
            t2 = n2.redSub(i2).redSub(o2).redMul(a2.redSub(this.curve.two)), e2 = a2.redMul(c2.redSub(o2)), r2 = a2.redSqr().redSub(a2).redSub(a2);
          else {
            var s2 = this.z.redSqr(), u2 = a2.redSub(s2).redISub(s2);
            t2 = n2.redSub(i2).redISub(o2).redMul(u2), e2 = a2.redMul(c2.redSub(o2)), r2 = a2.redMul(u2);
          }
        } else {
          var c2 = i2.redAdd(o2);
          s2 = this.curve._mulC(this.z).redSqr(), u2 = c2.redSub(s2).redSub(s2);
          t2 = this.curve._mulC(n2.redISub(c2)).redMul(u2), e2 = this.curve._mulC(c2).redMul(i2.redISub(o2)), r2 = c2.redMul(u2);
        }
        return this.curve.point(t2, e2, r2);
      }, c.prototype.dbl = function() {
        return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
      }, c.prototype._extAdd = function(t2) {
        var e2 = this.y.redSub(this.x).redMul(t2.y.redSub(t2.x)), r2 = this.y.redAdd(this.x).redMul(t2.y.redAdd(t2.x)), n2 = this.t.redMul(this.curve.dd).redMul(t2.t), i2 = this.z.redMul(t2.z.redAdd(t2.z)), o2 = r2.redSub(e2), a2 = i2.redSub(n2), s2 = i2.redAdd(n2), u2 = r2.redAdd(e2), c2 = o2.redMul(a2), f = s2.redMul(u2), l = o2.redMul(u2), h = a2.redMul(s2);
        return this.curve.point(c2, f, h, l);
      }, c.prototype._projAdd = function(t2) {
        var e2, r2, n2 = this.z.redMul(t2.z), i2 = n2.redSqr(), o2 = this.x.redMul(t2.x), a2 = this.y.redMul(t2.y), s2 = this.curve.d.redMul(o2).redMul(a2), u2 = i2.redSub(s2), c2 = i2.redAdd(s2), f = this.x.redAdd(this.y).redMul(t2.x.redAdd(t2.y)).redISub(o2).redISub(a2), l = n2.redMul(u2).redMul(f);
        return this.curve.twisted ? (e2 = n2.redMul(c2).redMul(a2.redSub(this.curve._mulA(o2))), r2 = u2.redMul(c2)) : (e2 = n2.redMul(c2).redMul(a2.redSub(o2)), r2 = this.curve._mulC(u2).redMul(c2)), this.curve.point(l, e2, r2);
      }, c.prototype.add = function(t2) {
        return this.isInfinity() ? t2 : t2.isInfinity() ? this : this.curve.extended ? this._extAdd(t2) : this._projAdd(t2);
      }, c.prototype.mul = function(t2) {
        return this._hasDoubles(t2) ? this.curve._fixedNafMul(this, t2) : this.curve._wnafMul(this, t2);
      }, c.prototype.mulAdd = function(t2, e2, r2) {
        return this.curve._wnafMulAdd(1, [this, e2], [t2, r2], 2, false);
      }, c.prototype.jmulAdd = function(t2, e2, r2) {
        return this.curve._wnafMulAdd(1, [this, e2], [t2, r2], 2, true);
      }, c.prototype.normalize = function() {
        if (this.zOne)
          return this;
        var t2 = this.z.redInvm();
        return this.x = this.x.redMul(t2), this.y = this.y.redMul(t2), this.t && (this.t = this.t.redMul(t2)), this.z = this.curve.one, this.zOne = true, this;
      }, c.prototype.neg = function() {
        return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
      }, c.prototype.getX = function() {
        return this.normalize(), this.x.fromRed();
      }, c.prototype.getY = function() {
        return this.normalize(), this.y.fromRed();
      }, c.prototype.eq = function(t2) {
        return this === t2 || this.getX().cmp(t2.getX()) === 0 && this.getY().cmp(t2.getY()) === 0;
      }, c.prototype.eqXToP = function(t2) {
        var e2 = t2.toRed(this.curve.red).redMul(this.z);
        if (this.x.cmp(e2) === 0)
          return true;
        for (var r2 = t2.clone(), n2 = this.curve.redN.redMul(this.z); ; ) {
          if (r2.iadd(this.curve.n), r2.cmp(this.curve.p) >= 0)
            return false;
          if (e2.redIAdd(n2), this.x.cmp(e2) === 0)
            return true;
        }
      }, c.prototype.toP = c.prototype.normalize, c.prototype.mixedAdd = c.prototype.add;
    }, { "../utils": 364, "./base": 351, "bn.js": 365, inherits: 387 }], 353: [function(t, e, r) {
      var n = r;
      n.base = t("./base"), n.short = t("./short"), n.mont = t("./mont"), n.edwards = t("./edwards");
    }, { "./base": 351, "./edwards": 352, "./mont": 354, "./short": 355 }], 354: [function(t, e, r) {
      var n = t("bn.js"), i = t("inherits"), o = t("./base"), a = t("../utils");
      function s(t2) {
        o.call(this, "mont", t2), this.a = new n(t2.a, 16).toRed(this.red), this.b = new n(t2.b, 16).toRed(this.red), this.i4 = new n(4).toRed(this.red).redInvm(), this.two = new n(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
      }
      function u(t2, e2, r2) {
        o.BasePoint.call(this, t2, "projective"), e2 === null && r2 === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new n(e2, 16), this.z = new n(r2, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
      }
      i(s, o), e.exports = s, s.prototype.validate = function(t2) {
        var e2 = t2.normalize().x, r2 = e2.redSqr(), n2 = r2.redMul(e2).redAdd(r2.redMul(this.a)).redAdd(e2);
        return n2.redSqrt().redSqr().cmp(n2) === 0;
      }, i(u, o.BasePoint), s.prototype.decodePoint = function(t2, e2) {
        return this.point(a.toArray(t2, e2), 1);
      }, s.prototype.point = function(t2, e2) {
        return new u(this, t2, e2);
      }, s.prototype.pointFromJSON = function(t2) {
        return u.fromJSON(this, t2);
      }, u.prototype.precompute = function() {
      }, u.prototype._encode = function() {
        return this.getX().toArray("be", this.curve.p.byteLength());
      }, u.fromJSON = function(t2, e2) {
        return new u(t2, e2[0], e2[1] || t2.one);
      }, u.prototype.inspect = function() {
        return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
      }, u.prototype.isInfinity = function() {
        return this.z.cmpn(0) === 0;
      }, u.prototype.dbl = function() {
        var t2 = this.x.redAdd(this.z).redSqr(), e2 = this.x.redSub(this.z).redSqr(), r2 = t2.redSub(e2), n2 = t2.redMul(e2), i2 = r2.redMul(e2.redAdd(this.curve.a24.redMul(r2)));
        return this.curve.point(n2, i2);
      }, u.prototype.add = function() {
        throw new Error("Not supported on Montgomery curve");
      }, u.prototype.diffAdd = function(t2, e2) {
        var r2 = this.x.redAdd(this.z), n2 = this.x.redSub(this.z), i2 = t2.x.redAdd(t2.z), o2 = t2.x.redSub(t2.z).redMul(r2), a2 = i2.redMul(n2), s2 = e2.z.redMul(o2.redAdd(a2).redSqr()), u2 = e2.x.redMul(o2.redISub(a2).redSqr());
        return this.curve.point(s2, u2);
      }, u.prototype.mul = function(t2) {
        for (var e2 = t2.clone(), r2 = this, n2 = this.curve.point(null, null), i2 = []; e2.cmpn(0) !== 0; e2.iushrn(1))
          i2.push(e2.andln(1));
        for (var o2 = i2.length - 1; o2 >= 0; o2--)
          i2[o2] === 0 ? (r2 = r2.diffAdd(n2, this), n2 = n2.dbl()) : (n2 = r2.diffAdd(n2, this), r2 = r2.dbl());
        return n2;
      }, u.prototype.mulAdd = function() {
        throw new Error("Not supported on Montgomery curve");
      }, u.prototype.jumlAdd = function() {
        throw new Error("Not supported on Montgomery curve");
      }, u.prototype.eq = function(t2) {
        return this.getX().cmp(t2.getX()) === 0;
      }, u.prototype.normalize = function() {
        return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
      }, u.prototype.getX = function() {
        return this.normalize(), this.x.fromRed();
      };
    }, { "../utils": 364, "./base": 351, "bn.js": 365, inherits: 387 }], 355: [function(t, e, r) {
      var n = t("../utils"), i = t("bn.js"), o = t("inherits"), a = t("./base"), s = n.assert;
      function u(t2) {
        a.call(this, "short", t2), this.a = new i(t2.a, 16).toRed(this.red), this.b = new i(t2.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(t2), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
      }
      function c(t2, e2, r2, n2) {
        a.BasePoint.call(this, t2, "affine"), e2 === null && r2 === null ? (this.x = null, this.y = null, this.inf = true) : (this.x = new i(e2, 16), this.y = new i(r2, 16), n2 && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = false);
      }
      function f(t2, e2, r2, n2) {
        a.BasePoint.call(this, t2, "jacobian"), e2 === null && r2 === null && n2 === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new i(0)) : (this.x = new i(e2, 16), this.y = new i(r2, 16), this.z = new i(n2, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
      }
      o(u, a), e.exports = u, u.prototype._getEndomorphism = function(t2) {
        if (this.zeroA && this.g && this.n && this.p.modn(3) === 1) {
          var e2, r2;
          if (t2.beta)
            e2 = new i(t2.beta, 16).toRed(this.red);
          else {
            var n2 = this._getEndoRoots(this.p);
            e2 = (e2 = n2[0].cmp(n2[1]) < 0 ? n2[0] : n2[1]).toRed(this.red);
          }
          if (t2.lambda)
            r2 = new i(t2.lambda, 16);
          else {
            var o2 = this._getEndoRoots(this.n);
            this.g.mul(o2[0]).x.cmp(this.g.x.redMul(e2)) === 0 ? r2 = o2[0] : (r2 = o2[1], s(this.g.mul(r2).x.cmp(this.g.x.redMul(e2)) === 0));
          }
          return { beta: e2, lambda: r2, basis: t2.basis ? t2.basis.map(function(t3) {
            return { a: new i(t3.a, 16), b: new i(t3.b, 16) };
          }) : this._getEndoBasis(r2) };
        }
      }, u.prototype._getEndoRoots = function(t2) {
        var e2 = t2 === this.p ? this.red : i.mont(t2), r2 = new i(2).toRed(e2).redInvm(), n2 = r2.redNeg(), o2 = new i(3).toRed(e2).redNeg().redSqrt().redMul(r2);
        return [n2.redAdd(o2).fromRed(), n2.redSub(o2).fromRed()];
      }, u.prototype._getEndoBasis = function(t2) {
        for (var e2, r2, n2, o2, a2, s2, u2, c2, f2, l = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), h = t2, d = this.n.clone(), p = new i(1), m = new i(0), y = new i(0), b = new i(1), v = 0; h.cmpn(0) !== 0; ) {
          var g = d.div(h);
          c2 = d.sub(g.mul(h)), f2 = y.sub(g.mul(p));
          var w = b.sub(g.mul(m));
          if (!n2 && c2.cmp(l) < 0)
            e2 = u2.neg(), r2 = p, n2 = c2.neg(), o2 = f2;
          else if (n2 && ++v == 2)
            break;
          u2 = c2, d = h, h = c2, y = p, p = f2, b = m, m = w;
        }
        a2 = c2.neg(), s2 = f2;
        var _ = n2.sqr().add(o2.sqr());
        return a2.sqr().add(s2.sqr()).cmp(_) >= 0 && (a2 = e2, s2 = r2), n2.negative && (n2 = n2.neg(), o2 = o2.neg()), a2.negative && (a2 = a2.neg(), s2 = s2.neg()), [{ a: n2, b: o2 }, { a: a2, b: s2 }];
      }, u.prototype._endoSplit = function(t2) {
        var e2 = this.endo.basis, r2 = e2[0], n2 = e2[1], i2 = n2.b.mul(t2).divRound(this.n), o2 = r2.b.neg().mul(t2).divRound(this.n), a2 = i2.mul(r2.a), s2 = o2.mul(n2.a), u2 = i2.mul(r2.b), c2 = o2.mul(n2.b);
        return { k1: t2.sub(a2).sub(s2), k2: u2.add(c2).neg() };
      }, u.prototype.pointFromX = function(t2, e2) {
        (t2 = new i(t2, 16)).red || (t2 = t2.toRed(this.red));
        var r2 = t2.redSqr().redMul(t2).redIAdd(t2.redMul(this.a)).redIAdd(this.b), n2 = r2.redSqrt();
        if (n2.redSqr().redSub(r2).cmp(this.zero) !== 0)
          throw new Error("invalid point");
        var o2 = n2.fromRed().isOdd();
        return (e2 && !o2 || !e2 && o2) && (n2 = n2.redNeg()), this.point(t2, n2);
      }, u.prototype.validate = function(t2) {
        if (t2.inf)
          return true;
        var e2 = t2.x, r2 = t2.y, n2 = this.a.redMul(e2), i2 = e2.redSqr().redMul(e2).redIAdd(n2).redIAdd(this.b);
        return r2.redSqr().redISub(i2).cmpn(0) === 0;
      }, u.prototype._endoWnafMulAdd = function(t2, e2, r2) {
        for (var n2 = this._endoWnafT1, i2 = this._endoWnafT2, o2 = 0; o2 < t2.length; o2++) {
          var a2 = this._endoSplit(e2[o2]), s2 = t2[o2], u2 = s2._getBeta();
          a2.k1.negative && (a2.k1.ineg(), s2 = s2.neg(true)), a2.k2.negative && (a2.k2.ineg(), u2 = u2.neg(true)), n2[2 * o2] = s2, n2[2 * o2 + 1] = u2, i2[2 * o2] = a2.k1, i2[2 * o2 + 1] = a2.k2;
        }
        for (var c2 = this._wnafMulAdd(1, n2, i2, 2 * o2, r2), f2 = 0; f2 < 2 * o2; f2++)
          n2[f2] = null, i2[f2] = null;
        return c2;
      }, o(c, a.BasePoint), u.prototype.point = function(t2, e2, r2) {
        return new c(this, t2, e2, r2);
      }, u.prototype.pointFromJSON = function(t2, e2) {
        return c.fromJSON(this, t2, e2);
      }, c.prototype._getBeta = function() {
        if (this.curve.endo) {
          var t2 = this.precomputed;
          if (t2 && t2.beta)
            return t2.beta;
          var e2 = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
          if (t2) {
            var r2 = this.curve, n2 = function(t3) {
              return r2.point(t3.x.redMul(r2.endo.beta), t3.y);
            };
            t2.beta = e2, e2.precomputed = { beta: null, naf: t2.naf && { wnd: t2.naf.wnd, points: t2.naf.points.map(n2) }, doubles: t2.doubles && { step: t2.doubles.step, points: t2.doubles.points.map(n2) } };
          }
          return e2;
        }
      }, c.prototype.toJSON = function() {
        return this.precomputed ? [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }] : [this.x, this.y];
      }, c.fromJSON = function(t2, e2, r2) {
        typeof e2 == "string" && (e2 = JSON.parse(e2));
        var n2 = t2.point(e2[0], e2[1], r2);
        if (!e2[2])
          return n2;
        function i2(e3) {
          return t2.point(e3[0], e3[1], r2);
        }
        var o2 = e2[2];
        return n2.precomputed = { beta: null, doubles: o2.doubles && { step: o2.doubles.step, points: [n2].concat(o2.doubles.points.map(i2)) }, naf: o2.naf && { wnd: o2.naf.wnd, points: [n2].concat(o2.naf.points.map(i2)) } }, n2;
      }, c.prototype.inspect = function() {
        return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
      }, c.prototype.isInfinity = function() {
        return this.inf;
      }, c.prototype.add = function(t2) {
        if (this.inf)
          return t2;
        if (t2.inf)
          return this;
        if (this.eq(t2))
          return this.dbl();
        if (this.neg().eq(t2))
          return this.curve.point(null, null);
        if (this.x.cmp(t2.x) === 0)
          return this.curve.point(null, null);
        var e2 = this.y.redSub(t2.y);
        e2.cmpn(0) !== 0 && (e2 = e2.redMul(this.x.redSub(t2.x).redInvm()));
        var r2 = e2.redSqr().redISub(this.x).redISub(t2.x), n2 = e2.redMul(this.x.redSub(r2)).redISub(this.y);
        return this.curve.point(r2, n2);
      }, c.prototype.dbl = function() {
        if (this.inf)
          return this;
        var t2 = this.y.redAdd(this.y);
        if (t2.cmpn(0) === 0)
          return this.curve.point(null, null);
        var e2 = this.curve.a, r2 = this.x.redSqr(), n2 = t2.redInvm(), i2 = r2.redAdd(r2).redIAdd(r2).redIAdd(e2).redMul(n2), o2 = i2.redSqr().redISub(this.x.redAdd(this.x)), a2 = i2.redMul(this.x.redSub(o2)).redISub(this.y);
        return this.curve.point(o2, a2);
      }, c.prototype.getX = function() {
        return this.x.fromRed();
      }, c.prototype.getY = function() {
        return this.y.fromRed();
      }, c.prototype.mul = function(t2) {
        return t2 = new i(t2, 16), this.isInfinity() ? this : this._hasDoubles(t2) ? this.curve._fixedNafMul(this, t2) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [t2]) : this.curve._wnafMul(this, t2);
      }, c.prototype.mulAdd = function(t2, e2, r2) {
        var n2 = [this, e2], i2 = [t2, r2];
        return this.curve.endo ? this.curve._endoWnafMulAdd(n2, i2) : this.curve._wnafMulAdd(1, n2, i2, 2);
      }, c.prototype.jmulAdd = function(t2, e2, r2) {
        var n2 = [this, e2], i2 = [t2, r2];
        return this.curve.endo ? this.curve._endoWnafMulAdd(n2, i2, true) : this.curve._wnafMulAdd(1, n2, i2, 2, true);
      }, c.prototype.eq = function(t2) {
        return this === t2 || this.inf === t2.inf && (this.inf || this.x.cmp(t2.x) === 0 && this.y.cmp(t2.y) === 0);
      }, c.prototype.neg = function(t2) {
        if (this.inf)
          return this;
        var e2 = this.curve.point(this.x, this.y.redNeg());
        if (t2 && this.precomputed) {
          var r2 = this.precomputed, n2 = function(t3) {
            return t3.neg();
          };
          e2.precomputed = { naf: r2.naf && { wnd: r2.naf.wnd, points: r2.naf.points.map(n2) }, doubles: r2.doubles && { step: r2.doubles.step, points: r2.doubles.points.map(n2) } };
        }
        return e2;
      }, c.prototype.toJ = function() {
        return this.inf ? this.curve.jpoint(null, null, null) : this.curve.jpoint(this.x, this.y, this.curve.one);
      }, o(f, a.BasePoint), u.prototype.jpoint = function(t2, e2, r2) {
        return new f(this, t2, e2, r2);
      }, f.prototype.toP = function() {
        if (this.isInfinity())
          return this.curve.point(null, null);
        var t2 = this.z.redInvm(), e2 = t2.redSqr(), r2 = this.x.redMul(e2), n2 = this.y.redMul(e2).redMul(t2);
        return this.curve.point(r2, n2);
      }, f.prototype.neg = function() {
        return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
      }, f.prototype.add = function(t2) {
        if (this.isInfinity())
          return t2;
        if (t2.isInfinity())
          return this;
        var e2 = t2.z.redSqr(), r2 = this.z.redSqr(), n2 = this.x.redMul(e2), i2 = t2.x.redMul(r2), o2 = this.y.redMul(e2.redMul(t2.z)), a2 = t2.y.redMul(r2.redMul(this.z)), s2 = n2.redSub(i2), u2 = o2.redSub(a2);
        if (s2.cmpn(0) === 0)
          return u2.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
        var c2 = s2.redSqr(), f2 = c2.redMul(s2), l = n2.redMul(c2), h = u2.redSqr().redIAdd(f2).redISub(l).redISub(l), d = u2.redMul(l.redISub(h)).redISub(o2.redMul(f2)), p = this.z.redMul(t2.z).redMul(s2);
        return this.curve.jpoint(h, d, p);
      }, f.prototype.mixedAdd = function(t2) {
        if (this.isInfinity())
          return t2.toJ();
        if (t2.isInfinity())
          return this;
        var e2 = this.z.redSqr(), r2 = this.x, n2 = t2.x.redMul(e2), i2 = this.y, o2 = t2.y.redMul(e2).redMul(this.z), a2 = r2.redSub(n2), s2 = i2.redSub(o2);
        if (a2.cmpn(0) === 0)
          return s2.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
        var u2 = a2.redSqr(), c2 = u2.redMul(a2), f2 = r2.redMul(u2), l = s2.redSqr().redIAdd(c2).redISub(f2).redISub(f2), h = s2.redMul(f2.redISub(l)).redISub(i2.redMul(c2)), d = this.z.redMul(a2);
        return this.curve.jpoint(l, h, d);
      }, f.prototype.dblp = function(t2) {
        if (t2 === 0)
          return this;
        if (this.isInfinity())
          return this;
        if (!t2)
          return this.dbl();
        if (this.curve.zeroA || this.curve.threeA) {
          for (var e2 = this, r2 = 0; r2 < t2; r2++)
            e2 = e2.dbl();
          return e2;
        }
        var n2 = this.curve.a, i2 = this.curve.tinv, o2 = this.x, a2 = this.y, s2 = this.z, u2 = s2.redSqr().redSqr(), c2 = a2.redAdd(a2);
        for (r2 = 0; r2 < t2; r2++) {
          var f2 = o2.redSqr(), l = c2.redSqr(), h = l.redSqr(), d = f2.redAdd(f2).redIAdd(f2).redIAdd(n2.redMul(u2)), p = o2.redMul(l), m = d.redSqr().redISub(p.redAdd(p)), y = p.redISub(m), b = d.redMul(y);
          b = b.redIAdd(b).redISub(h);
          var v = c2.redMul(s2);
          r2 + 1 < t2 && (u2 = u2.redMul(h)), o2 = m, s2 = v, c2 = b;
        }
        return this.curve.jpoint(o2, c2.redMul(i2), s2);
      }, f.prototype.dbl = function() {
        return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
      }, f.prototype._zeroDbl = function() {
        var t2, e2, r2;
        if (this.zOne) {
          var n2 = this.x.redSqr(), i2 = this.y.redSqr(), o2 = i2.redSqr(), a2 = this.x.redAdd(i2).redSqr().redISub(n2).redISub(o2);
          a2 = a2.redIAdd(a2);
          var s2 = n2.redAdd(n2).redIAdd(n2), u2 = s2.redSqr().redISub(a2).redISub(a2), c2 = o2.redIAdd(o2);
          c2 = (c2 = c2.redIAdd(c2)).redIAdd(c2), t2 = u2, e2 = s2.redMul(a2.redISub(u2)).redISub(c2), r2 = this.y.redAdd(this.y);
        } else {
          var f2 = this.x.redSqr(), l = this.y.redSqr(), h = l.redSqr(), d = this.x.redAdd(l).redSqr().redISub(f2).redISub(h);
          d = d.redIAdd(d);
          var p = f2.redAdd(f2).redIAdd(f2), m = p.redSqr(), y = h.redIAdd(h);
          y = (y = y.redIAdd(y)).redIAdd(y), t2 = m.redISub(d).redISub(d), e2 = p.redMul(d.redISub(t2)).redISub(y), r2 = (r2 = this.y.redMul(this.z)).redIAdd(r2);
        }
        return this.curve.jpoint(t2, e2, r2);
      }, f.prototype._threeDbl = function() {
        var t2, e2, r2;
        if (this.zOne) {
          var n2 = this.x.redSqr(), i2 = this.y.redSqr(), o2 = i2.redSqr(), a2 = this.x.redAdd(i2).redSqr().redISub(n2).redISub(o2);
          a2 = a2.redIAdd(a2);
          var s2 = n2.redAdd(n2).redIAdd(n2).redIAdd(this.curve.a), u2 = s2.redSqr().redISub(a2).redISub(a2);
          t2 = u2;
          var c2 = o2.redIAdd(o2);
          c2 = (c2 = c2.redIAdd(c2)).redIAdd(c2), e2 = s2.redMul(a2.redISub(u2)).redISub(c2), r2 = this.y.redAdd(this.y);
        } else {
          var f2 = this.z.redSqr(), l = this.y.redSqr(), h = this.x.redMul(l), d = this.x.redSub(f2).redMul(this.x.redAdd(f2));
          d = d.redAdd(d).redIAdd(d);
          var p = h.redIAdd(h), m = (p = p.redIAdd(p)).redAdd(p);
          t2 = d.redSqr().redISub(m), r2 = this.y.redAdd(this.z).redSqr().redISub(l).redISub(f2);
          var y = l.redSqr();
          y = (y = (y = y.redIAdd(y)).redIAdd(y)).redIAdd(y), e2 = d.redMul(p.redISub(t2)).redISub(y);
        }
        return this.curve.jpoint(t2, e2, r2);
      }, f.prototype._dbl = function() {
        var t2 = this.curve.a, e2 = this.x, r2 = this.y, n2 = this.z, i2 = n2.redSqr().redSqr(), o2 = e2.redSqr(), a2 = r2.redSqr(), s2 = o2.redAdd(o2).redIAdd(o2).redIAdd(t2.redMul(i2)), u2 = e2.redAdd(e2), c2 = (u2 = u2.redIAdd(u2)).redMul(a2), f2 = s2.redSqr().redISub(c2.redAdd(c2)), l = c2.redISub(f2), h = a2.redSqr();
        h = (h = (h = h.redIAdd(h)).redIAdd(h)).redIAdd(h);
        var d = s2.redMul(l).redISub(h), p = r2.redAdd(r2).redMul(n2);
        return this.curve.jpoint(f2, d, p);
      }, f.prototype.trpl = function() {
        if (!this.curve.zeroA)
          return this.dbl().add(this);
        var t2 = this.x.redSqr(), e2 = this.y.redSqr(), r2 = this.z.redSqr(), n2 = e2.redSqr(), i2 = t2.redAdd(t2).redIAdd(t2), o2 = i2.redSqr(), a2 = this.x.redAdd(e2).redSqr().redISub(t2).redISub(n2), s2 = (a2 = (a2 = (a2 = a2.redIAdd(a2)).redAdd(a2).redIAdd(a2)).redISub(o2)).redSqr(), u2 = n2.redIAdd(n2);
        u2 = (u2 = (u2 = u2.redIAdd(u2)).redIAdd(u2)).redIAdd(u2);
        var c2 = i2.redIAdd(a2).redSqr().redISub(o2).redISub(s2).redISub(u2), f2 = e2.redMul(c2);
        f2 = (f2 = f2.redIAdd(f2)).redIAdd(f2);
        var l = this.x.redMul(s2).redISub(f2);
        l = (l = l.redIAdd(l)).redIAdd(l);
        var h = this.y.redMul(c2.redMul(u2.redISub(c2)).redISub(a2.redMul(s2)));
        h = (h = (h = h.redIAdd(h)).redIAdd(h)).redIAdd(h);
        var d = this.z.redAdd(a2).redSqr().redISub(r2).redISub(s2);
        return this.curve.jpoint(l, h, d);
      }, f.prototype.mul = function(t2, e2) {
        return t2 = new i(t2, e2), this.curve._wnafMul(this, t2);
      }, f.prototype.eq = function(t2) {
        if (t2.type === "affine")
          return this.eq(t2.toJ());
        if (this === t2)
          return true;
        var e2 = this.z.redSqr(), r2 = t2.z.redSqr();
        if (this.x.redMul(r2).redISub(t2.x.redMul(e2)).cmpn(0) !== 0)
          return false;
        var n2 = e2.redMul(this.z), i2 = r2.redMul(t2.z);
        return this.y.redMul(i2).redISub(t2.y.redMul(n2)).cmpn(0) === 0;
      }, f.prototype.eqXToP = function(t2) {
        var e2 = this.z.redSqr(), r2 = t2.toRed(this.curve.red).redMul(e2);
        if (this.x.cmp(r2) === 0)
          return true;
        for (var n2 = t2.clone(), i2 = this.curve.redN.redMul(e2); ; ) {
          if (n2.iadd(this.curve.n), n2.cmp(this.curve.p) >= 0)
            return false;
          if (r2.redIAdd(i2), this.x.cmp(r2) === 0)
            return true;
        }
      }, f.prototype.inspect = function() {
        return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
      }, f.prototype.isInfinity = function() {
        return this.z.cmpn(0) === 0;
      };
    }, { "../utils": 364, "./base": 351, "bn.js": 365, inherits: 387 }], 356: [function(t, e, r) {
      var n, i = r, o = t("hash.js"), a = t("./curve"), s = t("./utils").assert;
      function u(t2) {
        t2.type === "short" ? this.curve = new a.short(t2) : t2.type === "edwards" ? this.curve = new a.edwards(t2) : this.curve = new a.mont(t2), this.g = this.curve.g, this.n = this.curve.n, this.hash = t2.hash, s(this.g.validate(), "Invalid curve"), s(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
      }
      function c(t2, e2) {
        Object.defineProperty(i, t2, { configurable: true, enumerable: true, get: function() {
          var r2 = new u(e2);
          return Object.defineProperty(i, t2, { configurable: true, enumerable: true, value: r2 }), r2;
        } });
      }
      i.PresetCurve = u, c("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: o.sha256, gRed: false, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] }), c("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: o.sha256, gRed: false, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] }), c("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: o.sha256, gRed: false, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] }), c("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: o.sha384, gRed: false, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] }), c("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: o.sha512, gRed: false, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] }), c("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: o.sha256, gRed: false, g: ["9"] }), c("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: o.sha256, gRed: false, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] });
      try {
        n = t("./precomputed/secp256k1");
      } catch (t2) {
        n = void 0;
      }
      c("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: o.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: false, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", n] });
    }, { "./curve": 353, "./precomputed/secp256k1": 363, "./utils": 364, "hash.js": 372 }], 357: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      var i = t("bn.js"), o = t("hmac-drbg"), a = t("../utils"), s = t("../curves"), u = t("brorand"), c = a.assert, f = t("./key"), l = t("./signature");
      function h(t2) {
        if (!(this instanceof h))
          return new h(t2);
        typeof t2 == "string" && (c(s.hasOwnProperty(t2), "Unknown curve " + t2), t2 = s[t2]), t2 instanceof s.PresetCurve && (t2 = { curve: t2 }), this.curve = t2.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = t2.curve.g, this.g.precompute(t2.curve.n.bitLength() + 1), this.hash = t2.hash || t2.curve.hash;
      }
      e.exports = h, h.prototype.keyPair = function(t2) {
        return new f(this, t2);
      }, h.prototype.keyFromPrivate = function(t2, e2) {
        return f.fromPrivate(this, t2, e2);
      }, h.prototype.keyFromPublic = function(t2, e2) {
        return f.fromPublic(this, t2, e2);
      }, h.prototype.genKeyPair = function(t2) {
        t2 || (t2 = {});
        for (var e2 = new o({ hash: this.hash, pers: t2.pers, persEnc: t2.persEnc || "utf8", entropy: t2.entropy || u(this.hash.hmacStrength), entropyEnc: t2.entropy && t2.entropyEnc || "utf8", nonce: this.n.toArray() }), r2 = this.n.byteLength(), n2 = this.n.sub(new i(2)); ; ) {
          var a2 = new i(e2.generate(r2));
          if (!(a2.cmp(n2) > 0))
            return a2.iaddn(1), this.keyFromPrivate(a2);
        }
      }, h.prototype._truncateToN = function(t2, e2) {
        var r2 = 8 * t2.byteLength() - this.n.bitLength();
        return r2 > 0 && (t2 = t2.ushrn(r2)), !e2 && t2.cmp(this.n) >= 0 ? t2.sub(this.n) : t2;
      }, h.prototype.sign = function(t2, e2, r2, a2) {
        n(r2) === "object" && (a2 = r2, r2 = null), a2 || (a2 = {}), e2 = this.keyFromPrivate(e2, r2), t2 = this._truncateToN(new i(t2, 16));
        for (var s2 = this.n.byteLength(), u2 = e2.getPrivate().toArray("be", s2), c2 = t2.toArray("be", s2), f2 = new o({ hash: this.hash, entropy: u2, nonce: c2, pers: a2.pers, persEnc: a2.persEnc || "utf8" }), h2 = this.n.sub(new i(1)), d = 0; ; d++) {
          var p = a2.k ? a2.k(d) : new i(f2.generate(this.n.byteLength()));
          if (!((p = this._truncateToN(p, true)).cmpn(1) <= 0 || p.cmp(h2) >= 0)) {
            var m = this.g.mul(p);
            if (!m.isInfinity()) {
              var y = m.getX(), b = y.umod(this.n);
              if (b.cmpn(0) !== 0) {
                var v = p.invm(this.n).mul(b.mul(e2.getPrivate()).iadd(t2));
                if ((v = v.umod(this.n)).cmpn(0) !== 0) {
                  var g = (m.getY().isOdd() ? 1 : 0) | (y.cmp(b) !== 0 ? 2 : 0);
                  return a2.canonical && v.cmp(this.nh) > 0 && (v = this.n.sub(v), g ^= 1), new l({ r: b, s: v, recoveryParam: g });
                }
              }
            }
          }
        }
      }, h.prototype.verify = function(t2, e2, r2, n2) {
        t2 = this._truncateToN(new i(t2, 16)), r2 = this.keyFromPublic(r2, n2);
        var o2 = (e2 = new l(e2, "hex")).r, a2 = e2.s;
        if (o2.cmpn(1) < 0 || o2.cmp(this.n) >= 0)
          return false;
        if (a2.cmpn(1) < 0 || a2.cmp(this.n) >= 0)
          return false;
        var s2, u2 = a2.invm(this.n), c2 = u2.mul(t2).umod(this.n), f2 = u2.mul(o2).umod(this.n);
        return this.curve._maxwellTrick ? !(s2 = this.g.jmulAdd(c2, r2.getPublic(), f2)).isInfinity() && s2.eqXToP(o2) : !(s2 = this.g.mulAdd(c2, r2.getPublic(), f2)).isInfinity() && s2.getX().umod(this.n).cmp(o2) === 0;
      }, h.prototype.recoverPubKey = function(t2, e2, r2, n2) {
        c((3 & r2) === r2, "The recovery param is more than two bits"), e2 = new l(e2, n2);
        var o2 = this.n, a2 = new i(t2), s2 = e2.r, u2 = e2.s, f2 = 1 & r2, h2 = r2 >> 1;
        if (s2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && h2)
          throw new Error("Unable to find sencond key candinate");
        s2 = h2 ? this.curve.pointFromX(s2.add(this.curve.n), f2) : this.curve.pointFromX(s2, f2);
        var d = e2.r.invm(o2), p = o2.sub(a2).mul(d).umod(o2), m = u2.mul(d).umod(o2);
        return this.g.mulAdd(p, s2, m);
      }, h.prototype.getKeyRecoveryParam = function(t2, e2, r2, n2) {
        if ((e2 = new l(e2, n2)).recoveryParam !== null)
          return e2.recoveryParam;
        for (var i2 = 0; i2 < 4; i2++) {
          var o2;
          try {
            o2 = this.recoverPubKey(t2, e2, i2);
          } catch (t3) {
            continue;
          }
          if (o2.eq(r2))
            return i2;
        }
        throw new Error("Unable to find valid recovery factor");
      };
    }, { "../curves": 356, "../utils": 364, "./key": 358, "./signature": 359, "bn.js": 365, brorand: 184, "hmac-drbg": 384 }], 358: [function(t, e, r) {
      var n = t("bn.js"), i = t("../utils").assert;
      function o(t2, e2) {
        this.ec = t2, this.priv = null, this.pub = null, e2.priv && this._importPrivate(e2.priv, e2.privEnc), e2.pub && this._importPublic(e2.pub, e2.pubEnc);
      }
      e.exports = o, o.fromPublic = function(t2, e2, r2) {
        return e2 instanceof o ? e2 : new o(t2, { pub: e2, pubEnc: r2 });
      }, o.fromPrivate = function(t2, e2, r2) {
        return e2 instanceof o ? e2 : new o(t2, { priv: e2, privEnc: r2 });
      }, o.prototype.validate = function() {
        var t2 = this.getPublic();
        return t2.isInfinity() ? { result: false, reason: "Invalid public key" } : t2.validate() ? t2.mul(this.ec.curve.n).isInfinity() ? { result: true, reason: null } : { result: false, reason: "Public key * N != O" } : { result: false, reason: "Public key is not a point" };
      }, o.prototype.getPublic = function(t2, e2) {
        return typeof t2 == "string" && (e2 = t2, t2 = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), e2 ? this.pub.encode(e2, t2) : this.pub;
      }, o.prototype.getPrivate = function(t2) {
        return t2 === "hex" ? this.priv.toString(16, 2) : this.priv;
      }, o.prototype._importPrivate = function(t2, e2) {
        this.priv = new n(t2, e2 || 16), this.priv = this.priv.umod(this.ec.curve.n);
      }, o.prototype._importPublic = function(t2, e2) {
        if (t2.x || t2.y)
          return this.ec.curve.type === "mont" ? i(t2.x, "Need x coordinate") : this.ec.curve.type !== "short" && this.ec.curve.type !== "edwards" || i(t2.x && t2.y, "Need both x and y coordinate"), void (this.pub = this.ec.curve.point(t2.x, t2.y));
        this.pub = this.ec.curve.decodePoint(t2, e2);
      }, o.prototype.derive = function(t2) {
        return t2.mul(this.priv).getX();
      }, o.prototype.sign = function(t2, e2, r2) {
        return this.ec.sign(t2, this, e2, r2);
      }, o.prototype.verify = function(t2, e2) {
        return this.ec.verify(t2, e2, this);
      }, o.prototype.inspect = function() {
        return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
      };
    }, { "../utils": 364, "bn.js": 365 }], 359: [function(t, e, r) {
      var n = t("bn.js"), i = t("../utils"), o = i.assert;
      function a(t2, e2) {
        if (t2 instanceof a)
          return t2;
        this._importDER(t2, e2) || (o(t2.r && t2.s, "Signature without r or s"), this.r = new n(t2.r, 16), this.s = new n(t2.s, 16), t2.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = t2.recoveryParam);
      }
      function s() {
        this.place = 0;
      }
      function u(t2, e2) {
        var r2 = t2[e2.place++];
        if (!(128 & r2))
          return r2;
        var n2 = 15 & r2;
        if (n2 === 0 || n2 > 4)
          return false;
        for (var i2 = 0, o2 = 0, a2 = e2.place; o2 < n2; o2++, a2++)
          i2 <<= 8, i2 |= t2[a2], i2 >>>= 0;
        return !(i2 <= 127) && (e2.place = a2, i2);
      }
      function c(t2) {
        for (var e2 = 0, r2 = t2.length - 1; !t2[e2] && !(128 & t2[e2 + 1]) && e2 < r2; )
          e2++;
        return e2 === 0 ? t2 : t2.slice(e2);
      }
      function f(t2, e2) {
        if (e2 < 128)
          t2.push(e2);
        else {
          var r2 = 1 + (Math.log(e2) / Math.LN2 >>> 3);
          for (t2.push(128 | r2); --r2; )
            t2.push(e2 >>> (r2 << 3) & 255);
          t2.push(e2);
        }
      }
      e.exports = a, a.prototype._importDER = function(t2, e2) {
        t2 = i.toArray(t2, e2);
        var r2 = new s();
        if (t2[r2.place++] !== 48)
          return false;
        var o2 = u(t2, r2);
        if (o2 === false)
          return false;
        if (o2 + r2.place !== t2.length)
          return false;
        if (t2[r2.place++] !== 2)
          return false;
        var a2 = u(t2, r2);
        if (a2 === false)
          return false;
        var c2 = t2.slice(r2.place, a2 + r2.place);
        if (r2.place += a2, t2[r2.place++] !== 2)
          return false;
        var f2 = u(t2, r2);
        if (f2 === false)
          return false;
        if (t2.length !== f2 + r2.place)
          return false;
        var l = t2.slice(r2.place, f2 + r2.place);
        if (c2[0] === 0) {
          if (!(128 & c2[1]))
            return false;
          c2 = c2.slice(1);
        }
        if (l[0] === 0) {
          if (!(128 & l[1]))
            return false;
          l = l.slice(1);
        }
        return this.r = new n(c2), this.s = new n(l), this.recoveryParam = null, true;
      }, a.prototype.toDER = function(t2) {
        var e2 = this.r.toArray(), r2 = this.s.toArray();
        for (128 & e2[0] && (e2 = [0].concat(e2)), 128 & r2[0] && (r2 = [0].concat(r2)), e2 = c(e2), r2 = c(r2); !(r2[0] || 128 & r2[1]); )
          r2 = r2.slice(1);
        var n2 = [2];
        f(n2, e2.length), (n2 = n2.concat(e2)).push(2), f(n2, r2.length);
        var o2 = n2.concat(r2), a2 = [48];
        return f(a2, o2.length), a2 = a2.concat(o2), i.encode(a2, t2);
      };
    }, { "../utils": 364, "bn.js": 365 }], 360: [function(t, e, r) {
      var n = t("hash.js"), i = t("../curves"), o = t("../utils"), a = o.assert, s = o.parseBytes, u = t("./key"), c = t("./signature");
      function f(t2) {
        if (a(t2 === "ed25519", "only tested with ed25519 so far"), !(this instanceof f))
          return new f(t2);
        t2 = i[t2].curve;
        this.curve = t2, this.g = t2.g, this.g.precompute(t2.n.bitLength() + 1), this.pointClass = t2.point().constructor, this.encodingLength = Math.ceil(t2.n.bitLength() / 8), this.hash = n.sha512;
      }
      e.exports = f, f.prototype.sign = function(t2, e2) {
        t2 = s(t2);
        var r2 = this.keyFromSecret(e2), n2 = this.hashInt(r2.messagePrefix(), t2), i2 = this.g.mul(n2), o2 = this.encodePoint(i2), a2 = this.hashInt(o2, r2.pubBytes(), t2).mul(r2.priv()), u2 = n2.add(a2).umod(this.curve.n);
        return this.makeSignature({ R: i2, S: u2, Rencoded: o2 });
      }, f.prototype.verify = function(t2, e2, r2) {
        t2 = s(t2), e2 = this.makeSignature(e2);
        var n2 = this.keyFromPublic(r2), i2 = this.hashInt(e2.Rencoded(), n2.pubBytes(), t2), o2 = this.g.mul(e2.S());
        return e2.R().add(n2.pub().mul(i2)).eq(o2);
      }, f.prototype.hashInt = function() {
        for (var t2 = this.hash(), e2 = 0; e2 < arguments.length; e2++)
          t2.update(arguments[e2]);
        return o.intFromLE(t2.digest()).umod(this.curve.n);
      }, f.prototype.keyFromPublic = function(t2) {
        return u.fromPublic(this, t2);
      }, f.prototype.keyFromSecret = function(t2) {
        return u.fromSecret(this, t2);
      }, f.prototype.makeSignature = function(t2) {
        return t2 instanceof c ? t2 : new c(this, t2);
      }, f.prototype.encodePoint = function(t2) {
        var e2 = t2.getY().toArray("le", this.encodingLength);
        return e2[this.encodingLength - 1] |= t2.getX().isOdd() ? 128 : 0, e2;
      }, f.prototype.decodePoint = function(t2) {
        var e2 = (t2 = o.parseBytes(t2)).length - 1, r2 = t2.slice(0, e2).concat(-129 & t2[e2]), n2 = (128 & t2[e2]) != 0, i2 = o.intFromLE(r2);
        return this.curve.pointFromY(i2, n2);
      }, f.prototype.encodeInt = function(t2) {
        return t2.toArray("le", this.encodingLength);
      }, f.prototype.decodeInt = function(t2) {
        return o.intFromLE(t2);
      }, f.prototype.isPoint = function(t2) {
        return t2 instanceof this.pointClass;
      };
    }, { "../curves": 356, "../utils": 364, "./key": 361, "./signature": 362, "hash.js": 372 }], 361: [function(t, e, r) {
      var n = t("../utils"), i = n.assert, o = n.parseBytes, a = n.cachedProperty;
      function s(t2, e2) {
        this.eddsa = t2, this._secret = o(e2.secret), t2.isPoint(e2.pub) ? this._pub = e2.pub : this._pubBytes = o(e2.pub);
      }
      s.fromPublic = function(t2, e2) {
        return e2 instanceof s ? e2 : new s(t2, { pub: e2 });
      }, s.fromSecret = function(t2, e2) {
        return e2 instanceof s ? e2 : new s(t2, { secret: e2 });
      }, s.prototype.secret = function() {
        return this._secret;
      }, a(s, "pubBytes", function() {
        return this.eddsa.encodePoint(this.pub());
      }), a(s, "pub", function() {
        return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
      }), a(s, "privBytes", function() {
        var t2 = this.eddsa, e2 = this.hash(), r2 = t2.encodingLength - 1, n2 = e2.slice(0, t2.encodingLength);
        return n2[0] &= 248, n2[r2] &= 127, n2[r2] |= 64, n2;
      }), a(s, "priv", function() {
        return this.eddsa.decodeInt(this.privBytes());
      }), a(s, "hash", function() {
        return this.eddsa.hash().update(this.secret()).digest();
      }), a(s, "messagePrefix", function() {
        return this.hash().slice(this.eddsa.encodingLength);
      }), s.prototype.sign = function(t2) {
        return i(this._secret, "KeyPair can only verify"), this.eddsa.sign(t2, this);
      }, s.prototype.verify = function(t2, e2) {
        return this.eddsa.verify(t2, e2, this);
      }, s.prototype.getSecret = function(t2) {
        return i(this._secret, "KeyPair is public only"), n.encode(this.secret(), t2);
      }, s.prototype.getPublic = function(t2) {
        return n.encode(this.pubBytes(), t2);
      }, e.exports = s;
    }, { "../utils": 364 }], 362: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      var i = t("bn.js"), o = t("../utils"), a = o.assert, s = o.cachedProperty, u = o.parseBytes;
      function c(t2, e2) {
        this.eddsa = t2, n(e2) !== "object" && (e2 = u(e2)), Array.isArray(e2) && (e2 = { R: e2.slice(0, t2.encodingLength), S: e2.slice(t2.encodingLength) }), a(e2.R && e2.S, "Signature without R or S"), t2.isPoint(e2.R) && (this._R = e2.R), e2.S instanceof i && (this._S = e2.S), this._Rencoded = Array.isArray(e2.R) ? e2.R : e2.Rencoded, this._Sencoded = Array.isArray(e2.S) ? e2.S : e2.Sencoded;
      }
      s(c, "S", function() {
        return this.eddsa.decodeInt(this.Sencoded());
      }), s(c, "R", function() {
        return this.eddsa.decodePoint(this.Rencoded());
      }), s(c, "Rencoded", function() {
        return this.eddsa.encodePoint(this.R());
      }), s(c, "Sencoded", function() {
        return this.eddsa.encodeInt(this.S());
      }), c.prototype.toBytes = function() {
        return this.Rencoded().concat(this.Sencoded());
      }, c.prototype.toHex = function() {
        return o.encode(this.toBytes(), "hex").toUpperCase();
      }, e.exports = c;
    }, { "../utils": 364, "bn.js": 365 }], 363: [function(t, e, r) {
      e.exports = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } };
    }, {}], 364: [function(t, e, r) {
      var n = r, i = t("bn.js"), o = t("minimalistic-assert"), a = t("minimalistic-crypto-utils");
      n.assert = o, n.toArray = a.toArray, n.zero2 = a.zero2, n.toHex = a.toHex, n.encode = a.encode, n.getNAF = function(t2, e2, r2) {
        var n2 = new Array(Math.max(t2.bitLength(), r2) + 1);
        n2.fill(0);
        for (var i2 = 1 << e2 + 1, o2 = t2.clone(), a2 = 0; a2 < n2.length; a2++) {
          var s, u = o2.andln(i2 - 1);
          o2.isOdd() ? (s = u > (i2 >> 1) - 1 ? (i2 >> 1) - u : u, o2.isubn(s)) : s = 0, n2[a2] = s, o2.iushrn(1);
        }
        return n2;
      }, n.getJSF = function(t2, e2) {
        var r2 = [[], []];
        t2 = t2.clone(), e2 = e2.clone();
        for (var n2 = 0, i2 = 0; t2.cmpn(-n2) > 0 || e2.cmpn(-i2) > 0; ) {
          var o2, a2, s, u = t2.andln(3) + n2 & 3, c = e2.andln(3) + i2 & 3;
          if (u === 3 && (u = -1), c === 3 && (c = -1), (1 & u) == 0)
            o2 = 0;
          else
            o2 = (s = t2.andln(7) + n2 & 7) !== 3 && s !== 5 || c !== 2 ? u : -u;
          if (r2[0].push(o2), (1 & c) == 0)
            a2 = 0;
          else
            a2 = (s = e2.andln(7) + i2 & 7) !== 3 && s !== 5 || u !== 2 ? c : -c;
          r2[1].push(a2), 2 * n2 === o2 + 1 && (n2 = 1 - n2), 2 * i2 === a2 + 1 && (i2 = 1 - i2), t2.iushrn(1), e2.iushrn(1);
        }
        return r2;
      }, n.cachedProperty = function(t2, e2, r2) {
        var n2 = "_" + e2;
        t2.prototype[e2] = function() {
          return this[n2] !== void 0 ? this[n2] : this[n2] = r2.call(this);
        };
      }, n.parseBytes = function(t2) {
        return typeof t2 == "string" ? n.toArray(t2, "hex") : t2;
      }, n.intFromLE = function(t2) {
        return new i(t2, "hex", "le");
      };
    }, { "bn.js": 365, "minimalistic-assert": 437, "minimalistic-crypto-utils": 438 }], 365: [function(t, e, r) {
      arguments[4][181][0].apply(r, arguments);
    }, { buffer: 185, dup: 181 }], 366: [function(t, e, r) {
      e.exports = { _from: "elliptic@^6.5.3", _id: "elliptic@6.5.3", _inBundle: false, _integrity: "sha512-IMqzv5wNQf+E6aHeIqATs0tOLeOTwj1QKbRcS3jBbYkl5oLAserA8yJTT7/VyHUYG91PRmPyeQDObKLPpeS4dw==", _location: "/elliptic", _phantomChildren: {}, _requested: { type: "range", registry: true, raw: "elliptic@^6.5.3", name: "elliptic", escapedName: "elliptic", rawSpec: "^6.5.3", saveSpec: null, fetchSpec: "^6.5.3" }, _requiredBy: ["/browserify-sign", "/create-ecdh"], _resolved: "https://registry.npmjs.org/elliptic/-/elliptic-6.5.3.tgz", _shasum: "cb59eb2efdaf73a0bd78ccd7015a62ad6e0f93d6", _spec: "elliptic@^6.5.3", _where: "/mnt/d/dev/git/exceljs/node_modules/browserify-sign", author: { name: "Fedor Indutny", email: "fedor@indutny.com" }, bugs: { url: "https://github.com/indutny/elliptic/issues" }, bundleDependencies: false, dependencies: { "bn.js": "^4.4.0", brorand: "^1.0.1", "hash.js": "^1.0.0", "hmac-drbg": "^1.0.0", inherits: "^2.0.1", "minimalistic-assert": "^1.0.0", "minimalistic-crypto-utils": "^1.0.0" }, deprecated: false, description: "EC cryptography", devDependencies: { brfs: "^1.4.3", coveralls: "^3.0.8", grunt: "^1.0.4", "grunt-browserify": "^5.0.0", "grunt-cli": "^1.2.0", "grunt-contrib-connect": "^1.0.0", "grunt-contrib-copy": "^1.0.0", "grunt-contrib-uglify": "^1.0.1", "grunt-mocha-istanbul": "^3.0.1", "grunt-saucelabs": "^9.0.1", istanbul: "^0.4.2", jscs: "^3.0.7", jshint: "^2.10.3", mocha: "^6.2.2" }, files: ["lib"], homepage: "https://github.com/indutny/elliptic", keywords: ["EC", "Elliptic", "curve", "Cryptography"], license: "MIT", main: "lib/elliptic.js", name: "elliptic", repository: { type: "git", url: "git+ssh://git@github.com/indutny/elliptic.git" }, scripts: { jscs: "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js", jshint: "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js", lint: "npm run jscs && npm run jshint", test: "npm run lint && npm run unit", unit: "istanbul test _mocha --reporter=spec test/index.js", version: "grunt dist && git add dist/" }, version: "6.5.3" };
    }, {}], 367: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      var i = Object.create || function(t2) {
        var e2 = function() {
        };
        return e2.prototype = t2, new e2();
      }, o = Object.keys || function(t2) {
        var e2 = [];
        for (var r2 in t2)
          Object.prototype.hasOwnProperty.call(t2, r2) && e2.push(r2);
        return r2;
      }, a = Function.prototype.bind || function(t2) {
        var e2 = this;
        return function() {
          return e2.apply(t2, arguments);
        };
      };
      function s() {
        this._events && Object.prototype.hasOwnProperty.call(this, "_events") || (this._events = i(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
      }
      e.exports = s, s.EventEmitter = s, s.prototype._events = void 0, s.prototype._maxListeners = void 0;
      var u, c = 10;
      try {
        var f = {};
        Object.defineProperty && Object.defineProperty(f, "x", { value: 0 }), u = f.x === 0;
      } catch (t2) {
        u = false;
      }
      function l(t2) {
        return t2._maxListeners === void 0 ? s.defaultMaxListeners : t2._maxListeners;
      }
      function h(t2, e2, r2) {
        if (e2)
          t2.call(r2);
        else
          for (var n2 = t2.length, i2 = k(t2, n2), o2 = 0; o2 < n2; ++o2)
            i2[o2].call(r2);
      }
      function d(t2, e2, r2, n2) {
        if (e2)
          t2.call(r2, n2);
        else
          for (var i2 = t2.length, o2 = k(t2, i2), a2 = 0; a2 < i2; ++a2)
            o2[a2].call(r2, n2);
      }
      function p(t2, e2, r2, n2, i2) {
        if (e2)
          t2.call(r2, n2, i2);
        else
          for (var o2 = t2.length, a2 = k(t2, o2), s2 = 0; s2 < o2; ++s2)
            a2[s2].call(r2, n2, i2);
      }
      function m(t2, e2, r2, n2, i2, o2) {
        if (e2)
          t2.call(r2, n2, i2, o2);
        else
          for (var a2 = t2.length, s2 = k(t2, a2), u2 = 0; u2 < a2; ++u2)
            s2[u2].call(r2, n2, i2, o2);
      }
      function y(t2, e2, r2, n2) {
        if (e2)
          t2.apply(r2, n2);
        else
          for (var i2 = t2.length, o2 = k(t2, i2), a2 = 0; a2 < i2; ++a2)
            o2[a2].apply(r2, n2);
      }
      function b(t2, e2, r2, o2) {
        var a2, s2, u2;
        if (typeof r2 != "function")
          throw new TypeError('"listener" argument must be a function');
        if ((s2 = t2._events) ? (s2.newListener && (t2.emit("newListener", e2, r2.listener ? r2.listener : r2), s2 = t2._events), u2 = s2[e2]) : (s2 = t2._events = i(null), t2._eventsCount = 0), u2) {
          if (typeof u2 == "function" ? u2 = s2[e2] = o2 ? [r2, u2] : [u2, r2] : o2 ? u2.unshift(r2) : u2.push(r2), !u2.warned && (a2 = l(t2)) && a2 > 0 && u2.length > a2) {
            u2.warned = true;
            var c2 = new Error("Possible EventEmitter memory leak detected. " + u2.length + ' "' + String(e2) + '" listeners added. Use emitter.setMaxListeners() to increase limit.');
            c2.name = "MaxListenersExceededWarning", c2.emitter = t2, c2.type = e2, c2.count = u2.length, (typeof console == "undefined" ? "undefined" : n(console)) === "object" && console.warn && console.warn("%s: %s", c2.name, c2.message);
          }
        } else
          u2 = s2[e2] = r2, ++t2._eventsCount;
        return t2;
      }
      function v() {
        if (!this.fired)
          switch (this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length) {
            case 0:
              return this.listener.call(this.target);
            case 1:
              return this.listener.call(this.target, arguments[0]);
            case 2:
              return this.listener.call(this.target, arguments[0], arguments[1]);
            case 3:
              return this.listener.call(this.target, arguments[0], arguments[1], arguments[2]);
            default:
              for (var t2 = new Array(arguments.length), e2 = 0; e2 < t2.length; ++e2)
                t2[e2] = arguments[e2];
              this.listener.apply(this.target, t2);
          }
      }
      function g(t2, e2, r2) {
        var n2 = { fired: false, wrapFn: void 0, target: t2, type: e2, listener: r2 }, i2 = a.call(v, n2);
        return i2.listener = r2, n2.wrapFn = i2, i2;
      }
      function w(t2, e2, r2) {
        var n2 = t2._events;
        if (!n2)
          return [];
        var i2 = n2[e2];
        return i2 ? typeof i2 == "function" ? r2 ? [i2.listener || i2] : [i2] : r2 ? function(t3) {
          for (var e3 = new Array(t3.length), r3 = 0; r3 < e3.length; ++r3)
            e3[r3] = t3[r3].listener || t3[r3];
          return e3;
        }(i2) : k(i2, i2.length) : [];
      }
      function _(t2) {
        var e2 = this._events;
        if (e2) {
          var r2 = e2[t2];
          if (typeof r2 == "function")
            return 1;
          if (r2)
            return r2.length;
        }
        return 0;
      }
      function k(t2, e2) {
        for (var r2 = new Array(e2), n2 = 0; n2 < e2; ++n2)
          r2[n2] = t2[n2];
        return r2;
      }
      u ? Object.defineProperty(s, "defaultMaxListeners", { enumerable: true, get: function() {
        return c;
      }, set: function(t2) {
        if (typeof t2 != "number" || t2 < 0 || t2 != t2)
          throw new TypeError('"defaultMaxListeners" must be a positive number');
        c = t2;
      } }) : s.defaultMaxListeners = c, s.prototype.setMaxListeners = function(t2) {
        if (typeof t2 != "number" || t2 < 0 || isNaN(t2))
          throw new TypeError('"n" argument must be a positive number');
        return this._maxListeners = t2, this;
      }, s.prototype.getMaxListeners = function() {
        return l(this);
      }, s.prototype.emit = function(t2) {
        var e2, r2, n2, i2, o2, a2, s2 = t2 === "error";
        if (a2 = this._events)
          s2 = s2 && a2.error == null;
        else if (!s2)
          return false;
        if (s2) {
          if (arguments.length > 1 && (e2 = arguments[1]), e2 instanceof Error)
            throw e2;
          var u2 = new Error('Unhandled "error" event. (' + e2 + ")");
          throw u2.context = e2, u2;
        }
        if (!(r2 = a2[t2]))
          return false;
        var c2 = typeof r2 == "function";
        switch (n2 = arguments.length) {
          case 1:
            h(r2, c2, this);
            break;
          case 2:
            d(r2, c2, this, arguments[1]);
            break;
          case 3:
            p(r2, c2, this, arguments[1], arguments[2]);
            break;
          case 4:
            m(r2, c2, this, arguments[1], arguments[2], arguments[3]);
            break;
          default:
            for (i2 = new Array(n2 - 1), o2 = 1; o2 < n2; o2++)
              i2[o2 - 1] = arguments[o2];
            y(r2, c2, this, i2);
        }
        return true;
      }, s.prototype.addListener = function(t2, e2) {
        return b(this, t2, e2, false);
      }, s.prototype.on = s.prototype.addListener, s.prototype.prependListener = function(t2, e2) {
        return b(this, t2, e2, true);
      }, s.prototype.once = function(t2, e2) {
        if (typeof e2 != "function")
          throw new TypeError('"listener" argument must be a function');
        return this.on(t2, g(this, t2, e2)), this;
      }, s.prototype.prependOnceListener = function(t2, e2) {
        if (typeof e2 != "function")
          throw new TypeError('"listener" argument must be a function');
        return this.prependListener(t2, g(this, t2, e2)), this;
      }, s.prototype.removeListener = function(t2, e2) {
        var r2, n2, o2, a2, s2;
        if (typeof e2 != "function")
          throw new TypeError('"listener" argument must be a function');
        if (!(n2 = this._events))
          return this;
        if (!(r2 = n2[t2]))
          return this;
        if (r2 === e2 || r2.listener === e2)
          --this._eventsCount == 0 ? this._events = i(null) : (delete n2[t2], n2.removeListener && this.emit("removeListener", t2, r2.listener || e2));
        else if (typeof r2 != "function") {
          for (o2 = -1, a2 = r2.length - 1; a2 >= 0; a2--)
            if (r2[a2] === e2 || r2[a2].listener === e2) {
              s2 = r2[a2].listener, o2 = a2;
              break;
            }
          if (o2 < 0)
            return this;
          o2 === 0 ? r2.shift() : function(t3, e3) {
            for (var r3 = e3, n3 = r3 + 1, i2 = t3.length; n3 < i2; r3 += 1, n3 += 1)
              t3[r3] = t3[n3];
            t3.pop();
          }(r2, o2), r2.length === 1 && (n2[t2] = r2[0]), n2.removeListener && this.emit("removeListener", t2, s2 || e2);
        }
        return this;
      }, s.prototype.removeAllListeners = function(t2) {
        var e2, r2, n2;
        if (!(r2 = this._events))
          return this;
        if (!r2.removeListener)
          return arguments.length === 0 ? (this._events = i(null), this._eventsCount = 0) : r2[t2] && (--this._eventsCount == 0 ? this._events = i(null) : delete r2[t2]), this;
        if (arguments.length === 0) {
          var a2, s2 = o(r2);
          for (n2 = 0; n2 < s2.length; ++n2)
            (a2 = s2[n2]) !== "removeListener" && this.removeAllListeners(a2);
          return this.removeAllListeners("removeListener"), this._events = i(null), this._eventsCount = 0, this;
        }
        if (typeof (e2 = r2[t2]) == "function")
          this.removeListener(t2, e2);
        else if (e2)
          for (n2 = e2.length - 1; n2 >= 0; n2--)
            this.removeListener(t2, e2[n2]);
        return this;
      }, s.prototype.listeners = function(t2) {
        return w(this, t2, true);
      }, s.prototype.rawListeners = function(t2) {
        return w(this, t2, false);
      }, s.listenerCount = function(t2, e2) {
        return typeof t2.listenerCount == "function" ? t2.listenerCount(e2) : _.call(t2, e2);
      }, s.prototype.listenerCount = _, s.prototype.eventNames = function() {
        return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
      };
    }, {}], 368: [function(t, e, r) {
      var n = t("safe-buffer").Buffer, i = t("md5.js");
      e.exports = function(t2, e2, r2, o) {
        if (n.isBuffer(t2) || (t2 = n.from(t2, "binary")), e2 && (n.isBuffer(e2) || (e2 = n.from(e2, "binary")), e2.length !== 8))
          throw new RangeError("salt should be Buffer with 8 byte length");
        for (var a = r2 / 8, s = n.alloc(a), u = n.alloc(o || 0), c = n.alloc(0); a > 0 || o > 0; ) {
          var f = new i();
          f.update(c), f.update(t2), e2 && f.update(e2), c = f.digest();
          var l = 0;
          if (a > 0) {
            var h = s.length - a;
            l = Math.min(a, c.length), c.copy(s, h, 0, l), a -= l;
          }
          if (l < c.length && o > 0) {
            var d = u.length - o, p = Math.min(o, c.length - l);
            c.copy(u, d, l, l + p), o -= p;
          }
        }
        return c.fill(0), { key: s, iv: u };
      };
    }, { "md5.js": 434, "safe-buffer": 494 }], 369: [function(t, e, r) {
      Object.defineProperty(r, "__esModule", { value: true });
      var n = t("@fast-csv/format");
      Object.defineProperty(r, "format", { enumerable: true, get: function() {
        return n.format;
      } }), Object.defineProperty(r, "write", { enumerable: true, get: function() {
        return n.write;
      } }), Object.defineProperty(r, "writeToStream", { enumerable: true, get: function() {
        return n.writeToStream;
      } }), Object.defineProperty(r, "writeToBuffer", { enumerable: true, get: function() {
        return n.writeToBuffer;
      } }), Object.defineProperty(r, "writeToString", { enumerable: true, get: function() {
        return n.writeToString;
      } }), Object.defineProperty(r, "writeToPath", { enumerable: true, get: function() {
        return n.writeToPath;
      } }), Object.defineProperty(r, "CsvFormatterStream", { enumerable: true, get: function() {
        return n.CsvFormatterStream;
      } }), Object.defineProperty(r, "FormatterOptions", { enumerable: true, get: function() {
        return n.FormatterOptions;
      } });
      var i = t("@fast-csv/parse");
      Object.defineProperty(r, "parse", { enumerable: true, get: function() {
        return i.parse;
      } }), Object.defineProperty(r, "parseString", { enumerable: true, get: function() {
        return i.parseString;
      } }), Object.defineProperty(r, "parseStream", { enumerable: true, get: function() {
        return i.parseStream;
      } }), Object.defineProperty(r, "parseFile", { enumerable: true, get: function() {
        return i.parseFile;
      } }), Object.defineProperty(r, "ParserOptions", { enumerable: true, get: function() {
        return i.ParserOptions;
      } }), Object.defineProperty(r, "CsvParserStream", { enumerable: true, get: function() {
        return i.CsvParserStream;
      } });
    }, { "@fast-csv/format": 148, "@fast-csv/parse": 152 }], 370: [function(t, e, r) {
      var n = t("safe-buffer").Buffer, i = t("readable-stream").Transform;
      function o(t2) {
        i.call(this), this._block = n.allocUnsafe(t2), this._blockSize = t2, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = false;
      }
      t("inherits")(o, i), o.prototype._transform = function(t2, e2, r2) {
        var n2 = null;
        try {
          this.update(t2, e2);
        } catch (t3) {
          n2 = t3;
        }
        r2(n2);
      }, o.prototype._flush = function(t2) {
        var e2 = null;
        try {
          this.push(this.digest());
        } catch (t3) {
          e2 = t3;
        }
        t2(e2);
      }, o.prototype.update = function(t2, e2) {
        if (function(t3, e3) {
          if (!n.isBuffer(t3) && typeof t3 != "string")
            throw new TypeError(e3 + " must be a string or a buffer");
        }(t2, "Data"), this._finalized)
          throw new Error("Digest already called");
        n.isBuffer(t2) || (t2 = n.from(t2, e2));
        for (var r2 = this._block, i2 = 0; this._blockOffset + t2.length - i2 >= this._blockSize; ) {
          for (var o2 = this._blockOffset; o2 < this._blockSize; )
            r2[o2++] = t2[i2++];
          this._update(), this._blockOffset = 0;
        }
        for (; i2 < t2.length; )
          r2[this._blockOffset++] = t2[i2++];
        for (var a = 0, s = 8 * t2.length; s > 0; ++a)
          this._length[a] += s, (s = this._length[a] / 4294967296 | 0) > 0 && (this._length[a] -= 4294967296 * s);
        return this;
      }, o.prototype._update = function() {
        throw new Error("_update is not implemented");
      }, o.prototype.digest = function(t2) {
        if (this._finalized)
          throw new Error("Digest already called");
        this._finalized = true;
        var e2 = this._digest();
        t2 !== void 0 && (e2 = e2.toString(t2)), this._block.fill(0), this._blockOffset = 0;
        for (var r2 = 0; r2 < 4; ++r2)
          this._length[r2] = 0;
        return e2;
      }, o.prototype._digest = function() {
        throw new Error("_digest is not implemented");
      }, e.exports = o;
    }, { inherits: 387, "readable-stream": 491, "safe-buffer": 371 }], 371: [function(t, e, r) {
      arguments[4][214][0].apply(r, arguments);
    }, { buffer: 216, dup: 214 }], 372: [function(t, e, r) {
      var n = r;
      n.utils = t("./hash/utils"), n.common = t("./hash/common"), n.sha = t("./hash/sha"), n.ripemd = t("./hash/ripemd"), n.hmac = t("./hash/hmac"), n.sha1 = n.sha.sha1, n.sha256 = n.sha.sha256, n.sha224 = n.sha.sha224, n.sha384 = n.sha.sha384, n.sha512 = n.sha.sha512, n.ripemd160 = n.ripemd.ripemd160;
    }, { "./hash/common": 373, "./hash/hmac": 374, "./hash/ripemd": 375, "./hash/sha": 376, "./hash/utils": 383 }], 373: [function(t, e, r) {
      var n = t("./utils"), i = t("minimalistic-assert");
      function o() {
        this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
      }
      r.BlockHash = o, o.prototype.update = function(t2, e2) {
        if (t2 = n.toArray(t2, e2), this.pending ? this.pending = this.pending.concat(t2) : this.pending = t2, this.pendingTotal += t2.length, this.pending.length >= this._delta8) {
          var r2 = (t2 = this.pending).length % this._delta8;
          this.pending = t2.slice(t2.length - r2, t2.length), this.pending.length === 0 && (this.pending = null), t2 = n.join32(t2, 0, t2.length - r2, this.endian);
          for (var i2 = 0; i2 < t2.length; i2 += this._delta32)
            this._update(t2, i2, i2 + this._delta32);
        }
        return this;
      }, o.prototype.digest = function(t2) {
        return this.update(this._pad()), i(this.pending === null), this._digest(t2);
      }, o.prototype._pad = function() {
        var t2 = this.pendingTotal, e2 = this._delta8, r2 = e2 - (t2 + this.padLength) % e2, n2 = new Array(r2 + this.padLength);
        n2[0] = 128;
        for (var i2 = 1; i2 < r2; i2++)
          n2[i2] = 0;
        if (t2 <<= 3, this.endian === "big") {
          for (var o2 = 8; o2 < this.padLength; o2++)
            n2[i2++] = 0;
          n2[i2++] = 0, n2[i2++] = 0, n2[i2++] = 0, n2[i2++] = 0, n2[i2++] = t2 >>> 24 & 255, n2[i2++] = t2 >>> 16 & 255, n2[i2++] = t2 >>> 8 & 255, n2[i2++] = 255 & t2;
        } else
          for (n2[i2++] = 255 & t2, n2[i2++] = t2 >>> 8 & 255, n2[i2++] = t2 >>> 16 & 255, n2[i2++] = t2 >>> 24 & 255, n2[i2++] = 0, n2[i2++] = 0, n2[i2++] = 0, n2[i2++] = 0, o2 = 8; o2 < this.padLength; o2++)
            n2[i2++] = 0;
        return n2;
      };
    }, { "./utils": 383, "minimalistic-assert": 437 }], 374: [function(t, e, r) {
      var n = t("./utils"), i = t("minimalistic-assert");
      function o(t2, e2, r2) {
        if (!(this instanceof o))
          return new o(t2, e2, r2);
        this.Hash = t2, this.blockSize = t2.blockSize / 8, this.outSize = t2.outSize / 8, this.inner = null, this.outer = null, this._init(n.toArray(e2, r2));
      }
      e.exports = o, o.prototype._init = function(t2) {
        t2.length > this.blockSize && (t2 = new this.Hash().update(t2).digest()), i(t2.length <= this.blockSize);
        for (var e2 = t2.length; e2 < this.blockSize; e2++)
          t2.push(0);
        for (e2 = 0; e2 < t2.length; e2++)
          t2[e2] ^= 54;
        for (this.inner = new this.Hash().update(t2), e2 = 0; e2 < t2.length; e2++)
          t2[e2] ^= 106;
        this.outer = new this.Hash().update(t2);
      }, o.prototype.update = function(t2, e2) {
        return this.inner.update(t2, e2), this;
      }, o.prototype.digest = function(t2) {
        return this.outer.update(this.inner.digest()), this.outer.digest(t2);
      };
    }, { "./utils": 383, "minimalistic-assert": 437 }], 375: [function(t, e, r) {
      var n = t("./utils"), i = t("./common"), o = n.rotl32, a = n.sum32, s = n.sum32_3, u = n.sum32_4, c = i.BlockHash;
      function f() {
        if (!(this instanceof f))
          return new f();
        c.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
      }
      function l(t2, e2, r2, n2) {
        return t2 <= 15 ? e2 ^ r2 ^ n2 : t2 <= 31 ? e2 & r2 | ~e2 & n2 : t2 <= 47 ? (e2 | ~r2) ^ n2 : t2 <= 63 ? e2 & n2 | r2 & ~n2 : e2 ^ (r2 | ~n2);
      }
      function h(t2) {
        return t2 <= 15 ? 0 : t2 <= 31 ? 1518500249 : t2 <= 47 ? 1859775393 : t2 <= 63 ? 2400959708 : 2840853838;
      }
      function d(t2) {
        return t2 <= 15 ? 1352829926 : t2 <= 31 ? 1548603684 : t2 <= 47 ? 1836072691 : t2 <= 63 ? 2053994217 : 0;
      }
      n.inherits(f, c), r.ripemd160 = f, f.blockSize = 512, f.outSize = 160, f.hmacStrength = 192, f.padLength = 64, f.prototype._update = function(t2, e2) {
        for (var r2 = this.h[0], n2 = this.h[1], i2 = this.h[2], c2 = this.h[3], f2 = this.h[4], v = r2, g = n2, w = i2, _ = c2, k = f2, x = 0; x < 80; x++) {
          var S = a(o(u(r2, l(x, n2, i2, c2), t2[p[x] + e2], h(x)), y[x]), f2);
          r2 = f2, f2 = c2, c2 = o(i2, 10), i2 = n2, n2 = S, S = a(o(u(v, l(79 - x, g, w, _), t2[m[x] + e2], d(x)), b[x]), k), v = k, k = _, _ = o(w, 10), w = g, g = S;
        }
        S = s(this.h[1], i2, _), this.h[1] = s(this.h[2], c2, k), this.h[2] = s(this.h[3], f2, v), this.h[3] = s(this.h[4], r2, g), this.h[4] = s(this.h[0], n2, w), this.h[0] = S;
      }, f.prototype._digest = function(t2) {
        return t2 === "hex" ? n.toHex32(this.h, "little") : n.split32(this.h, "little");
      };
      var p = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], m = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], y = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], b = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
    }, { "./common": 373, "./utils": 383 }], 376: [function(t, e, r) {
      r.sha1 = t("./sha/1"), r.sha224 = t("./sha/224"), r.sha256 = t("./sha/256"), r.sha384 = t("./sha/384"), r.sha512 = t("./sha/512");
    }, { "./sha/1": 377, "./sha/224": 378, "./sha/256": 379, "./sha/384": 380, "./sha/512": 381 }], 377: [function(t, e, r) {
      var n = t("../utils"), i = t("../common"), o = t("./common"), a = n.rotl32, s = n.sum32, u = n.sum32_5, c = o.ft_1, f = i.BlockHash, l = [1518500249, 1859775393, 2400959708, 3395469782];
      function h() {
        if (!(this instanceof h))
          return new h();
        f.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80);
      }
      n.inherits(h, f), e.exports = h, h.blockSize = 512, h.outSize = 160, h.hmacStrength = 80, h.padLength = 64, h.prototype._update = function(t2, e2) {
        for (var r2 = this.W, n2 = 0; n2 < 16; n2++)
          r2[n2] = t2[e2 + n2];
        for (; n2 < r2.length; n2++)
          r2[n2] = a(r2[n2 - 3] ^ r2[n2 - 8] ^ r2[n2 - 14] ^ r2[n2 - 16], 1);
        var i2 = this.h[0], o2 = this.h[1], f2 = this.h[2], h2 = this.h[3], d = this.h[4];
        for (n2 = 0; n2 < r2.length; n2++) {
          var p = ~~(n2 / 20), m = u(a(i2, 5), c(p, o2, f2, h2), d, r2[n2], l[p]);
          d = h2, h2 = f2, f2 = a(o2, 30), o2 = i2, i2 = m;
        }
        this.h[0] = s(this.h[0], i2), this.h[1] = s(this.h[1], o2), this.h[2] = s(this.h[2], f2), this.h[3] = s(this.h[3], h2), this.h[4] = s(this.h[4], d);
      }, h.prototype._digest = function(t2) {
        return t2 === "hex" ? n.toHex32(this.h, "big") : n.split32(this.h, "big");
      };
    }, { "../common": 373, "../utils": 383, "./common": 382 }], 378: [function(t, e, r) {
      var n = t("../utils"), i = t("./256");
      function o() {
        if (!(this instanceof o))
          return new o();
        i.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
      }
      n.inherits(o, i), e.exports = o, o.blockSize = 512, o.outSize = 224, o.hmacStrength = 192, o.padLength = 64, o.prototype._digest = function(t2) {
        return t2 === "hex" ? n.toHex32(this.h.slice(0, 7), "big") : n.split32(this.h.slice(0, 7), "big");
      };
    }, { "../utils": 383, "./256": 379 }], 379: [function(t, e, r) {
      var n = t("../utils"), i = t("../common"), o = t("./common"), a = t("minimalistic-assert"), s = n.sum32, u = n.sum32_4, c = n.sum32_5, f = o.ch32, l = o.maj32, h = o.s0_256, d = o.s1_256, p = o.g0_256, m = o.g1_256, y = i.BlockHash, b = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
      function v() {
        if (!(this instanceof v))
          return new v();
        y.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = b, this.W = new Array(64);
      }
      n.inherits(v, y), e.exports = v, v.blockSize = 512, v.outSize = 256, v.hmacStrength = 192, v.padLength = 64, v.prototype._update = function(t2, e2) {
        for (var r2 = this.W, n2 = 0; n2 < 16; n2++)
          r2[n2] = t2[e2 + n2];
        for (; n2 < r2.length; n2++)
          r2[n2] = u(m(r2[n2 - 2]), r2[n2 - 7], p(r2[n2 - 15]), r2[n2 - 16]);
        var i2 = this.h[0], o2 = this.h[1], y2 = this.h[2], b2 = this.h[3], v2 = this.h[4], g = this.h[5], w = this.h[6], _ = this.h[7];
        for (a(this.k.length === r2.length), n2 = 0; n2 < r2.length; n2++) {
          var k = c(_, d(v2), f(v2, g, w), this.k[n2], r2[n2]), x = s(h(i2), l(i2, o2, y2));
          _ = w, w = g, g = v2, v2 = s(b2, k), b2 = y2, y2 = o2, o2 = i2, i2 = s(k, x);
        }
        this.h[0] = s(this.h[0], i2), this.h[1] = s(this.h[1], o2), this.h[2] = s(this.h[2], y2), this.h[3] = s(this.h[3], b2), this.h[4] = s(this.h[4], v2), this.h[5] = s(this.h[5], g), this.h[6] = s(this.h[6], w), this.h[7] = s(this.h[7], _);
      }, v.prototype._digest = function(t2) {
        return t2 === "hex" ? n.toHex32(this.h, "big") : n.split32(this.h, "big");
      };
    }, { "../common": 373, "../utils": 383, "./common": 382, "minimalistic-assert": 437 }], 380: [function(t, e, r) {
      var n = t("../utils"), i = t("./512");
      function o() {
        if (!(this instanceof o))
          return new o();
        i.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
      }
      n.inherits(o, i), e.exports = o, o.blockSize = 1024, o.outSize = 384, o.hmacStrength = 192, o.padLength = 128, o.prototype._digest = function(t2) {
        return t2 === "hex" ? n.toHex32(this.h.slice(0, 12), "big") : n.split32(this.h.slice(0, 12), "big");
      };
    }, { "../utils": 383, "./512": 381 }], 381: [function(t, e, r) {
      var n = t("../utils"), i = t("../common"), o = t("minimalistic-assert"), a = n.rotr64_hi, s = n.rotr64_lo, u = n.shr64_hi, c = n.shr64_lo, f = n.sum64, l = n.sum64_hi, h = n.sum64_lo, d = n.sum64_4_hi, p = n.sum64_4_lo, m = n.sum64_5_hi, y = n.sum64_5_lo, b = i.BlockHash, v = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
      function g() {
        if (!(this instanceof g))
          return new g();
        b.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = v, this.W = new Array(160);
      }
      function w(t2, e2, r2, n2, i2) {
        var o2 = t2 & r2 ^ ~t2 & i2;
        return o2 < 0 && (o2 += 4294967296), o2;
      }
      function _(t2, e2, r2, n2, i2, o2) {
        var a2 = e2 & n2 ^ ~e2 & o2;
        return a2 < 0 && (a2 += 4294967296), a2;
      }
      function k(t2, e2, r2, n2, i2) {
        var o2 = t2 & r2 ^ t2 & i2 ^ r2 & i2;
        return o2 < 0 && (o2 += 4294967296), o2;
      }
      function x(t2, e2, r2, n2, i2, o2) {
        var a2 = e2 & n2 ^ e2 & o2 ^ n2 & o2;
        return a2 < 0 && (a2 += 4294967296), a2;
      }
      function S(t2, e2) {
        var r2 = a(t2, e2, 28) ^ a(e2, t2, 2) ^ a(e2, t2, 7);
        return r2 < 0 && (r2 += 4294967296), r2;
      }
      function O(t2, e2) {
        var r2 = s(t2, e2, 28) ^ s(e2, t2, 2) ^ s(e2, t2, 7);
        return r2 < 0 && (r2 += 4294967296), r2;
      }
      function j(t2, e2) {
        var r2 = a(t2, e2, 14) ^ a(t2, e2, 18) ^ a(e2, t2, 9);
        return r2 < 0 && (r2 += 4294967296), r2;
      }
      function E(t2, e2) {
        var r2 = s(t2, e2, 14) ^ s(t2, e2, 18) ^ s(e2, t2, 9);
        return r2 < 0 && (r2 += 4294967296), r2;
      }
      function R(t2, e2) {
        var r2 = a(t2, e2, 1) ^ a(t2, e2, 8) ^ u(t2, e2, 7);
        return r2 < 0 && (r2 += 4294967296), r2;
      }
      function T(t2, e2) {
        var r2 = s(t2, e2, 1) ^ s(t2, e2, 8) ^ c(t2, e2, 7);
        return r2 < 0 && (r2 += 4294967296), r2;
      }
      function C(t2, e2) {
        var r2 = a(t2, e2, 19) ^ a(e2, t2, 29) ^ u(t2, e2, 6);
        return r2 < 0 && (r2 += 4294967296), r2;
      }
      function P(t2, e2) {
        var r2 = s(t2, e2, 19) ^ s(e2, t2, 29) ^ c(t2, e2, 6);
        return r2 < 0 && (r2 += 4294967296), r2;
      }
      n.inherits(g, b), e.exports = g, g.blockSize = 1024, g.outSize = 512, g.hmacStrength = 192, g.padLength = 128, g.prototype._prepareBlock = function(t2, e2) {
        for (var r2 = this.W, n2 = 0; n2 < 32; n2++)
          r2[n2] = t2[e2 + n2];
        for (; n2 < r2.length; n2 += 2) {
          var i2 = C(r2[n2 - 4], r2[n2 - 3]), o2 = P(r2[n2 - 4], r2[n2 - 3]), a2 = r2[n2 - 14], s2 = r2[n2 - 13], u2 = R(r2[n2 - 30], r2[n2 - 29]), c2 = T(r2[n2 - 30], r2[n2 - 29]), f2 = r2[n2 - 32], l2 = r2[n2 - 31];
          r2[n2] = d(i2, o2, a2, s2, u2, c2, f2, l2), r2[n2 + 1] = p(i2, o2, a2, s2, u2, c2, f2, l2);
        }
      }, g.prototype._update = function(t2, e2) {
        this._prepareBlock(t2, e2);
        var r2 = this.W, n2 = this.h[0], i2 = this.h[1], a2 = this.h[2], s2 = this.h[3], u2 = this.h[4], c2 = this.h[5], d2 = this.h[6], p2 = this.h[7], b2 = this.h[8], v2 = this.h[9], g2 = this.h[10], R2 = this.h[11], T2 = this.h[12], C2 = this.h[13], P2 = this.h[14], M = this.h[15];
        o(this.k.length === r2.length);
        for (var A = 0; A < r2.length; A += 2) {
          var I = P2, N = M, D = j(b2, v2), B = E(b2, v2), F = w(b2, v2, g2, R2, T2), L = _(b2, v2, g2, R2, T2, C2), z = this.k[A], U = this.k[A + 1], H = r2[A], V = r2[A + 1], q = m(I, N, D, B, F, L, z, U, H, V), W = y(I, N, D, B, F, L, z, U, H, V);
          I = S(n2, i2), N = O(n2, i2), D = k(n2, i2, a2, s2, u2), B = x(n2, i2, a2, s2, u2, c2);
          var $ = l(I, N, D, B), X = h(I, N, D, B);
          P2 = T2, M = C2, T2 = g2, C2 = R2, g2 = b2, R2 = v2, b2 = l(d2, p2, q, W), v2 = h(p2, p2, q, W), d2 = u2, p2 = c2, u2 = a2, c2 = s2, a2 = n2, s2 = i2, n2 = l(q, W, $, X), i2 = h(q, W, $, X);
        }
        f(this.h, 0, n2, i2), f(this.h, 2, a2, s2), f(this.h, 4, u2, c2), f(this.h, 6, d2, p2), f(this.h, 8, b2, v2), f(this.h, 10, g2, R2), f(this.h, 12, T2, C2), f(this.h, 14, P2, M);
      }, g.prototype._digest = function(t2) {
        return t2 === "hex" ? n.toHex32(this.h, "big") : n.split32(this.h, "big");
      };
    }, { "../common": 373, "../utils": 383, "minimalistic-assert": 437 }], 382: [function(t, e, r) {
      var n = t("../utils").rotr32;
      function i(t2, e2, r2) {
        return t2 & e2 ^ ~t2 & r2;
      }
      function o(t2, e2, r2) {
        return t2 & e2 ^ t2 & r2 ^ e2 & r2;
      }
      function a(t2, e2, r2) {
        return t2 ^ e2 ^ r2;
      }
      r.ft_1 = function(t2, e2, r2, n2) {
        return t2 === 0 ? i(e2, r2, n2) : t2 === 1 || t2 === 3 ? a(e2, r2, n2) : t2 === 2 ? o(e2, r2, n2) : void 0;
      }, r.ch32 = i, r.maj32 = o, r.p32 = a, r.s0_256 = function(t2) {
        return n(t2, 2) ^ n(t2, 13) ^ n(t2, 22);
      }, r.s1_256 = function(t2) {
        return n(t2, 6) ^ n(t2, 11) ^ n(t2, 25);
      }, r.g0_256 = function(t2) {
        return n(t2, 7) ^ n(t2, 18) ^ t2 >>> 3;
      }, r.g1_256 = function(t2) {
        return n(t2, 17) ^ n(t2, 19) ^ t2 >>> 10;
      };
    }, { "../utils": 383 }], 383: [function(t, e, r) {
      var n = t("minimalistic-assert"), i = t("inherits");
      function o(t2, e2) {
        return (64512 & t2.charCodeAt(e2)) == 55296 && (!(e2 < 0 || e2 + 1 >= t2.length) && (64512 & t2.charCodeAt(e2 + 1)) == 56320);
      }
      function a(t2) {
        return (t2 >>> 24 | t2 >>> 8 & 65280 | t2 << 8 & 16711680 | (255 & t2) << 24) >>> 0;
      }
      function s(t2) {
        return t2.length === 1 ? "0" + t2 : t2;
      }
      function u(t2) {
        return t2.length === 7 ? "0" + t2 : t2.length === 6 ? "00" + t2 : t2.length === 5 ? "000" + t2 : t2.length === 4 ? "0000" + t2 : t2.length === 3 ? "00000" + t2 : t2.length === 2 ? "000000" + t2 : t2.length === 1 ? "0000000" + t2 : t2;
      }
      r.inherits = i, r.toArray = function(t2, e2) {
        if (Array.isArray(t2))
          return t2.slice();
        if (!t2)
          return [];
        var r2 = [];
        if (typeof t2 == "string")
          if (e2) {
            if (e2 === "hex")
              for ((t2 = t2.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (t2 = "0" + t2), i2 = 0; i2 < t2.length; i2 += 2)
                r2.push(parseInt(t2[i2] + t2[i2 + 1], 16));
          } else
            for (var n2 = 0, i2 = 0; i2 < t2.length; i2++) {
              var a2 = t2.charCodeAt(i2);
              a2 < 128 ? r2[n2++] = a2 : a2 < 2048 ? (r2[n2++] = a2 >> 6 | 192, r2[n2++] = 63 & a2 | 128) : o(t2, i2) ? (a2 = 65536 + ((1023 & a2) << 10) + (1023 & t2.charCodeAt(++i2)), r2[n2++] = a2 >> 18 | 240, r2[n2++] = a2 >> 12 & 63 | 128, r2[n2++] = a2 >> 6 & 63 | 128, r2[n2++] = 63 & a2 | 128) : (r2[n2++] = a2 >> 12 | 224, r2[n2++] = a2 >> 6 & 63 | 128, r2[n2++] = 63 & a2 | 128);
            }
        else
          for (i2 = 0; i2 < t2.length; i2++)
            r2[i2] = 0 | t2[i2];
        return r2;
      }, r.toHex = function(t2) {
        for (var e2 = "", r2 = 0; r2 < t2.length; r2++)
          e2 += s(t2[r2].toString(16));
        return e2;
      }, r.htonl = a, r.toHex32 = function(t2, e2) {
        for (var r2 = "", n2 = 0; n2 < t2.length; n2++) {
          var i2 = t2[n2];
          e2 === "little" && (i2 = a(i2)), r2 += u(i2.toString(16));
        }
        return r2;
      }, r.zero2 = s, r.zero8 = u, r.join32 = function(t2, e2, r2, i2) {
        var o2 = r2 - e2;
        n(o2 % 4 == 0);
        for (var a2 = new Array(o2 / 4), s2 = 0, u2 = e2; s2 < a2.length; s2++, u2 += 4) {
          var c;
          c = i2 === "big" ? t2[u2] << 24 | t2[u2 + 1] << 16 | t2[u2 + 2] << 8 | t2[u2 + 3] : t2[u2 + 3] << 24 | t2[u2 + 2] << 16 | t2[u2 + 1] << 8 | t2[u2], a2[s2] = c >>> 0;
        }
        return a2;
      }, r.split32 = function(t2, e2) {
        for (var r2 = new Array(4 * t2.length), n2 = 0, i2 = 0; n2 < t2.length; n2++, i2 += 4) {
          var o2 = t2[n2];
          e2 === "big" ? (r2[i2] = o2 >>> 24, r2[i2 + 1] = o2 >>> 16 & 255, r2[i2 + 2] = o2 >>> 8 & 255, r2[i2 + 3] = 255 & o2) : (r2[i2 + 3] = o2 >>> 24, r2[i2 + 2] = o2 >>> 16 & 255, r2[i2 + 1] = o2 >>> 8 & 255, r2[i2] = 255 & o2);
        }
        return r2;
      }, r.rotr32 = function(t2, e2) {
        return t2 >>> e2 | t2 << 32 - e2;
      }, r.rotl32 = function(t2, e2) {
        return t2 << e2 | t2 >>> 32 - e2;
      }, r.sum32 = function(t2, e2) {
        return t2 + e2 >>> 0;
      }, r.sum32_3 = function(t2, e2, r2) {
        return t2 + e2 + r2 >>> 0;
      }, r.sum32_4 = function(t2, e2, r2, n2) {
        return t2 + e2 + r2 + n2 >>> 0;
      }, r.sum32_5 = function(t2, e2, r2, n2, i2) {
        return t2 + e2 + r2 + n2 + i2 >>> 0;
      }, r.sum64 = function(t2, e2, r2, n2) {
        var i2 = t2[e2], o2 = n2 + t2[e2 + 1] >>> 0, a2 = (o2 < n2 ? 1 : 0) + r2 + i2;
        t2[e2] = a2 >>> 0, t2[e2 + 1] = o2;
      }, r.sum64_hi = function(t2, e2, r2, n2) {
        return (e2 + n2 >>> 0 < e2 ? 1 : 0) + t2 + r2 >>> 0;
      }, r.sum64_lo = function(t2, e2, r2, n2) {
        return e2 + n2 >>> 0;
      }, r.sum64_4_hi = function(t2, e2, r2, n2, i2, o2, a2, s2) {
        var u2 = 0, c = e2;
        return u2 += (c = c + n2 >>> 0) < e2 ? 1 : 0, u2 += (c = c + o2 >>> 0) < o2 ? 1 : 0, t2 + r2 + i2 + a2 + (u2 += (c = c + s2 >>> 0) < s2 ? 1 : 0) >>> 0;
      }, r.sum64_4_lo = function(t2, e2, r2, n2, i2, o2, a2, s2) {
        return e2 + n2 + o2 + s2 >>> 0;
      }, r.sum64_5_hi = function(t2, e2, r2, n2, i2, o2, a2, s2, u2, c) {
        var f = 0, l = e2;
        return f += (l = l + n2 >>> 0) < e2 ? 1 : 0, f += (l = l + o2 >>> 0) < o2 ? 1 : 0, f += (l = l + s2 >>> 0) < s2 ? 1 : 0, t2 + r2 + i2 + a2 + u2 + (f += (l = l + c >>> 0) < c ? 1 : 0) >>> 0;
      }, r.sum64_5_lo = function(t2, e2, r2, n2, i2, o2, a2, s2, u2, c) {
        return e2 + n2 + o2 + s2 + c >>> 0;
      }, r.rotr64_hi = function(t2, e2, r2) {
        return (e2 << 32 - r2 | t2 >>> r2) >>> 0;
      }, r.rotr64_lo = function(t2, e2, r2) {
        return (t2 << 32 - r2 | e2 >>> r2) >>> 0;
      }, r.shr64_hi = function(t2, e2, r2) {
        return t2 >>> r2;
      }, r.shr64_lo = function(t2, e2, r2) {
        return (t2 << 32 - r2 | e2 >>> r2) >>> 0;
      };
    }, { inherits: 387, "minimalistic-assert": 437 }], 384: [function(t, e, r) {
      var n = t("hash.js"), i = t("minimalistic-crypto-utils"), o = t("minimalistic-assert");
      function a(t2) {
        if (!(this instanceof a))
          return new a(t2);
        this.hash = t2.hash, this.predResist = !!t2.predResist, this.outLen = this.hash.outSize, this.minEntropy = t2.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
        var e2 = i.toArray(t2.entropy, t2.entropyEnc || "hex"), r2 = i.toArray(t2.nonce, t2.nonceEnc || "hex"), n2 = i.toArray(t2.pers, t2.persEnc || "hex");
        o(e2.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e2, r2, n2);
      }
      e.exports = a, a.prototype._init = function(t2, e2, r2) {
        var n2 = t2.concat(e2).concat(r2);
        this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
        for (var i2 = 0; i2 < this.V.length; i2++)
          this.K[i2] = 0, this.V[i2] = 1;
        this._update(n2), this._reseed = 1, this.reseedInterval = 281474976710656;
      }, a.prototype._hmac = function() {
        return new n.hmac(this.hash, this.K);
      }, a.prototype._update = function(t2) {
        var e2 = this._hmac().update(this.V).update([0]);
        t2 && (e2 = e2.update(t2)), this.K = e2.digest(), this.V = this._hmac().update(this.V).digest(), t2 && (this.K = this._hmac().update(this.V).update([1]).update(t2).digest(), this.V = this._hmac().update(this.V).digest());
      }, a.prototype.reseed = function(t2, e2, r2, n2) {
        typeof e2 != "string" && (n2 = r2, r2 = e2, e2 = null), t2 = i.toArray(t2, e2), r2 = i.toArray(r2, n2), o(t2.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(t2.concat(r2 || [])), this._reseed = 1;
      }, a.prototype.generate = function(t2, e2, r2, n2) {
        if (this._reseed > this.reseedInterval)
          throw new Error("Reseed is required");
        typeof e2 != "string" && (n2 = r2, r2 = e2, e2 = null), r2 && (r2 = i.toArray(r2, n2 || "hex"), this._update(r2));
        for (var o2 = []; o2.length < t2; )
          this.V = this._hmac().update(this.V).digest(), o2 = o2.concat(this.V);
        var a2 = o2.slice(0, t2);
        return this._update(r2), this._reseed++, i.encode(a2, e2);
      };
    }, { "hash.js": 372, "minimalistic-assert": 437, "minimalistic-crypto-utils": 438 }], 385: [function(t, e, r) {
      r.read = function(t2, e2, r2, n, i) {
        var o, a, s = 8 * i - n - 1, u = (1 << s) - 1, c = u >> 1, f = -7, l = r2 ? i - 1 : 0, h = r2 ? -1 : 1, d = t2[e2 + l];
        for (l += h, o = d & (1 << -f) - 1, d >>= -f, f += s; f > 0; o = 256 * o + t2[e2 + l], l += h, f -= 8)
          ;
        for (a = o & (1 << -f) - 1, o >>= -f, f += n; f > 0; a = 256 * a + t2[e2 + l], l += h, f -= 8)
          ;
        if (o === 0)
          o = 1 - c;
        else {
          if (o === u)
            return a ? NaN : 1 / 0 * (d ? -1 : 1);
          a += Math.pow(2, n), o -= c;
        }
        return (d ? -1 : 1) * a * Math.pow(2, o - n);
      }, r.write = function(t2, e2, r2, n, i, o) {
        var a, s, u, c = 8 * o - i - 1, f = (1 << c) - 1, l = f >> 1, h = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = n ? 0 : o - 1, p = n ? 1 : -1, m = e2 < 0 || e2 === 0 && 1 / e2 < 0 ? 1 : 0;
        for (e2 = Math.abs(e2), isNaN(e2) || e2 === 1 / 0 ? (s = isNaN(e2) ? 1 : 0, a = f) : (a = Math.floor(Math.log(e2) / Math.LN2), e2 * (u = Math.pow(2, -a)) < 1 && (a--, u *= 2), (e2 += a + l >= 1 ? h / u : h * Math.pow(2, 1 - l)) * u >= 2 && (a++, u /= 2), a + l >= f ? (s = 0, a = f) : a + l >= 1 ? (s = (e2 * u - 1) * Math.pow(2, i), a += l) : (s = e2 * Math.pow(2, l - 1) * Math.pow(2, i), a = 0)); i >= 8; t2[r2 + d] = 255 & s, d += p, s /= 256, i -= 8)
          ;
        for (a = a << i | s, c += i; c > 0; t2[r2 + d] = 255 & a, d += p, a /= 256, c -= 8)
          ;
        t2[r2 + d - p] |= 128 * m;
      };
    }, {}], 386: [function(t, e, r) {
      (function(t2) {
        var r2, n, i = t2.MutationObserver || t2.WebKitMutationObserver;
        if (i) {
          var o = 0, a = new i(f), s = t2.document.createTextNode("");
          a.observe(s, { characterData: true }), r2 = function() {
            s.data = o = ++o % 2;
          };
        } else if (t2.setImmediate || t2.MessageChannel === void 0)
          r2 = "document" in t2 && "onreadystatechange" in t2.document.createElement("script") ? function() {
            var e2 = t2.document.createElement("script");
            e2.onreadystatechange = function() {
              f(), e2.onreadystatechange = null, e2.parentNode.removeChild(e2), e2 = null;
            }, t2.document.documentElement.appendChild(e2);
          } : function() {
            setTimeout(f, 0);
          };
        else {
          var u = new t2.MessageChannel();
          u.port1.onmessage = f, r2 = function() {
            u.port2.postMessage(0);
          };
        }
        var c = [];
        function f() {
          var t3, e2;
          n = true;
          for (var r3 = c.length; r3; ) {
            for (e2 = c, c = [], t3 = -1; ++t3 < r3; )
              e2[t3]();
            r3 = c.length;
          }
          n = false;
        }
        e.exports = function(t3) {
          c.push(t3) !== 1 || n || r2();
        };
      }).call(this, typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, {}], 387: [function(t, e, r) {
      typeof Object.create == "function" ? e.exports = function(t2, e2) {
        e2 && (t2.super_ = e2, t2.prototype = Object.create(e2.prototype, { constructor: { value: t2, enumerable: false, writable: true, configurable: true } }));
      } : e.exports = function(t2, e2) {
        if (e2) {
          t2.super_ = e2;
          var r2 = function() {
          };
          r2.prototype = e2.prototype, t2.prototype = new r2(), t2.prototype.constructor = t2;
        }
      };
    }, {}], 388: [function(t, e, r) {
      /*!
       * Determine if an object is a Buffer
       *
       * @author   Feross Aboukhadijeh <https://feross.org>
       * @license  MIT
       */
      function n(t2) {
        return !!t2.constructor && typeof t2.constructor.isBuffer == "function" && t2.constructor.isBuffer(t2);
      }
      e.exports = function(t2) {
        return t2 != null && (n(t2) || function(t3) {
          return typeof t3.readFloatLE == "function" && typeof t3.slice == "function" && n(t3.slice(0, 0));
        }(t2) || !!t2._isBuffer);
      };
    }, {}], 389: [function(t, e, r) {
      var n = {}.toString;
      e.exports = Array.isArray || function(t2) {
        return n.call(t2) == "[object Array]";
      };
    }, {}], 390: [function(t, e, r) {
      var n = t("./utils"), i = t("./support"), o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      r.encode = function(t2) {
        for (var e2, r2, i2, a, s, u, c, f = [], l = 0, h = t2.length, d = h, p = n.getTypeOf(t2) !== "string"; l < t2.length; )
          d = h - l, p ? (e2 = t2[l++], r2 = l < h ? t2[l++] : 0, i2 = l < h ? t2[l++] : 0) : (e2 = t2.charCodeAt(l++), r2 = l < h ? t2.charCodeAt(l++) : 0, i2 = l < h ? t2.charCodeAt(l++) : 0), a = e2 >> 2, s = (3 & e2) << 4 | r2 >> 4, u = d > 1 ? (15 & r2) << 2 | i2 >> 6 : 64, c = d > 2 ? 63 & i2 : 64, f.push(o.charAt(a) + o.charAt(s) + o.charAt(u) + o.charAt(c));
        return f.join("");
      }, r.decode = function(t2) {
        var e2, r2, n2, a, s, u, c = 0, f = 0;
        if (t2.substr(0, "data:".length) === "data:")
          throw new Error("Invalid base64 input, it looks like a data url.");
        var l, h = 3 * (t2 = t2.replace(/[^A-Za-z0-9\+\/\=]/g, "")).length / 4;
        if (t2.charAt(t2.length - 1) === o.charAt(64) && h--, t2.charAt(t2.length - 2) === o.charAt(64) && h--, h % 1 != 0)
          throw new Error("Invalid base64 input, bad content length.");
        for (l = i.uint8array ? new Uint8Array(0 | h) : new Array(0 | h); c < t2.length; )
          e2 = o.indexOf(t2.charAt(c++)) << 2 | (a = o.indexOf(t2.charAt(c++))) >> 4, r2 = (15 & a) << 4 | (s = o.indexOf(t2.charAt(c++))) >> 2, n2 = (3 & s) << 6 | (u = o.indexOf(t2.charAt(c++))), l[f++] = e2, s !== 64 && (l[f++] = r2), u !== 64 && (l[f++] = n2);
        return l;
      };
    }, { "./support": 419, "./utils": 421 }], 391: [function(t, e, r) {
      var n = t("./external"), i = t("./stream/DataWorker"), o = t("./stream/DataLengthProbe"), a = t("./stream/Crc32Probe");
      o = t("./stream/DataLengthProbe");
      function s(t2, e2, r2, n2, i2) {
        this.compressedSize = t2, this.uncompressedSize = e2, this.crc32 = r2, this.compression = n2, this.compressedContent = i2;
      }
      s.prototype = { getContentWorker: function() {
        var t2 = new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new o("data_length")), e2 = this;
        return t2.on("end", function() {
          if (this.streamInfo.data_length !== e2.uncompressedSize)
            throw new Error("Bug : uncompressed data size mismatch");
        }), t2;
      }, getCompressedWorker: function() {
        return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, s.createWorkerFrom = function(t2, e2, r2) {
        return t2.pipe(new a()).pipe(new o("uncompressedSize")).pipe(e2.compressWorker(r2)).pipe(new o("compressedSize")).withStreamInfo("compression", e2);
      }, e.exports = s;
    }, { "./external": 395, "./stream/Crc32Probe": 414, "./stream/DataLengthProbe": 415, "./stream/DataWorker": 416 }], 392: [function(t, e, r) {
      var n = t("./stream/GenericWorker");
      r.STORE = { magic: "\0\0", compressWorker: function(t2) {
        return new n("STORE compression");
      }, uncompressWorker: function() {
        return new n("STORE decompression");
      } }, r.DEFLATE = t("./flate");
    }, { "./flate": 396, "./stream/GenericWorker": 417 }], 393: [function(t, e, r) {
      var n = t("./utils");
      var i = function() {
        for (var t2, e2 = [], r2 = 0; r2 < 256; r2++) {
          t2 = r2;
          for (var n2 = 0; n2 < 8; n2++)
            t2 = 1 & t2 ? 3988292384 ^ t2 >>> 1 : t2 >>> 1;
          e2[r2] = t2;
        }
        return e2;
      }();
      e.exports = function(t2, e2) {
        return t2 !== void 0 && t2.length ? n.getTypeOf(t2) !== "string" ? function(t3, e3, r2, n2) {
          var o = i, a = n2 + r2;
          t3 ^= -1;
          for (var s = n2; s < a; s++)
            t3 = t3 >>> 8 ^ o[255 & (t3 ^ e3[s])];
          return -1 ^ t3;
        }(0 | e2, t2, t2.length, 0) : function(t3, e3, r2, n2) {
          var o = i, a = n2 + r2;
          t3 ^= -1;
          for (var s = n2; s < a; s++)
            t3 = t3 >>> 8 ^ o[255 & (t3 ^ e3.charCodeAt(s))];
          return -1 ^ t3;
        }(0 | e2, t2, t2.length, 0) : 0;
      };
    }, { "./utils": 421 }], 394: [function(t, e, r) {
      r.base64 = false, r.binary = false, r.dir = false, r.createFolders = true, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
    }, {}], 395: [function(t, e, r) {
      var n = null;
      n = typeof Promise != "undefined" ? Promise : t("lie"), e.exports = { Promise: n };
    }, { lie: 425 }], 396: [function(t, e, r) {
      var n = typeof Uint8Array != "undefined" && typeof Uint16Array != "undefined" && typeof Uint32Array != "undefined", i = t("pako"), o = t("./utils"), a = t("./stream/GenericWorker"), s = n ? "uint8array" : "array";
      function u(t2, e2) {
        a.call(this, "FlateWorker/" + t2), this._pako = null, this._pakoAction = t2, this._pakoOptions = e2, this.meta = {};
      }
      r.magic = "\b\0", o.inherits(u, a), u.prototype.processChunk = function(t2) {
        this.meta = t2.meta, this._pako === null && this._createPako(), this._pako.push(o.transformTo(s, t2.data), false);
      }, u.prototype.flush = function() {
        a.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], true);
      }, u.prototype.cleanUp = function() {
        a.prototype.cleanUp.call(this), this._pako = null;
      }, u.prototype._createPako = function() {
        this._pako = new i[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
        var t2 = this;
        this._pako.onData = function(e2) {
          t2.push({ data: e2, meta: t2.meta });
        };
      }, r.compressWorker = function(t2) {
        return new u("Deflate", t2);
      }, r.uncompressWorker = function() {
        return new u("Inflate", {});
      };
    }, { "./stream/GenericWorker": 417, "./utils": 421, pako: 439 }], 397: [function(t, e, r) {
      var n = t("../utils"), i = t("../stream/GenericWorker"), o = t("../utf8"), a = t("../crc32"), s = t("../signature"), u = function(t2, e2) {
        var r2, n2 = "";
        for (r2 = 0; r2 < e2; r2++)
          n2 += String.fromCharCode(255 & t2), t2 >>>= 8;
        return n2;
      }, c = function(t2, e2, r2, i2, c2, f2) {
        var l2, h, d = t2.file, p = t2.compression, m = f2 !== o.utf8encode, y = n.transformTo("string", f2(d.name)), b = n.transformTo("string", o.utf8encode(d.name)), v = d.comment, g = n.transformTo("string", f2(v)), w = n.transformTo("string", o.utf8encode(v)), _ = b.length !== d.name.length, k = w.length !== v.length, x = "", S = "", O = "", j = d.dir, E = d.date, R = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        e2 && !r2 || (R.crc32 = t2.crc32, R.compressedSize = t2.compressedSize, R.uncompressedSize = t2.uncompressedSize);
        var T = 0;
        e2 && (T |= 8), m || !_ && !k || (T |= 2048);
        var C, P, M, A = 0, I = 0;
        j && (A |= 16), c2 === "UNIX" ? (I = 798, A |= (C = d.unixPermissions, P = j, M = C, C || (M = P ? 16893 : 33204), (65535 & M) << 16)) : (I = 20, A |= 63 & (d.dosPermissions || 0)), l2 = E.getUTCHours(), l2 <<= 6, l2 |= E.getUTCMinutes(), l2 <<= 5, l2 |= E.getUTCSeconds() / 2, h = E.getUTCFullYear() - 1980, h <<= 4, h |= E.getUTCMonth() + 1, h <<= 5, h |= E.getUTCDate(), _ && (S = u(1, 1) + u(a(y), 4) + b, x += "up" + u(S.length, 2) + S), k && (O = u(1, 1) + u(a(g), 4) + w, x += "uc" + u(O.length, 2) + O);
        var N = "";
        return N += "\n\0", N += u(T, 2), N += p.magic, N += u(l2, 2), N += u(h, 2), N += u(R.crc32, 4), N += u(R.compressedSize, 4), N += u(R.uncompressedSize, 4), N += u(y.length, 2), N += u(x.length, 2), { fileRecord: s.LOCAL_FILE_HEADER + N + y + x, dirRecord: s.CENTRAL_FILE_HEADER + u(I, 2) + N + u(g.length, 2) + "\0\0\0\0" + u(A, 4) + u(i2, 4) + y + x + g };
      }, f = function(t2) {
        return s.DATA_DESCRIPTOR + u(t2.crc32, 4) + u(t2.compressedSize, 4) + u(t2.uncompressedSize, 4);
      };
      function l(t2, e2, r2, n2) {
        i.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = e2, this.zipPlatform = r2, this.encodeFileName = n2, this.streamFiles = t2, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      n.inherits(l, i), l.prototype.push = function(t2) {
        var e2 = t2.meta.percent || 0, r2 = this.entriesCount, n2 = this._sources.length;
        this.accumulate ? this.contentBuffer.push(t2) : (this.bytesWritten += t2.data.length, i.prototype.push.call(this, { data: t2.data, meta: { currentFile: this.currentFile, percent: r2 ? (e2 + 100 * (r2 - n2 - 1)) / r2 : 100 } }));
      }, l.prototype.openedSource = function(t2) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = t2.file.name;
        var e2 = this.streamFiles && !t2.file.dir;
        if (e2) {
          var r2 = c(t2, e2, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: r2.fileRecord, meta: { percent: 0 } });
        } else
          this.accumulate = true;
      }, l.prototype.closedSource = function(t2) {
        this.accumulate = false;
        var e2 = this.streamFiles && !t2.file.dir, r2 = c(t2, e2, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(r2.dirRecord), e2)
          this.push({ data: f(t2), meta: { percent: 100 } });
        else
          for (this.push({ data: r2.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
            this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, l.prototype.flush = function() {
        for (var t2 = this.bytesWritten, e2 = 0; e2 < this.dirRecords.length; e2++)
          this.push({ data: this.dirRecords[e2], meta: { percent: 100 } });
        var r2 = this.bytesWritten - t2, i2 = function(t3, e3, r3, i3, o2) {
          var a2 = n.transformTo("string", o2(i3));
          return s.CENTRAL_DIRECTORY_END + "\0\0\0\0" + u(t3, 2) + u(t3, 2) + u(e3, 4) + u(r3, 4) + u(a2.length, 2) + a2;
        }(this.dirRecords.length, r2, t2, this.zipComment, this.encodeFileName);
        this.push({ data: i2, meta: { percent: 100 } });
      }, l.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, l.prototype.registerPrevious = function(t2) {
        this._sources.push(t2);
        var e2 = this;
        return t2.on("data", function(t3) {
          e2.processChunk(t3);
        }), t2.on("end", function() {
          e2.closedSource(e2.previous.streamInfo), e2._sources.length ? e2.prepareNextSource() : e2.end();
        }), t2.on("error", function(t3) {
          e2.error(t3);
        }), this;
      }, l.prototype.resume = function() {
        return !!i.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
      }, l.prototype.error = function(t2) {
        var e2 = this._sources;
        if (!i.prototype.error.call(this, t2))
          return false;
        for (var r2 = 0; r2 < e2.length; r2++)
          try {
            e2[r2].error(t2);
          } catch (t3) {
          }
        return true;
      }, l.prototype.lock = function() {
        i.prototype.lock.call(this);
        for (var t2 = this._sources, e2 = 0; e2 < t2.length; e2++)
          t2[e2].lock();
      }, e.exports = l;
    }, { "../crc32": 393, "../signature": 412, "../stream/GenericWorker": 417, "../utf8": 420, "../utils": 421 }], 398: [function(t, e, r) {
      var n = t("../compressions"), i = t("./ZipFileWorker");
      r.generateWorker = function(t2, e2, r2) {
        var o = new i(e2.streamFiles, r2, e2.platform, e2.encodeFileName), a = 0;
        try {
          t2.forEach(function(t3, r3) {
            a++;
            var i2 = function(t4, e3) {
              var r4 = t4 || e3, i3 = n[r4];
              if (!i3)
                throw new Error(r4 + " is not a valid compression method !");
              return i3;
            }(r3.options.compression, e2.compression), s = r3.options.compressionOptions || e2.compressionOptions || {}, u = r3.dir, c = r3.date;
            r3._compressWorker(i2, s).withStreamInfo("file", { name: t3, dir: u, date: c, comment: r3.comment || "", unixPermissions: r3.unixPermissions, dosPermissions: r3.dosPermissions }).pipe(o);
          }), o.entriesCount = a;
        } catch (t3) {
          o.error(t3);
        }
        return o;
      };
    }, { "../compressions": 392, "./ZipFileWorker": 397 }], 399: [function(t, e, r) {
      function n() {
        if (!(this instanceof n))
          return new n();
        if (arguments.length)
          throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = {}, this.comment = null, this.root = "", this.clone = function() {
          var t2 = new n();
          for (var e2 in this)
            typeof this[e2] != "function" && (t2[e2] = this[e2]);
          return t2;
        };
      }
      n.prototype = t("./object"), n.prototype.loadAsync = t("./load"), n.support = t("./support"), n.defaults = t("./defaults"), n.version = "3.5.0", n.loadAsync = function(t2, e2) {
        return new n().loadAsync(t2, e2);
      }, n.external = t("./external"), e.exports = n;
    }, { "./defaults": 394, "./external": 395, "./load": 400, "./object": 404, "./support": 419 }], 400: [function(t, e, r) {
      var n = t("./utils"), i = t("./external"), o = t("./utf8"), a = (n = t("./utils"), t("./zipEntries")), s = t("./stream/Crc32Probe"), u = t("./nodejsUtils");
      function c(t2) {
        return new i.Promise(function(e2, r2) {
          var n2 = t2.decompressed.getContentWorker().pipe(new s());
          n2.on("error", function(t3) {
            r2(t3);
          }).on("end", function() {
            n2.streamInfo.crc32 !== t2.decompressed.crc32 ? r2(new Error("Corrupted zip : CRC32 mismatch")) : e2();
          }).resume();
        });
      }
      e.exports = function(t2, e2) {
        var r2 = this;
        return e2 = n.extend(e2 || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: o.utf8decode }), u.isNode && u.isStream(t2) ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : n.prepareContent("the loaded zip file", t2, true, e2.optimizedBinaryString, e2.base64).then(function(t3) {
          var r3 = new a(e2);
          return r3.load(t3), r3;
        }).then(function(t3) {
          var r3 = [i.Promise.resolve(t3)], n2 = t3.files;
          if (e2.checkCRC32)
            for (var o2 = 0; o2 < n2.length; o2++)
              r3.push(c(n2[o2]));
          return i.Promise.all(r3);
        }).then(function(t3) {
          for (var n2 = t3.shift(), i2 = n2.files, o2 = 0; o2 < i2.length; o2++) {
            var a2 = i2[o2];
            r2.file(a2.fileNameStr, a2.decompressed, { binary: true, optimizedBinaryString: true, date: a2.date, dir: a2.dir, comment: a2.fileCommentStr.length ? a2.fileCommentStr : null, unixPermissions: a2.unixPermissions, dosPermissions: a2.dosPermissions, createFolders: e2.createFolders });
          }
          return n2.zipComment.length && (r2.comment = n2.zipComment), r2;
        });
      };
    }, { "./external": 395, "./nodejsUtils": 403, "./stream/Crc32Probe": 414, "./utf8": 420, "./utils": 421, "./zipEntries": 422 }], 401: [function(t, e, r) {
      var n = t("../utils"), i = t("../stream/GenericWorker");
      function o(t2, e2) {
        i.call(this, "Nodejs stream input adapter for " + t2), this._upstreamEnded = false, this._bindStream(e2);
      }
      n.inherits(o, i), o.prototype._bindStream = function(t2) {
        var e2 = this;
        this._stream = t2, t2.pause(), t2.on("data", function(t3) {
          e2.push({ data: t3, meta: { percent: 0 } });
        }).on("error", function(t3) {
          e2.isPaused ? this.generatedError = t3 : e2.error(t3);
        }).on("end", function() {
          e2.isPaused ? e2._upstreamEnded = true : e2.end();
        });
      }, o.prototype.pause = function() {
        return !!i.prototype.pause.call(this) && (this._stream.pause(), true);
      }, o.prototype.resume = function() {
        return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
      }, e.exports = o;
    }, { "../stream/GenericWorker": 417, "../utils": 421 }], 402: [function(t, e, r) {
      var n = t("readable-stream").Readable;
      function i(t2, e2, r2) {
        n.call(this, e2), this._helper = t2;
        var i2 = this;
        t2.on("data", function(t3, e3) {
          i2.push(t3) || i2._helper.pause(), r2 && r2(e3);
        }).on("error", function(t3) {
          i2.emit("error", t3);
        }).on("end", function() {
          i2.push(null);
        });
      }
      t("../utils").inherits(i, n), i.prototype._read = function() {
        this._helper.resume();
      }, e.exports = i;
    }, { "../utils": 421, "readable-stream": 405 }], 403: [function(t, e, r) {
      (function(t2) {
        e.exports = { isNode: t2 !== void 0, newBufferFrom: function(e2, r2) {
          if (t2.from && t2.from !== Uint8Array.from)
            return t2.from(e2, r2);
          if (typeof e2 == "number")
            throw new Error('The "data" argument must not be a number');
          return new t2(e2, r2);
        }, allocBuffer: function(e2) {
          if (t2.alloc)
            return t2.alloc(e2);
          var r2 = new t2(e2);
          return r2.fill(0), r2;
        }, isBuffer: function(e2) {
          return t2.isBuffer(e2);
        }, isStream: function(t3) {
          return t3 && typeof t3.on == "function" && typeof t3.pause == "function" && typeof t3.resume == "function";
        } };
      }).call(this, t("buffer").Buffer);
    }, { buffer: 216 }], 404: [function(t, e, r) {
      var n = t("./utf8"), i = t("./utils"), o = t("./stream/GenericWorker"), a = t("./stream/StreamHelper"), s = t("./defaults"), u = t("./compressedObject"), c = t("./zipObject"), f = t("./generate"), l = t("./nodejsUtils"), h = t("./nodejs/NodejsStreamInputAdapter"), d = function(t2, e2, r2) {
        var n2, a2 = i.getTypeOf(e2), f2 = i.extend(r2 || {}, s);
        f2.date = f2.date || new Date(), f2.compression !== null && (f2.compression = f2.compression.toUpperCase()), typeof f2.unixPermissions == "string" && (f2.unixPermissions = parseInt(f2.unixPermissions, 8)), f2.unixPermissions && 16384 & f2.unixPermissions && (f2.dir = true), f2.dosPermissions && 16 & f2.dosPermissions && (f2.dir = true), f2.dir && (t2 = m(t2)), f2.createFolders && (n2 = p(t2)) && y.call(this, n2, true);
        var d2 = a2 === "string" && f2.binary === false && f2.base64 === false;
        r2 && r2.binary !== void 0 || (f2.binary = !d2), (e2 instanceof u && e2.uncompressedSize === 0 || f2.dir || !e2 || e2.length === 0) && (f2.base64 = false, f2.binary = true, e2 = "", f2.compression = "STORE", a2 = "string");
        var b2 = null;
        b2 = e2 instanceof u || e2 instanceof o ? e2 : l.isNode && l.isStream(e2) ? new h(t2, e2) : i.prepareContent(t2, e2, f2.binary, f2.optimizedBinaryString, f2.base64);
        var v2 = new c(t2, b2, f2);
        this.files[t2] = v2;
      }, p = function(t2) {
        t2.slice(-1) === "/" && (t2 = t2.substring(0, t2.length - 1));
        var e2 = t2.lastIndexOf("/");
        return e2 > 0 ? t2.substring(0, e2) : "";
      }, m = function(t2) {
        return t2.slice(-1) !== "/" && (t2 += "/"), t2;
      }, y = function(t2, e2) {
        return e2 = e2 !== void 0 ? e2 : s.createFolders, t2 = m(t2), this.files[t2] || d.call(this, t2, null, { dir: true, createFolders: e2 }), this.files[t2];
      };
      function b(t2) {
        return Object.prototype.toString.call(t2) === "[object RegExp]";
      }
      var v = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(t2) {
        var e2, r2, n2;
        for (e2 in this.files)
          this.files.hasOwnProperty(e2) && (n2 = this.files[e2], (r2 = e2.slice(this.root.length, e2.length)) && e2.slice(0, this.root.length) === this.root && t2(r2, n2));
      }, filter: function(t2) {
        var e2 = [];
        return this.forEach(function(r2, n2) {
          t2(r2, n2) && e2.push(n2);
        }), e2;
      }, file: function(t2, e2, r2) {
        if (arguments.length === 1) {
          if (b(t2)) {
            var n2 = t2;
            return this.filter(function(t3, e3) {
              return !e3.dir && n2.test(t3);
            });
          }
          var i2 = this.files[this.root + t2];
          return i2 && !i2.dir ? i2 : null;
        }
        return t2 = this.root + t2, d.call(this, t2, e2, r2), this;
      }, folder: function(t2) {
        if (!t2)
          return this;
        if (b(t2))
          return this.filter(function(e3, r3) {
            return r3.dir && t2.test(e3);
          });
        var e2 = this.root + t2, r2 = y.call(this, e2), n2 = this.clone();
        return n2.root = r2.name, n2;
      }, remove: function(t2) {
        t2 = this.root + t2;
        var e2 = this.files[t2];
        if (e2 || (t2.slice(-1) !== "/" && (t2 += "/"), e2 = this.files[t2]), e2 && !e2.dir)
          delete this.files[t2];
        else
          for (var r2 = this.filter(function(e3, r3) {
            return r3.name.slice(0, t2.length) === t2;
          }), n2 = 0; n2 < r2.length; n2++)
            delete this.files[r2[n2].name];
        return this;
      }, generate: function(t2) {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(t2) {
        var e2, r2 = {};
        try {
          if ((r2 = i.extend(t2 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: n.utf8encode })).type = r2.type.toLowerCase(), r2.compression = r2.compression.toUpperCase(), r2.type === "binarystring" && (r2.type = "string"), !r2.type)
            throw new Error("No output type specified.");
          i.checkSupport(r2.type), r2.platform !== "darwin" && r2.platform !== "freebsd" && r2.platform !== "linux" && r2.platform !== "sunos" || (r2.platform = "UNIX"), r2.platform === "win32" && (r2.platform = "DOS");
          var s2 = r2.comment || this.comment || "";
          e2 = f.generateWorker(this, r2, s2);
        } catch (t3) {
          (e2 = new o("error")).error(t3);
        }
        return new a(e2, r2.type || "string", r2.mimeType);
      }, generateAsync: function(t2, e2) {
        return this.generateInternalStream(t2).accumulate(e2);
      }, generateNodeStream: function(t2, e2) {
        return (t2 = t2 || {}).type || (t2.type = "nodebuffer"), this.generateInternalStream(t2).toNodejsStream(e2);
      } };
      e.exports = v;
    }, { "./compressedObject": 391, "./defaults": 394, "./generate": 398, "./nodejs/NodejsStreamInputAdapter": 401, "./nodejsUtils": 403, "./stream/GenericWorker": 417, "./stream/StreamHelper": 418, "./utf8": 420, "./utils": 421, "./zipObject": 424 }], 405: [function(t, e, r) {
      e.exports = t("stream");
    }, { stream: 506 }], 406: [function(t, e, r) {
      var n = t("./DataReader");
      function i(t2) {
        n.call(this, t2);
        for (var e2 = 0; e2 < this.data.length; e2++)
          t2[e2] = 255 & t2[e2];
      }
      t("../utils").inherits(i, n), i.prototype.byteAt = function(t2) {
        return this.data[this.zero + t2];
      }, i.prototype.lastIndexOfSignature = function(t2) {
        for (var e2 = t2.charCodeAt(0), r2 = t2.charCodeAt(1), n2 = t2.charCodeAt(2), i2 = t2.charCodeAt(3), o = this.length - 4; o >= 0; --o)
          if (this.data[o] === e2 && this.data[o + 1] === r2 && this.data[o + 2] === n2 && this.data[o + 3] === i2)
            return o - this.zero;
        return -1;
      }, i.prototype.readAndCheckSignature = function(t2) {
        var e2 = t2.charCodeAt(0), r2 = t2.charCodeAt(1), n2 = t2.charCodeAt(2), i2 = t2.charCodeAt(3), o = this.readData(4);
        return e2 === o[0] && r2 === o[1] && n2 === o[2] && i2 === o[3];
      }, i.prototype.readData = function(t2) {
        if (this.checkOffset(t2), t2 === 0)
          return [];
        var e2 = this.data.slice(this.zero + this.index, this.zero + this.index + t2);
        return this.index += t2, e2;
      }, e.exports = i;
    }, { "../utils": 421, "./DataReader": 407 }], 407: [function(t, e, r) {
      var n = t("../utils");
      function i(t2) {
        this.data = t2, this.length = t2.length, this.index = 0, this.zero = 0;
      }
      i.prototype = { checkOffset: function(t2) {
        this.checkIndex(this.index + t2);
      }, checkIndex: function(t2) {
        if (this.length < this.zero + t2 || t2 < 0)
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + t2 + "). Corrupted zip ?");
      }, setIndex: function(t2) {
        this.checkIndex(t2), this.index = t2;
      }, skip: function(t2) {
        this.setIndex(this.index + t2);
      }, byteAt: function(t2) {
      }, readInt: function(t2) {
        var e2, r2 = 0;
        for (this.checkOffset(t2), e2 = this.index + t2 - 1; e2 >= this.index; e2--)
          r2 = (r2 << 8) + this.byteAt(e2);
        return this.index += t2, r2;
      }, readString: function(t2) {
        return n.transformTo("string", this.readData(t2));
      }, readData: function(t2) {
      }, lastIndexOfSignature: function(t2) {
      }, readAndCheckSignature: function(t2) {
      }, readDate: function() {
        var t2 = this.readInt(4);
        return new Date(Date.UTC(1980 + (t2 >> 25 & 127), (t2 >> 21 & 15) - 1, t2 >> 16 & 31, t2 >> 11 & 31, t2 >> 5 & 63, (31 & t2) << 1));
      } }, e.exports = i;
    }, { "../utils": 421 }], 408: [function(t, e, r) {
      var n = t("./Uint8ArrayReader");
      function i(t2) {
        n.call(this, t2);
      }
      t("../utils").inherits(i, n), i.prototype.readData = function(t2) {
        this.checkOffset(t2);
        var e2 = this.data.slice(this.zero + this.index, this.zero + this.index + t2);
        return this.index += t2, e2;
      }, e.exports = i;
    }, { "../utils": 421, "./Uint8ArrayReader": 410 }], 409: [function(t, e, r) {
      var n = t("./DataReader");
      function i(t2) {
        n.call(this, t2);
      }
      t("../utils").inherits(i, n), i.prototype.byteAt = function(t2) {
        return this.data.charCodeAt(this.zero + t2);
      }, i.prototype.lastIndexOfSignature = function(t2) {
        return this.data.lastIndexOf(t2) - this.zero;
      }, i.prototype.readAndCheckSignature = function(t2) {
        return t2 === this.readData(4);
      }, i.prototype.readData = function(t2) {
        this.checkOffset(t2);
        var e2 = this.data.slice(this.zero + this.index, this.zero + this.index + t2);
        return this.index += t2, e2;
      }, e.exports = i;
    }, { "../utils": 421, "./DataReader": 407 }], 410: [function(t, e, r) {
      var n = t("./ArrayReader");
      function i(t2) {
        n.call(this, t2);
      }
      t("../utils").inherits(i, n), i.prototype.readData = function(t2) {
        if (this.checkOffset(t2), t2 === 0)
          return new Uint8Array(0);
        var e2 = this.data.subarray(this.zero + this.index, this.zero + this.index + t2);
        return this.index += t2, e2;
      }, e.exports = i;
    }, { "../utils": 421, "./ArrayReader": 406 }], 411: [function(t, e, r) {
      var n = t("../utils"), i = t("../support"), o = t("./ArrayReader"), a = t("./StringReader"), s = t("./NodeBufferReader"), u = t("./Uint8ArrayReader");
      e.exports = function(t2) {
        var e2 = n.getTypeOf(t2);
        return n.checkSupport(e2), e2 !== "string" || i.uint8array ? e2 === "nodebuffer" ? new s(t2) : i.uint8array ? new u(n.transformTo("uint8array", t2)) : new o(n.transformTo("array", t2)) : new a(t2);
      };
    }, { "../support": 419, "../utils": 421, "./ArrayReader": 406, "./NodeBufferReader": 408, "./StringReader": 409, "./Uint8ArrayReader": 410 }], 412: [function(t, e, r) {
      r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 413: [function(t, e, r) {
      var n = t("./GenericWorker"), i = t("../utils");
      function o(t2) {
        n.call(this, "ConvertWorker to " + t2), this.destType = t2;
      }
      i.inherits(o, n), o.prototype.processChunk = function(t2) {
        this.push({ data: i.transformTo(this.destType, t2.data), meta: t2.meta });
      }, e.exports = o;
    }, { "../utils": 421, "./GenericWorker": 417 }], 414: [function(t, e, r) {
      var n = t("./GenericWorker"), i = t("../crc32");
      function o() {
        n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      t("../utils").inherits(o, n), o.prototype.processChunk = function(t2) {
        this.streamInfo.crc32 = i(t2.data, this.streamInfo.crc32 || 0), this.push(t2);
      }, e.exports = o;
    }, { "../crc32": 393, "../utils": 421, "./GenericWorker": 417 }], 415: [function(t, e, r) {
      var n = t("../utils"), i = t("./GenericWorker");
      function o(t2) {
        i.call(this, "DataLengthProbe for " + t2), this.propName = t2, this.withStreamInfo(t2, 0);
      }
      n.inherits(o, i), o.prototype.processChunk = function(t2) {
        if (t2) {
          var e2 = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = e2 + t2.data.length;
        }
        i.prototype.processChunk.call(this, t2);
      }, e.exports = o;
    }, { "../utils": 421, "./GenericWorker": 417 }], 416: [function(t, e, r) {
      var n = t("../utils"), i = t("./GenericWorker");
      function o(t2) {
        i.call(this, "DataWorker");
        var e2 = this;
        this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, t2.then(function(t3) {
          e2.dataIsReady = true, e2.data = t3, e2.max = t3 && t3.length || 0, e2.type = n.getTypeOf(t3), e2.isPaused || e2._tickAndRepeat();
        }, function(t3) {
          e2.error(t3);
        });
      }
      n.inherits(o, i), o.prototype.cleanUp = function() {
        i.prototype.cleanUp.call(this), this.data = null;
      }, o.prototype.resume = function() {
        return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n.delay(this._tickAndRepeat, [], this)), true);
      }, o.prototype._tickAndRepeat = function() {
        this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
      }, o.prototype._tick = function() {
        if (this.isPaused || this.isFinished)
          return false;
        var t2 = null, e2 = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max)
          return this.end();
        switch (this.type) {
          case "string":
            t2 = this.data.substring(this.index, e2);
            break;
          case "uint8array":
            t2 = this.data.subarray(this.index, e2);
            break;
          case "array":
          case "nodebuffer":
            t2 = this.data.slice(this.index, e2);
        }
        return this.index = e2, this.push({ data: t2, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, e.exports = o;
    }, { "../utils": 421, "./GenericWorker": 417 }], 417: [function(t, e, r) {
      function n(t2) {
        this.name = t2 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      n.prototype = { push: function(t2) {
        this.emit("data", t2);
      }, end: function() {
        if (this.isFinished)
          return false;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = true;
        } catch (t2) {
          this.emit("error", t2);
        }
        return true;
      }, error: function(t2) {
        return !this.isFinished && (this.isPaused ? this.generatedError = t2 : (this.isFinished = true, this.emit("error", t2), this.previous && this.previous.error(t2), this.cleanUp()), true);
      }, on: function(t2, e2) {
        return this._listeners[t2].push(e2), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(t2, e2) {
        if (this._listeners[t2])
          for (var r2 = 0; r2 < this._listeners[t2].length; r2++)
            this._listeners[t2][r2].call(this, e2);
      }, pipe: function(t2) {
        return t2.registerPrevious(this);
      }, registerPrevious: function(t2) {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = t2.streamInfo, this.mergeStreamInfo(), this.previous = t2;
        var e2 = this;
        return t2.on("data", function(t3) {
          e2.processChunk(t3);
        }), t2.on("end", function() {
          e2.end();
        }), t2.on("error", function(t3) {
          e2.error(t3);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
      }, resume: function() {
        if (!this.isPaused || this.isFinished)
          return false;
        this.isPaused = false;
        var t2 = false;
        return this.generatedError && (this.error(this.generatedError), t2 = true), this.previous && this.previous.resume(), !t2;
      }, flush: function() {
      }, processChunk: function(t2) {
        this.push(t2);
      }, withStreamInfo: function(t2, e2) {
        return this.extraStreamInfo[t2] = e2, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var t2 in this.extraStreamInfo)
          this.extraStreamInfo.hasOwnProperty(t2) && (this.streamInfo[t2] = this.extraStreamInfo[t2]);
      }, lock: function() {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = true, this.previous && this.previous.lock();
      }, toString: function() {
        var t2 = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + t2 : t2;
      } }, e.exports = n;
    }, {}], 418: [function(t, e, r) {
      (function(r2) {
        var n = t("../utils"), i = t("./ConvertWorker"), o = t("./GenericWorker"), a = t("../base64"), s = t("../support"), u = t("../external"), c = null;
        if (s.nodestream)
          try {
            c = t("../nodejs/NodejsStreamOutputAdapter");
          } catch (t2) {
          }
        function f(t2, e2) {
          return new u.Promise(function(i2, o2) {
            var s2 = [], u2 = t2._internalType, c2 = t2._outputType, f2 = t2._mimeType;
            t2.on("data", function(t3, r3) {
              s2.push(t3), e2 && e2(r3);
            }).on("error", function(t3) {
              s2 = [], o2(t3);
            }).on("end", function() {
              try {
                var t3 = function(t4, e3, r3) {
                  switch (t4) {
                    case "blob":
                      return n.newBlob(n.transformTo("arraybuffer", e3), r3);
                    case "base64":
                      return a.encode(e3);
                    default:
                      return n.transformTo(t4, e3);
                  }
                }(c2, function(t4, e3) {
                  var n2, i3 = 0, o3 = null, a2 = 0;
                  for (n2 = 0; n2 < e3.length; n2++)
                    a2 += e3[n2].length;
                  switch (t4) {
                    case "string":
                      return e3.join("");
                    case "array":
                      return Array.prototype.concat.apply([], e3);
                    case "uint8array":
                      for (o3 = new Uint8Array(a2), n2 = 0; n2 < e3.length; n2++)
                        o3.set(e3[n2], i3), i3 += e3[n2].length;
                      return o3;
                    case "nodebuffer":
                      return r2.concat(e3);
                    default:
                      throw new Error("concat : unsupported type '" + t4 + "'");
                  }
                }(u2, s2), f2);
                i2(t3);
              } catch (t4) {
                o2(t4);
              }
              s2 = [];
            }).resume();
          });
        }
        function l(t2, e2, r3) {
          var a2 = e2;
          switch (e2) {
            case "blob":
            case "arraybuffer":
              a2 = "uint8array";
              break;
            case "base64":
              a2 = "string";
          }
          try {
            this._internalType = a2, this._outputType = e2, this._mimeType = r3, n.checkSupport(a2), this._worker = t2.pipe(new i(a2)), t2.lock();
          } catch (t3) {
            this._worker = new o("error"), this._worker.error(t3);
          }
        }
        l.prototype = { accumulate: function(t2) {
          return f(this, t2);
        }, on: function(t2, e2) {
          var r3 = this;
          return t2 === "data" ? this._worker.on(t2, function(t3) {
            e2.call(r3, t3.data, t3.meta);
          }) : this._worker.on(t2, function() {
            n.delay(e2, arguments, r3);
          }), this;
        }, resume: function() {
          return n.delay(this._worker.resume, [], this._worker), this;
        }, pause: function() {
          return this._worker.pause(), this;
        }, toNodejsStream: function(t2) {
          if (n.checkSupport("nodestream"), this._outputType !== "nodebuffer")
            throw new Error(this._outputType + " is not supported by this method");
          return new c(this, { objectMode: this._outputType !== "nodebuffer" }, t2);
        } }, e.exports = l;
      }).call(this, t("buffer").Buffer);
    }, { "../base64": 390, "../external": 395, "../nodejs/NodejsStreamOutputAdapter": 402, "../support": 419, "../utils": 421, "./ConvertWorker": 413, "./GenericWorker": 417, buffer: 216 }], 419: [function(t, e, r) {
      (function(e2) {
        if (r.base64 = true, r.array = true, r.string = true, r.arraybuffer = typeof ArrayBuffer != "undefined" && typeof Uint8Array != "undefined", r.nodebuffer = e2 !== void 0, r.uint8array = typeof Uint8Array != "undefined", typeof ArrayBuffer == "undefined")
          r.blob = false;
        else {
          var n = new ArrayBuffer(0);
          try {
            r.blob = new Blob([n], { type: "application/zip" }).size === 0;
          } catch (t2) {
            try {
              var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              i.append(n), r.blob = i.getBlob("application/zip").size === 0;
            } catch (t3) {
              r.blob = false;
            }
          }
        }
        try {
          r.nodestream = !!t("readable-stream").Readable;
        } catch (t2) {
          r.nodestream = false;
        }
      }).call(this, t("buffer").Buffer);
    }, { buffer: 216, "readable-stream": 405 }], 420: [function(t, e, r) {
      for (var n = t("./utils"), i = t("./support"), o = t("./nodejsUtils"), a = t("./stream/GenericWorker"), s = new Array(256), u = 0; u < 256; u++)
        s[u] = u >= 252 ? 6 : u >= 248 ? 5 : u >= 240 ? 4 : u >= 224 ? 3 : u >= 192 ? 2 : 1;
      s[254] = s[254] = 1;
      function c() {
        a.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function f() {
        a.call(this, "utf-8 encode");
      }
      r.utf8encode = function(t2) {
        return i.nodebuffer ? o.newBufferFrom(t2, "utf-8") : function(t3) {
          var e2, r2, n2, o2, a2, s2 = t3.length, u2 = 0;
          for (o2 = 0; o2 < s2; o2++)
            (64512 & (r2 = t3.charCodeAt(o2))) == 55296 && o2 + 1 < s2 && (64512 & (n2 = t3.charCodeAt(o2 + 1))) == 56320 && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), o2++), u2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
          for (e2 = i.uint8array ? new Uint8Array(u2) : new Array(u2), a2 = 0, o2 = 0; a2 < u2; o2++)
            (64512 & (r2 = t3.charCodeAt(o2))) == 55296 && o2 + 1 < s2 && (64512 & (n2 = t3.charCodeAt(o2 + 1))) == 56320 && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), o2++), r2 < 128 ? e2[a2++] = r2 : r2 < 2048 ? (e2[a2++] = 192 | r2 >>> 6, e2[a2++] = 128 | 63 & r2) : r2 < 65536 ? (e2[a2++] = 224 | r2 >>> 12, e2[a2++] = 128 | r2 >>> 6 & 63, e2[a2++] = 128 | 63 & r2) : (e2[a2++] = 240 | r2 >>> 18, e2[a2++] = 128 | r2 >>> 12 & 63, e2[a2++] = 128 | r2 >>> 6 & 63, e2[a2++] = 128 | 63 & r2);
          return e2;
        }(t2);
      }, r.utf8decode = function(t2) {
        return i.nodebuffer ? n.transformTo("nodebuffer", t2).toString("utf-8") : function(t3) {
          var e2, r2, i2, o2, a2 = t3.length, u2 = new Array(2 * a2);
          for (r2 = 0, e2 = 0; e2 < a2; )
            if ((i2 = t3[e2++]) < 128)
              u2[r2++] = i2;
            else if ((o2 = s[i2]) > 4)
              u2[r2++] = 65533, e2 += o2 - 1;
            else {
              for (i2 &= o2 === 2 ? 31 : o2 === 3 ? 15 : 7; o2 > 1 && e2 < a2; )
                i2 = i2 << 6 | 63 & t3[e2++], o2--;
              o2 > 1 ? u2[r2++] = 65533 : i2 < 65536 ? u2[r2++] = i2 : (i2 -= 65536, u2[r2++] = 55296 | i2 >> 10 & 1023, u2[r2++] = 56320 | 1023 & i2);
            }
          return u2.length !== r2 && (u2.subarray ? u2 = u2.subarray(0, r2) : u2.length = r2), n.applyFromCharCode(u2);
        }(t2 = n.transformTo(i.uint8array ? "uint8array" : "array", t2));
      }, n.inherits(c, a), c.prototype.processChunk = function(t2) {
        var e2 = n.transformTo(i.uint8array ? "uint8array" : "array", t2.data);
        if (this.leftOver && this.leftOver.length) {
          if (i.uint8array) {
            var o2 = e2;
            (e2 = new Uint8Array(o2.length + this.leftOver.length)).set(this.leftOver, 0), e2.set(o2, this.leftOver.length);
          } else
            e2 = this.leftOver.concat(e2);
          this.leftOver = null;
        }
        var a2 = function(t3, e3) {
          var r2;
          for ((e3 = e3 || t3.length) > t3.length && (e3 = t3.length), r2 = e3 - 1; r2 >= 0 && (192 & t3[r2]) == 128; )
            r2--;
          return r2 < 0 || r2 === 0 ? e3 : r2 + s[t3[r2]] > e3 ? r2 : e3;
        }(e2), u2 = e2;
        a2 !== e2.length && (i.uint8array ? (u2 = e2.subarray(0, a2), this.leftOver = e2.subarray(a2, e2.length)) : (u2 = e2.slice(0, a2), this.leftOver = e2.slice(a2, e2.length))), this.push({ data: r.utf8decode(u2), meta: t2.meta });
      }, c.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: r.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, r.Utf8DecodeWorker = c, n.inherits(f, a), f.prototype.processChunk = function(t2) {
        this.push({ data: r.utf8encode(t2.data), meta: t2.meta });
      }, r.Utf8EncodeWorker = f;
    }, { "./nodejsUtils": 403, "./stream/GenericWorker": 417, "./support": 419, "./utils": 421 }], 421: [function(t, e, r) {
      var n = t("./support"), i = t("./base64"), o = t("./nodejsUtils"), a = t("set-immediate-shim"), s = t("./external");
      function u(t2) {
        return t2;
      }
      function c(t2, e2) {
        for (var r2 = 0; r2 < t2.length; ++r2)
          e2[r2] = 255 & t2.charCodeAt(r2);
        return e2;
      }
      r.newBlob = function(t2, e2) {
        r.checkSupport("blob");
        try {
          return new Blob([t2], { type: e2 });
        } catch (r2) {
          try {
            var n2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return n2.append(t2), n2.getBlob(e2);
          } catch (t3) {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var f = { stringifyByChunk: function(t2, e2, r2) {
        var n2 = [], i2 = 0, o2 = t2.length;
        if (o2 <= r2)
          return String.fromCharCode.apply(null, t2);
        for (; i2 < o2; )
          e2 === "array" || e2 === "nodebuffer" ? n2.push(String.fromCharCode.apply(null, t2.slice(i2, Math.min(i2 + r2, o2)))) : n2.push(String.fromCharCode.apply(null, t2.subarray(i2, Math.min(i2 + r2, o2)))), i2 += r2;
        return n2.join("");
      }, stringifyByChar: function(t2) {
        for (var e2 = "", r2 = 0; r2 < t2.length; r2++)
          e2 += String.fromCharCode(t2[r2]);
        return e2;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return n.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch (t2) {
          return false;
        }
      }(), nodebuffer: function() {
        try {
          return n.nodebuffer && String.fromCharCode.apply(null, o.allocBuffer(1)).length === 1;
        } catch (t2) {
          return false;
        }
      }() } };
      function l(t2) {
        var e2 = 65536, n2 = r.getTypeOf(t2), i2 = true;
        if (n2 === "uint8array" ? i2 = f.applyCanBeUsed.uint8array : n2 === "nodebuffer" && (i2 = f.applyCanBeUsed.nodebuffer), i2)
          for (; e2 > 1; )
            try {
              return f.stringifyByChunk(t2, n2, e2);
            } catch (t3) {
              e2 = Math.floor(e2 / 2);
            }
        return f.stringifyByChar(t2);
      }
      function h(t2, e2) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e2[r2] = t2[r2];
        return e2;
      }
      r.applyFromCharCode = l;
      var d = {};
      d.string = { string: u, array: function(t2) {
        return c(t2, new Array(t2.length));
      }, arraybuffer: function(t2) {
        return d.string.uint8array(t2).buffer;
      }, uint8array: function(t2) {
        return c(t2, new Uint8Array(t2.length));
      }, nodebuffer: function(t2) {
        return c(t2, o.allocBuffer(t2.length));
      } }, d.array = { string: l, array: u, arraybuffer: function(t2) {
        return new Uint8Array(t2).buffer;
      }, uint8array: function(t2) {
        return new Uint8Array(t2);
      }, nodebuffer: function(t2) {
        return o.newBufferFrom(t2);
      } }, d.arraybuffer = { string: function(t2) {
        return l(new Uint8Array(t2));
      }, array: function(t2) {
        return h(new Uint8Array(t2), new Array(t2.byteLength));
      }, arraybuffer: u, uint8array: function(t2) {
        return new Uint8Array(t2);
      }, nodebuffer: function(t2) {
        return o.newBufferFrom(new Uint8Array(t2));
      } }, d.uint8array = { string: l, array: function(t2) {
        return h(t2, new Array(t2.length));
      }, arraybuffer: function(t2) {
        return t2.buffer;
      }, uint8array: u, nodebuffer: function(t2) {
        return o.newBufferFrom(t2);
      } }, d.nodebuffer = { string: l, array: function(t2) {
        return h(t2, new Array(t2.length));
      }, arraybuffer: function(t2) {
        return d.nodebuffer.uint8array(t2).buffer;
      }, uint8array: function(t2) {
        return h(t2, new Uint8Array(t2.length));
      }, nodebuffer: u }, r.transformTo = function(t2, e2) {
        if (e2 || (e2 = ""), !t2)
          return e2;
        r.checkSupport(t2);
        var n2 = r.getTypeOf(e2);
        return d[n2][t2](e2);
      }, r.getTypeOf = function(t2) {
        return typeof t2 == "string" ? "string" : Object.prototype.toString.call(t2) === "[object Array]" ? "array" : n.nodebuffer && o.isBuffer(t2) ? "nodebuffer" : n.uint8array && t2 instanceof Uint8Array ? "uint8array" : n.arraybuffer && t2 instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, r.checkSupport = function(t2) {
        if (!n[t2.toLowerCase()])
          throw new Error(t2 + " is not supported by this platform");
      }, r.MAX_VALUE_16BITS = 65535, r.MAX_VALUE_32BITS = -1, r.pretty = function(t2) {
        var e2, r2, n2 = "";
        for (r2 = 0; r2 < (t2 || "").length; r2++)
          n2 += "\\x" + ((e2 = t2.charCodeAt(r2)) < 16 ? "0" : "") + e2.toString(16).toUpperCase();
        return n2;
      }, r.delay = function(t2, e2, r2) {
        a(function() {
          t2.apply(r2 || null, e2 || []);
        });
      }, r.inherits = function(t2, e2) {
        var r2 = function() {
        };
        r2.prototype = e2.prototype, t2.prototype = new r2();
      }, r.extend = function() {
        var t2, e2, r2 = {};
        for (t2 = 0; t2 < arguments.length; t2++)
          for (e2 in arguments[t2])
            arguments[t2].hasOwnProperty(e2) && r2[e2] === void 0 && (r2[e2] = arguments[t2][e2]);
        return r2;
      }, r.prepareContent = function(t2, e2, o2, a2, u2) {
        return s.Promise.resolve(e2).then(function(t3) {
          return n.blob && (t3 instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(t3)) !== -1) && typeof FileReader != "undefined" ? new s.Promise(function(e3, r2) {
            var n2 = new FileReader();
            n2.onload = function(t4) {
              e3(t4.target.result);
            }, n2.onerror = function(t4) {
              r2(t4.target.error);
            }, n2.readAsArrayBuffer(t3);
          }) : t3;
        }).then(function(e3) {
          var f2, l2 = r.getTypeOf(e3);
          return l2 ? (l2 === "arraybuffer" ? e3 = r.transformTo("uint8array", e3) : l2 === "string" && (u2 ? e3 = i.decode(e3) : o2 && a2 !== true && (e3 = c(f2 = e3, n.uint8array ? new Uint8Array(f2.length) : new Array(f2.length)))), e3) : s.Promise.reject(new Error("Can't read the data of '" + t2 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 390, "./external": 395, "./nodejsUtils": 403, "./support": 419, "set-immediate-shim": 497 }], 422: [function(t, e, r) {
      var n = t("./reader/readerFor"), i = t("./utils"), o = t("./signature"), a = t("./zipEntry"), s = (t("./utf8"), t("./support"));
      function u(t2) {
        this.files = [], this.loadOptions = t2;
      }
      u.prototype = { checkSignature: function(t2) {
        if (!this.reader.readAndCheckSignature(t2)) {
          this.reader.index -= 4;
          var e2 = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + i.pretty(e2) + ", expected " + i.pretty(t2) + ")");
        }
      }, isSignature: function(t2, e2) {
        var r2 = this.reader.index;
        this.reader.setIndex(t2);
        var n2 = this.reader.readString(4) === e2;
        return this.reader.setIndex(r2), n2;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var t2 = this.reader.readData(this.zipCommentLength), e2 = s.uint8array ? "uint8array" : "array", r2 = i.transformTo(e2, t2);
        this.zipComment = this.loadOptions.decodeFileName(r2);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var t2, e2, r2, n2 = this.zip64EndOfCentralSize - 44; 0 < n2; )
          t2 = this.reader.readInt(2), e2 = this.reader.readInt(4), r2 = this.reader.readData(e2), this.zip64ExtensibleData[t2] = { id: t2, length: e2, value: r2 };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), this.disksCount > 1)
          throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var t2, e2;
        for (t2 = 0; t2 < this.files.length; t2++)
          e2 = this.files[t2], this.reader.setIndex(e2.localHeaderOffset), this.checkSignature(o.LOCAL_FILE_HEADER), e2.readLocalPart(this.reader), e2.handleUTF8(), e2.processAttributes();
      }, readCentralDir: function() {
        var t2;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(o.CENTRAL_FILE_HEADER); )
          (t2 = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(t2);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0)
          throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var t2 = this.reader.lastIndexOfSignature(o.CENTRAL_DIRECTORY_END);
        if (t2 < 0)
          throw !this.isSignature(0, o.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
        this.reader.setIndex(t2);
        var e2 = t2;
        if (this.checkSignature(o.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) {
          if (this.zip64 = true, (t2 = this.reader.lastIndexOfSignature(o.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(t2), this.checkSignature(o.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, o.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(o.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(o.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var r2 = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (r2 += 20, r2 += 12 + this.zip64EndOfCentralSize);
        var n2 = e2 - r2;
        if (n2 > 0)
          this.isSignature(e2, o.CENTRAL_FILE_HEADER) || (this.reader.zero = n2);
        else if (n2 < 0)
          throw new Error("Corrupted zip: missing " + Math.abs(n2) + " bytes.");
      }, prepareReader: function(t2) {
        this.reader = n(t2);
      }, load: function(t2) {
        this.prepareReader(t2), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, e.exports = u;
    }, { "./reader/readerFor": 411, "./signature": 412, "./support": 419, "./utf8": 420, "./utils": 421, "./zipEntry": 423 }], 423: [function(t, e, r) {
      var n = t("./reader/readerFor"), i = t("./utils"), o = t("./compressedObject"), a = t("./crc32"), s = t("./utf8"), u = t("./compressions"), c = t("./support");
      function f(t2, e2) {
        this.options = t2, this.loadOptions = e2;
      }
      f.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(t2) {
        var e2, r2;
        if (t2.skip(22), this.fileNameLength = t2.readInt(2), r2 = t2.readInt(2), this.fileName = t2.readData(this.fileNameLength), t2.skip(r2), this.compressedSize === -1 || this.uncompressedSize === -1)
          throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((e2 = function(t3) {
          for (var e3 in u)
            if (u.hasOwnProperty(e3) && u[e3].magic === t3)
              return u[e3];
          return null;
        }(this.compressionMethod)) === null)
          throw new Error("Corrupted zip : compression " + i.pretty(this.compressionMethod) + " unknown (inner file : " + i.transformTo("string", this.fileName) + ")");
        this.decompressed = new o(this.compressedSize, this.uncompressedSize, this.crc32, e2, t2.readData(this.compressedSize));
      }, readCentralPart: function(t2) {
        this.versionMadeBy = t2.readInt(2), t2.skip(2), this.bitFlag = t2.readInt(2), this.compressionMethod = t2.readString(2), this.date = t2.readDate(), this.crc32 = t2.readInt(4), this.compressedSize = t2.readInt(4), this.uncompressedSize = t2.readInt(4);
        var e2 = t2.readInt(2);
        if (this.extraFieldsLength = t2.readInt(2), this.fileCommentLength = t2.readInt(2), this.diskNumberStart = t2.readInt(2), this.internalFileAttributes = t2.readInt(2), this.externalFileAttributes = t2.readInt(4), this.localHeaderOffset = t2.readInt(4), this.isEncrypted())
          throw new Error("Encrypted zip are not supported");
        t2.skip(e2), this.readExtraFields(t2), this.parseZIP64ExtraField(t2), this.fileComment = t2.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var t2 = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), t2 === 0 && (this.dosPermissions = 63 & this.externalFileAttributes), t2 === 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = true);
      }, parseZIP64ExtraField: function(t2) {
        if (this.extraFields[1]) {
          var e2 = n(this.extraFields[1].value);
          this.uncompressedSize === i.MAX_VALUE_32BITS && (this.uncompressedSize = e2.readInt(8)), this.compressedSize === i.MAX_VALUE_32BITS && (this.compressedSize = e2.readInt(8)), this.localHeaderOffset === i.MAX_VALUE_32BITS && (this.localHeaderOffset = e2.readInt(8)), this.diskNumberStart === i.MAX_VALUE_32BITS && (this.diskNumberStart = e2.readInt(4));
        }
      }, readExtraFields: function(t2) {
        var e2, r2, n2, i2 = t2.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); t2.index + 4 < i2; )
          e2 = t2.readInt(2), r2 = t2.readInt(2), n2 = t2.readData(r2), this.extraFields[e2] = { id: e2, length: r2, value: n2 };
        t2.setIndex(i2);
      }, handleUTF8: function() {
        var t2 = c.uint8array ? "uint8array" : "array";
        if (this.useUTF8())
          this.fileNameStr = s.utf8decode(this.fileName), this.fileCommentStr = s.utf8decode(this.fileComment);
        else {
          var e2 = this.findExtraFieldUnicodePath();
          if (e2 !== null)
            this.fileNameStr = e2;
          else {
            var r2 = i.transformTo(t2, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(r2);
          }
          var n2 = this.findExtraFieldUnicodeComment();
          if (n2 !== null)
            this.fileCommentStr = n2;
          else {
            var o2 = i.transformTo(t2, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(o2);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var t2 = this.extraFields[28789];
        if (t2) {
          var e2 = n(t2.value);
          return e2.readInt(1) !== 1 || a(this.fileName) !== e2.readInt(4) ? null : s.utf8decode(e2.readData(t2.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var t2 = this.extraFields[25461];
        if (t2) {
          var e2 = n(t2.value);
          return e2.readInt(1) !== 1 || a(this.fileComment) !== e2.readInt(4) ? null : s.utf8decode(e2.readData(t2.length - 5));
        }
        return null;
      } }, e.exports = f;
    }, { "./compressedObject": 391, "./compressions": 392, "./crc32": 393, "./reader/readerFor": 411, "./support": 419, "./utf8": 420, "./utils": 421 }], 424: [function(t, e, r) {
      var n = t("./stream/StreamHelper"), i = t("./stream/DataWorker"), o = t("./utf8"), a = t("./compressedObject"), s = t("./stream/GenericWorker"), u = function(t2, e2, r2) {
        this.name = t2, this.dir = r2.dir, this.date = r2.date, this.comment = r2.comment, this.unixPermissions = r2.unixPermissions, this.dosPermissions = r2.dosPermissions, this._data = e2, this._dataBinary = r2.binary, this.options = { compression: r2.compression, compressionOptions: r2.compressionOptions };
      };
      u.prototype = { internalStream: function(t2) {
        var e2 = null, r2 = "string";
        try {
          if (!t2)
            throw new Error("No output type specified.");
          var i2 = (r2 = t2.toLowerCase()) === "string" || r2 === "text";
          r2 !== "binarystring" && r2 !== "text" || (r2 = "string"), e2 = this._decompressWorker();
          var a2 = !this._dataBinary;
          a2 && !i2 && (e2 = e2.pipe(new o.Utf8EncodeWorker())), !a2 && i2 && (e2 = e2.pipe(new o.Utf8DecodeWorker()));
        } catch (t3) {
          (e2 = new s("error")).error(t3);
        }
        return new n(e2, r2, "");
      }, async: function(t2, e2) {
        return this.internalStream(t2).accumulate(e2);
      }, nodeStream: function(t2, e2) {
        return this.internalStream(t2 || "nodebuffer").toNodejsStream(e2);
      }, _compressWorker: function(t2, e2) {
        if (this._data instanceof a && this._data.compression.magic === t2.magic)
          return this._data.getCompressedWorker();
        var r2 = this._decompressWorker();
        return this._dataBinary || (r2 = r2.pipe(new o.Utf8EncodeWorker())), a.createWorkerFrom(r2, t2, e2);
      }, _decompressWorker: function() {
        return this._data instanceof a ? this._data.getContentWorker() : this._data instanceof s ? this._data : new i(this._data);
      } };
      for (var c = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], f = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, l = 0; l < c.length; l++)
        u.prototype[c[l]] = f;
      e.exports = u;
    }, { "./compressedObject": 391, "./stream/DataWorker": 416, "./stream/GenericWorker": 417, "./stream/StreamHelper": 418, "./utf8": 420 }], 425: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      var i = t("immediate");
      function o() {
      }
      var a = {}, s = ["REJECTED"], u = ["FULFILLED"], c = ["PENDING"];
      function f(t2) {
        if (typeof t2 != "function")
          throw new TypeError("resolver must be a function");
        this.state = c, this.queue = [], this.outcome = void 0, t2 !== o && p(this, t2);
      }
      function l(t2, e2, r2) {
        this.promise = t2, typeof e2 == "function" && (this.onFulfilled = e2, this.callFulfilled = this.otherCallFulfilled), typeof r2 == "function" && (this.onRejected = r2, this.callRejected = this.otherCallRejected);
      }
      function h(t2, e2, r2) {
        i(function() {
          var n2;
          try {
            n2 = e2(r2);
          } catch (e3) {
            return a.reject(t2, e3);
          }
          n2 === t2 ? a.reject(t2, new TypeError("Cannot resolve promise with itself")) : a.resolve(t2, n2);
        });
      }
      function d(t2) {
        var e2 = t2 && t2.then;
        if (t2 && (n(t2) === "object" || typeof t2 == "function") && typeof e2 == "function")
          return function() {
            e2.apply(t2, arguments);
          };
      }
      function p(t2, e2) {
        var r2 = false;
        function n2(e3) {
          r2 || (r2 = true, a.reject(t2, e3));
        }
        function i2(e3) {
          r2 || (r2 = true, a.resolve(t2, e3));
        }
        var o2 = m(function() {
          e2(i2, n2);
        });
        o2.status === "error" && n2(o2.value);
      }
      function m(t2, e2) {
        var r2 = {};
        try {
          r2.value = t2(e2), r2.status = "success";
        } catch (t3) {
          r2.status = "error", r2.value = t3;
        }
        return r2;
      }
      e.exports = f, f.prototype.finally = function(t2) {
        if (typeof t2 != "function")
          return this;
        var e2 = this.constructor;
        return this.then(function(r2) {
          return e2.resolve(t2()).then(function() {
            return r2;
          });
        }, function(r2) {
          return e2.resolve(t2()).then(function() {
            throw r2;
          });
        });
      }, f.prototype.catch = function(t2) {
        return this.then(null, t2);
      }, f.prototype.then = function(t2, e2) {
        if (typeof t2 != "function" && this.state === u || typeof e2 != "function" && this.state === s)
          return this;
        var r2 = new this.constructor(o);
        this.state !== c ? h(r2, this.state === u ? t2 : e2, this.outcome) : this.queue.push(new l(r2, t2, e2));
        return r2;
      }, l.prototype.callFulfilled = function(t2) {
        a.resolve(this.promise, t2);
      }, l.prototype.otherCallFulfilled = function(t2) {
        h(this.promise, this.onFulfilled, t2);
      }, l.prototype.callRejected = function(t2) {
        a.reject(this.promise, t2);
      }, l.prototype.otherCallRejected = function(t2) {
        h(this.promise, this.onRejected, t2);
      }, a.resolve = function(t2, e2) {
        var r2 = m(d, e2);
        if (r2.status === "error")
          return a.reject(t2, r2.value);
        var n2 = r2.value;
        if (n2)
          p(t2, n2);
        else {
          t2.state = u, t2.outcome = e2;
          for (var i2 = -1, o2 = t2.queue.length; ++i2 < o2; )
            t2.queue[i2].callFulfilled(e2);
        }
        return t2;
      }, a.reject = function(t2, e2) {
        t2.state = s, t2.outcome = e2;
        for (var r2 = -1, n2 = t2.queue.length; ++r2 < n2; )
          t2.queue[r2].callRejected(e2);
        return t2;
      }, f.resolve = function(t2) {
        if (t2 instanceof this)
          return t2;
        return a.resolve(new this(o), t2);
      }, f.reject = function(t2) {
        var e2 = new this(o);
        return a.reject(e2, t2);
      }, f.all = function(t2) {
        var e2 = this;
        if (Object.prototype.toString.call(t2) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var r2 = t2.length, n2 = false;
        if (!r2)
          return this.resolve([]);
        var i2 = new Array(r2), s2 = 0, u2 = -1, c2 = new this(o);
        for (; ++u2 < r2; )
          f2(t2[u2], u2);
        return c2;
        function f2(t3, o2) {
          e2.resolve(t3).then(function(t4) {
            i2[o2] = t4, ++s2 !== r2 || n2 || (n2 = true, a.resolve(c2, i2));
          }, function(t4) {
            n2 || (n2 = true, a.reject(c2, t4));
          });
        }
      }, f.race = function(t2) {
        var e2 = this;
        if (Object.prototype.toString.call(t2) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var r2 = t2.length, n2 = false;
        if (!r2)
          return this.resolve([]);
        var i2 = -1, s2 = new this(o);
        for (; ++i2 < r2; )
          u2 = t2[i2], e2.resolve(u2).then(function(t3) {
            n2 || (n2 = true, a.resolve(s2, t3));
          }, function(t3) {
            n2 || (n2 = true, a.reject(s2, t3));
          });
        var u2;
        return s2;
      };
    }, { immediate: 386 }], 426: [function(t, e, r) {
      (function(t2) {
        function r2(t3) {
          return (r2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && typeof Symbol == "function" && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        var n = /[\\^$.*+?()[\]{}|]/g, i = RegExp(n.source), o = (t2 === void 0 ? "undefined" : r2(t2)) == "object" && t2 && t2.Object === Object && t2, a = (typeof self == "undefined" ? "undefined" : r2(self)) == "object" && self && self.Object === Object && self, s = o || a || Function("return this")(), u = Object.prototype.toString, c = s.Symbol, f = c ? c.prototype : void 0, l = f ? f.toString : void 0;
        function h(t3) {
          if (typeof t3 == "string")
            return t3;
          if (function(t4) {
            return r2(t4) == "symbol" || function(t5) {
              return !!t5 && r2(t5) == "object";
            }(t4) && u.call(t4) == "[object Symbol]";
          }(t3))
            return l ? l.call(t3) : "";
          var e2 = t3 + "";
          return e2 == "0" && 1 / t3 == -1 / 0 ? "-0" : e2;
        }
        e.exports = function(t3) {
          var e2;
          return (t3 = (e2 = t3) == null ? "" : h(e2)) && i.test(t3) ? t3.replace(n, "\\$&") : t3;
        };
      }).call(this, typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, {}], 427: [function(t, e, r) {
      (function(t2) {
        function n(t3) {
          return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && typeof Symbol == "function" && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        var i = "[object Arguments]", o = "[object Map]", a = "[object Object]", s = "[object Set]", u = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, c = /^\w*$/, f = /^\./, l = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, h = /\\(\\)?/g, d = /^\[object .+?Constructor\]$/, p = /^(?:0|[1-9]\d*)$/, m = {};
        m["[object Float32Array]"] = m["[object Float64Array]"] = m["[object Int8Array]"] = m["[object Int16Array]"] = m["[object Int32Array]"] = m["[object Uint8Array]"] = m["[object Uint8ClampedArray]"] = m["[object Uint16Array]"] = m["[object Uint32Array]"] = true, m[i] = m["[object Array]"] = m["[object ArrayBuffer]"] = m["[object Boolean]"] = m["[object DataView]"] = m["[object Date]"] = m["[object Error]"] = m["[object Function]"] = m[o] = m["[object Number]"] = m[a] = m["[object RegExp]"] = m[s] = m["[object String]"] = m["[object WeakMap]"] = false;
        var y = (t2 === void 0 ? "undefined" : n(t2)) == "object" && t2 && t2.Object === Object && t2, b = (typeof self == "undefined" ? "undefined" : n(self)) == "object" && self && self.Object === Object && self, v = y || b || Function("return this")(), g = (r === void 0 ? "undefined" : n(r)) == "object" && r && !r.nodeType && r, w = g && (e === void 0 ? "undefined" : n(e)) == "object" && e && !e.nodeType && e, _ = w && w.exports === g && y.process, k = function() {
          try {
            return _ && _.binding("util");
          } catch (t3) {
          }
        }(), x = k && k.isTypedArray;
        function S(t3, e2, r2, n2) {
          for (var i2 = -1, o2 = t3 ? t3.length : 0; ++i2 < o2; ) {
            var a2 = t3[i2];
            e2(n2, a2, r2(a2), t3);
          }
          return n2;
        }
        function O(t3, e2) {
          for (var r2 = -1, n2 = t3 ? t3.length : 0; ++r2 < n2; )
            if (e2(t3[r2], r2, t3))
              return true;
          return false;
        }
        function j(t3) {
          var e2 = false;
          if (t3 != null && typeof t3.toString != "function")
            try {
              e2 = !!(t3 + "");
            } catch (t4) {
            }
          return e2;
        }
        function E(t3) {
          var e2 = -1, r2 = Array(t3.size);
          return t3.forEach(function(t4, n2) {
            r2[++e2] = [n2, t4];
          }), r2;
        }
        function R(t3) {
          var e2 = -1, r2 = Array(t3.size);
          return t3.forEach(function(t4) {
            r2[++e2] = t4;
          }), r2;
        }
        var T, C, P, M = Array.prototype, A = Function.prototype, I = Object.prototype, N = v["__core-js_shared__"], D = (T = /[^.]+$/.exec(N && N.keys && N.keys.IE_PROTO || "")) ? "Symbol(src)_1." + T : "", B = A.toString, F = I.hasOwnProperty, L = I.toString, z = RegExp("^" + B.call(F).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), U = v.Symbol, H = v.Uint8Array, V = I.propertyIsEnumerable, q = M.splice, W = (C = Object.keys, P = Object, function(t3) {
          return C(P(t3));
        }), $ = Et(v, "DataView"), X = Et(v, "Map"), K = Et(v, "Promise"), Z = Et(v, "Set"), Y = Et(v, "WeakMap"), G = Et(Object, "create"), J = Nt($), Q = Nt(X), tt = Nt(K), et = Nt(Z), rt = Nt(Y), nt = U ? U.prototype : void 0, it = nt ? nt.valueOf : void 0, ot = nt ? nt.toString : void 0;
        function at(t3) {
          var e2 = -1, r2 = t3 ? t3.length : 0;
          for (this.clear(); ++e2 < r2; ) {
            var n2 = t3[e2];
            this.set(n2[0], n2[1]);
          }
        }
        function st(t3) {
          var e2 = -1, r2 = t3 ? t3.length : 0;
          for (this.clear(); ++e2 < r2; ) {
            var n2 = t3[e2];
            this.set(n2[0], n2[1]);
          }
        }
        function ut(t3) {
          var e2 = -1, r2 = t3 ? t3.length : 0;
          for (this.clear(); ++e2 < r2; ) {
            var n2 = t3[e2];
            this.set(n2[0], n2[1]);
          }
        }
        function ct(t3) {
          var e2 = -1, r2 = t3 ? t3.length : 0;
          for (this.__data__ = new ut(); ++e2 < r2; )
            this.add(t3[e2]);
        }
        function ft(t3) {
          this.__data__ = new st(t3);
        }
        function lt(t3, e2) {
          var r2 = Ht(t3) || Ut(t3) ? function(t4, e3) {
            for (var r3 = -1, n3 = Array(t4); ++r3 < t4; )
              n3[r3] = e3(r3);
            return n3;
          }(t3.length, String) : [], n2 = r2.length, i2 = !!n2;
          for (var o2 in t3)
            !e2 && !F.call(t3, o2) || i2 && (o2 == "length" || Tt(o2, n2)) || r2.push(o2);
          return r2;
        }
        function ht(t3, e2) {
          for (var r2 = t3.length; r2--; )
            if (zt(t3[r2][0], e2))
              return r2;
          return -1;
        }
        function dt(t3, e2, r2, n2) {
          return yt(t3, function(t4, i2, o2) {
            e2(n2, t4, r2(t4), o2);
          }), n2;
        }
        at.prototype.clear = function() {
          this.__data__ = G ? G(null) : {};
        }, at.prototype.delete = function(t3) {
          return this.has(t3) && delete this.__data__[t3];
        }, at.prototype.get = function(t3) {
          var e2 = this.__data__;
          if (G) {
            var r2 = e2[t3];
            return r2 === "__lodash_hash_undefined__" ? void 0 : r2;
          }
          return F.call(e2, t3) ? e2[t3] : void 0;
        }, at.prototype.has = function(t3) {
          var e2 = this.__data__;
          return G ? e2[t3] !== void 0 : F.call(e2, t3);
        }, at.prototype.set = function(t3, e2) {
          return this.__data__[t3] = G && e2 === void 0 ? "__lodash_hash_undefined__" : e2, this;
        }, st.prototype.clear = function() {
          this.__data__ = [];
        }, st.prototype.delete = function(t3) {
          var e2 = this.__data__, r2 = ht(e2, t3);
          return !(r2 < 0) && (r2 == e2.length - 1 ? e2.pop() : q.call(e2, r2, 1), true);
        }, st.prototype.get = function(t3) {
          var e2 = this.__data__, r2 = ht(e2, t3);
          return r2 < 0 ? void 0 : e2[r2][1];
        }, st.prototype.has = function(t3) {
          return ht(this.__data__, t3) > -1;
        }, st.prototype.set = function(t3, e2) {
          var r2 = this.__data__, n2 = ht(r2, t3);
          return n2 < 0 ? r2.push([t3, e2]) : r2[n2][1] = e2, this;
        }, ut.prototype.clear = function() {
          this.__data__ = { hash: new at(), map: new (X || st)(), string: new at() };
        }, ut.prototype.delete = function(t3) {
          return jt(this, t3).delete(t3);
        }, ut.prototype.get = function(t3) {
          return jt(this, t3).get(t3);
        }, ut.prototype.has = function(t3) {
          return jt(this, t3).has(t3);
        }, ut.prototype.set = function(t3, e2) {
          return jt(this, t3).set(t3, e2), this;
        }, ct.prototype.add = ct.prototype.push = function(t3) {
          return this.__data__.set(t3, "__lodash_hash_undefined__"), this;
        }, ct.prototype.has = function(t3) {
          return this.__data__.has(t3);
        }, ft.prototype.clear = function() {
          this.__data__ = new st();
        }, ft.prototype.delete = function(t3) {
          return this.__data__.delete(t3);
        }, ft.prototype.get = function(t3) {
          return this.__data__.get(t3);
        }, ft.prototype.has = function(t3) {
          return this.__data__.has(t3);
        }, ft.prototype.set = function(t3, e2) {
          var r2 = this.__data__;
          if (r2 instanceof st) {
            var n2 = r2.__data__;
            if (!X || n2.length < 199)
              return n2.push([t3, e2]), this;
            r2 = this.__data__ = new ut(n2);
          }
          return r2.set(t3, e2), this;
        };
        var pt, yt = (pt = function(t3, e2) {
          return t3 && bt(t3, e2, Yt);
        }, function(t3, e2) {
          if (t3 == null)
            return t3;
          if (!Vt(t3))
            return pt(t3, e2);
          for (var r2 = t3.length, n2 = -1, i2 = Object(t3); (++n2 < r2) && e2(i2[n2], n2, i2) !== false; )
            ;
          return t3;
        }), bt = function(t3) {
          return function(e2, r2, n2) {
            for (var i2 = -1, o2 = Object(e2), a2 = n2(e2), s2 = a2.length; s2--; ) {
              var u2 = a2[t3 ? s2 : ++i2];
              if (r2(o2[u2], u2, o2) === false)
                break;
            }
            return e2;
          };
        }();
        function vt(t3, e2) {
          for (var r2 = 0, n2 = (e2 = Ct(e2, t3) ? [e2] : St(e2)).length; t3 != null && r2 < n2; )
            t3 = t3[It(e2[r2++])];
          return r2 && r2 == n2 ? t3 : void 0;
        }
        function gt(t3, e2) {
          return t3 != null && e2 in Object(t3);
        }
        function wt(t3, e2, r2, n2, u2) {
          return t3 === e2 || (t3 == null || e2 == null || !$t(t3) && !Xt(e2) ? t3 != t3 && e2 != e2 : function(t4, e3, r3, n3, u3, c2) {
            var f2 = Ht(t4), l2 = Ht(e3), h2 = "[object Array]", d2 = "[object Array]";
            f2 || (h2 = (h2 = Rt(t4)) == i ? a : h2);
            l2 || (d2 = (d2 = Rt(e3)) == i ? a : d2);
            var p2 = h2 == a && !j(t4), m2 = d2 == a && !j(e3), y2 = h2 == d2;
            if (y2 && !p2)
              return c2 || (c2 = new ft()), f2 || Zt(t4) ? Ot(t4, e3, r3, n3, u3, c2) : function(t5, e4, r4, n4, i2, a2, u4) {
                switch (r4) {
                  case "[object DataView]":
                    if (t5.byteLength != e4.byteLength || t5.byteOffset != e4.byteOffset)
                      return false;
                    t5 = t5.buffer, e4 = e4.buffer;
                  case "[object ArrayBuffer]":
                    return !(t5.byteLength != e4.byteLength || !n4(new H(t5), new H(e4)));
                  case "[object Boolean]":
                  case "[object Date]":
                  case "[object Number]":
                    return zt(+t5, +e4);
                  case "[object Error]":
                    return t5.name == e4.name && t5.message == e4.message;
                  case "[object RegExp]":
                  case "[object String]":
                    return t5 == e4 + "";
                  case o:
                    var c3 = E;
                  case s:
                    var f3 = 2 & a2;
                    if (c3 || (c3 = R), t5.size != e4.size && !f3)
                      return false;
                    var l3 = u4.get(t5);
                    if (l3)
                      return l3 == e4;
                    a2 |= 1, u4.set(t5, e4);
                    var h3 = Ot(c3(t5), c3(e4), n4, i2, a2, u4);
                    return u4.delete(t5), h3;
                  case "[object Symbol]":
                    if (it)
                      return it.call(t5) == it.call(e4);
                }
                return false;
              }(t4, e3, h2, r3, n3, u3, c2);
            if (!(2 & u3)) {
              var b2 = p2 && F.call(t4, "__wrapped__"), v2 = m2 && F.call(e3, "__wrapped__");
              if (b2 || v2) {
                var g2 = b2 ? t4.value() : t4, w2 = v2 ? e3.value() : e3;
                return c2 || (c2 = new ft()), r3(g2, w2, n3, u3, c2);
              }
            }
            if (!y2)
              return false;
            return c2 || (c2 = new ft()), function(t5, e4, r4, n4, i2, o2) {
              var a2 = 2 & i2, s2 = Yt(t5), u4 = s2.length, c3 = Yt(e4).length;
              if (u4 != c3 && !a2)
                return false;
              var f3 = u4;
              for (; f3--; ) {
                var l3 = s2[f3];
                if (!(a2 ? l3 in e4 : F.call(e4, l3)))
                  return false;
              }
              var h3 = o2.get(t5);
              if (h3 && o2.get(e4))
                return h3 == e4;
              var d3 = true;
              o2.set(t5, e4), o2.set(e4, t5);
              var p3 = a2;
              for (; ++f3 < u4; ) {
                l3 = s2[f3];
                var m3 = t5[l3], y3 = e4[l3];
                if (n4)
                  var b3 = a2 ? n4(y3, m3, l3, e4, t5, o2) : n4(m3, y3, l3, t5, e4, o2);
                if (!(b3 === void 0 ? m3 === y3 || r4(m3, y3, n4, i2, o2) : b3)) {
                  d3 = false;
                  break;
                }
                p3 || (p3 = l3 == "constructor");
              }
              if (d3 && !p3) {
                var v3 = t5.constructor, g3 = e4.constructor;
                v3 == g3 || !("constructor" in t5) || !("constructor" in e4) || typeof v3 == "function" && v3 instanceof v3 && typeof g3 == "function" && g3 instanceof g3 || (d3 = false);
              }
              return o2.delete(t5), o2.delete(e4), d3;
            }(t4, e3, r3, n3, u3, c2);
          }(t3, e2, wt, r2, n2, u2));
        }
        function _t(t3) {
          return !(!$t(t3) || function(t4) {
            return !!D && D in t4;
          }(t3)) && (qt(t3) || j(t3) ? z : d).test(Nt(t3));
        }
        function kt(t3) {
          return typeof t3 == "function" ? t3 : t3 == null ? Gt : n(t3) == "object" ? Ht(t3) ? function(t4, e3) {
            if (Ct(t4) && Pt(e3))
              return Mt(It(t4), e3);
            return function(r3) {
              var n2 = function(t5, e4, r4) {
                var n3 = t5 == null ? void 0 : vt(t5, e4);
                return n3 === void 0 ? r4 : n3;
              }(r3, t4);
              return n2 === void 0 && n2 === e3 ? function(t5, e4) {
                return t5 != null && function(t6, e5, r4) {
                  e5 = Ct(e5, t6) ? [e5] : St(e5);
                  var n3, i2 = -1, o2 = e5.length;
                  for (; ++i2 < o2; ) {
                    var a2 = It(e5[i2]);
                    if (!(n3 = t6 != null && r4(t6, a2)))
                      break;
                    t6 = t6[a2];
                  }
                  if (n3)
                    return n3;
                  return !!(o2 = t6 ? t6.length : 0) && Wt(o2) && Tt(a2, o2) && (Ht(t6) || Ut(t6));
                }(t5, e4, gt);
              }(r3, t4) : wt(e3, n2, void 0, 3);
            };
          }(t3[0], t3[1]) : function(t4) {
            var e3 = function(t5) {
              var e4 = Yt(t5), r3 = e4.length;
              for (; r3--; ) {
                var n2 = e4[r3], i2 = t5[n2];
                e4[r3] = [n2, i2, Pt(i2)];
              }
              return e4;
            }(t4);
            if (e3.length == 1 && e3[0][2])
              return Mt(e3[0][0], e3[0][1]);
            return function(r3) {
              return r3 === t4 || function(t5, e4, r4, n2) {
                var i2 = r4.length, o2 = i2, a2 = !n2;
                if (t5 == null)
                  return !o2;
                for (t5 = Object(t5); i2--; ) {
                  var s2 = r4[i2];
                  if (a2 && s2[2] ? s2[1] !== t5[s2[0]] : !(s2[0] in t5))
                    return false;
                }
                for (; ++i2 < o2; ) {
                  var u2 = (s2 = r4[i2])[0], c2 = t5[u2], f2 = s2[1];
                  if (a2 && s2[2]) {
                    if (c2 === void 0 && !(u2 in t5))
                      return false;
                  } else {
                    var l2 = new ft();
                    if (n2)
                      var h2 = n2(c2, f2, u2, t5, e4, l2);
                    if (!(h2 === void 0 ? wt(f2, c2, n2, 3, l2) : h2))
                      return false;
                  }
                }
                return true;
              }(r3, t4, e3);
            };
          }(t3) : Ct(e2 = t3) ? (r2 = It(e2), function(t4) {
            return t4 == null ? void 0 : t4[r2];
          }) : function(t4) {
            return function(e3) {
              return vt(e3, t4);
            };
          }(e2);
          var e2, r2;
        }
        function xt(t3) {
          if (r2 = (e2 = t3) && e2.constructor, n2 = typeof r2 == "function" && r2.prototype || I, e2 !== n2)
            return W(t3);
          var e2, r2, n2, i2 = [];
          for (var o2 in Object(t3))
            F.call(t3, o2) && o2 != "constructor" && i2.push(o2);
          return i2;
        }
        function St(t3) {
          return Ht(t3) ? t3 : At(t3);
        }
        function Ot(t3, e2, r2, n2, i2, o2) {
          var a2 = 2 & i2, s2 = t3.length, u2 = e2.length;
          if (s2 != u2 && !(a2 && u2 > s2))
            return false;
          var c2 = o2.get(t3);
          if (c2 && o2.get(e2))
            return c2 == e2;
          var f2 = -1, l2 = true, h2 = 1 & i2 ? new ct() : void 0;
          for (o2.set(t3, e2), o2.set(e2, t3); ++f2 < s2; ) {
            var d2 = t3[f2], p2 = e2[f2];
            if (n2)
              var m2 = a2 ? n2(p2, d2, f2, e2, t3, o2) : n2(d2, p2, f2, t3, e2, o2);
            if (m2 !== void 0) {
              if (m2)
                continue;
              l2 = false;
              break;
            }
            if (h2) {
              if (!O(e2, function(t4, e3) {
                if (!h2.has(e3) && (d2 === t4 || r2(d2, t4, n2, i2, o2)))
                  return h2.add(e3);
              })) {
                l2 = false;
                break;
              }
            } else if (d2 !== p2 && !r2(d2, p2, n2, i2, o2)) {
              l2 = false;
              break;
            }
          }
          return o2.delete(t3), o2.delete(e2), l2;
        }
        function jt(t3, e2) {
          var r2, i2, o2 = t3.__data__;
          return ((i2 = n(r2 = e2)) == "string" || i2 == "number" || i2 == "symbol" || i2 == "boolean" ? r2 !== "__proto__" : r2 === null) ? o2[typeof e2 == "string" ? "string" : "hash"] : o2.map;
        }
        function Et(t3, e2) {
          var r2 = function(t4, e3) {
            return t4 == null ? void 0 : t4[e3];
          }(t3, e2);
          return _t(r2) ? r2 : void 0;
        }
        var Rt = function(t3) {
          return L.call(t3);
        };
        function Tt(t3, e2) {
          return !!(e2 = e2 == null ? 9007199254740991 : e2) && (typeof t3 == "number" || p.test(t3)) && t3 > -1 && t3 % 1 == 0 && t3 < e2;
        }
        function Ct(t3, e2) {
          if (Ht(t3))
            return false;
          var r2 = n(t3);
          return !(r2 != "number" && r2 != "symbol" && r2 != "boolean" && t3 != null && !Kt(t3)) || (c.test(t3) || !u.test(t3) || e2 != null && t3 in Object(e2));
        }
        function Pt(t3) {
          return t3 == t3 && !$t(t3);
        }
        function Mt(t3, e2) {
          return function(r2) {
            return r2 != null && (r2[t3] === e2 && (e2 !== void 0 || t3 in Object(r2)));
          };
        }
        ($ && Rt(new $(new ArrayBuffer(1))) != "[object DataView]" || X && Rt(new X()) != o || K && Rt(K.resolve()) != "[object Promise]" || Z && Rt(new Z()) != s || Y && Rt(new Y()) != "[object WeakMap]") && (Rt = function(t3) {
          var e2 = L.call(t3), r2 = e2 == a ? t3.constructor : void 0, n2 = r2 ? Nt(r2) : void 0;
          if (n2)
            switch (n2) {
              case J:
                return "[object DataView]";
              case Q:
                return o;
              case tt:
                return "[object Promise]";
              case et:
                return s;
              case rt:
                return "[object WeakMap]";
            }
          return e2;
        });
        var At = Lt(function(t3) {
          var e2;
          t3 = (e2 = t3) == null ? "" : function(t4) {
            if (typeof t4 == "string")
              return t4;
            if (Kt(t4))
              return ot ? ot.call(t4) : "";
            var e3 = t4 + "";
            return e3 == "0" && 1 / t4 == -1 / 0 ? "-0" : e3;
          }(e2);
          var r2 = [];
          return f.test(t3) && r2.push(""), t3.replace(l, function(t4, e3, n2, i2) {
            r2.push(n2 ? i2.replace(h, "$1") : e3 || t4);
          }), r2;
        });
        function It(t3) {
          if (typeof t3 == "string" || Kt(t3))
            return t3;
          var e2 = t3 + "";
          return e2 == "0" && 1 / t3 == -1 / 0 ? "-0" : e2;
        }
        function Nt(t3) {
          if (t3 != null) {
            try {
              return B.call(t3);
            } catch (t4) {
            }
            try {
              return t3 + "";
            } catch (t4) {
            }
          }
          return "";
        }
        var Dt, Ft = (Dt = function(t3, e2, r2) {
          F.call(t3, r2) ? t3[r2].push(e2) : t3[r2] = [e2];
        }, function(t3, e2) {
          var r2 = Ht(t3) ? S : dt, n2 = {};
          return r2(t3, Dt, kt(e2), n2);
        });
        function Lt(t3, e2) {
          if (typeof t3 != "function" || e2 && typeof e2 != "function")
            throw new TypeError("Expected a function");
          var r2 = function r3() {
            var n2 = arguments, i2 = e2 ? e2.apply(this, n2) : n2[0], o2 = r3.cache;
            if (o2.has(i2))
              return o2.get(i2);
            var a2 = t3.apply(this, n2);
            return r3.cache = o2.set(i2, a2), a2;
          };
          return r2.cache = new (Lt.Cache || ut)(), r2;
        }
        function zt(t3, e2) {
          return t3 === e2 || t3 != t3 && e2 != e2;
        }
        function Ut(t3) {
          return function(t4) {
            return Xt(t4) && Vt(t4);
          }(t3) && F.call(t3, "callee") && (!V.call(t3, "callee") || L.call(t3) == i);
        }
        Lt.Cache = ut;
        var Ht = Array.isArray;
        function Vt(t3) {
          return t3 != null && Wt(t3.length) && !qt(t3);
        }
        function qt(t3) {
          var e2 = $t(t3) ? L.call(t3) : "";
          return e2 == "[object Function]" || e2 == "[object GeneratorFunction]";
        }
        function Wt(t3) {
          return typeof t3 == "number" && t3 > -1 && t3 % 1 == 0 && t3 <= 9007199254740991;
        }
        function $t(t3) {
          var e2 = n(t3);
          return !!t3 && (e2 == "object" || e2 == "function");
        }
        function Xt(t3) {
          return !!t3 && n(t3) == "object";
        }
        function Kt(t3) {
          return n(t3) == "symbol" || Xt(t3) && L.call(t3) == "[object Symbol]";
        }
        var Zt = x ? function(t3) {
          return function(e2) {
            return t3(e2);
          };
        }(x) : function(t3) {
          return Xt(t3) && Wt(t3.length) && !!m[L.call(t3)];
        };
        function Yt(t3) {
          return Vt(t3) ? lt(t3) : xt(t3);
        }
        function Gt(t3) {
          return t3;
        }
        e.exports = Ft;
      }).call(this, typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, {}], 428: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      var i = Object.prototype.toString;
      e.exports = function(t2) {
        return t2 === true || t2 === false || function(t3) {
          return !!t3 && n(t3) == "object";
        }(t2) && i.call(t2) == "[object Boolean]";
      };
    }, {}], 429: [function(t, e, r) {
      (function(t2) {
        function n(t3) {
          return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && typeof Symbol == "function" && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        var i = "[object Arguments]", o = "[object Map]", a = "[object Object]", s = "[object Set]", u = /^\[object .+?Constructor\]$/, c = /^(?:0|[1-9]\d*)$/, f = {};
        f["[object Float32Array]"] = f["[object Float64Array]"] = f["[object Int8Array]"] = f["[object Int16Array]"] = f["[object Int32Array]"] = f["[object Uint8Array]"] = f["[object Uint8ClampedArray]"] = f["[object Uint16Array]"] = f["[object Uint32Array]"] = true, f[i] = f["[object Array]"] = f["[object ArrayBuffer]"] = f["[object Boolean]"] = f["[object DataView]"] = f["[object Date]"] = f["[object Error]"] = f["[object Function]"] = f[o] = f["[object Number]"] = f[a] = f["[object RegExp]"] = f[s] = f["[object String]"] = f["[object WeakMap]"] = false;
        var l = (t2 === void 0 ? "undefined" : n(t2)) == "object" && t2 && t2.Object === Object && t2, h = (typeof self == "undefined" ? "undefined" : n(self)) == "object" && self && self.Object === Object && self, d = l || h || Function("return this")(), p = (r === void 0 ? "undefined" : n(r)) == "object" && r && !r.nodeType && r, m = p && (e === void 0 ? "undefined" : n(e)) == "object" && e && !e.nodeType && e, y = m && m.exports === p, b = y && l.process, v = function() {
          try {
            return b && b.binding && b.binding("util");
          } catch (t3) {
          }
        }(), g = v && v.isTypedArray;
        function w(t3, e2) {
          for (var r2 = -1, n2 = t3 == null ? 0 : t3.length; ++r2 < n2; )
            if (e2(t3[r2], r2, t3))
              return true;
          return false;
        }
        function _(t3) {
          var e2 = -1, r2 = Array(t3.size);
          return t3.forEach(function(t4, n2) {
            r2[++e2] = [n2, t4];
          }), r2;
        }
        function k(t3) {
          var e2 = -1, r2 = Array(t3.size);
          return t3.forEach(function(t4) {
            r2[++e2] = t4;
          }), r2;
        }
        var x, S, O, j = Array.prototype, E = Function.prototype, R = Object.prototype, T = d["__core-js_shared__"], C = E.toString, P = R.hasOwnProperty, M = (x = /[^.]+$/.exec(T && T.keys && T.keys.IE_PROTO || "")) ? "Symbol(src)_1." + x : "", A = R.toString, I = RegExp("^" + C.call(P).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), N = y ? d.Buffer : void 0, D = d.Symbol, B = d.Uint8Array, F = R.propertyIsEnumerable, L = j.splice, z = D ? D.toStringTag : void 0, U = Object.getOwnPropertySymbols, H = N ? N.isBuffer : void 0, V = (S = Object.keys, O = Object, function(t3) {
          return S(O(t3));
        }), q = vt(d, "DataView"), W = vt(d, "Map"), $ = vt(d, "Promise"), X = vt(d, "Set"), K = vt(d, "WeakMap"), Z = vt(Object, "create"), Y = kt(q), G = kt(W), J = kt($), Q = kt(X), tt = kt(K), et = D ? D.prototype : void 0, rt = et ? et.valueOf : void 0;
        function nt(t3) {
          var e2 = -1, r2 = t3 == null ? 0 : t3.length;
          for (this.clear(); ++e2 < r2; ) {
            var n2 = t3[e2];
            this.set(n2[0], n2[1]);
          }
        }
        function it(t3) {
          var e2 = -1, r2 = t3 == null ? 0 : t3.length;
          for (this.clear(); ++e2 < r2; ) {
            var n2 = t3[e2];
            this.set(n2[0], n2[1]);
          }
        }
        function ot(t3) {
          var e2 = -1, r2 = t3 == null ? 0 : t3.length;
          for (this.clear(); ++e2 < r2; ) {
            var n2 = t3[e2];
            this.set(n2[0], n2[1]);
          }
        }
        function at(t3) {
          var e2 = -1, r2 = t3 == null ? 0 : t3.length;
          for (this.__data__ = new ot(); ++e2 < r2; )
            this.add(t3[e2]);
        }
        function st(t3) {
          var e2 = this.__data__ = new it(t3);
          this.size = e2.size;
        }
        function ut(t3, e2) {
          var r2 = Ot(t3), n2 = !r2 && St(t3), i2 = !r2 && !n2 && jt(t3), o2 = !r2 && !n2 && !i2 && Pt(t3), a2 = r2 || n2 || i2 || o2, s2 = a2 ? function(t4, e3) {
            for (var r3 = -1, n3 = Array(t4); ++r3 < t4; )
              n3[r3] = e3(r3);
            return n3;
          }(t3.length, String) : [], u2 = s2.length;
          for (var c2 in t3)
            !e2 && !P.call(t3, c2) || a2 && (c2 == "length" || i2 && (c2 == "offset" || c2 == "parent") || o2 && (c2 == "buffer" || c2 == "byteLength" || c2 == "byteOffset") || _t(c2, u2)) || s2.push(c2);
          return s2;
        }
        function ct(t3, e2) {
          for (var r2 = t3.length; r2--; )
            if (xt(t3[r2][0], e2))
              return r2;
          return -1;
        }
        function ft(t3) {
          return t3 == null ? t3 === void 0 ? "[object Undefined]" : "[object Null]" : z && z in Object(t3) ? function(t4) {
            var e2 = P.call(t4, z), r2 = t4[z];
            try {
              t4[z] = void 0;
              var n2 = true;
            } catch (t5) {
            }
            var i2 = A.call(t4);
            n2 && (e2 ? t4[z] = r2 : delete t4[z]);
            return i2;
          }(t3) : function(t4) {
            return A.call(t4);
          }(t3);
        }
        function lt(t3) {
          return Ct(t3) && ft(t3) == i;
        }
        function ht(t3, e2, r2, n2, u2) {
          return t3 === e2 || (t3 == null || e2 == null || !Ct(t3) && !Ct(e2) ? t3 != t3 && e2 != e2 : function(t4, e3, r3, n3, u3, c2) {
            var f2 = Ot(t4), l2 = Ot(e3), h2 = f2 ? "[object Array]" : wt(t4), d2 = l2 ? "[object Array]" : wt(e3), p2 = (h2 = h2 == i ? a : h2) == a, m2 = (d2 = d2 == i ? a : d2) == a, y2 = h2 == d2;
            if (y2 && jt(t4)) {
              if (!jt(e3))
                return false;
              f2 = true, p2 = false;
            }
            if (y2 && !p2)
              return c2 || (c2 = new st()), f2 || Pt(t4) ? mt(t4, e3, r3, n3, u3, c2) : function(t5, e4, r4, n4, i2, a2, u4) {
                switch (r4) {
                  case "[object DataView]":
                    if (t5.byteLength != e4.byteLength || t5.byteOffset != e4.byteOffset)
                      return false;
                    t5 = t5.buffer, e4 = e4.buffer;
                  case "[object ArrayBuffer]":
                    return !(t5.byteLength != e4.byteLength || !a2(new B(t5), new B(e4)));
                  case "[object Boolean]":
                  case "[object Date]":
                  case "[object Number]":
                    return xt(+t5, +e4);
                  case "[object Error]":
                    return t5.name == e4.name && t5.message == e4.message;
                  case "[object RegExp]":
                  case "[object String]":
                    return t5 == e4 + "";
                  case o:
                    var c3 = _;
                  case s:
                    var f3 = 1 & n4;
                    if (c3 || (c3 = k), t5.size != e4.size && !f3)
                      return false;
                    var l3 = u4.get(t5);
                    if (l3)
                      return l3 == e4;
                    n4 |= 2, u4.set(t5, e4);
                    var h3 = mt(c3(t5), c3(e4), n4, i2, a2, u4);
                    return u4.delete(t5), h3;
                  case "[object Symbol]":
                    if (rt)
                      return rt.call(t5) == rt.call(e4);
                }
                return false;
              }(t4, e3, h2, r3, n3, u3, c2);
            if (!(1 & r3)) {
              var b2 = p2 && P.call(t4, "__wrapped__"), v2 = m2 && P.call(e3, "__wrapped__");
              if (b2 || v2) {
                var g2 = b2 ? t4.value() : t4, w2 = v2 ? e3.value() : e3;
                return c2 || (c2 = new st()), u3(g2, w2, r3, n3, c2);
              }
            }
            if (!y2)
              return false;
            return c2 || (c2 = new st()), function(t5, e4, r4, n4, i2, o2) {
              var a2 = 1 & r4, s2 = yt(t5), u4 = s2.length, c3 = yt(e4).length;
              if (u4 != c3 && !a2)
                return false;
              var f3 = u4;
              for (; f3--; ) {
                var l3 = s2[f3];
                if (!(a2 ? l3 in e4 : P.call(e4, l3)))
                  return false;
              }
              var h3 = o2.get(t5);
              if (h3 && o2.get(e4))
                return h3 == e4;
              var d3 = true;
              o2.set(t5, e4), o2.set(e4, t5);
              var p3 = a2;
              for (; ++f3 < u4; ) {
                l3 = s2[f3];
                var m3 = t5[l3], y3 = e4[l3];
                if (n4)
                  var b3 = a2 ? n4(y3, m3, l3, e4, t5, o2) : n4(m3, y3, l3, t5, e4, o2);
                if (!(b3 === void 0 ? m3 === y3 || i2(m3, y3, r4, n4, o2) : b3)) {
                  d3 = false;
                  break;
                }
                p3 || (p3 = l3 == "constructor");
              }
              if (d3 && !p3) {
                var v3 = t5.constructor, g3 = e4.constructor;
                v3 == g3 || !("constructor" in t5) || !("constructor" in e4) || typeof v3 == "function" && v3 instanceof v3 && typeof g3 == "function" && g3 instanceof g3 || (d3 = false);
              }
              return o2.delete(t5), o2.delete(e4), d3;
            }(t4, e3, r3, n3, u3, c2);
          }(t3, e2, r2, n2, ht, u2));
        }
        function dt(t3) {
          return !(!Tt(t3) || function(t4) {
            return !!M && M in t4;
          }(t3)) && (Et(t3) ? I : u).test(kt(t3));
        }
        function pt(t3) {
          if (r2 = (e2 = t3) && e2.constructor, n2 = typeof r2 == "function" && r2.prototype || R, e2 !== n2)
            return V(t3);
          var e2, r2, n2, i2 = [];
          for (var o2 in Object(t3))
            P.call(t3, o2) && o2 != "constructor" && i2.push(o2);
          return i2;
        }
        function mt(t3, e2, r2, n2, i2, o2) {
          var a2 = 1 & r2, s2 = t3.length, u2 = e2.length;
          if (s2 != u2 && !(a2 && u2 > s2))
            return false;
          var c2 = o2.get(t3);
          if (c2 && o2.get(e2))
            return c2 == e2;
          var f2 = -1, l2 = true, h2 = 2 & r2 ? new at() : void 0;
          for (o2.set(t3, e2), o2.set(e2, t3); ++f2 < s2; ) {
            var d2 = t3[f2], p2 = e2[f2];
            if (n2)
              var m2 = a2 ? n2(p2, d2, f2, e2, t3, o2) : n2(d2, p2, f2, t3, e2, o2);
            if (m2 !== void 0) {
              if (m2)
                continue;
              l2 = false;
              break;
            }
            if (h2) {
              if (!w(e2, function(t4, e3) {
                if (a3 = e3, !h2.has(a3) && (d2 === t4 || i2(d2, t4, r2, n2, o2)))
                  return h2.push(e3);
                var a3;
              })) {
                l2 = false;
                break;
              }
            } else if (d2 !== p2 && !i2(d2, p2, r2, n2, o2)) {
              l2 = false;
              break;
            }
          }
          return o2.delete(t3), o2.delete(e2), l2;
        }
        function yt(t3) {
          return function(t4, e2, r2) {
            var n2 = e2(t4);
            return Ot(t4) ? n2 : function(t5, e3) {
              for (var r3 = -1, n3 = e3.length, i2 = t5.length; ++r3 < n3; )
                t5[i2 + r3] = e3[r3];
              return t5;
            }(n2, r2(t4));
          }(t3, Mt, gt);
        }
        function bt(t3, e2) {
          var r2, i2, o2 = t3.__data__;
          return ((i2 = n(r2 = e2)) == "string" || i2 == "number" || i2 == "symbol" || i2 == "boolean" ? r2 !== "__proto__" : r2 === null) ? o2[typeof e2 == "string" ? "string" : "hash"] : o2.map;
        }
        function vt(t3, e2) {
          var r2 = function(t4, e3) {
            return t4 == null ? void 0 : t4[e3];
          }(t3, e2);
          return dt(r2) ? r2 : void 0;
        }
        nt.prototype.clear = function() {
          this.__data__ = Z ? Z(null) : {}, this.size = 0;
        }, nt.prototype.delete = function(t3) {
          var e2 = this.has(t3) && delete this.__data__[t3];
          return this.size -= e2 ? 1 : 0, e2;
        }, nt.prototype.get = function(t3) {
          var e2 = this.__data__;
          if (Z) {
            var r2 = e2[t3];
            return r2 === "__lodash_hash_undefined__" ? void 0 : r2;
          }
          return P.call(e2, t3) ? e2[t3] : void 0;
        }, nt.prototype.has = function(t3) {
          var e2 = this.__data__;
          return Z ? e2[t3] !== void 0 : P.call(e2, t3);
        }, nt.prototype.set = function(t3, e2) {
          var r2 = this.__data__;
          return this.size += this.has(t3) ? 0 : 1, r2[t3] = Z && e2 === void 0 ? "__lodash_hash_undefined__" : e2, this;
        }, it.prototype.clear = function() {
          this.__data__ = [], this.size = 0;
        }, it.prototype.delete = function(t3) {
          var e2 = this.__data__, r2 = ct(e2, t3);
          return !(r2 < 0) && (r2 == e2.length - 1 ? e2.pop() : L.call(e2, r2, 1), --this.size, true);
        }, it.prototype.get = function(t3) {
          var e2 = this.__data__, r2 = ct(e2, t3);
          return r2 < 0 ? void 0 : e2[r2][1];
        }, it.prototype.has = function(t3) {
          return ct(this.__data__, t3) > -1;
        }, it.prototype.set = function(t3, e2) {
          var r2 = this.__data__, n2 = ct(r2, t3);
          return n2 < 0 ? (++this.size, r2.push([t3, e2])) : r2[n2][1] = e2, this;
        }, ot.prototype.clear = function() {
          this.size = 0, this.__data__ = { hash: new nt(), map: new (W || it)(), string: new nt() };
        }, ot.prototype.delete = function(t3) {
          var e2 = bt(this, t3).delete(t3);
          return this.size -= e2 ? 1 : 0, e2;
        }, ot.prototype.get = function(t3) {
          return bt(this, t3).get(t3);
        }, ot.prototype.has = function(t3) {
          return bt(this, t3).has(t3);
        }, ot.prototype.set = function(t3, e2) {
          var r2 = bt(this, t3), n2 = r2.size;
          return r2.set(t3, e2), this.size += r2.size == n2 ? 0 : 1, this;
        }, at.prototype.add = at.prototype.push = function(t3) {
          return this.__data__.set(t3, "__lodash_hash_undefined__"), this;
        }, at.prototype.has = function(t3) {
          return this.__data__.has(t3);
        }, st.prototype.clear = function() {
          this.__data__ = new it(), this.size = 0;
        }, st.prototype.delete = function(t3) {
          var e2 = this.__data__, r2 = e2.delete(t3);
          return this.size = e2.size, r2;
        }, st.prototype.get = function(t3) {
          return this.__data__.get(t3);
        }, st.prototype.has = function(t3) {
          return this.__data__.has(t3);
        }, st.prototype.set = function(t3, e2) {
          var r2 = this.__data__;
          if (r2 instanceof it) {
            var n2 = r2.__data__;
            if (!W || n2.length < 199)
              return n2.push([t3, e2]), this.size = ++r2.size, this;
            r2 = this.__data__ = new ot(n2);
          }
          return r2.set(t3, e2), this.size = r2.size, this;
        };
        var gt = U ? function(t3) {
          return t3 == null ? [] : (t3 = Object(t3), function(t4, e2) {
            for (var r2 = -1, n2 = t4 == null ? 0 : t4.length, i2 = 0, o2 = []; ++r2 < n2; ) {
              var a2 = t4[r2];
              e2(a2, r2, t4) && (o2[i2++] = a2);
            }
            return o2;
          }(U(t3), function(e2) {
            return F.call(t3, e2);
          }));
        } : function() {
          return [];
        }, wt = ft;
        function _t(t3, e2) {
          return !!(e2 = e2 == null ? 9007199254740991 : e2) && (typeof t3 == "number" || c.test(t3)) && t3 > -1 && t3 % 1 == 0 && t3 < e2;
        }
        function kt(t3) {
          if (t3 != null) {
            try {
              return C.call(t3);
            } catch (t4) {
            }
            try {
              return t3 + "";
            } catch (t4) {
            }
          }
          return "";
        }
        function xt(t3, e2) {
          return t3 === e2 || t3 != t3 && e2 != e2;
        }
        (q && wt(new q(new ArrayBuffer(1))) != "[object DataView]" || W && wt(new W()) != o || $ && wt($.resolve()) != "[object Promise]" || X && wt(new X()) != s || K && wt(new K()) != "[object WeakMap]") && (wt = function(t3) {
          var e2 = ft(t3), r2 = e2 == a ? t3.constructor : void 0, n2 = r2 ? kt(r2) : "";
          if (n2)
            switch (n2) {
              case Y:
                return "[object DataView]";
              case G:
                return o;
              case J:
                return "[object Promise]";
              case Q:
                return s;
              case tt:
                return "[object WeakMap]";
            }
          return e2;
        });
        var St = lt(function() {
          return arguments;
        }()) ? lt : function(t3) {
          return Ct(t3) && P.call(t3, "callee") && !F.call(t3, "callee");
        }, Ot = Array.isArray;
        var jt = H || function() {
          return false;
        };
        function Et(t3) {
          if (!Tt(t3))
            return false;
          var e2 = ft(t3);
          return e2 == "[object Function]" || e2 == "[object GeneratorFunction]" || e2 == "[object AsyncFunction]" || e2 == "[object Proxy]";
        }
        function Rt(t3) {
          return typeof t3 == "number" && t3 > -1 && t3 % 1 == 0 && t3 <= 9007199254740991;
        }
        function Tt(t3) {
          var e2 = n(t3);
          return t3 != null && (e2 == "object" || e2 == "function");
        }
        function Ct(t3) {
          return t3 != null && n(t3) == "object";
        }
        var Pt = g ? function(t3) {
          return function(e2) {
            return t3(e2);
          };
        }(g) : function(t3) {
          return Ct(t3) && Rt(t3.length) && !!f[ft(t3)];
        };
        function Mt(t3) {
          return (e2 = t3) != null && Rt(e2.length) && !Et(e2) ? ut(t3) : pt(t3);
          var e2;
        }
        e.exports = function(t3, e2) {
          return ht(t3, e2);
        };
      }).call(this, typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, {}], 430: [function(t, e, r) {
      (function(t2) {
        function r2(t3) {
          return (r2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && typeof Symbol == "function" && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        var n = (t2 === void 0 ? "undefined" : r2(t2)) == "object" && t2 && t2.Object === Object && t2, i = (typeof self == "undefined" ? "undefined" : r2(self)) == "object" && self && self.Object === Object && self, o = n || i || Function("return this")(), a = Object.prototype, s = a.hasOwnProperty, u = a.toString, c = o.Symbol, f = c ? c.toStringTag : void 0;
        function l(t3) {
          return t3 == null ? t3 === void 0 ? "[object Undefined]" : "[object Null]" : f && f in Object(t3) ? function(t4) {
            var e2 = s.call(t4, f), r3 = t4[f];
            try {
              t4[f] = void 0;
              var n2 = true;
            } catch (t5) {
            }
            var i2 = u.call(t4);
            n2 && (e2 ? t4[f] = r3 : delete t4[f]);
            return i2;
          }(t3) : function(t4) {
            return u.call(t4);
          }(t3);
        }
        e.exports = function(t3) {
          if (!function(t4) {
            var e3 = r2(t4);
            return t4 != null && (e3 == "object" || e3 == "function");
          }(t3))
            return false;
          var e2 = l(t3);
          return e2 == "[object Function]" || e2 == "[object GeneratorFunction]" || e2 == "[object AsyncFunction]" || e2 == "[object Proxy]";
        };
      }).call(this, typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, {}], 431: [function(t, e, r) {
      e.exports = function(t2) {
        return t2 == null;
      };
    }, {}], 432: [function(t, e, r) {
      e.exports = function(t2) {
        return t2 === void 0;
      };
    }, {}], 433: [function(t, e, r) {
      (function(t2) {
        function r2(t3) {
          return (r2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && typeof Symbol == "function" && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          })(t3);
        }
        var n = /^\[object .+?Constructor\]$/, i = (t2 === void 0 ? "undefined" : r2(t2)) == "object" && t2 && t2.Object === Object && t2, o = (typeof self == "undefined" ? "undefined" : r2(self)) == "object" && self && self.Object === Object && self, a = i || o || Function("return this")();
        function s(t3, e2) {
          return !!(t3 ? t3.length : 0) && function(t4, e3, r3) {
            if (e3 != e3)
              return function(t5, e4, r4, n3) {
                var i3 = t5.length, o2 = r4 + (n3 ? 1 : -1);
                for (; n3 ? o2-- : ++o2 < i3; )
                  if (e4(t5[o2], o2, t5))
                    return o2;
                return -1;
              }(t4, c, r3);
            var n2 = r3 - 1, i2 = t4.length;
            for (; ++n2 < i2; )
              if (t4[n2] === e3)
                return n2;
            return -1;
          }(t3, e2, 0) > -1;
        }
        function u(t3, e2, r3) {
          for (var n2 = -1, i2 = t3 ? t3.length : 0; ++n2 < i2; )
            if (r3(e2, t3[n2]))
              return true;
          return false;
        }
        function c(t3) {
          return t3 != t3;
        }
        function f(t3, e2) {
          return t3.has(e2);
        }
        function l(t3) {
          var e2 = -1, r3 = Array(t3.size);
          return t3.forEach(function(t4) {
            r3[++e2] = t4;
          }), r3;
        }
        var h, d = Array.prototype, p = Function.prototype, m = Object.prototype, y = a["__core-js_shared__"], b = (h = /[^.]+$/.exec(y && y.keys && y.keys.IE_PROTO || "")) ? "Symbol(src)_1." + h : "", v = p.toString, g = m.hasOwnProperty, w = m.toString, _ = RegExp("^" + v.call(g).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), k = d.splice, x = I(a, "Map"), S = I(a, "Set"), O = I(Object, "create");
        function j(t3) {
          var e2 = -1, r3 = t3 ? t3.length : 0;
          for (this.clear(); ++e2 < r3; ) {
            var n2 = t3[e2];
            this.set(n2[0], n2[1]);
          }
        }
        function E(t3) {
          var e2 = -1, r3 = t3 ? t3.length : 0;
          for (this.clear(); ++e2 < r3; ) {
            var n2 = t3[e2];
            this.set(n2[0], n2[1]);
          }
        }
        function R(t3) {
          var e2 = -1, r3 = t3 ? t3.length : 0;
          for (this.clear(); ++e2 < r3; ) {
            var n2 = t3[e2];
            this.set(n2[0], n2[1]);
          }
        }
        function T(t3) {
          var e2 = -1, r3 = t3 ? t3.length : 0;
          for (this.__data__ = new R(); ++e2 < r3; )
            this.add(t3[e2]);
        }
        function C(t3, e2) {
          for (var r3, n2, i2 = t3.length; i2--; )
            if ((r3 = t3[i2][0]) === (n2 = e2) || r3 != r3 && n2 != n2)
              return i2;
          return -1;
        }
        function P(t3) {
          return !(!N(t3) || (e2 = t3, b && b in e2)) && (function(t4) {
            var e3 = N(t4) ? w.call(t4) : "";
            return e3 == "[object Function]" || e3 == "[object GeneratorFunction]";
          }(t3) || function(t4) {
            var e3 = false;
            if (t4 != null && typeof t4.toString != "function")
              try {
                e3 = !!(t4 + "");
              } catch (t5) {
              }
            return e3;
          }(t3) ? _ : n).test(function(t4) {
            if (t4 != null) {
              try {
                return v.call(t4);
              } catch (t5) {
              }
              try {
                return t4 + "";
              } catch (t5) {
              }
            }
            return "";
          }(t3));
          var e2;
        }
        j.prototype.clear = function() {
          this.__data__ = O ? O(null) : {};
        }, j.prototype.delete = function(t3) {
          return this.has(t3) && delete this.__data__[t3];
        }, j.prototype.get = function(t3) {
          var e2 = this.__data__;
          if (O) {
            var r3 = e2[t3];
            return r3 === "__lodash_hash_undefined__" ? void 0 : r3;
          }
          return g.call(e2, t3) ? e2[t3] : void 0;
        }, j.prototype.has = function(t3) {
          var e2 = this.__data__;
          return O ? e2[t3] !== void 0 : g.call(e2, t3);
        }, j.prototype.set = function(t3, e2) {
          return this.__data__[t3] = O && e2 === void 0 ? "__lodash_hash_undefined__" : e2, this;
        }, E.prototype.clear = function() {
          this.__data__ = [];
        }, E.prototype.delete = function(t3) {
          var e2 = this.__data__, r3 = C(e2, t3);
          return !(r3 < 0) && (r3 == e2.length - 1 ? e2.pop() : k.call(e2, r3, 1), true);
        }, E.prototype.get = function(t3) {
          var e2 = this.__data__, r3 = C(e2, t3);
          return r3 < 0 ? void 0 : e2[r3][1];
        }, E.prototype.has = function(t3) {
          return C(this.__data__, t3) > -1;
        }, E.prototype.set = function(t3, e2) {
          var r3 = this.__data__, n2 = C(r3, t3);
          return n2 < 0 ? r3.push([t3, e2]) : r3[n2][1] = e2, this;
        }, R.prototype.clear = function() {
          this.__data__ = { hash: new j(), map: new (x || E)(), string: new j() };
        }, R.prototype.delete = function(t3) {
          return A(this, t3).delete(t3);
        }, R.prototype.get = function(t3) {
          return A(this, t3).get(t3);
        }, R.prototype.has = function(t3) {
          return A(this, t3).has(t3);
        }, R.prototype.set = function(t3, e2) {
          return A(this, t3).set(t3, e2), this;
        }, T.prototype.add = T.prototype.push = function(t3) {
          return this.__data__.set(t3, "__lodash_hash_undefined__"), this;
        }, T.prototype.has = function(t3) {
          return this.__data__.has(t3);
        };
        var M = S && 1 / l(new S([, -0]))[1] == 1 / 0 ? function(t3) {
          return new S(t3);
        } : function() {
        };
        function A(t3, e2) {
          var n2, i2, o2 = t3.__data__;
          return ((i2 = r2(n2 = e2)) == "string" || i2 == "number" || i2 == "symbol" || i2 == "boolean" ? n2 !== "__proto__" : n2 === null) ? o2[typeof e2 == "string" ? "string" : "hash"] : o2.map;
        }
        function I(t3, e2) {
          var r3 = function(t4, e3) {
            return t4 == null ? void 0 : t4[e3];
          }(t3, e2);
          return P(r3) ? r3 : void 0;
        }
        function N(t3) {
          var e2 = r2(t3);
          return !!t3 && (e2 == "object" || e2 == "function");
        }
        e.exports = function(t3) {
          return t3 && t3.length ? function(t4, e2, r3) {
            var n2 = -1, i2 = s, o2 = t4.length, a2 = true, c2 = [], h2 = c2;
            if (r3)
              a2 = false, i2 = u;
            else if (o2 >= 200) {
              var d2 = e2 ? null : M(t4);
              if (d2)
                return l(d2);
              a2 = false, i2 = f, h2 = new T();
            } else
              h2 = e2 ? [] : c2;
            t:
              for (; ++n2 < o2; ) {
                var p2 = t4[n2], m2 = e2 ? e2(p2) : p2;
                if (p2 = r3 || p2 !== 0 ? p2 : 0, a2 && m2 == m2) {
                  for (var y2 = h2.length; y2--; )
                    if (h2[y2] === m2)
                      continue t;
                  e2 && h2.push(m2), c2.push(p2);
                } else
                  i2(h2, m2, r3) || (h2 !== c2 && h2.push(m2), c2.push(p2));
              }
            return c2;
          }(t3) : [];
        };
      }).call(this, typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, {}], 434: [function(t, e, r) {
      var n = t("inherits"), i = t("hash-base"), o = t("safe-buffer").Buffer, a = new Array(16);
      function s() {
        i.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
      }
      function u(t2, e2) {
        return t2 << e2 | t2 >>> 32 - e2;
      }
      function c(t2, e2, r2, n2, i2, o2, a2) {
        return u(t2 + (e2 & r2 | ~e2 & n2) + i2 + o2 | 0, a2) + e2 | 0;
      }
      function f(t2, e2, r2, n2, i2, o2, a2) {
        return u(t2 + (e2 & n2 | r2 & ~n2) + i2 + o2 | 0, a2) + e2 | 0;
      }
      function l(t2, e2, r2, n2, i2, o2, a2) {
        return u(t2 + (e2 ^ r2 ^ n2) + i2 + o2 | 0, a2) + e2 | 0;
      }
      function h(t2, e2, r2, n2, i2, o2, a2) {
        return u(t2 + (r2 ^ (e2 | ~n2)) + i2 + o2 | 0, a2) + e2 | 0;
      }
      n(s, i), s.prototype._update = function() {
        for (var t2 = a, e2 = 0; e2 < 16; ++e2)
          t2[e2] = this._block.readInt32LE(4 * e2);
        var r2 = this._a, n2 = this._b, i2 = this._c, o2 = this._d;
        r2 = c(r2, n2, i2, o2, t2[0], 3614090360, 7), o2 = c(o2, r2, n2, i2, t2[1], 3905402710, 12), i2 = c(i2, o2, r2, n2, t2[2], 606105819, 17), n2 = c(n2, i2, o2, r2, t2[3], 3250441966, 22), r2 = c(r2, n2, i2, o2, t2[4], 4118548399, 7), o2 = c(o2, r2, n2, i2, t2[5], 1200080426, 12), i2 = c(i2, o2, r2, n2, t2[6], 2821735955, 17), n2 = c(n2, i2, o2, r2, t2[7], 4249261313, 22), r2 = c(r2, n2, i2, o2, t2[8], 1770035416, 7), o2 = c(o2, r2, n2, i2, t2[9], 2336552879, 12), i2 = c(i2, o2, r2, n2, t2[10], 4294925233, 17), n2 = c(n2, i2, o2, r2, t2[11], 2304563134, 22), r2 = c(r2, n2, i2, o2, t2[12], 1804603682, 7), o2 = c(o2, r2, n2, i2, t2[13], 4254626195, 12), i2 = c(i2, o2, r2, n2, t2[14], 2792965006, 17), r2 = f(r2, n2 = c(n2, i2, o2, r2, t2[15], 1236535329, 22), i2, o2, t2[1], 4129170786, 5), o2 = f(o2, r2, n2, i2, t2[6], 3225465664, 9), i2 = f(i2, o2, r2, n2, t2[11], 643717713, 14), n2 = f(n2, i2, o2, r2, t2[0], 3921069994, 20), r2 = f(r2, n2, i2, o2, t2[5], 3593408605, 5), o2 = f(o2, r2, n2, i2, t2[10], 38016083, 9), i2 = f(i2, o2, r2, n2, t2[15], 3634488961, 14), n2 = f(n2, i2, o2, r2, t2[4], 3889429448, 20), r2 = f(r2, n2, i2, o2, t2[9], 568446438, 5), o2 = f(o2, r2, n2, i2, t2[14], 3275163606, 9), i2 = f(i2, o2, r2, n2, t2[3], 4107603335, 14), n2 = f(n2, i2, o2, r2, t2[8], 1163531501, 20), r2 = f(r2, n2, i2, o2, t2[13], 2850285829, 5), o2 = f(o2, r2, n2, i2, t2[2], 4243563512, 9), i2 = f(i2, o2, r2, n2, t2[7], 1735328473, 14), r2 = l(r2, n2 = f(n2, i2, o2, r2, t2[12], 2368359562, 20), i2, o2, t2[5], 4294588738, 4), o2 = l(o2, r2, n2, i2, t2[8], 2272392833, 11), i2 = l(i2, o2, r2, n2, t2[11], 1839030562, 16), n2 = l(n2, i2, o2, r2, t2[14], 4259657740, 23), r2 = l(r2, n2, i2, o2, t2[1], 2763975236, 4), o2 = l(o2, r2, n2, i2, t2[4], 1272893353, 11), i2 = l(i2, o2, r2, n2, t2[7], 4139469664, 16), n2 = l(n2, i2, o2, r2, t2[10], 3200236656, 23), r2 = l(r2, n2, i2, o2, t2[13], 681279174, 4), o2 = l(o2, r2, n2, i2, t2[0], 3936430074, 11), i2 = l(i2, o2, r2, n2, t2[3], 3572445317, 16), n2 = l(n2, i2, o2, r2, t2[6], 76029189, 23), r2 = l(r2, n2, i2, o2, t2[9], 3654602809, 4), o2 = l(o2, r2, n2, i2, t2[12], 3873151461, 11), i2 = l(i2, o2, r2, n2, t2[15], 530742520, 16), r2 = h(r2, n2 = l(n2, i2, o2, r2, t2[2], 3299628645, 23), i2, o2, t2[0], 4096336452, 6), o2 = h(o2, r2, n2, i2, t2[7], 1126891415, 10), i2 = h(i2, o2, r2, n2, t2[14], 2878612391, 15), n2 = h(n2, i2, o2, r2, t2[5], 4237533241, 21), r2 = h(r2, n2, i2, o2, t2[12], 1700485571, 6), o2 = h(o2, r2, n2, i2, t2[3], 2399980690, 10), i2 = h(i2, o2, r2, n2, t2[10], 4293915773, 15), n2 = h(n2, i2, o2, r2, t2[1], 2240044497, 21), r2 = h(r2, n2, i2, o2, t2[8], 1873313359, 6), o2 = h(o2, r2, n2, i2, t2[15], 4264355552, 10), i2 = h(i2, o2, r2, n2, t2[6], 2734768916, 15), n2 = h(n2, i2, o2, r2, t2[13], 1309151649, 21), r2 = h(r2, n2, i2, o2, t2[4], 4149444226, 6), o2 = h(o2, r2, n2, i2, t2[11], 3174756917, 10), i2 = h(i2, o2, r2, n2, t2[2], 718787259, 15), n2 = h(n2, i2, o2, r2, t2[9], 3951481745, 21), this._a = this._a + r2 | 0, this._b = this._b + n2 | 0, this._c = this._c + i2 | 0, this._d = this._d + o2 | 0;
      }, s.prototype._digest = function() {
        this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
        var t2 = o.allocUnsafe(16);
        return t2.writeInt32LE(this._a, 0), t2.writeInt32LE(this._b, 4), t2.writeInt32LE(this._c, 8), t2.writeInt32LE(this._d, 12), t2;
      }, e.exports = s;
    }, { "hash-base": 370, inherits: 387, "safe-buffer": 494 }], 435: [function(t, e, r) {
      var n = t("bn.js"), i = t("brorand");
      function o(t2) {
        this.rand = t2 || new i.Rand();
      }
      e.exports = o, o.create = function(t2) {
        return new o(t2);
      }, o.prototype._randbelow = function(t2) {
        var e2 = t2.bitLength(), r2 = Math.ceil(e2 / 8);
        do {
          var i2 = new n(this.rand.generate(r2));
        } while (i2.cmp(t2) >= 0);
        return i2;
      }, o.prototype._randrange = function(t2, e2) {
        var r2 = e2.sub(t2);
        return t2.add(this._randbelow(r2));
      }, o.prototype.test = function(t2, e2, r2) {
        var i2 = t2.bitLength(), o2 = n.mont(t2), a = new n(1).toRed(o2);
        e2 || (e2 = Math.max(1, i2 / 48 | 0));
        for (var s = t2.subn(1), u = 0; !s.testn(u); u++)
          ;
        for (var c = t2.shrn(u), f = s.toRed(o2); e2 > 0; e2--) {
          var l = this._randrange(new n(2), s);
          r2 && r2(l);
          var h = l.toRed(o2).redPow(c);
          if (h.cmp(a) !== 0 && h.cmp(f) !== 0) {
            for (var d = 1; d < u; d++) {
              if ((h = h.redSqr()).cmp(a) === 0)
                return false;
              if (h.cmp(f) === 0)
                break;
            }
            if (d === u)
              return false;
          }
        }
        return true;
      }, o.prototype.getDivisor = function(t2, e2) {
        var r2 = t2.bitLength(), i2 = n.mont(t2), o2 = new n(1).toRed(i2);
        e2 || (e2 = Math.max(1, r2 / 48 | 0));
        for (var a = t2.subn(1), s = 0; !a.testn(s); s++)
          ;
        for (var u = t2.shrn(s), c = a.toRed(i2); e2 > 0; e2--) {
          var f = this._randrange(new n(2), a), l = t2.gcd(f);
          if (l.cmpn(1) !== 0)
            return l;
          var h = f.toRed(i2).redPow(u);
          if (h.cmp(o2) !== 0 && h.cmp(c) !== 0) {
            for (var d = 1; d < s; d++) {
              if ((h = h.redSqr()).cmp(o2) === 0)
                return h.fromRed().subn(1).gcd(t2);
              if (h.cmp(c) === 0)
                break;
            }
            if (d === s)
              return (h = h.redSqr()).fromRed().subn(1).gcd(t2);
          }
        }
        return false;
      };
    }, { "bn.js": 436, brorand: 184 }], 436: [function(t, e, r) {
      arguments[4][181][0].apply(r, arguments);
    }, { buffer: 185, dup: 181 }], 437: [function(t, e, r) {
      function n(t2, e2) {
        if (!t2)
          throw new Error(e2 || "Assertion failed");
      }
      e.exports = n, n.equal = function(t2, e2, r2) {
        if (t2 != e2)
          throw new Error(r2 || "Assertion failed: " + t2 + " != " + e2);
      };
    }, {}], 438: [function(t, e, r) {
      var n = r;
      function i(t2) {
        return t2.length === 1 ? "0" + t2 : t2;
      }
      function o(t2) {
        for (var e2 = "", r2 = 0; r2 < t2.length; r2++)
          e2 += i(t2[r2].toString(16));
        return e2;
      }
      n.toArray = function(t2, e2) {
        if (Array.isArray(t2))
          return t2.slice();
        if (!t2)
          return [];
        var r2 = [];
        if (typeof t2 != "string") {
          for (var n2 = 0; n2 < t2.length; n2++)
            r2[n2] = 0 | t2[n2];
          return r2;
        }
        if (e2 === "hex") {
          (t2 = t2.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (t2 = "0" + t2);
          for (n2 = 0; n2 < t2.length; n2 += 2)
            r2.push(parseInt(t2[n2] + t2[n2 + 1], 16));
        } else
          for (n2 = 0; n2 < t2.length; n2++) {
            var i2 = t2.charCodeAt(n2), o2 = i2 >> 8, a = 255 & i2;
            o2 ? r2.push(o2, a) : r2.push(a);
          }
        return r2;
      }, n.zero2 = i, n.toHex = o, n.encode = function(t2, e2) {
        return e2 === "hex" ? o(t2) : t2;
      };
    }, {}], 439: [function(t, e, r) {
      var n = {};
      (0, t("./lib/utils/common").assign)(n, t("./lib/deflate"), t("./lib/inflate"), t("./lib/zlib/constants")), e.exports = n;
    }, { "./lib/deflate": 440, "./lib/inflate": 441, "./lib/utils/common": 442, "./lib/zlib/constants": 445 }], 440: [function(t, e, r) {
      var n = t("./zlib/deflate"), i = t("./utils/common"), o = t("./utils/strings"), a = t("./zlib/messages"), s = t("./zlib/zstream"), u = Object.prototype.toString;
      function c(t2) {
        if (!(this instanceof c))
          return new c(t2);
        this.options = i.assign({ level: -1, method: 8, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: 0, to: "" }, t2 || {});
        var e2 = this.options;
        e2.raw && e2.windowBits > 0 ? e2.windowBits = -e2.windowBits : e2.gzip && e2.windowBits > 0 && e2.windowBits < 16 && (e2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;
        var r2 = n.deflateInit2(this.strm, e2.level, e2.method, e2.windowBits, e2.memLevel, e2.strategy);
        if (r2 !== 0)
          throw new Error(a[r2]);
        if (e2.header && n.deflateSetHeader(this.strm, e2.header), e2.dictionary) {
          var f2;
          if (f2 = typeof e2.dictionary == "string" ? o.string2buf(e2.dictionary) : u.call(e2.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(e2.dictionary) : e2.dictionary, (r2 = n.deflateSetDictionary(this.strm, f2)) !== 0)
            throw new Error(a[r2]);
          this._dict_set = true;
        }
      }
      function f(t2, e2) {
        var r2 = new c(e2);
        if (r2.push(t2, true), r2.err)
          throw r2.msg || a[r2.err];
        return r2.result;
      }
      c.prototype.push = function(t2, e2) {
        var r2, a2, s2 = this.strm, c2 = this.options.chunkSize;
        if (this.ended)
          return false;
        a2 = e2 === ~~e2 ? e2 : e2 === true ? 4 : 0, typeof t2 == "string" ? s2.input = o.string2buf(t2) : u.call(t2) === "[object ArrayBuffer]" ? s2.input = new Uint8Array(t2) : s2.input = t2, s2.next_in = 0, s2.avail_in = s2.input.length;
        do {
          if (s2.avail_out === 0 && (s2.output = new i.Buf8(c2), s2.next_out = 0, s2.avail_out = c2), (r2 = n.deflate(s2, a2)) !== 1 && r2 !== 0)
            return this.onEnd(r2), this.ended = true, false;
          s2.avail_out !== 0 && (s2.avail_in !== 0 || a2 !== 4 && a2 !== 2) || (this.options.to === "string" ? this.onData(o.buf2binstring(i.shrinkBuf(s2.output, s2.next_out))) : this.onData(i.shrinkBuf(s2.output, s2.next_out)));
        } while ((s2.avail_in > 0 || s2.avail_out === 0) && r2 !== 1);
        return a2 === 4 ? (r2 = n.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === 0) : a2 !== 2 || (this.onEnd(0), s2.avail_out = 0, true);
      }, c.prototype.onData = function(t2) {
        this.chunks.push(t2);
      }, c.prototype.onEnd = function(t2) {
        t2 === 0 && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = i.flattenChunks(this.chunks)), this.chunks = [], this.err = t2, this.msg = this.strm.msg;
      }, r.Deflate = c, r.deflate = f, r.deflateRaw = function(t2, e2) {
        return (e2 = e2 || {}).raw = true, f(t2, e2);
      }, r.gzip = function(t2, e2) {
        return (e2 = e2 || {}).gzip = true, f(t2, e2);
      };
    }, { "./utils/common": 442, "./utils/strings": 443, "./zlib/deflate": 447, "./zlib/messages": 452, "./zlib/zstream": 454 }], 441: [function(t, e, r) {
      var n = t("./zlib/inflate"), i = t("./utils/common"), o = t("./utils/strings"), a = t("./zlib/constants"), s = t("./zlib/messages"), u = t("./zlib/zstream"), c = t("./zlib/gzheader"), f = Object.prototype.toString;
      function l(t2) {
        if (!(this instanceof l))
          return new l(t2);
        this.options = i.assign({ chunkSize: 16384, windowBits: 0, to: "" }, t2 || {});
        var e2 = this.options;
        e2.raw && e2.windowBits >= 0 && e2.windowBits < 16 && (e2.windowBits = -e2.windowBits, e2.windowBits === 0 && (e2.windowBits = -15)), !(e2.windowBits >= 0 && e2.windowBits < 16) || t2 && t2.windowBits || (e2.windowBits += 32), e2.windowBits > 15 && e2.windowBits < 48 && (15 & e2.windowBits) == 0 && (e2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new u(), this.strm.avail_out = 0;
        var r2 = n.inflateInit2(this.strm, e2.windowBits);
        if (r2 !== a.Z_OK)
          throw new Error(s[r2]);
        if (this.header = new c(), n.inflateGetHeader(this.strm, this.header), e2.dictionary && (typeof e2.dictionary == "string" ? e2.dictionary = o.string2buf(e2.dictionary) : f.call(e2.dictionary) === "[object ArrayBuffer]" && (e2.dictionary = new Uint8Array(e2.dictionary)), e2.raw && (r2 = n.inflateSetDictionary(this.strm, e2.dictionary)) !== a.Z_OK))
          throw new Error(s[r2]);
      }
      function h(t2, e2) {
        var r2 = new l(e2);
        if (r2.push(t2, true), r2.err)
          throw r2.msg || s[r2.err];
        return r2.result;
      }
      l.prototype.push = function(t2, e2) {
        var r2, s2, u2, c2, l2, h2 = this.strm, d = this.options.chunkSize, p = this.options.dictionary, m = false;
        if (this.ended)
          return false;
        s2 = e2 === ~~e2 ? e2 : e2 === true ? a.Z_FINISH : a.Z_NO_FLUSH, typeof t2 == "string" ? h2.input = o.binstring2buf(t2) : f.call(t2) === "[object ArrayBuffer]" ? h2.input = new Uint8Array(t2) : h2.input = t2, h2.next_in = 0, h2.avail_in = h2.input.length;
        do {
          if (h2.avail_out === 0 && (h2.output = new i.Buf8(d), h2.next_out = 0, h2.avail_out = d), (r2 = n.inflate(h2, a.Z_NO_FLUSH)) === a.Z_NEED_DICT && p && (r2 = n.inflateSetDictionary(this.strm, p)), r2 === a.Z_BUF_ERROR && m === true && (r2 = a.Z_OK, m = false), r2 !== a.Z_STREAM_END && r2 !== a.Z_OK)
            return this.onEnd(r2), this.ended = true, false;
          h2.next_out && (h2.avail_out !== 0 && r2 !== a.Z_STREAM_END && (h2.avail_in !== 0 || s2 !== a.Z_FINISH && s2 !== a.Z_SYNC_FLUSH) || (this.options.to === "string" ? (u2 = o.utf8border(h2.output, h2.next_out), c2 = h2.next_out - u2, l2 = o.buf2string(h2.output, u2), h2.next_out = c2, h2.avail_out = d - c2, c2 && i.arraySet(h2.output, h2.output, u2, c2, 0), this.onData(l2)) : this.onData(i.shrinkBuf(h2.output, h2.next_out)))), h2.avail_in === 0 && h2.avail_out === 0 && (m = true);
        } while ((h2.avail_in > 0 || h2.avail_out === 0) && r2 !== a.Z_STREAM_END);
        return r2 === a.Z_STREAM_END && (s2 = a.Z_FINISH), s2 === a.Z_FINISH ? (r2 = n.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === a.Z_OK) : s2 !== a.Z_SYNC_FLUSH || (this.onEnd(a.Z_OK), h2.avail_out = 0, true);
      }, l.prototype.onData = function(t2) {
        this.chunks.push(t2);
      }, l.prototype.onEnd = function(t2) {
        t2 === a.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = i.flattenChunks(this.chunks)), this.chunks = [], this.err = t2, this.msg = this.strm.msg;
      }, r.Inflate = l, r.inflate = h, r.inflateRaw = function(t2, e2) {
        return (e2 = e2 || {}).raw = true, h(t2, e2);
      }, r.ungzip = h;
    }, { "./utils/common": 442, "./utils/strings": 443, "./zlib/constants": 445, "./zlib/gzheader": 448, "./zlib/inflate": 450, "./zlib/messages": 452, "./zlib/zstream": 454 }], 442: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      var i = typeof Uint8Array != "undefined" && typeof Uint16Array != "undefined" && typeof Int32Array != "undefined";
      function o(t2, e2) {
        return Object.prototype.hasOwnProperty.call(t2, e2);
      }
      r.assign = function(t2) {
        for (var e2 = Array.prototype.slice.call(arguments, 1); e2.length; ) {
          var r2 = e2.shift();
          if (r2) {
            if (n(r2) !== "object")
              throw new TypeError(r2 + "must be non-object");
            for (var i2 in r2)
              o(r2, i2) && (t2[i2] = r2[i2]);
          }
        }
        return t2;
      }, r.shrinkBuf = function(t2, e2) {
        return t2.length === e2 ? t2 : t2.subarray ? t2.subarray(0, e2) : (t2.length = e2, t2);
      };
      var a = { arraySet: function(t2, e2, r2, n2, i2) {
        if (e2.subarray && t2.subarray)
          t2.set(e2.subarray(r2, r2 + n2), i2);
        else
          for (var o2 = 0; o2 < n2; o2++)
            t2[i2 + o2] = e2[r2 + o2];
      }, flattenChunks: function(t2) {
        var e2, r2, n2, i2, o2, a2;
        for (n2 = 0, e2 = 0, r2 = t2.length; e2 < r2; e2++)
          n2 += t2[e2].length;
        for (a2 = new Uint8Array(n2), i2 = 0, e2 = 0, r2 = t2.length; e2 < r2; e2++)
          o2 = t2[e2], a2.set(o2, i2), i2 += o2.length;
        return a2;
      } }, s = { arraySet: function(t2, e2, r2, n2, i2) {
        for (var o2 = 0; o2 < n2; o2++)
          t2[i2 + o2] = e2[r2 + o2];
      }, flattenChunks: function(t2) {
        return [].concat.apply([], t2);
      } };
      r.setTyped = function(t2) {
        t2 ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, a)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s));
      }, r.setTyped(i);
    }, {}], 443: [function(t, e, r) {
      var n = t("./common"), i = true, o = true;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch (t2) {
        i = false;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch (t2) {
        o = false;
      }
      for (var a = new n.Buf8(256), s = 0; s < 256; s++)
        a[s] = s >= 252 ? 6 : s >= 248 ? 5 : s >= 240 ? 4 : s >= 224 ? 3 : s >= 192 ? 2 : 1;
      function u(t2, e2) {
        if (e2 < 65534 && (t2.subarray && o || !t2.subarray && i))
          return String.fromCharCode.apply(null, n.shrinkBuf(t2, e2));
        for (var r2 = "", a2 = 0; a2 < e2; a2++)
          r2 += String.fromCharCode(t2[a2]);
        return r2;
      }
      a[254] = a[254] = 1, r.string2buf = function(t2) {
        var e2, r2, i2, o2, a2, s2 = t2.length, u2 = 0;
        for (o2 = 0; o2 < s2; o2++)
          (64512 & (r2 = t2.charCodeAt(o2))) == 55296 && o2 + 1 < s2 && (64512 & (i2 = t2.charCodeAt(o2 + 1))) == 56320 && (r2 = 65536 + (r2 - 55296 << 10) + (i2 - 56320), o2++), u2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
        for (e2 = new n.Buf8(u2), a2 = 0, o2 = 0; a2 < u2; o2++)
          (64512 & (r2 = t2.charCodeAt(o2))) == 55296 && o2 + 1 < s2 && (64512 & (i2 = t2.charCodeAt(o2 + 1))) == 56320 && (r2 = 65536 + (r2 - 55296 << 10) + (i2 - 56320), o2++), r2 < 128 ? e2[a2++] = r2 : r2 < 2048 ? (e2[a2++] = 192 | r2 >>> 6, e2[a2++] = 128 | 63 & r2) : r2 < 65536 ? (e2[a2++] = 224 | r2 >>> 12, e2[a2++] = 128 | r2 >>> 6 & 63, e2[a2++] = 128 | 63 & r2) : (e2[a2++] = 240 | r2 >>> 18, e2[a2++] = 128 | r2 >>> 12 & 63, e2[a2++] = 128 | r2 >>> 6 & 63, e2[a2++] = 128 | 63 & r2);
        return e2;
      }, r.buf2binstring = function(t2) {
        return u(t2, t2.length);
      }, r.binstring2buf = function(t2) {
        for (var e2 = new n.Buf8(t2.length), r2 = 0, i2 = e2.length; r2 < i2; r2++)
          e2[r2] = t2.charCodeAt(r2);
        return e2;
      }, r.buf2string = function(t2, e2) {
        var r2, n2, i2, o2, s2 = e2 || t2.length, c = new Array(2 * s2);
        for (n2 = 0, r2 = 0; r2 < s2; )
          if ((i2 = t2[r2++]) < 128)
            c[n2++] = i2;
          else if ((o2 = a[i2]) > 4)
            c[n2++] = 65533, r2 += o2 - 1;
          else {
            for (i2 &= o2 === 2 ? 31 : o2 === 3 ? 15 : 7; o2 > 1 && r2 < s2; )
              i2 = i2 << 6 | 63 & t2[r2++], o2--;
            o2 > 1 ? c[n2++] = 65533 : i2 < 65536 ? c[n2++] = i2 : (i2 -= 65536, c[n2++] = 55296 | i2 >> 10 & 1023, c[n2++] = 56320 | 1023 & i2);
          }
        return u(c, n2);
      }, r.utf8border = function(t2, e2) {
        var r2;
        for ((e2 = e2 || t2.length) > t2.length && (e2 = t2.length), r2 = e2 - 1; r2 >= 0 && (192 & t2[r2]) == 128; )
          r2--;
        return r2 < 0 || r2 === 0 ? e2 : r2 + a[t2[r2]] > e2 ? r2 : e2;
      };
    }, { "./common": 442 }], 444: [function(t, e, r) {
      e.exports = function(t2, e2, r2, n) {
        for (var i = 65535 & t2 | 0, o = t2 >>> 16 & 65535 | 0, a = 0; r2 !== 0; ) {
          r2 -= a = r2 > 2e3 ? 2e3 : r2;
          do {
            o = o + (i = i + e2[n++] | 0) | 0;
          } while (--a);
          i %= 65521, o %= 65521;
        }
        return i | o << 16 | 0;
      };
    }, {}], 445: [function(t, e, r) {
      e.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 446: [function(t, e, r) {
      var n = function() {
        for (var t2, e2 = [], r2 = 0; r2 < 256; r2++) {
          t2 = r2;
          for (var n2 = 0; n2 < 8; n2++)
            t2 = 1 & t2 ? 3988292384 ^ t2 >>> 1 : t2 >>> 1;
          e2[r2] = t2;
        }
        return e2;
      }();
      e.exports = function(t2, e2, r2, i) {
        var o = n, a = i + r2;
        t2 ^= -1;
        for (var s = i; s < a; s++)
          t2 = t2 >>> 8 ^ o[255 & (t2 ^ e2[s])];
        return -1 ^ t2;
      };
    }, {}], 447: [function(t, e, r) {
      var n, i = t("../utils/common"), o = t("./trees"), a = t("./adler32"), s = t("./crc32"), u = t("./messages");
      function c(t2, e2) {
        return t2.msg = u[e2], e2;
      }
      function f(t2) {
        return (t2 << 1) - (t2 > 4 ? 9 : 0);
      }
      function l(t2) {
        for (var e2 = t2.length; --e2 >= 0; )
          t2[e2] = 0;
      }
      function h(t2) {
        var e2 = t2.state, r2 = e2.pending;
        r2 > t2.avail_out && (r2 = t2.avail_out), r2 !== 0 && (i.arraySet(t2.output, e2.pending_buf, e2.pending_out, r2, t2.next_out), t2.next_out += r2, e2.pending_out += r2, t2.total_out += r2, t2.avail_out -= r2, e2.pending -= r2, e2.pending === 0 && (e2.pending_out = 0));
      }
      function d(t2, e2) {
        o._tr_flush_block(t2, t2.block_start >= 0 ? t2.block_start : -1, t2.strstart - t2.block_start, e2), t2.block_start = t2.strstart, h(t2.strm);
      }
      function p(t2, e2) {
        t2.pending_buf[t2.pending++] = e2;
      }
      function m(t2, e2) {
        t2.pending_buf[t2.pending++] = e2 >>> 8 & 255, t2.pending_buf[t2.pending++] = 255 & e2;
      }
      function y(t2, e2) {
        var r2, n2, i2 = t2.max_chain_length, o2 = t2.strstart, a2 = t2.prev_length, s2 = t2.nice_match, u2 = t2.strstart > t2.w_size - 262 ? t2.strstart - (t2.w_size - 262) : 0, c2 = t2.window, f2 = t2.w_mask, l2 = t2.prev, h2 = t2.strstart + 258, d2 = c2[o2 + a2 - 1], p2 = c2[o2 + a2];
        t2.prev_length >= t2.good_match && (i2 >>= 2), s2 > t2.lookahead && (s2 = t2.lookahead);
        do {
          if (c2[(r2 = e2) + a2] === p2 && c2[r2 + a2 - 1] === d2 && c2[r2] === c2[o2] && c2[++r2] === c2[o2 + 1]) {
            o2 += 2, r2++;
            do {
            } while (c2[++o2] === c2[++r2] && c2[++o2] === c2[++r2] && c2[++o2] === c2[++r2] && c2[++o2] === c2[++r2] && c2[++o2] === c2[++r2] && c2[++o2] === c2[++r2] && c2[++o2] === c2[++r2] && c2[++o2] === c2[++r2] && o2 < h2);
            if (n2 = 258 - (h2 - o2), o2 = h2 - 258, n2 > a2) {
              if (t2.match_start = e2, a2 = n2, n2 >= s2)
                break;
              d2 = c2[o2 + a2 - 1], p2 = c2[o2 + a2];
            }
          }
        } while ((e2 = l2[e2 & f2]) > u2 && --i2 != 0);
        return a2 <= t2.lookahead ? a2 : t2.lookahead;
      }
      function b(t2) {
        var e2, r2, n2, o2, u2, c2, f2, l2, h2, d2, p2 = t2.w_size;
        do {
          if (o2 = t2.window_size - t2.lookahead - t2.strstart, t2.strstart >= p2 + (p2 - 262)) {
            i.arraySet(t2.window, t2.window, p2, p2, 0), t2.match_start -= p2, t2.strstart -= p2, t2.block_start -= p2, e2 = r2 = t2.hash_size;
            do {
              n2 = t2.head[--e2], t2.head[e2] = n2 >= p2 ? n2 - p2 : 0;
            } while (--r2);
            e2 = r2 = p2;
            do {
              n2 = t2.prev[--e2], t2.prev[e2] = n2 >= p2 ? n2 - p2 : 0;
            } while (--r2);
            o2 += p2;
          }
          if (t2.strm.avail_in === 0)
            break;
          if (c2 = t2.strm, f2 = t2.window, l2 = t2.strstart + t2.lookahead, h2 = o2, d2 = void 0, (d2 = c2.avail_in) > h2 && (d2 = h2), r2 = d2 === 0 ? 0 : (c2.avail_in -= d2, i.arraySet(f2, c2.input, c2.next_in, d2, l2), c2.state.wrap === 1 ? c2.adler = a(c2.adler, f2, d2, l2) : c2.state.wrap === 2 && (c2.adler = s(c2.adler, f2, d2, l2)), c2.next_in += d2, c2.total_in += d2, d2), t2.lookahead += r2, t2.lookahead + t2.insert >= 3)
            for (u2 = t2.strstart - t2.insert, t2.ins_h = t2.window[u2], t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[u2 + 1]) & t2.hash_mask; t2.insert && (t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[u2 + 3 - 1]) & t2.hash_mask, t2.prev[u2 & t2.w_mask] = t2.head[t2.ins_h], t2.head[t2.ins_h] = u2, u2++, t2.insert--, !(t2.lookahead + t2.insert < 3)); )
              ;
        } while (t2.lookahead < 262 && t2.strm.avail_in !== 0);
      }
      function v(t2, e2) {
        for (var r2, n2; ; ) {
          if (t2.lookahead < 262) {
            if (b(t2), t2.lookahead < 262 && e2 === 0)
              return 1;
            if (t2.lookahead === 0)
              break;
          }
          if (r2 = 0, t2.lookahead >= 3 && (t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[t2.strstart + 3 - 1]) & t2.hash_mask, r2 = t2.prev[t2.strstart & t2.w_mask] = t2.head[t2.ins_h], t2.head[t2.ins_h] = t2.strstart), r2 !== 0 && t2.strstart - r2 <= t2.w_size - 262 && (t2.match_length = y(t2, r2)), t2.match_length >= 3)
            if (n2 = o._tr_tally(t2, t2.strstart - t2.match_start, t2.match_length - 3), t2.lookahead -= t2.match_length, t2.match_length <= t2.max_lazy_match && t2.lookahead >= 3) {
              t2.match_length--;
              do {
                t2.strstart++, t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[t2.strstart + 3 - 1]) & t2.hash_mask, r2 = t2.prev[t2.strstart & t2.w_mask] = t2.head[t2.ins_h], t2.head[t2.ins_h] = t2.strstart;
              } while (--t2.match_length != 0);
              t2.strstart++;
            } else
              t2.strstart += t2.match_length, t2.match_length = 0, t2.ins_h = t2.window[t2.strstart], t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[t2.strstart + 1]) & t2.hash_mask;
          else
            n2 = o._tr_tally(t2, 0, t2.window[t2.strstart]), t2.lookahead--, t2.strstart++;
          if (n2 && (d(t2, false), t2.strm.avail_out === 0))
            return 1;
        }
        return t2.insert = t2.strstart < 2 ? t2.strstart : 2, e2 === 4 ? (d(t2, true), t2.strm.avail_out === 0 ? 3 : 4) : t2.last_lit && (d(t2, false), t2.strm.avail_out === 0) ? 1 : 2;
      }
      function g(t2, e2) {
        for (var r2, n2, i2; ; ) {
          if (t2.lookahead < 262) {
            if (b(t2), t2.lookahead < 262 && e2 === 0)
              return 1;
            if (t2.lookahead === 0)
              break;
          }
          if (r2 = 0, t2.lookahead >= 3 && (t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[t2.strstart + 3 - 1]) & t2.hash_mask, r2 = t2.prev[t2.strstart & t2.w_mask] = t2.head[t2.ins_h], t2.head[t2.ins_h] = t2.strstart), t2.prev_length = t2.match_length, t2.prev_match = t2.match_start, t2.match_length = 2, r2 !== 0 && t2.prev_length < t2.max_lazy_match && t2.strstart - r2 <= t2.w_size - 262 && (t2.match_length = y(t2, r2), t2.match_length <= 5 && (t2.strategy === 1 || t2.match_length === 3 && t2.strstart - t2.match_start > 4096) && (t2.match_length = 2)), t2.prev_length >= 3 && t2.match_length <= t2.prev_length) {
            i2 = t2.strstart + t2.lookahead - 3, n2 = o._tr_tally(t2, t2.strstart - 1 - t2.prev_match, t2.prev_length - 3), t2.lookahead -= t2.prev_length - 1, t2.prev_length -= 2;
            do {
              ++t2.strstart <= i2 && (t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[t2.strstart + 3 - 1]) & t2.hash_mask, r2 = t2.prev[t2.strstart & t2.w_mask] = t2.head[t2.ins_h], t2.head[t2.ins_h] = t2.strstart);
            } while (--t2.prev_length != 0);
            if (t2.match_available = 0, t2.match_length = 2, t2.strstart++, n2 && (d(t2, false), t2.strm.avail_out === 0))
              return 1;
          } else if (t2.match_available) {
            if ((n2 = o._tr_tally(t2, 0, t2.window[t2.strstart - 1])) && d(t2, false), t2.strstart++, t2.lookahead--, t2.strm.avail_out === 0)
              return 1;
          } else
            t2.match_available = 1, t2.strstart++, t2.lookahead--;
        }
        return t2.match_available && (n2 = o._tr_tally(t2, 0, t2.window[t2.strstart - 1]), t2.match_available = 0), t2.insert = t2.strstart < 2 ? t2.strstart : 2, e2 === 4 ? (d(t2, true), t2.strm.avail_out === 0 ? 3 : 4) : t2.last_lit && (d(t2, false), t2.strm.avail_out === 0) ? 1 : 2;
      }
      function w(t2, e2, r2, n2, i2) {
        this.good_length = t2, this.max_lazy = e2, this.nice_length = r2, this.max_chain = n2, this.func = i2;
      }
      function _() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = 8, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new i.Buf16(1146), this.dyn_dtree = new i.Buf16(122), this.bl_tree = new i.Buf16(78), l(this.dyn_ltree), l(this.dyn_dtree), l(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new i.Buf16(16), this.heap = new i.Buf16(573), l(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new i.Buf16(573), l(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function k(t2) {
        var e2;
        return t2 && t2.state ? (t2.total_in = t2.total_out = 0, t2.data_type = 2, (e2 = t2.state).pending = 0, e2.pending_out = 0, e2.wrap < 0 && (e2.wrap = -e2.wrap), e2.status = e2.wrap ? 42 : 113, t2.adler = e2.wrap === 2 ? 0 : 1, e2.last_flush = 0, o._tr_init(e2), 0) : c(t2, -2);
      }
      function x(t2) {
        var e2, r2 = k(t2);
        return r2 === 0 && ((e2 = t2.state).window_size = 2 * e2.w_size, l(e2.head), e2.max_lazy_match = n[e2.level].max_lazy, e2.good_match = n[e2.level].good_length, e2.nice_match = n[e2.level].nice_length, e2.max_chain_length = n[e2.level].max_chain, e2.strstart = 0, e2.block_start = 0, e2.lookahead = 0, e2.insert = 0, e2.match_length = e2.prev_length = 2, e2.match_available = 0, e2.ins_h = 0), r2;
      }
      function S(t2, e2, r2, n2, o2, a2) {
        if (!t2)
          return -2;
        var s2 = 1;
        if (e2 === -1 && (e2 = 6), n2 < 0 ? (s2 = 0, n2 = -n2) : n2 > 15 && (s2 = 2, n2 -= 16), o2 < 1 || o2 > 9 || r2 !== 8 || n2 < 8 || n2 > 15 || e2 < 0 || e2 > 9 || a2 < 0 || a2 > 4)
          return c(t2, -2);
        n2 === 8 && (n2 = 9);
        var u2 = new _();
        return t2.state = u2, u2.strm = t2, u2.wrap = s2, u2.gzhead = null, u2.w_bits = n2, u2.w_size = 1 << u2.w_bits, u2.w_mask = u2.w_size - 1, u2.hash_bits = o2 + 7, u2.hash_size = 1 << u2.hash_bits, u2.hash_mask = u2.hash_size - 1, u2.hash_shift = ~~((u2.hash_bits + 3 - 1) / 3), u2.window = new i.Buf8(2 * u2.w_size), u2.head = new i.Buf16(u2.hash_size), u2.prev = new i.Buf16(u2.w_size), u2.lit_bufsize = 1 << o2 + 6, u2.pending_buf_size = 4 * u2.lit_bufsize, u2.pending_buf = new i.Buf8(u2.pending_buf_size), u2.d_buf = 1 * u2.lit_bufsize, u2.l_buf = 3 * u2.lit_bufsize, u2.level = e2, u2.strategy = a2, u2.method = r2, x(t2);
      }
      n = [new w(0, 0, 0, 0, function(t2, e2) {
        var r2 = 65535;
        for (r2 > t2.pending_buf_size - 5 && (r2 = t2.pending_buf_size - 5); ; ) {
          if (t2.lookahead <= 1) {
            if (b(t2), t2.lookahead === 0 && e2 === 0)
              return 1;
            if (t2.lookahead === 0)
              break;
          }
          t2.strstart += t2.lookahead, t2.lookahead = 0;
          var n2 = t2.block_start + r2;
          if ((t2.strstart === 0 || t2.strstart >= n2) && (t2.lookahead = t2.strstart - n2, t2.strstart = n2, d(t2, false), t2.strm.avail_out === 0))
            return 1;
          if (t2.strstart - t2.block_start >= t2.w_size - 262 && (d(t2, false), t2.strm.avail_out === 0))
            return 1;
        }
        return t2.insert = 0, e2 === 4 ? (d(t2, true), t2.strm.avail_out === 0 ? 3 : 4) : (t2.strstart > t2.block_start && (d(t2, false), t2.strm.avail_out), 1);
      }), new w(4, 4, 8, 4, v), new w(4, 5, 16, 8, v), new w(4, 6, 32, 32, v), new w(4, 4, 16, 16, g), new w(8, 16, 32, 32, g), new w(8, 16, 128, 128, g), new w(8, 32, 128, 256, g), new w(32, 128, 258, 1024, g), new w(32, 258, 258, 4096, g)], r.deflateInit = function(t2, e2) {
        return S(t2, e2, 8, 15, 8, 0);
      }, r.deflateInit2 = S, r.deflateReset = x, r.deflateResetKeep = k, r.deflateSetHeader = function(t2, e2) {
        return t2 && t2.state ? t2.state.wrap !== 2 ? -2 : (t2.state.gzhead = e2, 0) : -2;
      }, r.deflate = function(t2, e2) {
        var r2, i2, a2, u2;
        if (!t2 || !t2.state || e2 > 5 || e2 < 0)
          return t2 ? c(t2, -2) : -2;
        if (i2 = t2.state, !t2.output || !t2.input && t2.avail_in !== 0 || i2.status === 666 && e2 !== 4)
          return c(t2, t2.avail_out === 0 ? -5 : -2);
        if (i2.strm = t2, r2 = i2.last_flush, i2.last_flush = e2, i2.status === 42)
          if (i2.wrap === 2)
            t2.adler = 0, p(i2, 31), p(i2, 139), p(i2, 8), i2.gzhead ? (p(i2, (i2.gzhead.text ? 1 : 0) + (i2.gzhead.hcrc ? 2 : 0) + (i2.gzhead.extra ? 4 : 0) + (i2.gzhead.name ? 8 : 0) + (i2.gzhead.comment ? 16 : 0)), p(i2, 255 & i2.gzhead.time), p(i2, i2.gzhead.time >> 8 & 255), p(i2, i2.gzhead.time >> 16 & 255), p(i2, i2.gzhead.time >> 24 & 255), p(i2, i2.level === 9 ? 2 : i2.strategy >= 2 || i2.level < 2 ? 4 : 0), p(i2, 255 & i2.gzhead.os), i2.gzhead.extra && i2.gzhead.extra.length && (p(i2, 255 & i2.gzhead.extra.length), p(i2, i2.gzhead.extra.length >> 8 & 255)), i2.gzhead.hcrc && (t2.adler = s(t2.adler, i2.pending_buf, i2.pending, 0)), i2.gzindex = 0, i2.status = 69) : (p(i2, 0), p(i2, 0), p(i2, 0), p(i2, 0), p(i2, 0), p(i2, i2.level === 9 ? 2 : i2.strategy >= 2 || i2.level < 2 ? 4 : 0), p(i2, 3), i2.status = 113);
          else {
            var y2 = 8 + (i2.w_bits - 8 << 4) << 8;
            y2 |= (i2.strategy >= 2 || i2.level < 2 ? 0 : i2.level < 6 ? 1 : i2.level === 6 ? 2 : 3) << 6, i2.strstart !== 0 && (y2 |= 32), y2 += 31 - y2 % 31, i2.status = 113, m(i2, y2), i2.strstart !== 0 && (m(i2, t2.adler >>> 16), m(i2, 65535 & t2.adler)), t2.adler = 1;
          }
        if (i2.status === 69)
          if (i2.gzhead.extra) {
            for (a2 = i2.pending; i2.gzindex < (65535 & i2.gzhead.extra.length) && (i2.pending !== i2.pending_buf_size || (i2.gzhead.hcrc && i2.pending > a2 && (t2.adler = s(t2.adler, i2.pending_buf, i2.pending - a2, a2)), h(t2), a2 = i2.pending, i2.pending !== i2.pending_buf_size)); )
              p(i2, 255 & i2.gzhead.extra[i2.gzindex]), i2.gzindex++;
            i2.gzhead.hcrc && i2.pending > a2 && (t2.adler = s(t2.adler, i2.pending_buf, i2.pending - a2, a2)), i2.gzindex === i2.gzhead.extra.length && (i2.gzindex = 0, i2.status = 73);
          } else
            i2.status = 73;
        if (i2.status === 73)
          if (i2.gzhead.name) {
            a2 = i2.pending;
            do {
              if (i2.pending === i2.pending_buf_size && (i2.gzhead.hcrc && i2.pending > a2 && (t2.adler = s(t2.adler, i2.pending_buf, i2.pending - a2, a2)), h(t2), a2 = i2.pending, i2.pending === i2.pending_buf_size)) {
                u2 = 1;
                break;
              }
              u2 = i2.gzindex < i2.gzhead.name.length ? 255 & i2.gzhead.name.charCodeAt(i2.gzindex++) : 0, p(i2, u2);
            } while (u2 !== 0);
            i2.gzhead.hcrc && i2.pending > a2 && (t2.adler = s(t2.adler, i2.pending_buf, i2.pending - a2, a2)), u2 === 0 && (i2.gzindex = 0, i2.status = 91);
          } else
            i2.status = 91;
        if (i2.status === 91)
          if (i2.gzhead.comment) {
            a2 = i2.pending;
            do {
              if (i2.pending === i2.pending_buf_size && (i2.gzhead.hcrc && i2.pending > a2 && (t2.adler = s(t2.adler, i2.pending_buf, i2.pending - a2, a2)), h(t2), a2 = i2.pending, i2.pending === i2.pending_buf_size)) {
                u2 = 1;
                break;
              }
              u2 = i2.gzindex < i2.gzhead.comment.length ? 255 & i2.gzhead.comment.charCodeAt(i2.gzindex++) : 0, p(i2, u2);
            } while (u2 !== 0);
            i2.gzhead.hcrc && i2.pending > a2 && (t2.adler = s(t2.adler, i2.pending_buf, i2.pending - a2, a2)), u2 === 0 && (i2.status = 103);
          } else
            i2.status = 103;
        if (i2.status === 103 && (i2.gzhead.hcrc ? (i2.pending + 2 > i2.pending_buf_size && h(t2), i2.pending + 2 <= i2.pending_buf_size && (p(i2, 255 & t2.adler), p(i2, t2.adler >> 8 & 255), t2.adler = 0, i2.status = 113)) : i2.status = 113), i2.pending !== 0) {
          if (h(t2), t2.avail_out === 0)
            return i2.last_flush = -1, 0;
        } else if (t2.avail_in === 0 && f(e2) <= f(r2) && e2 !== 4)
          return c(t2, -5);
        if (i2.status === 666 && t2.avail_in !== 0)
          return c(t2, -5);
        if (t2.avail_in !== 0 || i2.lookahead !== 0 || e2 !== 0 && i2.status !== 666) {
          var v2 = i2.strategy === 2 ? function(t3, e3) {
            for (var r3; ; ) {
              if (t3.lookahead === 0 && (b(t3), t3.lookahead === 0)) {
                if (e3 === 0)
                  return 1;
                break;
              }
              if (t3.match_length = 0, r3 = o._tr_tally(t3, 0, t3.window[t3.strstart]), t3.lookahead--, t3.strstart++, r3 && (d(t3, false), t3.strm.avail_out === 0))
                return 1;
            }
            return t3.insert = 0, e3 === 4 ? (d(t3, true), t3.strm.avail_out === 0 ? 3 : 4) : t3.last_lit && (d(t3, false), t3.strm.avail_out === 0) ? 1 : 2;
          }(i2, e2) : i2.strategy === 3 ? function(t3, e3) {
            for (var r3, n2, i3, a3, s2 = t3.window; ; ) {
              if (t3.lookahead <= 258) {
                if (b(t3), t3.lookahead <= 258 && e3 === 0)
                  return 1;
                if (t3.lookahead === 0)
                  break;
              }
              if (t3.match_length = 0, t3.lookahead >= 3 && t3.strstart > 0 && (n2 = s2[i3 = t3.strstart - 1]) === s2[++i3] && n2 === s2[++i3] && n2 === s2[++i3]) {
                a3 = t3.strstart + 258;
                do {
                } while (n2 === s2[++i3] && n2 === s2[++i3] && n2 === s2[++i3] && n2 === s2[++i3] && n2 === s2[++i3] && n2 === s2[++i3] && n2 === s2[++i3] && n2 === s2[++i3] && i3 < a3);
                t3.match_length = 258 - (a3 - i3), t3.match_length > t3.lookahead && (t3.match_length = t3.lookahead);
              }
              if (t3.match_length >= 3 ? (r3 = o._tr_tally(t3, 1, t3.match_length - 3), t3.lookahead -= t3.match_length, t3.strstart += t3.match_length, t3.match_length = 0) : (r3 = o._tr_tally(t3, 0, t3.window[t3.strstart]), t3.lookahead--, t3.strstart++), r3 && (d(t3, false), t3.strm.avail_out === 0))
                return 1;
            }
            return t3.insert = 0, e3 === 4 ? (d(t3, true), t3.strm.avail_out === 0 ? 3 : 4) : t3.last_lit && (d(t3, false), t3.strm.avail_out === 0) ? 1 : 2;
          }(i2, e2) : n[i2.level].func(i2, e2);
          if (v2 !== 3 && v2 !== 4 || (i2.status = 666), v2 === 1 || v2 === 3)
            return t2.avail_out === 0 && (i2.last_flush = -1), 0;
          if (v2 === 2 && (e2 === 1 ? o._tr_align(i2) : e2 !== 5 && (o._tr_stored_block(i2, 0, 0, false), e2 === 3 && (l(i2.head), i2.lookahead === 0 && (i2.strstart = 0, i2.block_start = 0, i2.insert = 0))), h(t2), t2.avail_out === 0))
            return i2.last_flush = -1, 0;
        }
        return e2 !== 4 ? 0 : i2.wrap <= 0 ? 1 : (i2.wrap === 2 ? (p(i2, 255 & t2.adler), p(i2, t2.adler >> 8 & 255), p(i2, t2.adler >> 16 & 255), p(i2, t2.adler >> 24 & 255), p(i2, 255 & t2.total_in), p(i2, t2.total_in >> 8 & 255), p(i2, t2.total_in >> 16 & 255), p(i2, t2.total_in >> 24 & 255)) : (m(i2, t2.adler >>> 16), m(i2, 65535 & t2.adler)), h(t2), i2.wrap > 0 && (i2.wrap = -i2.wrap), i2.pending !== 0 ? 0 : 1);
      }, r.deflateEnd = function(t2) {
        var e2;
        return t2 && t2.state ? (e2 = t2.state.status) !== 42 && e2 !== 69 && e2 !== 73 && e2 !== 91 && e2 !== 103 && e2 !== 113 && e2 !== 666 ? c(t2, -2) : (t2.state = null, e2 === 113 ? c(t2, -3) : 0) : -2;
      }, r.deflateSetDictionary = function(t2, e2) {
        var r2, n2, o2, s2, u2, c2, f2, h2, d2 = e2.length;
        if (!t2 || !t2.state)
          return -2;
        if ((s2 = (r2 = t2.state).wrap) === 2 || s2 === 1 && r2.status !== 42 || r2.lookahead)
          return -2;
        for (s2 === 1 && (t2.adler = a(t2.adler, e2, d2, 0)), r2.wrap = 0, d2 >= r2.w_size && (s2 === 0 && (l(r2.head), r2.strstart = 0, r2.block_start = 0, r2.insert = 0), h2 = new i.Buf8(r2.w_size), i.arraySet(h2, e2, d2 - r2.w_size, r2.w_size, 0), e2 = h2, d2 = r2.w_size), u2 = t2.avail_in, c2 = t2.next_in, f2 = t2.input, t2.avail_in = d2, t2.next_in = 0, t2.input = e2, b(r2); r2.lookahead >= 3; ) {
          n2 = r2.strstart, o2 = r2.lookahead - 2;
          do {
            r2.ins_h = (r2.ins_h << r2.hash_shift ^ r2.window[n2 + 3 - 1]) & r2.hash_mask, r2.prev[n2 & r2.w_mask] = r2.head[r2.ins_h], r2.head[r2.ins_h] = n2, n2++;
          } while (--o2);
          r2.strstart = n2, r2.lookahead = 2, b(r2);
        }
        return r2.strstart += r2.lookahead, r2.block_start = r2.strstart, r2.insert = r2.lookahead, r2.lookahead = 0, r2.match_length = r2.prev_length = 2, r2.match_available = 0, t2.next_in = c2, t2.input = f2, t2.avail_in = u2, r2.wrap = s2, 0;
      }, r.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 442, "./adler32": 444, "./crc32": 446, "./messages": 452, "./trees": 453 }], 448: [function(t, e, r) {
      e.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
      };
    }, {}], 449: [function(t, e, r) {
      e.exports = function(t2, e2) {
        var r2, n, i, o, a, s, u, c, f, l, h, d, p, m, y, b, v, g, w, _, k, x, S, O, j;
        r2 = t2.state, n = t2.next_in, O = t2.input, i = n + (t2.avail_in - 5), o = t2.next_out, j = t2.output, a = o - (e2 - t2.avail_out), s = o + (t2.avail_out - 257), u = r2.dmax, c = r2.wsize, f = r2.whave, l = r2.wnext, h = r2.window, d = r2.hold, p = r2.bits, m = r2.lencode, y = r2.distcode, b = (1 << r2.lenbits) - 1, v = (1 << r2.distbits) - 1;
        t:
          do {
            p < 15 && (d += O[n++] << p, p += 8, d += O[n++] << p, p += 8), g = m[d & b];
            e:
              for (; ; ) {
                if (d >>>= w = g >>> 24, p -= w, (w = g >>> 16 & 255) === 0)
                  j[o++] = 65535 & g;
                else {
                  if (!(16 & w)) {
                    if ((64 & w) == 0) {
                      g = m[(65535 & g) + (d & (1 << w) - 1)];
                      continue e;
                    }
                    if (32 & w) {
                      r2.mode = 12;
                      break t;
                    }
                    t2.msg = "invalid literal/length code", r2.mode = 30;
                    break t;
                  }
                  _ = 65535 & g, (w &= 15) && (p < w && (d += O[n++] << p, p += 8), _ += d & (1 << w) - 1, d >>>= w, p -= w), p < 15 && (d += O[n++] << p, p += 8, d += O[n++] << p, p += 8), g = y[d & v];
                  r:
                    for (; ; ) {
                      if (d >>>= w = g >>> 24, p -= w, !(16 & (w = g >>> 16 & 255))) {
                        if ((64 & w) == 0) {
                          g = y[(65535 & g) + (d & (1 << w) - 1)];
                          continue r;
                        }
                        t2.msg = "invalid distance code", r2.mode = 30;
                        break t;
                      }
                      if (k = 65535 & g, p < (w &= 15) && (d += O[n++] << p, (p += 8) < w && (d += O[n++] << p, p += 8)), (k += d & (1 << w) - 1) > u) {
                        t2.msg = "invalid distance too far back", r2.mode = 30;
                        break t;
                      }
                      if (d >>>= w, p -= w, k > (w = o - a)) {
                        if ((w = k - w) > f && r2.sane) {
                          t2.msg = "invalid distance too far back", r2.mode = 30;
                          break t;
                        }
                        if (x = 0, S = h, l === 0) {
                          if (x += c - w, w < _) {
                            _ -= w;
                            do {
                              j[o++] = h[x++];
                            } while (--w);
                            x = o - k, S = j;
                          }
                        } else if (l < w) {
                          if (x += c + l - w, (w -= l) < _) {
                            _ -= w;
                            do {
                              j[o++] = h[x++];
                            } while (--w);
                            if (x = 0, l < _) {
                              _ -= w = l;
                              do {
                                j[o++] = h[x++];
                              } while (--w);
                              x = o - k, S = j;
                            }
                          }
                        } else if (x += l - w, w < _) {
                          _ -= w;
                          do {
                            j[o++] = h[x++];
                          } while (--w);
                          x = o - k, S = j;
                        }
                        for (; _ > 2; )
                          j[o++] = S[x++], j[o++] = S[x++], j[o++] = S[x++], _ -= 3;
                        _ && (j[o++] = S[x++], _ > 1 && (j[o++] = S[x++]));
                      } else {
                        x = o - k;
                        do {
                          j[o++] = j[x++], j[o++] = j[x++], j[o++] = j[x++], _ -= 3;
                        } while (_ > 2);
                        _ && (j[o++] = j[x++], _ > 1 && (j[o++] = j[x++]));
                      }
                      break;
                    }
                }
                break;
              }
          } while (n < i && o < s);
        n -= _ = p >> 3, d &= (1 << (p -= _ << 3)) - 1, t2.next_in = n, t2.next_out = o, t2.avail_in = n < i ? i - n + 5 : 5 - (n - i), t2.avail_out = o < s ? s - o + 257 : 257 - (o - s), r2.hold = d, r2.bits = p;
      };
    }, {}], 450: [function(t, e, r) {
      var n = t("../utils/common"), i = t("./adler32"), o = t("./crc32"), a = t("./inffast"), s = t("./inftrees");
      function u(t2) {
        return (t2 >>> 24 & 255) + (t2 >>> 8 & 65280) + ((65280 & t2) << 8) + ((255 & t2) << 24);
      }
      function c() {
        this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new n.Buf16(320), this.work = new n.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function f(t2) {
        var e2;
        return t2 && t2.state ? (e2 = t2.state, t2.total_in = t2.total_out = e2.total = 0, t2.msg = "", e2.wrap && (t2.adler = 1 & e2.wrap), e2.mode = 1, e2.last = 0, e2.havedict = 0, e2.dmax = 32768, e2.head = null, e2.hold = 0, e2.bits = 0, e2.lencode = e2.lendyn = new n.Buf32(852), e2.distcode = e2.distdyn = new n.Buf32(592), e2.sane = 1, e2.back = -1, 0) : -2;
      }
      function l(t2) {
        var e2;
        return t2 && t2.state ? ((e2 = t2.state).wsize = 0, e2.whave = 0, e2.wnext = 0, f(t2)) : -2;
      }
      function h(t2, e2) {
        var r2, n2;
        return t2 && t2.state ? (n2 = t2.state, e2 < 0 ? (r2 = 0, e2 = -e2) : (r2 = 1 + (e2 >> 4), e2 < 48 && (e2 &= 15)), e2 && (e2 < 8 || e2 > 15) ? -2 : (n2.window !== null && n2.wbits !== e2 && (n2.window = null), n2.wrap = r2, n2.wbits = e2, l(t2))) : -2;
      }
      function d(t2, e2) {
        var r2, n2;
        return t2 ? (n2 = new c(), t2.state = n2, n2.window = null, (r2 = h(t2, e2)) !== 0 && (t2.state = null), r2) : -2;
      }
      var p, m, y = true;
      function b(t2) {
        if (y) {
          var e2;
          for (p = new n.Buf32(512), m = new n.Buf32(32), e2 = 0; e2 < 144; )
            t2.lens[e2++] = 8;
          for (; e2 < 256; )
            t2.lens[e2++] = 9;
          for (; e2 < 280; )
            t2.lens[e2++] = 7;
          for (; e2 < 288; )
            t2.lens[e2++] = 8;
          for (s(1, t2.lens, 0, 288, p, 0, t2.work, { bits: 9 }), e2 = 0; e2 < 32; )
            t2.lens[e2++] = 5;
          s(2, t2.lens, 0, 32, m, 0, t2.work, { bits: 5 }), y = false;
        }
        t2.lencode = p, t2.lenbits = 9, t2.distcode = m, t2.distbits = 5;
      }
      function v(t2, e2, r2, i2) {
        var o2, a2 = t2.state;
        return a2.window === null && (a2.wsize = 1 << a2.wbits, a2.wnext = 0, a2.whave = 0, a2.window = new n.Buf8(a2.wsize)), i2 >= a2.wsize ? (n.arraySet(a2.window, e2, r2 - a2.wsize, a2.wsize, 0), a2.wnext = 0, a2.whave = a2.wsize) : ((o2 = a2.wsize - a2.wnext) > i2 && (o2 = i2), n.arraySet(a2.window, e2, r2 - i2, o2, a2.wnext), (i2 -= o2) ? (n.arraySet(a2.window, e2, r2 - i2, i2, 0), a2.wnext = i2, a2.whave = a2.wsize) : (a2.wnext += o2, a2.wnext === a2.wsize && (a2.wnext = 0), a2.whave < a2.wsize && (a2.whave += o2))), 0;
      }
      r.inflateReset = l, r.inflateReset2 = h, r.inflateResetKeep = f, r.inflateInit = function(t2) {
        return d(t2, 15);
      }, r.inflateInit2 = d, r.inflate = function(t2, e2) {
        var r2, c2, f2, l2, h2, d2, p2, m2, y2, g, w, _, k, x, S, O, j, E, R, T, C, P, M, A, I = 0, N = new n.Buf8(4), D = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!t2 || !t2.state || !t2.output || !t2.input && t2.avail_in !== 0)
          return -2;
        (r2 = t2.state).mode === 12 && (r2.mode = 13), h2 = t2.next_out, f2 = t2.output, p2 = t2.avail_out, l2 = t2.next_in, c2 = t2.input, d2 = t2.avail_in, m2 = r2.hold, y2 = r2.bits, g = d2, w = p2, P = 0;
        t:
          for (; ; )
            switch (r2.mode) {
              case 1:
                if (r2.wrap === 0) {
                  r2.mode = 13;
                  break;
                }
                for (; y2 < 16; ) {
                  if (d2 === 0)
                    break t;
                  d2--, m2 += c2[l2++] << y2, y2 += 8;
                }
                if (2 & r2.wrap && m2 === 35615) {
                  r2.check = 0, N[0] = 255 & m2, N[1] = m2 >>> 8 & 255, r2.check = o(r2.check, N, 2, 0), m2 = 0, y2 = 0, r2.mode = 2;
                  break;
                }
                if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & m2) << 8) + (m2 >> 8)) % 31) {
                  t2.msg = "incorrect header check", r2.mode = 30;
                  break;
                }
                if ((15 & m2) != 8) {
                  t2.msg = "unknown compression method", r2.mode = 30;
                  break;
                }
                if (y2 -= 4, C = 8 + (15 & (m2 >>>= 4)), r2.wbits === 0)
                  r2.wbits = C;
                else if (C > r2.wbits) {
                  t2.msg = "invalid window size", r2.mode = 30;
                  break;
                }
                r2.dmax = 1 << C, t2.adler = r2.check = 1, r2.mode = 512 & m2 ? 10 : 12, m2 = 0, y2 = 0;
                break;
              case 2:
                for (; y2 < 16; ) {
                  if (d2 === 0)
                    break t;
                  d2--, m2 += c2[l2++] << y2, y2 += 8;
                }
                if (r2.flags = m2, (255 & r2.flags) != 8) {
                  t2.msg = "unknown compression method", r2.mode = 30;
                  break;
                }
                if (57344 & r2.flags) {
                  t2.msg = "unknown header flags set", r2.mode = 30;
                  break;
                }
                r2.head && (r2.head.text = m2 >> 8 & 1), 512 & r2.flags && (N[0] = 255 & m2, N[1] = m2 >>> 8 & 255, r2.check = o(r2.check, N, 2, 0)), m2 = 0, y2 = 0, r2.mode = 3;
              case 3:
                for (; y2 < 32; ) {
                  if (d2 === 0)
                    break t;
                  d2--, m2 += c2[l2++] << y2, y2 += 8;
                }
                r2.head && (r2.head.time = m2), 512 & r2.flags && (N[0] = 255 & m2, N[1] = m2 >>> 8 & 255, N[2] = m2 >>> 16 & 255, N[3] = m2 >>> 24 & 255, r2.check = o(r2.check, N, 4, 0)), m2 = 0, y2 = 0, r2.mode = 4;
              case 4:
                for (; y2 < 16; ) {
                  if (d2 === 0)
                    break t;
                  d2--, m2 += c2[l2++] << y2, y2 += 8;
                }
                r2.head && (r2.head.xflags = 255 & m2, r2.head.os = m2 >> 8), 512 & r2.flags && (N[0] = 255 & m2, N[1] = m2 >>> 8 & 255, r2.check = o(r2.check, N, 2, 0)), m2 = 0, y2 = 0, r2.mode = 5;
              case 5:
                if (1024 & r2.flags) {
                  for (; y2 < 16; ) {
                    if (d2 === 0)
                      break t;
                    d2--, m2 += c2[l2++] << y2, y2 += 8;
                  }
                  r2.length = m2, r2.head && (r2.head.extra_len = m2), 512 & r2.flags && (N[0] = 255 & m2, N[1] = m2 >>> 8 & 255, r2.check = o(r2.check, N, 2, 0)), m2 = 0, y2 = 0;
                } else
                  r2.head && (r2.head.extra = null);
                r2.mode = 6;
              case 6:
                if (1024 & r2.flags && ((_ = r2.length) > d2 && (_ = d2), _ && (r2.head && (C = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)), n.arraySet(r2.head.extra, c2, l2, _, C)), 512 & r2.flags && (r2.check = o(r2.check, c2, _, l2)), d2 -= _, l2 += _, r2.length -= _), r2.length))
                  break t;
                r2.length = 0, r2.mode = 7;
              case 7:
                if (2048 & r2.flags) {
                  if (d2 === 0)
                    break t;
                  _ = 0;
                  do {
                    C = c2[l2 + _++], r2.head && C && r2.length < 65536 && (r2.head.name += String.fromCharCode(C));
                  } while (C && _ < d2);
                  if (512 & r2.flags && (r2.check = o(r2.check, c2, _, l2)), d2 -= _, l2 += _, C)
                    break t;
                } else
                  r2.head && (r2.head.name = null);
                r2.length = 0, r2.mode = 8;
              case 8:
                if (4096 & r2.flags) {
                  if (d2 === 0)
                    break t;
                  _ = 0;
                  do {
                    C = c2[l2 + _++], r2.head && C && r2.length < 65536 && (r2.head.comment += String.fromCharCode(C));
                  } while (C && _ < d2);
                  if (512 & r2.flags && (r2.check = o(r2.check, c2, _, l2)), d2 -= _, l2 += _, C)
                    break t;
                } else
                  r2.head && (r2.head.comment = null);
                r2.mode = 9;
              case 9:
                if (512 & r2.flags) {
                  for (; y2 < 16; ) {
                    if (d2 === 0)
                      break t;
                    d2--, m2 += c2[l2++] << y2, y2 += 8;
                  }
                  if (m2 !== (65535 & r2.check)) {
                    t2.msg = "header crc mismatch", r2.mode = 30;
                    break;
                  }
                  m2 = 0, y2 = 0;
                }
                r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), t2.adler = r2.check = 0, r2.mode = 12;
                break;
              case 10:
                for (; y2 < 32; ) {
                  if (d2 === 0)
                    break t;
                  d2--, m2 += c2[l2++] << y2, y2 += 8;
                }
                t2.adler = r2.check = u(m2), m2 = 0, y2 = 0, r2.mode = 11;
              case 11:
                if (r2.havedict === 0)
                  return t2.next_out = h2, t2.avail_out = p2, t2.next_in = l2, t2.avail_in = d2, r2.hold = m2, r2.bits = y2, 2;
                t2.adler = r2.check = 1, r2.mode = 12;
              case 12:
                if (e2 === 5 || e2 === 6)
                  break t;
              case 13:
                if (r2.last) {
                  m2 >>>= 7 & y2, y2 -= 7 & y2, r2.mode = 27;
                  break;
                }
                for (; y2 < 3; ) {
                  if (d2 === 0)
                    break t;
                  d2--, m2 += c2[l2++] << y2, y2 += 8;
                }
                switch (r2.last = 1 & m2, y2 -= 1, 3 & (m2 >>>= 1)) {
                  case 0:
                    r2.mode = 14;
                    break;
                  case 1:
                    if (b(r2), r2.mode = 20, e2 === 6) {
                      m2 >>>= 2, y2 -= 2;
                      break t;
                    }
                    break;
                  case 2:
                    r2.mode = 17;
                    break;
                  case 3:
                    t2.msg = "invalid block type", r2.mode = 30;
                }
                m2 >>>= 2, y2 -= 2;
                break;
              case 14:
                for (m2 >>>= 7 & y2, y2 -= 7 & y2; y2 < 32; ) {
                  if (d2 === 0)
                    break t;
                  d2--, m2 += c2[l2++] << y2, y2 += 8;
                }
                if ((65535 & m2) != (m2 >>> 16 ^ 65535)) {
                  t2.msg = "invalid stored block lengths", r2.mode = 30;
                  break;
                }
                if (r2.length = 65535 & m2, m2 = 0, y2 = 0, r2.mode = 15, e2 === 6)
                  break t;
              case 15:
                r2.mode = 16;
              case 16:
                if (_ = r2.length) {
                  if (_ > d2 && (_ = d2), _ > p2 && (_ = p2), _ === 0)
                    break t;
                  n.arraySet(f2, c2, l2, _, h2), d2 -= _, l2 += _, p2 -= _, h2 += _, r2.length -= _;
                  break;
                }
                r2.mode = 12;
                break;
              case 17:
                for (; y2 < 14; ) {
                  if (d2 === 0)
                    break t;
                  d2--, m2 += c2[l2++] << y2, y2 += 8;
                }
                if (r2.nlen = 257 + (31 & m2), m2 >>>= 5, y2 -= 5, r2.ndist = 1 + (31 & m2), m2 >>>= 5, y2 -= 5, r2.ncode = 4 + (15 & m2), m2 >>>= 4, y2 -= 4, r2.nlen > 286 || r2.ndist > 30) {
                  t2.msg = "too many length or distance symbols", r2.mode = 30;
                  break;
                }
                r2.have = 0, r2.mode = 18;
              case 18:
                for (; r2.have < r2.ncode; ) {
                  for (; y2 < 3; ) {
                    if (d2 === 0)
                      break t;
                    d2--, m2 += c2[l2++] << y2, y2 += 8;
                  }
                  r2.lens[D[r2.have++]] = 7 & m2, m2 >>>= 3, y2 -= 3;
                }
                for (; r2.have < 19; )
                  r2.lens[D[r2.have++]] = 0;
                if (r2.lencode = r2.lendyn, r2.lenbits = 7, M = { bits: r2.lenbits }, P = s(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, M), r2.lenbits = M.bits, P) {
                  t2.msg = "invalid code lengths set", r2.mode = 30;
                  break;
                }
                r2.have = 0, r2.mode = 19;
              case 19:
                for (; r2.have < r2.nlen + r2.ndist; ) {
                  for (; O = (I = r2.lencode[m2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, j = 65535 & I, !((S = I >>> 24) <= y2); ) {
                    if (d2 === 0)
                      break t;
                    d2--, m2 += c2[l2++] << y2, y2 += 8;
                  }
                  if (j < 16)
                    m2 >>>= S, y2 -= S, r2.lens[r2.have++] = j;
                  else {
                    if (j === 16) {
                      for (A = S + 2; y2 < A; ) {
                        if (d2 === 0)
                          break t;
                        d2--, m2 += c2[l2++] << y2, y2 += 8;
                      }
                      if (m2 >>>= S, y2 -= S, r2.have === 0) {
                        t2.msg = "invalid bit length repeat", r2.mode = 30;
                        break;
                      }
                      C = r2.lens[r2.have - 1], _ = 3 + (3 & m2), m2 >>>= 2, y2 -= 2;
                    } else if (j === 17) {
                      for (A = S + 3; y2 < A; ) {
                        if (d2 === 0)
                          break t;
                        d2--, m2 += c2[l2++] << y2, y2 += 8;
                      }
                      y2 -= S, C = 0, _ = 3 + (7 & (m2 >>>= S)), m2 >>>= 3, y2 -= 3;
                    } else {
                      for (A = S + 7; y2 < A; ) {
                        if (d2 === 0)
                          break t;
                        d2--, m2 += c2[l2++] << y2, y2 += 8;
                      }
                      y2 -= S, C = 0, _ = 11 + (127 & (m2 >>>= S)), m2 >>>= 7, y2 -= 7;
                    }
                    if (r2.have + _ > r2.nlen + r2.ndist) {
                      t2.msg = "invalid bit length repeat", r2.mode = 30;
                      break;
                    }
                    for (; _--; )
                      r2.lens[r2.have++] = C;
                  }
                }
                if (r2.mode === 30)
                  break;
                if (r2.lens[256] === 0) {
                  t2.msg = "invalid code -- missing end-of-block", r2.mode = 30;
                  break;
                }
                if (r2.lenbits = 9, M = { bits: r2.lenbits }, P = s(1, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, M), r2.lenbits = M.bits, P) {
                  t2.msg = "invalid literal/lengths set", r2.mode = 30;
                  break;
                }
                if (r2.distbits = 6, r2.distcode = r2.distdyn, M = { bits: r2.distbits }, P = s(2, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, M), r2.distbits = M.bits, P) {
                  t2.msg = "invalid distances set", r2.mode = 30;
                  break;
                }
                if (r2.mode = 20, e2 === 6)
                  break t;
              case 20:
                r2.mode = 21;
              case 21:
                if (d2 >= 6 && p2 >= 258) {
                  t2.next_out = h2, t2.avail_out = p2, t2.next_in = l2, t2.avail_in = d2, r2.hold = m2, r2.bits = y2, a(t2, w), h2 = t2.next_out, f2 = t2.output, p2 = t2.avail_out, l2 = t2.next_in, c2 = t2.input, d2 = t2.avail_in, m2 = r2.hold, y2 = r2.bits, r2.mode === 12 && (r2.back = -1);
                  break;
                }
                for (r2.back = 0; O = (I = r2.lencode[m2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, j = 65535 & I, !((S = I >>> 24) <= y2); ) {
                  if (d2 === 0)
                    break t;
                  d2--, m2 += c2[l2++] << y2, y2 += 8;
                }
                if (O && (240 & O) == 0) {
                  for (E = S, R = O, T = j; O = (I = r2.lencode[T + ((m2 & (1 << E + R) - 1) >> E)]) >>> 16 & 255, j = 65535 & I, !(E + (S = I >>> 24) <= y2); ) {
                    if (d2 === 0)
                      break t;
                    d2--, m2 += c2[l2++] << y2, y2 += 8;
                  }
                  m2 >>>= E, y2 -= E, r2.back += E;
                }
                if (m2 >>>= S, y2 -= S, r2.back += S, r2.length = j, O === 0) {
                  r2.mode = 26;
                  break;
                }
                if (32 & O) {
                  r2.back = -1, r2.mode = 12;
                  break;
                }
                if (64 & O) {
                  t2.msg = "invalid literal/length code", r2.mode = 30;
                  break;
                }
                r2.extra = 15 & O, r2.mode = 22;
              case 22:
                if (r2.extra) {
                  for (A = r2.extra; y2 < A; ) {
                    if (d2 === 0)
                      break t;
                    d2--, m2 += c2[l2++] << y2, y2 += 8;
                  }
                  r2.length += m2 & (1 << r2.extra) - 1, m2 >>>= r2.extra, y2 -= r2.extra, r2.back += r2.extra;
                }
                r2.was = r2.length, r2.mode = 23;
              case 23:
                for (; O = (I = r2.distcode[m2 & (1 << r2.distbits) - 1]) >>> 16 & 255, j = 65535 & I, !((S = I >>> 24) <= y2); ) {
                  if (d2 === 0)
                    break t;
                  d2--, m2 += c2[l2++] << y2, y2 += 8;
                }
                if ((240 & O) == 0) {
                  for (E = S, R = O, T = j; O = (I = r2.distcode[T + ((m2 & (1 << E + R) - 1) >> E)]) >>> 16 & 255, j = 65535 & I, !(E + (S = I >>> 24) <= y2); ) {
                    if (d2 === 0)
                      break t;
                    d2--, m2 += c2[l2++] << y2, y2 += 8;
                  }
                  m2 >>>= E, y2 -= E, r2.back += E;
                }
                if (m2 >>>= S, y2 -= S, r2.back += S, 64 & O) {
                  t2.msg = "invalid distance code", r2.mode = 30;
                  break;
                }
                r2.offset = j, r2.extra = 15 & O, r2.mode = 24;
              case 24:
                if (r2.extra) {
                  for (A = r2.extra; y2 < A; ) {
                    if (d2 === 0)
                      break t;
                    d2--, m2 += c2[l2++] << y2, y2 += 8;
                  }
                  r2.offset += m2 & (1 << r2.extra) - 1, m2 >>>= r2.extra, y2 -= r2.extra, r2.back += r2.extra;
                }
                if (r2.offset > r2.dmax) {
                  t2.msg = "invalid distance too far back", r2.mode = 30;
                  break;
                }
                r2.mode = 25;
              case 25:
                if (p2 === 0)
                  break t;
                if (_ = w - p2, r2.offset > _) {
                  if ((_ = r2.offset - _) > r2.whave && r2.sane) {
                    t2.msg = "invalid distance too far back", r2.mode = 30;
                    break;
                  }
                  _ > r2.wnext ? (_ -= r2.wnext, k = r2.wsize - _) : k = r2.wnext - _, _ > r2.length && (_ = r2.length), x = r2.window;
                } else
                  x = f2, k = h2 - r2.offset, _ = r2.length;
                _ > p2 && (_ = p2), p2 -= _, r2.length -= _;
                do {
                  f2[h2++] = x[k++];
                } while (--_);
                r2.length === 0 && (r2.mode = 21);
                break;
              case 26:
                if (p2 === 0)
                  break t;
                f2[h2++] = r2.length, p2--, r2.mode = 21;
                break;
              case 27:
                if (r2.wrap) {
                  for (; y2 < 32; ) {
                    if (d2 === 0)
                      break t;
                    d2--, m2 |= c2[l2++] << y2, y2 += 8;
                  }
                  if (w -= p2, t2.total_out += w, r2.total += w, w && (t2.adler = r2.check = r2.flags ? o(r2.check, f2, w, h2 - w) : i(r2.check, f2, w, h2 - w)), w = p2, (r2.flags ? m2 : u(m2)) !== r2.check) {
                    t2.msg = "incorrect data check", r2.mode = 30;
                    break;
                  }
                  m2 = 0, y2 = 0;
                }
                r2.mode = 28;
              case 28:
                if (r2.wrap && r2.flags) {
                  for (; y2 < 32; ) {
                    if (d2 === 0)
                      break t;
                    d2--, m2 += c2[l2++] << y2, y2 += 8;
                  }
                  if (m2 !== (4294967295 & r2.total)) {
                    t2.msg = "incorrect length check", r2.mode = 30;
                    break;
                  }
                  m2 = 0, y2 = 0;
                }
                r2.mode = 29;
              case 29:
                P = 1;
                break t;
              case 30:
                P = -3;
                break t;
              case 31:
                return -4;
              case 32:
              default:
                return -2;
            }
        return t2.next_out = h2, t2.avail_out = p2, t2.next_in = l2, t2.avail_in = d2, r2.hold = m2, r2.bits = y2, (r2.wsize || w !== t2.avail_out && r2.mode < 30 && (r2.mode < 27 || e2 !== 4)) && v(t2, t2.output, t2.next_out, w - t2.avail_out) ? (r2.mode = 31, -4) : (g -= t2.avail_in, w -= t2.avail_out, t2.total_in += g, t2.total_out += w, r2.total += w, r2.wrap && w && (t2.adler = r2.check = r2.flags ? o(r2.check, f2, w, t2.next_out - w) : i(r2.check, f2, w, t2.next_out - w)), t2.data_type = r2.bits + (r2.last ? 64 : 0) + (r2.mode === 12 ? 128 : 0) + (r2.mode === 20 || r2.mode === 15 ? 256 : 0), (g === 0 && w === 0 || e2 === 4) && P === 0 && (P = -5), P);
      }, r.inflateEnd = function(t2) {
        if (!t2 || !t2.state)
          return -2;
        var e2 = t2.state;
        return e2.window && (e2.window = null), t2.state = null, 0;
      }, r.inflateGetHeader = function(t2, e2) {
        var r2;
        return t2 && t2.state ? (2 & (r2 = t2.state).wrap) == 0 ? -2 : (r2.head = e2, e2.done = false, 0) : -2;
      }, r.inflateSetDictionary = function(t2, e2) {
        var r2, n2 = e2.length;
        return t2 && t2.state ? (r2 = t2.state).wrap !== 0 && r2.mode !== 11 ? -2 : r2.mode === 11 && i(1, e2, n2, 0) !== r2.check ? -3 : v(t2, e2, n2, n2) ? (r2.mode = 31, -4) : (r2.havedict = 1, 0) : -2;
      }, r.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 442, "./adler32": 444, "./crc32": 446, "./inffast": 449, "./inftrees": 451 }], 451: [function(t, e, r) {
      var n = t("../utils/common"), i = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], o = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], a = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], s = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      e.exports = function(t2, e2, r2, u, c, f, l, h) {
        var d, p, m, y, b, v, g, w, _, k = h.bits, x = 0, S = 0, O = 0, j = 0, E = 0, R = 0, T = 0, C = 0, P = 0, M = 0, A = null, I = 0, N = new n.Buf16(16), D = new n.Buf16(16), B = null, F = 0;
        for (x = 0; x <= 15; x++)
          N[x] = 0;
        for (S = 0; S < u; S++)
          N[e2[r2 + S]]++;
        for (E = k, j = 15; j >= 1 && N[j] === 0; j--)
          ;
        if (E > j && (E = j), j === 0)
          return c[f++] = 20971520, c[f++] = 20971520, h.bits = 1, 0;
        for (O = 1; O < j && N[O] === 0; O++)
          ;
        for (E < O && (E = O), C = 1, x = 1; x <= 15; x++)
          if (C <<= 1, (C -= N[x]) < 0)
            return -1;
        if (C > 0 && (t2 === 0 || j !== 1))
          return -1;
        for (D[1] = 0, x = 1; x < 15; x++)
          D[x + 1] = D[x] + N[x];
        for (S = 0; S < u; S++)
          e2[r2 + S] !== 0 && (l[D[e2[r2 + S]]++] = S);
        if (t2 === 0 ? (A = B = l, v = 19) : t2 === 1 ? (A = i, I -= 257, B = o, F -= 257, v = 256) : (A = a, B = s, v = -1), M = 0, S = 0, x = O, b = f, R = E, T = 0, m = -1, y = (P = 1 << E) - 1, t2 === 1 && P > 852 || t2 === 2 && P > 592)
          return 1;
        for (; ; ) {
          g = x - T, l[S] < v ? (w = 0, _ = l[S]) : l[S] > v ? (w = B[F + l[S]], _ = A[I + l[S]]) : (w = 96, _ = 0), d = 1 << x - T, O = p = 1 << R;
          do {
            c[b + (M >> T) + (p -= d)] = g << 24 | w << 16 | _ | 0;
          } while (p !== 0);
          for (d = 1 << x - 1; M & d; )
            d >>= 1;
          if (d !== 0 ? (M &= d - 1, M += d) : M = 0, S++, --N[x] == 0) {
            if (x === j)
              break;
            x = e2[r2 + l[S]];
          }
          if (x > E && (M & y) !== m) {
            for (T === 0 && (T = E), b += O, C = 1 << (R = x - T); R + T < j && !((C -= N[R + T]) <= 0); )
              R++, C <<= 1;
            if (P += 1 << R, t2 === 1 && P > 852 || t2 === 2 && P > 592)
              return 1;
            c[m = M & y] = E << 24 | R << 16 | b - f | 0;
          }
        }
        return M !== 0 && (c[b + M] = x - T << 24 | 64 << 16 | 0), h.bits = E, 0;
      };
    }, { "../utils/common": 442 }], 452: [function(t, e, r) {
      e.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 453: [function(t, e, r) {
      var n = t("../utils/common");
      function i(t2) {
        for (var e2 = t2.length; --e2 >= 0; )
          t2[e2] = 0;
      }
      var o = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], a = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], s = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], u = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], c = new Array(576);
      i(c);
      var f = new Array(60);
      i(f);
      var l = new Array(512);
      i(l);
      var h = new Array(256);
      i(h);
      var d = new Array(29);
      i(d);
      var p, m, y, b = new Array(30);
      function v(t2, e2, r2, n2, i2) {
        this.static_tree = t2, this.extra_bits = e2, this.extra_base = r2, this.elems = n2, this.max_length = i2, this.has_stree = t2 && t2.length;
      }
      function g(t2, e2) {
        this.dyn_tree = t2, this.max_code = 0, this.stat_desc = e2;
      }
      function w(t2) {
        return t2 < 256 ? l[t2] : l[256 + (t2 >>> 7)];
      }
      function _(t2, e2) {
        t2.pending_buf[t2.pending++] = 255 & e2, t2.pending_buf[t2.pending++] = e2 >>> 8 & 255;
      }
      function k(t2, e2, r2) {
        t2.bi_valid > 16 - r2 ? (t2.bi_buf |= e2 << t2.bi_valid & 65535, _(t2, t2.bi_buf), t2.bi_buf = e2 >> 16 - t2.bi_valid, t2.bi_valid += r2 - 16) : (t2.bi_buf |= e2 << t2.bi_valid & 65535, t2.bi_valid += r2);
      }
      function x(t2, e2, r2) {
        k(t2, r2[2 * e2], r2[2 * e2 + 1]);
      }
      function S(t2, e2) {
        var r2 = 0;
        do {
          r2 |= 1 & t2, t2 >>>= 1, r2 <<= 1;
        } while (--e2 > 0);
        return r2 >>> 1;
      }
      function O(t2, e2, r2) {
        var n2, i2, o2 = new Array(16), a2 = 0;
        for (n2 = 1; n2 <= 15; n2++)
          o2[n2] = a2 = a2 + r2[n2 - 1] << 1;
        for (i2 = 0; i2 <= e2; i2++) {
          var s2 = t2[2 * i2 + 1];
          s2 !== 0 && (t2[2 * i2] = S(o2[s2]++, s2));
        }
      }
      function j(t2) {
        var e2;
        for (e2 = 0; e2 < 286; e2++)
          t2.dyn_ltree[2 * e2] = 0;
        for (e2 = 0; e2 < 30; e2++)
          t2.dyn_dtree[2 * e2] = 0;
        for (e2 = 0; e2 < 19; e2++)
          t2.bl_tree[2 * e2] = 0;
        t2.dyn_ltree[512] = 1, t2.opt_len = t2.static_len = 0, t2.last_lit = t2.matches = 0;
      }
      function E(t2) {
        t2.bi_valid > 8 ? _(t2, t2.bi_buf) : t2.bi_valid > 0 && (t2.pending_buf[t2.pending++] = t2.bi_buf), t2.bi_buf = 0, t2.bi_valid = 0;
      }
      function R(t2, e2, r2, n2) {
        var i2 = 2 * e2, o2 = 2 * r2;
        return t2[i2] < t2[o2] || t2[i2] === t2[o2] && n2[e2] <= n2[r2];
      }
      function T(t2, e2, r2) {
        for (var n2 = t2.heap[r2], i2 = r2 << 1; i2 <= t2.heap_len && (i2 < t2.heap_len && R(e2, t2.heap[i2 + 1], t2.heap[i2], t2.depth) && i2++, !R(e2, n2, t2.heap[i2], t2.depth)); )
          t2.heap[r2] = t2.heap[i2], r2 = i2, i2 <<= 1;
        t2.heap[r2] = n2;
      }
      function C(t2, e2, r2) {
        var n2, i2, s2, u2, c2 = 0;
        if (t2.last_lit !== 0)
          do {
            n2 = t2.pending_buf[t2.d_buf + 2 * c2] << 8 | t2.pending_buf[t2.d_buf + 2 * c2 + 1], i2 = t2.pending_buf[t2.l_buf + c2], c2++, n2 === 0 ? x(t2, i2, e2) : (x(t2, (s2 = h[i2]) + 256 + 1, e2), (u2 = o[s2]) !== 0 && k(t2, i2 -= d[s2], u2), x(t2, s2 = w(--n2), r2), (u2 = a[s2]) !== 0 && k(t2, n2 -= b[s2], u2));
          } while (c2 < t2.last_lit);
        x(t2, 256, e2);
      }
      function P(t2, e2) {
        var r2, n2, i2, o2 = e2.dyn_tree, a2 = e2.stat_desc.static_tree, s2 = e2.stat_desc.has_stree, u2 = e2.stat_desc.elems, c2 = -1;
        for (t2.heap_len = 0, t2.heap_max = 573, r2 = 0; r2 < u2; r2++)
          o2[2 * r2] !== 0 ? (t2.heap[++t2.heap_len] = c2 = r2, t2.depth[r2] = 0) : o2[2 * r2 + 1] = 0;
        for (; t2.heap_len < 2; )
          o2[2 * (i2 = t2.heap[++t2.heap_len] = c2 < 2 ? ++c2 : 0)] = 1, t2.depth[i2] = 0, t2.opt_len--, s2 && (t2.static_len -= a2[2 * i2 + 1]);
        for (e2.max_code = c2, r2 = t2.heap_len >> 1; r2 >= 1; r2--)
          T(t2, o2, r2);
        i2 = u2;
        do {
          r2 = t2.heap[1], t2.heap[1] = t2.heap[t2.heap_len--], T(t2, o2, 1), n2 = t2.heap[1], t2.heap[--t2.heap_max] = r2, t2.heap[--t2.heap_max] = n2, o2[2 * i2] = o2[2 * r2] + o2[2 * n2], t2.depth[i2] = (t2.depth[r2] >= t2.depth[n2] ? t2.depth[r2] : t2.depth[n2]) + 1, o2[2 * r2 + 1] = o2[2 * n2 + 1] = i2, t2.heap[1] = i2++, T(t2, o2, 1);
        } while (t2.heap_len >= 2);
        t2.heap[--t2.heap_max] = t2.heap[1], function(t3, e3) {
          var r3, n3, i3, o3, a3, s3, u3 = e3.dyn_tree, c3 = e3.max_code, f2 = e3.stat_desc.static_tree, l2 = e3.stat_desc.has_stree, h2 = e3.stat_desc.extra_bits, d2 = e3.stat_desc.extra_base, p2 = e3.stat_desc.max_length, m2 = 0;
          for (o3 = 0; o3 <= 15; o3++)
            t3.bl_count[o3] = 0;
          for (u3[2 * t3.heap[t3.heap_max] + 1] = 0, r3 = t3.heap_max + 1; r3 < 573; r3++)
            (o3 = u3[2 * u3[2 * (n3 = t3.heap[r3]) + 1] + 1] + 1) > p2 && (o3 = p2, m2++), u3[2 * n3 + 1] = o3, n3 > c3 || (t3.bl_count[o3]++, a3 = 0, n3 >= d2 && (a3 = h2[n3 - d2]), s3 = u3[2 * n3], t3.opt_len += s3 * (o3 + a3), l2 && (t3.static_len += s3 * (f2[2 * n3 + 1] + a3)));
          if (m2 !== 0) {
            do {
              for (o3 = p2 - 1; t3.bl_count[o3] === 0; )
                o3--;
              t3.bl_count[o3]--, t3.bl_count[o3 + 1] += 2, t3.bl_count[p2]--, m2 -= 2;
            } while (m2 > 0);
            for (o3 = p2; o3 !== 0; o3--)
              for (n3 = t3.bl_count[o3]; n3 !== 0; )
                (i3 = t3.heap[--r3]) > c3 || (u3[2 * i3 + 1] !== o3 && (t3.opt_len += (o3 - u3[2 * i3 + 1]) * u3[2 * i3], u3[2 * i3 + 1] = o3), n3--);
          }
        }(t2, e2), O(o2, c2, t2.bl_count);
      }
      function M(t2, e2, r2) {
        var n2, i2, o2 = -1, a2 = e2[1], s2 = 0, u2 = 7, c2 = 4;
        for (a2 === 0 && (u2 = 138, c2 = 3), e2[2 * (r2 + 1) + 1] = 65535, n2 = 0; n2 <= r2; n2++)
          i2 = a2, a2 = e2[2 * (n2 + 1) + 1], ++s2 < u2 && i2 === a2 || (s2 < c2 ? t2.bl_tree[2 * i2] += s2 : i2 !== 0 ? (i2 !== o2 && t2.bl_tree[2 * i2]++, t2.bl_tree[32]++) : s2 <= 10 ? t2.bl_tree[34]++ : t2.bl_tree[36]++, s2 = 0, o2 = i2, a2 === 0 ? (u2 = 138, c2 = 3) : i2 === a2 ? (u2 = 6, c2 = 3) : (u2 = 7, c2 = 4));
      }
      function A(t2, e2, r2) {
        var n2, i2, o2 = -1, a2 = e2[1], s2 = 0, u2 = 7, c2 = 4;
        for (a2 === 0 && (u2 = 138, c2 = 3), n2 = 0; n2 <= r2; n2++)
          if (i2 = a2, a2 = e2[2 * (n2 + 1) + 1], !(++s2 < u2 && i2 === a2)) {
            if (s2 < c2)
              do {
                x(t2, i2, t2.bl_tree);
              } while (--s2 != 0);
            else
              i2 !== 0 ? (i2 !== o2 && (x(t2, i2, t2.bl_tree), s2--), x(t2, 16, t2.bl_tree), k(t2, s2 - 3, 2)) : s2 <= 10 ? (x(t2, 17, t2.bl_tree), k(t2, s2 - 3, 3)) : (x(t2, 18, t2.bl_tree), k(t2, s2 - 11, 7));
            s2 = 0, o2 = i2, a2 === 0 ? (u2 = 138, c2 = 3) : i2 === a2 ? (u2 = 6, c2 = 3) : (u2 = 7, c2 = 4);
          }
      }
      i(b);
      var I = false;
      function N(t2, e2, r2, i2) {
        k(t2, 0 + (i2 ? 1 : 0), 3), function(t3, e3, r3, i3) {
          E(t3), i3 && (_(t3, r3), _(t3, ~r3)), n.arraySet(t3.pending_buf, t3.window, e3, r3, t3.pending), t3.pending += r3;
        }(t2, e2, r2, true);
      }
      r._tr_init = function(t2) {
        I || (!function() {
          var t3, e2, r2, n2, i2, u2 = new Array(16);
          for (r2 = 0, n2 = 0; n2 < 28; n2++)
            for (d[n2] = r2, t3 = 0; t3 < 1 << o[n2]; t3++)
              h[r2++] = n2;
          for (h[r2 - 1] = n2, i2 = 0, n2 = 0; n2 < 16; n2++)
            for (b[n2] = i2, t3 = 0; t3 < 1 << a[n2]; t3++)
              l[i2++] = n2;
          for (i2 >>= 7; n2 < 30; n2++)
            for (b[n2] = i2 << 7, t3 = 0; t3 < 1 << a[n2] - 7; t3++)
              l[256 + i2++] = n2;
          for (e2 = 0; e2 <= 15; e2++)
            u2[e2] = 0;
          for (t3 = 0; t3 <= 143; )
            c[2 * t3 + 1] = 8, t3++, u2[8]++;
          for (; t3 <= 255; )
            c[2 * t3 + 1] = 9, t3++, u2[9]++;
          for (; t3 <= 279; )
            c[2 * t3 + 1] = 7, t3++, u2[7]++;
          for (; t3 <= 287; )
            c[2 * t3 + 1] = 8, t3++, u2[8]++;
          for (O(c, 287, u2), t3 = 0; t3 < 30; t3++)
            f[2 * t3 + 1] = 5, f[2 * t3] = S(t3, 5);
          p = new v(c, o, 257, 286, 15), m = new v(f, a, 0, 30, 15), y = new v(new Array(0), s, 0, 19, 7);
        }(), I = true), t2.l_desc = new g(t2.dyn_ltree, p), t2.d_desc = new g(t2.dyn_dtree, m), t2.bl_desc = new g(t2.bl_tree, y), t2.bi_buf = 0, t2.bi_valid = 0, j(t2);
      }, r._tr_stored_block = N, r._tr_flush_block = function(t2, e2, r2, n2) {
        var i2, o2, a2 = 0;
        t2.level > 0 ? (t2.strm.data_type === 2 && (t2.strm.data_type = function(t3) {
          var e3, r3 = 4093624447;
          for (e3 = 0; e3 <= 31; e3++, r3 >>>= 1)
            if (1 & r3 && t3.dyn_ltree[2 * e3] !== 0)
              return 0;
          if (t3.dyn_ltree[18] !== 0 || t3.dyn_ltree[20] !== 0 || t3.dyn_ltree[26] !== 0)
            return 1;
          for (e3 = 32; e3 < 256; e3++)
            if (t3.dyn_ltree[2 * e3] !== 0)
              return 1;
          return 0;
        }(t2)), P(t2, t2.l_desc), P(t2, t2.d_desc), a2 = function(t3) {
          var e3;
          for (M(t3, t3.dyn_ltree, t3.l_desc.max_code), M(t3, t3.dyn_dtree, t3.d_desc.max_code), P(t3, t3.bl_desc), e3 = 18; e3 >= 3 && t3.bl_tree[2 * u[e3] + 1] === 0; e3--)
            ;
          return t3.opt_len += 3 * (e3 + 1) + 5 + 5 + 4, e3;
        }(t2), i2 = t2.opt_len + 3 + 7 >>> 3, (o2 = t2.static_len + 3 + 7 >>> 3) <= i2 && (i2 = o2)) : i2 = o2 = r2 + 5, r2 + 4 <= i2 && e2 !== -1 ? N(t2, e2, r2, n2) : t2.strategy === 4 || o2 === i2 ? (k(t2, 2 + (n2 ? 1 : 0), 3), C(t2, c, f)) : (k(t2, 4 + (n2 ? 1 : 0), 3), function(t3, e3, r3, n3) {
          var i3;
          for (k(t3, e3 - 257, 5), k(t3, r3 - 1, 5), k(t3, n3 - 4, 4), i3 = 0; i3 < n3; i3++)
            k(t3, t3.bl_tree[2 * u[i3] + 1], 3);
          A(t3, t3.dyn_ltree, e3 - 1), A(t3, t3.dyn_dtree, r3 - 1);
        }(t2, t2.l_desc.max_code + 1, t2.d_desc.max_code + 1, a2 + 1), C(t2, t2.dyn_ltree, t2.dyn_dtree)), j(t2), n2 && E(t2);
      }, r._tr_tally = function(t2, e2, r2) {
        return t2.pending_buf[t2.d_buf + 2 * t2.last_lit] = e2 >>> 8 & 255, t2.pending_buf[t2.d_buf + 2 * t2.last_lit + 1] = 255 & e2, t2.pending_buf[t2.l_buf + t2.last_lit] = 255 & r2, t2.last_lit++, e2 === 0 ? t2.dyn_ltree[2 * r2]++ : (t2.matches++, e2--, t2.dyn_ltree[2 * (h[r2] + 256 + 1)]++, t2.dyn_dtree[2 * w(e2)]++), t2.last_lit === t2.lit_bufsize - 1;
      }, r._tr_align = function(t2) {
        k(t2, 2, 3), x(t2, 256, c), function(t3) {
          t3.bi_valid === 16 ? (_(t3, t3.bi_buf), t3.bi_buf = 0, t3.bi_valid = 0) : t3.bi_valid >= 8 && (t3.pending_buf[t3.pending++] = 255 & t3.bi_buf, t3.bi_buf >>= 8, t3.bi_valid -= 8);
        }(t2);
      };
    }, { "../utils/common": 442 }], 454: [function(t, e, r) {
      e.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 455: [function(t, e, r) {
      e.exports = { "2.16.840.1.101.3.4.1.1": "aes-128-ecb", "2.16.840.1.101.3.4.1.2": "aes-128-cbc", "2.16.840.1.101.3.4.1.3": "aes-128-ofb", "2.16.840.1.101.3.4.1.4": "aes-128-cfb", "2.16.840.1.101.3.4.1.21": "aes-192-ecb", "2.16.840.1.101.3.4.1.22": "aes-192-cbc", "2.16.840.1.101.3.4.1.23": "aes-192-ofb", "2.16.840.1.101.3.4.1.24": "aes-192-cfb", "2.16.840.1.101.3.4.1.41": "aes-256-ecb", "2.16.840.1.101.3.4.1.42": "aes-256-cbc", "2.16.840.1.101.3.4.1.43": "aes-256-ofb", "2.16.840.1.101.3.4.1.44": "aes-256-cfb" };
    }, {}], 456: [function(t, e, r) {
      var n = t("asn1.js");
      r.certificate = t("./certificate");
      var i = n.define("RSAPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
      });
      r.RSAPrivateKey = i;
      var o = n.define("RSAPublicKey", function() {
        this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
      });
      r.RSAPublicKey = o;
      var a = n.define("SubjectPublicKeyInfo", function() {
        this.seq().obj(this.key("algorithm").use(s), this.key("subjectPublicKey").bitstr());
      });
      r.PublicKey = a;
      var s = n.define("AlgorithmIdentifier", function() {
        this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
      }), u = n.define("PrivateKeyInfo", function() {
        this.seq().obj(this.key("version").int(), this.key("algorithm").use(s), this.key("subjectPrivateKey").octstr());
      });
      r.PrivateKey = u;
      var c = n.define("EncryptedPrivateKeyInfo", function() {
        this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
      });
      r.EncryptedPrivateKey = c;
      var f = n.define("DSAPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
      });
      r.DSAPrivateKey = f, r.DSAparam = n.define("DSAparam", function() {
        this.int();
      });
      var l = n.define("ECPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(h), this.key("publicKey").optional().explicit(1).bitstr());
      });
      r.ECPrivateKey = l;
      var h = n.define("ECParameters", function() {
        this.choice({ namedCurve: this.objid() });
      });
      r.signature = n.define("signature", function() {
        this.seq().obj(this.key("r").int(), this.key("s").int());
      });
    }, { "./certificate": 457, "asn1.js": 167 }], 457: [function(t, e, r) {
      var n = t("asn1.js"), i = n.define("Time", function() {
        this.choice({ utcTime: this.utctime(), generalTime: this.gentime() });
      }), o = n.define("AttributeTypeValue", function() {
        this.seq().obj(this.key("type").objid(), this.key("value").any());
      }), a = n.define("AlgorithmIdentifier", function() {
        this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
      }), s = n.define("SubjectPublicKeyInfo", function() {
        this.seq().obj(this.key("algorithm").use(a), this.key("subjectPublicKey").bitstr());
      }), u = n.define("RelativeDistinguishedName", function() {
        this.setof(o);
      }), c = n.define("RDNSequence", function() {
        this.seqof(u);
      }), f = n.define("Name", function() {
        this.choice({ rdnSequence: this.use(c) });
      }), l = n.define("Validity", function() {
        this.seq().obj(this.key("notBefore").use(i), this.key("notAfter").use(i));
      }), h = n.define("Extension", function() {
        this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
      }), d = n.define("TBSCertificate", function() {
        this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(a), this.key("issuer").use(f), this.key("validity").use(l), this.key("subject").use(f), this.key("subjectPublicKeyInfo").use(s), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(h).optional());
      }), p = n.define("X509Certificate", function() {
        this.seq().obj(this.key("tbsCertificate").use(d), this.key("signatureAlgorithm").use(a), this.key("signatureValue").bitstr());
      });
      e.exports = p;
    }, { "asn1.js": 167 }], 458: [function(t, e, r) {
      var n = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, i = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, o = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, a = t("evp_bytestokey"), s = t("browserify-aes"), u = t("safe-buffer").Buffer;
      e.exports = function(t2, e2) {
        var r2, c = t2.toString(), f = c.match(n);
        if (f) {
          var l = "aes" + f[1], h = u.from(f[2], "hex"), d = u.from(f[3].replace(/[\r\n]/g, ""), "base64"), p = a(e2, h.slice(0, 8), parseInt(f[1], 10)).key, m = [], y = s.createDecipheriv(l, p, h);
          m.push(y.update(d)), m.push(y.final()), r2 = u.concat(m);
        } else {
          var b = c.match(o);
          r2 = u.from(b[2].replace(/[\r\n]/g, ""), "base64");
        }
        return { tag: c.match(i)[1], data: r2 };
      };
    }, { "browserify-aes": 188, evp_bytestokey: 368, "safe-buffer": 494 }], 459: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      var i = t("./asn1"), o = t("./aesid.json"), a = t("./fixProc"), s = t("browserify-aes"), u = t("pbkdf2"), c = t("safe-buffer").Buffer;
      function f(t2) {
        var e2;
        n(t2) !== "object" || c.isBuffer(t2) || (e2 = t2.passphrase, t2 = t2.key), typeof t2 == "string" && (t2 = c.from(t2));
        var r2, f2, l = a(t2, e2), h = l.tag, d = l.data;
        switch (h) {
          case "CERTIFICATE":
            f2 = i.certificate.decode(d, "der").tbsCertificate.subjectPublicKeyInfo;
          case "PUBLIC KEY":
            switch (f2 || (f2 = i.PublicKey.decode(d, "der")), r2 = f2.algorithm.algorithm.join(".")) {
              case "1.2.840.113549.1.1.1":
                return i.RSAPublicKey.decode(f2.subjectPublicKey.data, "der");
              case "1.2.840.10045.2.1":
                return f2.subjectPrivateKey = f2.subjectPublicKey, { type: "ec", data: f2 };
              case "1.2.840.10040.4.1":
                return f2.algorithm.params.pub_key = i.DSAparam.decode(f2.subjectPublicKey.data, "der"), { type: "dsa", data: f2.algorithm.params };
              default:
                throw new Error("unknown key id " + r2);
            }
          case "ENCRYPTED PRIVATE KEY":
            d = function(t3, e3) {
              var r3 = t3.algorithm.decrypt.kde.kdeparams.salt, n2 = parseInt(t3.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), i2 = o[t3.algorithm.decrypt.cipher.algo.join(".")], a2 = t3.algorithm.decrypt.cipher.iv, f3 = t3.subjectPrivateKey, l2 = parseInt(i2.split("-")[1], 10) / 8, h2 = u.pbkdf2Sync(e3, r3, n2, l2, "sha1"), d2 = s.createDecipheriv(i2, h2, a2), p = [];
              return p.push(d2.update(f3)), p.push(d2.final()), c.concat(p);
            }(d = i.EncryptedPrivateKey.decode(d, "der"), e2);
          case "PRIVATE KEY":
            switch (r2 = (f2 = i.PrivateKey.decode(d, "der")).algorithm.algorithm.join(".")) {
              case "1.2.840.113549.1.1.1":
                return i.RSAPrivateKey.decode(f2.subjectPrivateKey, "der");
              case "1.2.840.10045.2.1":
                return { curve: f2.algorithm.curve, privateKey: i.ECPrivateKey.decode(f2.subjectPrivateKey, "der").privateKey };
              case "1.2.840.10040.4.1":
                return f2.algorithm.params.priv_key = i.DSAparam.decode(f2.subjectPrivateKey, "der"), { type: "dsa", params: f2.algorithm.params };
              default:
                throw new Error("unknown key id " + r2);
            }
          case "RSA PUBLIC KEY":
            return i.RSAPublicKey.decode(d, "der");
          case "RSA PRIVATE KEY":
            return i.RSAPrivateKey.decode(d, "der");
          case "DSA PRIVATE KEY":
            return { type: "dsa", params: i.DSAPrivateKey.decode(d, "der") };
          case "EC PRIVATE KEY":
            return { curve: (d = i.ECPrivateKey.decode(d, "der")).parameters.value, privateKey: d.privateKey };
          default:
            throw new Error("unknown key type " + h);
        }
      }
      e.exports = f, f.signature = i.signature;
    }, { "./aesid.json": 455, "./asn1": 456, "./fixProc": 458, "browserify-aes": 188, pbkdf2: 460, "safe-buffer": 494 }], 460: [function(t, e, r) {
      r.pbkdf2 = t("./lib/async"), r.pbkdf2Sync = t("./lib/sync");
    }, { "./lib/async": 461, "./lib/sync": 464 }], 461: [function(t, e, r) {
      (function(r2, n) {
        var i, o = t("safe-buffer").Buffer, a = t("./precondition"), s = t("./default-encoding"), u = t("./sync"), c = t("./to-buffer"), f = n.crypto && n.crypto.subtle, l = { sha: "SHA-1", "sha-1": "SHA-1", sha1: "SHA-1", sha256: "SHA-256", "sha-256": "SHA-256", sha384: "SHA-384", "sha-384": "SHA-384", "sha-512": "SHA-512", sha512: "SHA-512" }, h = [];
        function d(t2, e2, r3, n2, i2) {
          return f.importKey("raw", t2, { name: "PBKDF2" }, false, ["deriveBits"]).then(function(t3) {
            return f.deriveBits({ name: "PBKDF2", salt: e2, iterations: r3, hash: { name: i2 } }, t3, n2 << 3);
          }).then(function(t3) {
            return o.from(t3);
          });
        }
        e.exports = function(t2, e2, p, m, y, b) {
          typeof y == "function" && (b = y, y = void 0);
          var v = l[(y = y || "sha1").toLowerCase()];
          if (!v || typeof n.Promise != "function")
            return r2.nextTick(function() {
              var r3;
              try {
                r3 = u(t2, e2, p, m, y);
              } catch (t3) {
                return b(t3);
              }
              b(null, r3);
            });
          if (a(p, m), t2 = c(t2, s, "Password"), e2 = c(e2, s, "Salt"), typeof b != "function")
            throw new Error("No callback provided to pbkdf2");
          !function(t3, e3) {
            t3.then(function(t4) {
              r2.nextTick(function() {
                e3(null, t4);
              });
            }, function(t4) {
              r2.nextTick(function() {
                e3(t4);
              });
            });
          }(function(t3) {
            if (n.process && !n.process.browser)
              return Promise.resolve(false);
            if (!f || !f.importKey || !f.deriveBits)
              return Promise.resolve(false);
            if (h[t3] !== void 0)
              return h[t3];
            var e3 = d(i = i || o.alloc(8), i, 10, 128, t3).then(function() {
              return true;
            }).catch(function() {
              return false;
            });
            return h[t3] = e3, e3;
          }(v).then(function(r3) {
            return r3 ? d(t2, e2, p, m, v) : u(t2, e2, p, m, y);
          }), b);
        };
      }).call(this, t("_process"), typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, { "./default-encoding": 462, "./precondition": 463, "./sync": 464, "./to-buffer": 465, _process: 467, "safe-buffer": 494 }], 462: [function(t, e, r) {
      (function(t2) {
        var r2;
        if (t2.browser)
          r2 = "utf-8";
        else if (t2.version) {
          r2 = parseInt(t2.version.split(".")[0].slice(1), 10) >= 6 ? "utf-8" : "binary";
        } else
          r2 = "utf-8";
        e.exports = r2;
      }).call(this, t("_process"));
    }, { _process: 467 }], 463: [function(t, e, r) {
      var n = Math.pow(2, 30) - 1;
      e.exports = function(t2, e2) {
        if (typeof t2 != "number")
          throw new TypeError("Iterations not a number");
        if (t2 < 0)
          throw new TypeError("Bad iterations");
        if (typeof e2 != "number")
          throw new TypeError("Key length not a number");
        if (e2 < 0 || e2 > n || e2 != e2)
          throw new TypeError("Bad key length");
      };
    }, {}], 464: [function(t, e, r) {
      var n = t("create-hash/md5"), i = t("ripemd160"), o = t("sha.js"), a = t("safe-buffer").Buffer, s = t("./precondition"), u = t("./default-encoding"), c = t("./to-buffer"), f = a.alloc(128), l = { md5: 16, sha1: 20, sha224: 28, sha256: 32, sha384: 48, sha512: 64, rmd160: 20, ripemd160: 20 };
      function h(t2, e2, r2) {
        var s2 = function(t3) {
          function e3(e4) {
            return o(t3).update(e4).digest();
          }
          return t3 === "rmd160" || t3 === "ripemd160" ? function(t4) {
            return new i().update(t4).digest();
          } : t3 === "md5" ? n : e3;
        }(t2), u2 = t2 === "sha512" || t2 === "sha384" ? 128 : 64;
        e2.length > u2 ? e2 = s2(e2) : e2.length < u2 && (e2 = a.concat([e2, f], u2));
        for (var c2 = a.allocUnsafe(u2 + l[t2]), h2 = a.allocUnsafe(u2 + l[t2]), d = 0; d < u2; d++)
          c2[d] = 54 ^ e2[d], h2[d] = 92 ^ e2[d];
        var p = a.allocUnsafe(u2 + r2 + 4);
        c2.copy(p, 0, 0, u2), this.ipad1 = p, this.ipad2 = c2, this.opad = h2, this.alg = t2, this.blocksize = u2, this.hash = s2, this.size = l[t2];
      }
      h.prototype.run = function(t2, e2) {
        return t2.copy(e2, this.blocksize), this.hash(e2).copy(this.opad, this.blocksize), this.hash(this.opad);
      }, e.exports = function(t2, e2, r2, n2, i2) {
        s(r2, n2);
        var o2 = new h(i2 = i2 || "sha1", t2 = c(t2, u, "Password"), (e2 = c(e2, u, "Salt")).length), f2 = a.allocUnsafe(n2), d = a.allocUnsafe(e2.length + 4);
        e2.copy(d, 0, 0, e2.length);
        for (var p = 0, m = l[i2], y = Math.ceil(n2 / m), b = 1; b <= y; b++) {
          d.writeUInt32BE(b, e2.length);
          for (var v = o2.run(d, o2.ipad1), g = v, w = 1; w < r2; w++) {
            g = o2.run(g, o2.ipad2);
            for (var _ = 0; _ < m; _++)
              v[_] ^= g[_];
          }
          v.copy(f2, p), p += m;
        }
        return f2;
      };
    }, { "./default-encoding": 462, "./precondition": 463, "./to-buffer": 465, "create-hash/md5": 332, ripemd160: 493, "safe-buffer": 494, "sha.js": 499 }], 465: [function(t, e, r) {
      var n = t("safe-buffer").Buffer;
      e.exports = function(t2, e2, r2) {
        if (n.isBuffer(t2))
          return t2;
        if (typeof t2 == "string")
          return n.from(t2, e2);
        if (ArrayBuffer.isView(t2))
          return n.from(t2.buffer);
        throw new TypeError(r2 + " must be a string, a Buffer, a typed array or a DataView");
      };
    }, { "safe-buffer": 494 }], 466: [function(t, e, r) {
      (function(t2) {
        t2 === void 0 || !t2.version || t2.version.indexOf("v0.") === 0 || t2.version.indexOf("v1.") === 0 && t2.version.indexOf("v1.8.") !== 0 ? e.exports = { nextTick: function(e2, r2, n, i) {
          if (typeof e2 != "function")
            throw new TypeError('"callback" argument must be a function');
          var o, a, s = arguments.length;
          switch (s) {
            case 0:
            case 1:
              return t2.nextTick(e2);
            case 2:
              return t2.nextTick(function() {
                e2.call(null, r2);
              });
            case 3:
              return t2.nextTick(function() {
                e2.call(null, r2, n);
              });
            case 4:
              return t2.nextTick(function() {
                e2.call(null, r2, n, i);
              });
            default:
              for (o = new Array(s - 1), a = 0; a < o.length; )
                o[a++] = arguments[a];
              return t2.nextTick(function() {
                e2.apply(null, o);
              });
          }
        } } : e.exports = t2;
      }).call(this, t("_process"));
    }, { _process: 467 }], 467: [function(t, e, r) {
      var n, i, o = e.exports = {};
      function a() {
        throw new Error("setTimeout has not been defined");
      }
      function s() {
        throw new Error("clearTimeout has not been defined");
      }
      function u(t2) {
        if (n === setTimeout)
          return setTimeout(t2, 0);
        if ((n === a || !n) && setTimeout)
          return n = setTimeout, setTimeout(t2, 0);
        try {
          return n(t2, 0);
        } catch (e2) {
          try {
            return n.call(null, t2, 0);
          } catch (e3) {
            return n.call(this, t2, 0);
          }
        }
      }
      !function() {
        try {
          n = typeof setTimeout == "function" ? setTimeout : a;
        } catch (t2) {
          n = a;
        }
        try {
          i = typeof clearTimeout == "function" ? clearTimeout : s;
        } catch (t2) {
          i = s;
        }
      }();
      var c, f = [], l = false, h = -1;
      function d() {
        l && c && (l = false, c.length ? f = c.concat(f) : h = -1, f.length && p());
      }
      function p() {
        if (!l) {
          var t2 = u(d);
          l = true;
          for (var e2 = f.length; e2; ) {
            for (c = f, f = []; ++h < e2; )
              c && c[h].run();
            h = -1, e2 = f.length;
          }
          c = null, l = false, function(t3) {
            if (i === clearTimeout)
              return clearTimeout(t3);
            if ((i === s || !i) && clearTimeout)
              return i = clearTimeout, clearTimeout(t3);
            try {
              i(t3);
            } catch (e3) {
              try {
                return i.call(null, t3);
              } catch (e4) {
                return i.call(this, t3);
              }
            }
          }(t2);
        }
      }
      function m(t2, e2) {
        this.fun = t2, this.array = e2;
      }
      function y() {
      }
      o.nextTick = function(t2) {
        var e2 = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var r2 = 1; r2 < arguments.length; r2++)
            e2[r2 - 1] = arguments[r2];
        f.push(new m(t2, e2)), f.length !== 1 || l || u(p);
      }, m.prototype.run = function() {
        this.fun.apply(null, this.array);
      }, o.title = "browser", o.browser = true, o.env = {}, o.argv = [], o.version = "", o.versions = {}, o.on = y, o.addListener = y, o.once = y, o.off = y, o.removeListener = y, o.removeAllListeners = y, o.emit = y, o.prependListener = y, o.prependOnceListener = y, o.listeners = function(t2) {
        return [];
      }, o.binding = function(t2) {
        throw new Error("process.binding is not supported");
      }, o.cwd = function() {
        return "/";
      }, o.chdir = function(t2) {
        throw new Error("process.chdir is not supported");
      }, o.umask = function() {
        return 0;
      };
    }, {}], 468: [function(t, e, r) {
      r.publicEncrypt = t("./publicEncrypt"), r.privateDecrypt = t("./privateDecrypt"), r.privateEncrypt = function(t2, e2) {
        return r.publicEncrypt(t2, e2, true);
      }, r.publicDecrypt = function(t2, e2) {
        return r.privateDecrypt(t2, e2, true);
      };
    }, { "./privateDecrypt": 471, "./publicEncrypt": 472 }], 469: [function(t, e, r) {
      var n = t("create-hash"), i = t("safe-buffer").Buffer;
      function o(t2) {
        var e2 = i.allocUnsafe(4);
        return e2.writeUInt32BE(t2, 0), e2;
      }
      e.exports = function(t2, e2) {
        for (var r2, a = i.alloc(0), s = 0; a.length < e2; )
          r2 = o(s++), a = i.concat([a, n("sha1").update(t2).update(r2).digest()]);
        return a.slice(0, e2);
      };
    }, { "create-hash": 331, "safe-buffer": 494 }], 470: [function(t, e, r) {
      arguments[4][181][0].apply(r, arguments);
    }, { buffer: 185, dup: 181 }], 471: [function(t, e, r) {
      var n = t("parse-asn1"), i = t("./mgf"), o = t("./xor"), a = t("bn.js"), s = t("browserify-rsa"), u = t("create-hash"), c = t("./withPublic"), f = t("safe-buffer").Buffer;
      e.exports = function(t2, e2, r2) {
        var l;
        l = t2.padding ? t2.padding : r2 ? 1 : 4;
        var h, d = n(t2), p = d.modulus.byteLength();
        if (e2.length > p || new a(e2).cmp(d.modulus) >= 0)
          throw new Error("decryption error");
        h = r2 ? c(new a(e2), d) : s(e2, d);
        var m = f.alloc(p - h.length);
        if (h = f.concat([m, h], p), l === 4)
          return function(t3, e3) {
            var r3 = t3.modulus.byteLength(), n2 = u("sha1").update(f.alloc(0)).digest(), a2 = n2.length;
            if (e3[0] !== 0)
              throw new Error("decryption error");
            var s2 = e3.slice(1, a2 + 1), c2 = e3.slice(a2 + 1), l2 = o(s2, i(c2, a2)), h2 = o(c2, i(l2, r3 - a2 - 1));
            if (function(t4, e4) {
              t4 = f.from(t4), e4 = f.from(e4);
              var r4 = 0, n3 = t4.length;
              t4.length !== e4.length && (r4++, n3 = Math.min(t4.length, e4.length));
              var i2 = -1;
              for (; ++i2 < n3; )
                r4 += t4[i2] ^ e4[i2];
              return r4;
            }(n2, h2.slice(0, a2)))
              throw new Error("decryption error");
            var d2 = a2;
            for (; h2[d2] === 0; )
              d2++;
            if (h2[d2++] !== 1)
              throw new Error("decryption error");
            return h2.slice(d2);
          }(d, h);
        if (l === 1)
          return function(t3, e3, r3) {
            var n2 = e3.slice(0, 2), i2 = 2, o2 = 0;
            for (; e3[i2++] !== 0; )
              if (i2 >= e3.length) {
                o2++;
                break;
              }
            var a2 = e3.slice(2, i2 - 1);
            (n2.toString("hex") !== "0002" && !r3 || n2.toString("hex") !== "0001" && r3) && o2++;
            a2.length < 8 && o2++;
            if (o2)
              throw new Error("decryption error");
            return e3.slice(i2);
          }(0, h, r2);
        if (l === 3)
          return h;
        throw new Error("unknown padding");
      };
    }, { "./mgf": 469, "./withPublic": 473, "./xor": 474, "bn.js": 470, "browserify-rsa": 206, "create-hash": 331, "parse-asn1": 459, "safe-buffer": 494 }], 472: [function(t, e, r) {
      var n = t("parse-asn1"), i = t("randombytes"), o = t("create-hash"), a = t("./mgf"), s = t("./xor"), u = t("bn.js"), c = t("./withPublic"), f = t("browserify-rsa"), l = t("safe-buffer").Buffer;
      e.exports = function(t2, e2, r2) {
        var h;
        h = t2.padding ? t2.padding : r2 ? 1 : 4;
        var d, p = n(t2);
        if (h === 4)
          d = function(t3, e3) {
            var r3 = t3.modulus.byteLength(), n2 = e3.length, c2 = o("sha1").update(l.alloc(0)).digest(), f2 = c2.length, h2 = 2 * f2;
            if (n2 > r3 - h2 - 2)
              throw new Error("message too long");
            var d2 = l.alloc(r3 - n2 - h2 - 2), p2 = r3 - f2 - 1, m = i(f2), y = s(l.concat([c2, d2, l.alloc(1, 1), e3], p2), a(m, p2)), b = s(m, a(y, f2));
            return new u(l.concat([l.alloc(1), b, y], r3));
          }(p, e2);
        else if (h === 1)
          d = function(t3, e3, r3) {
            var n2, o2 = e3.length, a2 = t3.modulus.byteLength();
            if (o2 > a2 - 11)
              throw new Error("message too long");
            n2 = r3 ? l.alloc(a2 - o2 - 3, 255) : function(t4) {
              var e4, r4 = l.allocUnsafe(t4), n3 = 0, o3 = i(2 * t4), a3 = 0;
              for (; n3 < t4; )
                a3 === o3.length && (o3 = i(2 * t4), a3 = 0), (e4 = o3[a3++]) && (r4[n3++] = e4);
              return r4;
            }(a2 - o2 - 3);
            return new u(l.concat([l.from([0, r3 ? 1 : 2]), n2, l.alloc(1), e3], a2));
          }(p, e2, r2);
        else {
          if (h !== 3)
            throw new Error("unknown padding");
          if ((d = new u(e2)).cmp(p.modulus) >= 0)
            throw new Error("data too long for modulus");
        }
        return r2 ? f(d, p) : c(d, p);
      };
    }, { "./mgf": 469, "./withPublic": 473, "./xor": 474, "bn.js": 470, "browserify-rsa": 206, "create-hash": 331, "parse-asn1": 459, randombytes: 475, "safe-buffer": 494 }], 473: [function(t, e, r) {
      var n = t("bn.js"), i = t("safe-buffer").Buffer;
      e.exports = function(t2, e2) {
        return i.from(t2.toRed(n.mont(e2.modulus)).redPow(new n(e2.publicExponent)).fromRed().toArray());
      };
    }, { "bn.js": 470, "safe-buffer": 494 }], 474: [function(t, e, r) {
      e.exports = function(t2, e2) {
        for (var r2 = t2.length, n = -1; ++n < r2; )
          t2[n] ^= e2[n];
        return t2;
      };
    }, {}], 475: [function(t, e, r) {
      (function(r2, n) {
        var i = t("safe-buffer").Buffer, o = n.crypto || n.msCrypto;
        o && o.getRandomValues ? e.exports = function(t2, e2) {
          if (t2 > 4294967295)
            throw new RangeError("requested too many random bytes");
          var n2 = i.allocUnsafe(t2);
          if (t2 > 0)
            if (t2 > 65536)
              for (var a = 0; a < t2; a += 65536)
                o.getRandomValues(n2.slice(a, a + 65536));
            else
              o.getRandomValues(n2);
          if (typeof e2 == "function")
            return r2.nextTick(function() {
              e2(null, n2);
            });
          return n2;
        } : e.exports = function() {
          throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
        };
      }).call(this, t("_process"), typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, { _process: 467, "safe-buffer": 494 }], 476: [function(t, e, r) {
      (function(e2, n) {
        function i() {
          throw new Error("secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11");
        }
        var o = t("safe-buffer"), a = t("randombytes"), s = o.Buffer, u = o.kMaxLength, c = n.crypto || n.msCrypto, f = Math.pow(2, 32) - 1;
        function l(t2, e3) {
          if (typeof t2 != "number" || t2 != t2)
            throw new TypeError("offset must be a number");
          if (t2 > f || t2 < 0)
            throw new TypeError("offset must be a uint32");
          if (t2 > u || t2 > e3)
            throw new RangeError("offset out of range");
        }
        function h(t2, e3, r2) {
          if (typeof t2 != "number" || t2 != t2)
            throw new TypeError("size must be a number");
          if (t2 > f || t2 < 0)
            throw new TypeError("size must be a uint32");
          if (t2 + e3 > r2 || t2 > u)
            throw new RangeError("buffer too small");
        }
        function d(t2, r2, n2, i2) {
          if (e2.browser) {
            var o2 = t2.buffer, s2 = new Uint8Array(o2, r2, n2);
            return c.getRandomValues(s2), i2 ? void e2.nextTick(function() {
              i2(null, t2);
            }) : t2;
          }
          if (!i2)
            return a(n2).copy(t2, r2), t2;
          a(n2, function(e3, n3) {
            if (e3)
              return i2(e3);
            n3.copy(t2, r2), i2(null, t2);
          });
        }
        c && c.getRandomValues || !e2.browser ? (r.randomFill = function(t2, e3, r2, i2) {
          if (!(s.isBuffer(t2) || t2 instanceof n.Uint8Array))
            throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
          if (typeof e3 == "function")
            i2 = e3, e3 = 0, r2 = t2.length;
          else if (typeof r2 == "function")
            i2 = r2, r2 = t2.length - e3;
          else if (typeof i2 != "function")
            throw new TypeError('"cb" argument must be a function');
          return l(e3, t2.length), h(r2, e3, t2.length), d(t2, e3, r2, i2);
        }, r.randomFillSync = function(t2, e3, r2) {
          e3 === void 0 && (e3 = 0);
          if (!(s.isBuffer(t2) || t2 instanceof n.Uint8Array))
            throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
          l(e3, t2.length), r2 === void 0 && (r2 = t2.length - e3);
          return h(r2, e3, t2.length), d(t2, e3, r2);
        }) : (r.randomFill = i, r.randomFillSync = i);
      }).call(this, t("_process"), typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, { _process: 467, randombytes: 475, "safe-buffer": 494 }], 477: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      var i = {};
      function o(t2, e2, r2) {
        r2 || (r2 = Error);
        var n2 = function(t3) {
          var r3, n3;
          function i2(r4, n4, i3) {
            return t3.call(this, function(t4, r5, n5) {
              return typeof e2 == "string" ? e2 : e2(t4, r5, n5);
            }(r4, n4, i3)) || this;
          }
          return n3 = t3, (r3 = i2).prototype = Object.create(n3.prototype), r3.prototype.constructor = r3, r3.__proto__ = n3, i2;
        }(r2);
        n2.prototype.name = r2.name, n2.prototype.code = t2, i[t2] = n2;
      }
      function a(t2, e2) {
        if (Array.isArray(t2)) {
          var r2 = t2.length;
          return t2 = t2.map(function(t3) {
            return String(t3);
          }), r2 > 2 ? "one of ".concat(e2, " ").concat(t2.slice(0, r2 - 1).join(", "), ", or ") + t2[r2 - 1] : r2 === 2 ? "one of ".concat(e2, " ").concat(t2[0], " or ").concat(t2[1]) : "of ".concat(e2, " ").concat(t2[0]);
        }
        return "of ".concat(e2, " ").concat(String(t2));
      }
      o("ERR_INVALID_OPT_VALUE", function(t2, e2) {
        return 'The value "' + e2 + '" is invalid for option "' + t2 + '"';
      }, TypeError), o("ERR_INVALID_ARG_TYPE", function(t2, e2, r2) {
        var i2, o2, u;
        if (typeof e2 == "string" && (o2 = "not ", e2.substr(0 , o2.length) === o2) ? (i2 = "must not be", e2 = e2.replace(/^not /, "")) : i2 = "must be", function(t3, e3, r3) {
          return (r3 === void 0 || r3 > t3.length) && (r3 = t3.length), t3.substring(r3 - e3.length, r3) === e3;
        }(t2, " argument"))
          u = "The ".concat(t2, " ").concat(i2, " ").concat(a(e2, "type"));
        else {
          var c = function(t3, e3, r3) {
            return typeof r3 != "number" && (r3 = 0), !(r3 + e3.length > t3.length) && t3.indexOf(e3, r3) !== -1;
          }(t2, ".") ? "property" : "argument";
          u = 'The "'.concat(t2, '" ').concat(c, " ").concat(i2, " ").concat(a(e2, "type"));
        }
        return u += ". Received type ".concat(n(r2));
      }, TypeError), o("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), o("ERR_METHOD_NOT_IMPLEMENTED", function(t2) {
        return "The " + t2 + " method is not implemented";
      }), o("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), o("ERR_STREAM_DESTROYED", function(t2) {
        return "Cannot call " + t2 + " after a stream was destroyed";
      }), o("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), o("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), o("ERR_STREAM_WRITE_AFTER_END", "write after end"), o("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), o("ERR_UNKNOWN_ENCODING", function(t2) {
        return "Unknown encoding: " + t2;
      }, TypeError), o("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), e.exports.codes = i;
    }, {}], 478: [function(t, e, r) {
      (function(r2) {
        var n = Object.keys || function(t2) {
          var e2 = [];
          for (var r3 in t2)
            e2.push(r3);
          return e2;
        };
        e.exports = c;
        var i = t("./_stream_readable"), o = t("./_stream_writable");
        t("inherits")(c, i);
        for (var a = n(o.prototype), s = 0; s < a.length; s++) {
          var u = a[s];
          c.prototype[u] || (c.prototype[u] = o.prototype[u]);
        }
        function c(t2) {
          if (!(this instanceof c))
            return new c(t2);
          i.call(this, t2), o.call(this, t2), this.allowHalfOpen = true, t2 && (t2.readable === false && (this.readable = false), t2.writable === false && (this.writable = false), t2.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", f)));
        }
        function f() {
          this._writableState.ended || r2.nextTick(l, this);
        }
        function l(t2) {
          t2.end();
        }
        Object.defineProperty(c.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
          return this._writableState.highWaterMark;
        } }), Object.defineProperty(c.prototype, "writableBuffer", { enumerable: false, get: function() {
          return this._writableState && this._writableState.getBuffer();
        } }), Object.defineProperty(c.prototype, "writableLength", { enumerable: false, get: function() {
          return this._writableState.length;
        } }), Object.defineProperty(c.prototype, "destroyed", { enumerable: false, get: function() {
          return this._readableState !== void 0 && this._writableState !== void 0 && (this._readableState.destroyed && this._writableState.destroyed);
        }, set: function(t2) {
          this._readableState !== void 0 && this._writableState !== void 0 && (this._readableState.destroyed = t2, this._writableState.destroyed = t2);
        } });
      }).call(this, t("_process"));
    }, { "./_stream_readable": 480, "./_stream_writable": 482, _process: 467, inherits: 387 }], 479: [function(t, e, r) {
      e.exports = i;
      var n = t("./_stream_transform");
      function i(t2) {
        if (!(this instanceof i))
          return new i(t2);
        n.call(this, t2);
      }
      t("inherits")(i, n), i.prototype._transform = function(t2, e2, r2) {
        r2(null, t2);
      };
    }, { "./_stream_transform": 481, inherits: 387 }], 480: [function(t, e, r) {
      (function(r2, n) {
        var i;
        e.exports = O, O.ReadableState = S;
        t("events").EventEmitter;
        var o = function(t2, e2) {
          return t2.listeners(e2).length;
        }, a = t("./internal/streams/stream"), s = t("buffer").Buffer, u = n.Uint8Array || function() {
        };
        var c, f = t("util");
        c = f && f.debuglog ? f.debuglog("stream") : function() {
        };
        var l, h, d, p = t("./internal/streams/buffer_list"), m = t("./internal/streams/destroy"), y = t("./internal/streams/state").getHighWaterMark, b = t("../errors").codes, v = b.ERR_INVALID_ARG_TYPE, g = b.ERR_STREAM_PUSH_AFTER_EOF, w = b.ERR_METHOD_NOT_IMPLEMENTED, _ = b.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
        t("inherits")(O, a);
        var k = m.errorOrDestroy, x = ["error", "close", "destroy", "pause", "resume"];
        function S(e2, r3, n2) {
          i = i || t("./_stream_duplex"), e2 = e2 || {}, typeof n2 != "boolean" && (n2 = r3 instanceof i), this.objectMode = !!e2.objectMode, n2 && (this.objectMode = this.objectMode || !!e2.readableObjectMode), this.highWaterMark = y(this, e2, "readableHighWaterMark", n2), this.buffer = new p(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = e2.emitClose !== false, this.autoDestroy = !!e2.autoDestroy, this.destroyed = false, this.defaultEncoding = e2.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, e2.encoding && (l || (l = t("string_decoder/").StringDecoder), this.decoder = new l(e2.encoding), this.encoding = e2.encoding);
        }
        function O(e2) {
          if (i = i || t("./_stream_duplex"), !(this instanceof O))
            return new O(e2);
          var r3 = this instanceof i;
          this._readableState = new S(e2, this, r3), this.readable = true, e2 && (typeof e2.read == "function" && (this._read = e2.read), typeof e2.destroy == "function" && (this._destroy = e2.destroy)), a.call(this);
        }
        function j(t2, e2, r3, n2, i2) {
          c("readableAddChunk", e2);
          var o2, a2 = t2._readableState;
          if (e2 === null)
            a2.reading = false, function(t3, e3) {
              if (c("onEofChunk"), e3.ended)
                return;
              if (e3.decoder) {
                var r4 = e3.decoder.end();
                r4 && r4.length && (e3.buffer.push(r4), e3.length += e3.objectMode ? 1 : r4.length);
              }
              e3.ended = true, e3.sync ? T(t3) : (e3.needReadable = false, e3.emittedReadable || (e3.emittedReadable = true, C(t3)));
            }(t2, a2);
          else if (i2 || (o2 = function(t3, e3) {
            var r4;
            n3 = e3, s.isBuffer(n3) || n3 instanceof u || typeof e3 == "string" || e3 === void 0 || t3.objectMode || (r4 = new v("chunk", ["string", "Buffer", "Uint8Array"], e3));
            var n3;
            return r4;
          }(a2, e2)), o2)
            k(t2, o2);
          else if (a2.objectMode || e2 && e2.length > 0)
            if (typeof e2 == "string" || a2.objectMode || Object.getPrototypeOf(e2) === s.prototype || (e2 = function(t3) {
              return s.from(t3);
            }(e2)), n2)
              a2.endEmitted ? k(t2, new _()) : E(t2, a2, e2, true);
            else if (a2.ended)
              k(t2, new g());
            else {
              if (a2.destroyed)
                return false;
              a2.reading = false, a2.decoder && !r3 ? (e2 = a2.decoder.write(e2), a2.objectMode || e2.length !== 0 ? E(t2, a2, e2, false) : P(t2, a2)) : E(t2, a2, e2, false);
            }
          else
            n2 || (a2.reading = false, P(t2, a2));
          return !a2.ended && (a2.length < a2.highWaterMark || a2.length === 0);
        }
        function E(t2, e2, r3, n2) {
          e2.flowing && e2.length === 0 && !e2.sync ? (e2.awaitDrain = 0, t2.emit("data", r3)) : (e2.length += e2.objectMode ? 1 : r3.length, n2 ? e2.buffer.unshift(r3) : e2.buffer.push(r3), e2.needReadable && T(t2)), P(t2, e2);
        }
        Object.defineProperty(O.prototype, "destroyed", { enumerable: false, get: function() {
          return this._readableState !== void 0 && this._readableState.destroyed;
        }, set: function(t2) {
          this._readableState && (this._readableState.destroyed = t2);
        } }), O.prototype.destroy = m.destroy, O.prototype._undestroy = m.undestroy, O.prototype._destroy = function(t2, e2) {
          e2(t2);
        }, O.prototype.push = function(t2, e2) {
          var r3, n2 = this._readableState;
          return n2.objectMode ? r3 = true : typeof t2 == "string" && ((e2 = e2 || n2.defaultEncoding) !== n2.encoding && (t2 = s.from(t2, e2), e2 = ""), r3 = true), j(this, t2, e2, false, r3);
        }, O.prototype.unshift = function(t2) {
          return j(this, t2, null, true, false);
        }, O.prototype.isPaused = function() {
          return this._readableState.flowing === false;
        }, O.prototype.setEncoding = function(e2) {
          l || (l = t("string_decoder/").StringDecoder);
          var r3 = new l(e2);
          this._readableState.decoder = r3, this._readableState.encoding = this._readableState.decoder.encoding;
          for (var n2 = this._readableState.buffer.head, i2 = ""; n2 !== null; )
            i2 += r3.write(n2.data), n2 = n2.next;
          return this._readableState.buffer.clear(), i2 !== "" && this._readableState.buffer.push(i2), this._readableState.length = i2.length, this;
        };
        function R(t2, e2) {
          return t2 <= 0 || e2.length === 0 && e2.ended ? 0 : e2.objectMode ? 1 : t2 != t2 ? e2.flowing && e2.length ? e2.buffer.head.data.length : e2.length : (t2 > e2.highWaterMark && (e2.highWaterMark = function(t3) {
            return t3 >= 1073741824 ? t3 = 1073741824 : (t3--, t3 |= t3 >>> 1, t3 |= t3 >>> 2, t3 |= t3 >>> 4, t3 |= t3 >>> 8, t3 |= t3 >>> 16, t3++), t3;
          }(t2)), t2 <= e2.length ? t2 : e2.ended ? e2.length : (e2.needReadable = true, 0));
        }
        function T(t2) {
          var e2 = t2._readableState;
          c("emitReadable", e2.needReadable, e2.emittedReadable), e2.needReadable = false, e2.emittedReadable || (c("emitReadable", e2.flowing), e2.emittedReadable = true, r2.nextTick(C, t2));
        }
        function C(t2) {
          var e2 = t2._readableState;
          c("emitReadable_", e2.destroyed, e2.length, e2.ended), e2.destroyed || !e2.length && !e2.ended || (t2.emit("readable"), e2.emittedReadable = false), e2.needReadable = !e2.flowing && !e2.ended && e2.length <= e2.highWaterMark, D(t2);
        }
        function P(t2, e2) {
          e2.readingMore || (e2.readingMore = true, r2.nextTick(M, t2, e2));
        }
        function M(t2, e2) {
          for (; !e2.reading && !e2.ended && (e2.length < e2.highWaterMark || e2.flowing && e2.length === 0); ) {
            var r3 = e2.length;
            if (c("maybeReadMore read 0"), t2.read(0), r3 === e2.length)
              break;
          }
          e2.readingMore = false;
        }
        function A(t2) {
          var e2 = t2._readableState;
          e2.readableListening = t2.listenerCount("readable") > 0, e2.resumeScheduled && !e2.paused ? e2.flowing = true : t2.listenerCount("data") > 0 && t2.resume();
        }
        function I(t2) {
          c("readable nexttick read 0"), t2.read(0);
        }
        function N(t2, e2) {
          c("resume", e2.reading), e2.reading || t2.read(0), e2.resumeScheduled = false, t2.emit("resume"), D(t2), e2.flowing && !e2.reading && t2.read(0);
        }
        function D(t2) {
          var e2 = t2._readableState;
          for (c("flow", e2.flowing); e2.flowing && t2.read() !== null; )
            ;
        }
        function B(t2, e2) {
          return e2.length === 0 ? null : (e2.objectMode ? r3 = e2.buffer.shift() : !t2 || t2 >= e2.length ? (r3 = e2.decoder ? e2.buffer.join("") : e2.buffer.length === 1 ? e2.buffer.first() : e2.buffer.concat(e2.length), e2.buffer.clear()) : r3 = e2.buffer.consume(t2, e2.decoder), r3);
          var r3;
        }
        function F(t2) {
          var e2 = t2._readableState;
          c("endReadable", e2.endEmitted), e2.endEmitted || (e2.ended = true, r2.nextTick(L, e2, t2));
        }
        function L(t2, e2) {
          if (c("endReadableNT", t2.endEmitted, t2.length), !t2.endEmitted && t2.length === 0 && (t2.endEmitted = true, e2.readable = false, e2.emit("end"), t2.autoDestroy)) {
            var r3 = e2._writableState;
            (!r3 || r3.autoDestroy && r3.finished) && e2.destroy();
          }
        }
        function z(t2, e2) {
          for (var r3 = 0, n2 = t2.length; r3 < n2; r3++)
            if (t2[r3] === e2)
              return r3;
          return -1;
        }
        O.prototype.read = function(t2) {
          c("read", t2), t2 = parseInt(t2, 10);
          var e2 = this._readableState, r3 = t2;
          if (t2 !== 0 && (e2.emittedReadable = false), t2 === 0 && e2.needReadable && ((e2.highWaterMark !== 0 ? e2.length >= e2.highWaterMark : e2.length > 0) || e2.ended))
            return c("read: emitReadable", e2.length, e2.ended), e2.length === 0 && e2.ended ? F(this) : T(this), null;
          if ((t2 = R(t2, e2)) === 0 && e2.ended)
            return e2.length === 0 && F(this), null;
          var n2, i2 = e2.needReadable;
          return c("need readable", i2), (e2.length === 0 || e2.length - t2 < e2.highWaterMark) && c("length less than watermark", i2 = true), e2.ended || e2.reading ? c("reading or ended", i2 = false) : i2 && (c("do read"), e2.reading = true, e2.sync = true, e2.length === 0 && (e2.needReadable = true), this._read(e2.highWaterMark), e2.sync = false, e2.reading || (t2 = R(r3, e2))), (n2 = t2 > 0 ? B(t2, e2) : null) === null ? (e2.needReadable = e2.length <= e2.highWaterMark, t2 = 0) : (e2.length -= t2, e2.awaitDrain = 0), e2.length === 0 && (e2.ended || (e2.needReadable = true), r3 !== t2 && e2.ended && F(this)), n2 !== null && this.emit("data", n2), n2;
        }, O.prototype._read = function(t2) {
          k(this, new w("_read()"));
        }, O.prototype.pipe = function(t2, e2) {
          var n2 = this, i2 = this._readableState;
          switch (i2.pipesCount) {
            case 0:
              i2.pipes = t2;
              break;
            case 1:
              i2.pipes = [i2.pipes, t2];
              break;
            default:
              i2.pipes.push(t2);
          }
          i2.pipesCount += 1, c("pipe count=%d opts=%j", i2.pipesCount, e2);
          var a2 = (!e2 || e2.end !== false) && t2 !== r2.stdout && t2 !== r2.stderr ? u2 : y2;
          function s2(e3, r3) {
            c("onunpipe"), e3 === n2 && r3 && r3.hasUnpiped === false && (r3.hasUnpiped = true, c("cleanup"), t2.removeListener("close", p2), t2.removeListener("finish", m2), t2.removeListener("drain", f2), t2.removeListener("error", d2), t2.removeListener("unpipe", s2), n2.removeListener("end", u2), n2.removeListener("end", y2), n2.removeListener("data", h2), l2 = true, !i2.awaitDrain || t2._writableState && !t2._writableState.needDrain || f2());
          }
          function u2() {
            c("onend"), t2.end();
          }
          i2.endEmitted ? r2.nextTick(a2) : n2.once("end", a2), t2.on("unpipe", s2);
          var f2 = function(t3) {
            return function() {
              var e3 = t3._readableState;
              c("pipeOnDrain", e3.awaitDrain), e3.awaitDrain && e3.awaitDrain--, e3.awaitDrain === 0 && o(t3, "data") && (e3.flowing = true, D(t3));
            };
          }(n2);
          t2.on("drain", f2);
          var l2 = false;
          function h2(e3) {
            c("ondata");
            var r3 = t2.write(e3);
            c("dest.write", r3), r3 === false && ((i2.pipesCount === 1 && i2.pipes === t2 || i2.pipesCount > 1 && z(i2.pipes, t2) !== -1) && !l2 && (c("false write response, pause", i2.awaitDrain), i2.awaitDrain++), n2.pause());
          }
          function d2(e3) {
            c("onerror", e3), y2(), t2.removeListener("error", d2), o(t2, "error") === 0 && k(t2, e3);
          }
          function p2() {
            t2.removeListener("finish", m2), y2();
          }
          function m2() {
            c("onfinish"), t2.removeListener("close", p2), y2();
          }
          function y2() {
            c("unpipe"), n2.unpipe(t2);
          }
          return n2.on("data", h2), function(t3, e3, r3) {
            if (typeof t3.prependListener == "function")
              return t3.prependListener(e3, r3);
            t3._events && t3._events[e3] ? Array.isArray(t3._events[e3]) ? t3._events[e3].unshift(r3) : t3._events[e3] = [r3, t3._events[e3]] : t3.on(e3, r3);
          }(t2, "error", d2), t2.once("close", p2), t2.once("finish", m2), t2.emit("pipe", n2), i2.flowing || (c("pipe resume"), n2.resume()), t2;
        }, O.prototype.unpipe = function(t2) {
          var e2 = this._readableState, r3 = { hasUnpiped: false };
          if (e2.pipesCount === 0)
            return this;
          if (e2.pipesCount === 1)
            return t2 && t2 !== e2.pipes || (t2 || (t2 = e2.pipes), e2.pipes = null, e2.pipesCount = 0, e2.flowing = false, t2 && t2.emit("unpipe", this, r3)), this;
          if (!t2) {
            var n2 = e2.pipes, i2 = e2.pipesCount;
            e2.pipes = null, e2.pipesCount = 0, e2.flowing = false;
            for (var o2 = 0; o2 < i2; o2++)
              n2[o2].emit("unpipe", this, { hasUnpiped: false });
            return this;
          }
          var a2 = z(e2.pipes, t2);
          return a2 === -1 || (e2.pipes.splice(a2, 1), e2.pipesCount -= 1, e2.pipesCount === 1 && (e2.pipes = e2.pipes[0]), t2.emit("unpipe", this, r3)), this;
        }, O.prototype.on = function(t2, e2) {
          var n2 = a.prototype.on.call(this, t2, e2), i2 = this._readableState;
          return t2 === "data" ? (i2.readableListening = this.listenerCount("readable") > 0, i2.flowing !== false && this.resume()) : t2 === "readable" && (i2.endEmitted || i2.readableListening || (i2.readableListening = i2.needReadable = true, i2.flowing = false, i2.emittedReadable = false, c("on readable", i2.length, i2.reading), i2.length ? T(this) : i2.reading || r2.nextTick(I, this))), n2;
        }, O.prototype.addListener = O.prototype.on, O.prototype.removeListener = function(t2, e2) {
          var n2 = a.prototype.removeListener.call(this, t2, e2);
          return t2 === "readable" && r2.nextTick(A, this), n2;
        }, O.prototype.removeAllListeners = function(t2) {
          var e2 = a.prototype.removeAllListeners.apply(this, arguments);
          return t2 !== "readable" && t2 !== void 0 || r2.nextTick(A, this), e2;
        }, O.prototype.resume = function() {
          var t2 = this._readableState;
          return t2.flowing || (c("resume"), t2.flowing = !t2.readableListening, function(t3, e2) {
            e2.resumeScheduled || (e2.resumeScheduled = true, r2.nextTick(N, t3, e2));
          }(this, t2)), t2.paused = false, this;
        }, O.prototype.pause = function() {
          return c("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (c("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
        }, O.prototype.wrap = function(t2) {
          var e2 = this, r3 = this._readableState, n2 = false;
          for (var i2 in t2.on("end", function() {
            if (c("wrapped end"), r3.decoder && !r3.ended) {
              var t3 = r3.decoder.end();
              t3 && t3.length && e2.push(t3);
            }
            e2.push(null);
          }), t2.on("data", function(i3) {
            (c("wrapped data"), r3.decoder && (i3 = r3.decoder.write(i3)), r3.objectMode && i3 == null) || (r3.objectMode || i3 && i3.length) && (e2.push(i3) || (n2 = true, t2.pause()));
          }), t2)
            this[i2] === void 0 && typeof t2[i2] == "function" && (this[i2] = function(e3) {
              return function() {
                return t2[e3].apply(t2, arguments);
              };
            }(i2));
          for (var o2 = 0; o2 < x.length; o2++)
            t2.on(x[o2], this.emit.bind(this, x[o2]));
          return this._read = function(e3) {
            c("wrapped _read", e3), n2 && (n2 = false, t2.resume());
          }, this;
        }, typeof Symbol == "function" && (O.prototype[Symbol.asyncIterator] = function() {
          return h === void 0 && (h = t("./internal/streams/async_iterator")), h(this);
        }), Object.defineProperty(O.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
          return this._readableState.highWaterMark;
        } }), Object.defineProperty(O.prototype, "readableBuffer", { enumerable: false, get: function() {
          return this._readableState && this._readableState.buffer;
        } }), Object.defineProperty(O.prototype, "readableFlowing", { enumerable: false, get: function() {
          return this._readableState.flowing;
        }, set: function(t2) {
          this._readableState && (this._readableState.flowing = t2);
        } }), O._fromList = B, Object.defineProperty(O.prototype, "readableLength", { enumerable: false, get: function() {
          return this._readableState.length;
        } }), typeof Symbol == "function" && (O.from = function(e2, r3) {
          return d === void 0 && (d = t("./internal/streams/from")), d(O, e2, r3);
        });
      }).call(this, t("_process"), typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, { "../errors": 477, "./_stream_duplex": 478, "./internal/streams/async_iterator": 483, "./internal/streams/buffer_list": 484, "./internal/streams/destroy": 485, "./internal/streams/from": 487, "./internal/streams/state": 489, "./internal/streams/stream": 490, _process: 467, buffer: 216, events: 367, inherits: 387, "string_decoder/": 520, util: 185 }], 481: [function(t, e, r) {
      e.exports = f;
      var n = t("../errors").codes, i = n.ERR_METHOD_NOT_IMPLEMENTED, o = n.ERR_MULTIPLE_CALLBACK, a = n.ERR_TRANSFORM_ALREADY_TRANSFORMING, s = n.ERR_TRANSFORM_WITH_LENGTH_0, u = t("./_stream_duplex");
      function c(t2, e2) {
        var r2 = this._transformState;
        r2.transforming = false;
        var n2 = r2.writecb;
        if (n2 === null)
          return this.emit("error", new o());
        r2.writechunk = null, r2.writecb = null, e2 != null && this.push(e2), n2(t2);
        var i2 = this._readableState;
        i2.reading = false, (i2.needReadable || i2.length < i2.highWaterMark) && this._read(i2.highWaterMark);
      }
      function f(t2) {
        if (!(this instanceof f))
          return new f(t2);
        u.call(this, t2), this._transformState = { afterTransform: c.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, t2 && (typeof t2.transform == "function" && (this._transform = t2.transform), typeof t2.flush == "function" && (this._flush = t2.flush)), this.on("prefinish", l);
      }
      function l() {
        var t2 = this;
        typeof this._flush != "function" || this._readableState.destroyed ? h(this, null, null) : this._flush(function(e2, r2) {
          h(t2, e2, r2);
        });
      }
      function h(t2, e2, r2) {
        if (e2)
          return t2.emit("error", e2);
        if (r2 != null && t2.push(r2), t2._writableState.length)
          throw new s();
        if (t2._transformState.transforming)
          throw new a();
        return t2.push(null);
      }
      t("inherits")(f, u), f.prototype.push = function(t2, e2) {
        return this._transformState.needTransform = false, u.prototype.push.call(this, t2, e2);
      }, f.prototype._transform = function(t2, e2, r2) {
        r2(new i("_transform()"));
      }, f.prototype._write = function(t2, e2, r2) {
        var n2 = this._transformState;
        if (n2.writecb = r2, n2.writechunk = t2, n2.writeencoding = e2, !n2.transforming) {
          var i2 = this._readableState;
          (n2.needTransform || i2.needReadable || i2.length < i2.highWaterMark) && this._read(i2.highWaterMark);
        }
      }, f.prototype._read = function(t2) {
        var e2 = this._transformState;
        e2.writechunk === null || e2.transforming ? e2.needTransform = true : (e2.transforming = true, this._transform(e2.writechunk, e2.writeencoding, e2.afterTransform));
      }, f.prototype._destroy = function(t2, e2) {
        u.prototype._destroy.call(this, t2, function(t3) {
          e2(t3);
        });
      };
    }, { "../errors": 477, "./_stream_duplex": 478, inherits: 387 }], 482: [function(t, e, r) {
      (function(r2, n) {
        function i(t2) {
          var e2 = this;
          this.next = null, this.entry = null, this.finish = function() {
            !function(t3, e3, r3) {
              var n2 = t3.entry;
              t3.entry = null;
              for (; n2; ) {
                var i2 = n2.callback;
                e3.pendingcb--, i2(r3), n2 = n2.next;
              }
              e3.corkedRequestsFree.next = t3;
            }(e2, t2);
          };
        }
        var o;
        e.exports = O, O.WritableState = S;
        var a = { deprecate: t("util-deprecate") }, s = t("./internal/streams/stream"), u = t("buffer").Buffer, c = n.Uint8Array || function() {
        };
        var f, l = t("./internal/streams/destroy"), h = t("./internal/streams/state").getHighWaterMark, d = t("../errors").codes, p = d.ERR_INVALID_ARG_TYPE, m = d.ERR_METHOD_NOT_IMPLEMENTED, y = d.ERR_MULTIPLE_CALLBACK, b = d.ERR_STREAM_CANNOT_PIPE, v = d.ERR_STREAM_DESTROYED, g = d.ERR_STREAM_NULL_VALUES, w = d.ERR_STREAM_WRITE_AFTER_END, _ = d.ERR_UNKNOWN_ENCODING, k = l.errorOrDestroy;
        function x() {
        }
        function S(e2, n2, a2) {
          o = o || t("./_stream_duplex"), e2 = e2 || {}, typeof a2 != "boolean" && (a2 = n2 instanceof o), this.objectMode = !!e2.objectMode, a2 && (this.objectMode = this.objectMode || !!e2.writableObjectMode), this.highWaterMark = h(this, e2, "writableHighWaterMark", a2), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
          var s2 = e2.decodeStrings === false;
          this.decodeStrings = !s2, this.defaultEncoding = e2.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(t2) {
            !function(t3, e3) {
              var n3 = t3._writableState, i2 = n3.sync, o2 = n3.writecb;
              if (typeof o2 != "function")
                throw new y();
              if (function(t4) {
                t4.writing = false, t4.writecb = null, t4.length -= t4.writelen, t4.writelen = 0;
              }(n3), e3)
                !function(t4, e4, n4, i3, o3) {
                  --e4.pendingcb, n4 ? (r2.nextTick(o3, i3), r2.nextTick(P, t4, e4), t4._writableState.errorEmitted = true, k(t4, i3)) : (o3(i3), t4._writableState.errorEmitted = true, k(t4, i3), P(t4, e4));
                }(t3, n3, i2, e3, o2);
              else {
                var a3 = T(n3) || t3.destroyed;
                a3 || n3.corked || n3.bufferProcessing || !n3.bufferedRequest || R(t3, n3), i2 ? r2.nextTick(E, t3, n3, a3, o2) : E(t3, n3, a3, o2);
              }
            }(n2, t2);
          }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = e2.emitClose !== false, this.autoDestroy = !!e2.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new i(this);
        }
        function O(e2) {
          var r3 = this instanceof (o = o || t("./_stream_duplex"));
          if (!r3 && !f.call(O, this))
            return new O(e2);
          this._writableState = new S(e2, this, r3), this.writable = true, e2 && (typeof e2.write == "function" && (this._write = e2.write), typeof e2.writev == "function" && (this._writev = e2.writev), typeof e2.destroy == "function" && (this._destroy = e2.destroy), typeof e2.final == "function" && (this._final = e2.final)), s.call(this);
        }
        function j(t2, e2, r3, n2, i2, o2, a2) {
          e2.writelen = n2, e2.writecb = a2, e2.writing = true, e2.sync = true, e2.destroyed ? e2.onwrite(new v("write")) : r3 ? t2._writev(i2, e2.onwrite) : t2._write(i2, o2, e2.onwrite), e2.sync = false;
        }
        function E(t2, e2, r3, n2) {
          r3 || function(t3, e3) {
            e3.length === 0 && e3.needDrain && (e3.needDrain = false, t3.emit("drain"));
          }(t2, e2), e2.pendingcb--, n2(), P(t2, e2);
        }
        function R(t2, e2) {
          e2.bufferProcessing = true;
          var r3 = e2.bufferedRequest;
          if (t2._writev && r3 && r3.next) {
            var n2 = e2.bufferedRequestCount, o2 = new Array(n2), a2 = e2.corkedRequestsFree;
            a2.entry = r3;
            for (var s2 = 0, u2 = true; r3; )
              o2[s2] = r3, r3.isBuf || (u2 = false), r3 = r3.next, s2 += 1;
            o2.allBuffers = u2, j(t2, e2, true, e2.length, o2, "", a2.finish), e2.pendingcb++, e2.lastBufferedRequest = null, a2.next ? (e2.corkedRequestsFree = a2.next, a2.next = null) : e2.corkedRequestsFree = new i(e2), e2.bufferedRequestCount = 0;
          } else {
            for (; r3; ) {
              var c2 = r3.chunk, f2 = r3.encoding, l2 = r3.callback;
              if (j(t2, e2, false, e2.objectMode ? 1 : c2.length, c2, f2, l2), r3 = r3.next, e2.bufferedRequestCount--, e2.writing)
                break;
            }
            r3 === null && (e2.lastBufferedRequest = null);
          }
          e2.bufferedRequest = r3, e2.bufferProcessing = false;
        }
        function T(t2) {
          return t2.ending && t2.length === 0 && t2.bufferedRequest === null && !t2.finished && !t2.writing;
        }
        function C(t2, e2) {
          t2._final(function(r3) {
            e2.pendingcb--, r3 && k(t2, r3), e2.prefinished = true, t2.emit("prefinish"), P(t2, e2);
          });
        }
        function P(t2, e2) {
          var n2 = T(e2);
          if (n2 && (function(t3, e3) {
            e3.prefinished || e3.finalCalled || (typeof t3._final != "function" || e3.destroyed ? (e3.prefinished = true, t3.emit("prefinish")) : (e3.pendingcb++, e3.finalCalled = true, r2.nextTick(C, t3, e3)));
          }(t2, e2), e2.pendingcb === 0 && (e2.finished = true, t2.emit("finish"), e2.autoDestroy))) {
            var i2 = t2._readableState;
            (!i2 || i2.autoDestroy && i2.endEmitted) && t2.destroy();
          }
          return n2;
        }
        t("inherits")(O, s), S.prototype.getBuffer = function() {
          for (var t2 = this.bufferedRequest, e2 = []; t2; )
            e2.push(t2), t2 = t2.next;
          return e2;
        }, function() {
          try {
            Object.defineProperty(S.prototype, "buffer", { get: a.deprecate(function() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
          } catch (t2) {
          }
        }(), typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (f = Function.prototype[Symbol.hasInstance], Object.defineProperty(O, Symbol.hasInstance, { value: function(t2) {
          return !!f.call(this, t2) || this === O && (t2 && t2._writableState instanceof S);
        } })) : f = function(t2) {
          return t2 instanceof this;
        }, O.prototype.pipe = function() {
          k(this, new b());
        }, O.prototype.write = function(t2, e2, n2) {
          var i2, o2 = this._writableState, a2 = false, s2 = !o2.objectMode && (i2 = t2, u.isBuffer(i2) || i2 instanceof c);
          return s2 && !u.isBuffer(t2) && (t2 = function(t3) {
            return u.from(t3);
          }(t2)), typeof e2 == "function" && (n2 = e2, e2 = null), s2 ? e2 = "buffer" : e2 || (e2 = o2.defaultEncoding), typeof n2 != "function" && (n2 = x), o2.ending ? function(t3, e3) {
            var n3 = new w();
            k(t3, n3), r2.nextTick(e3, n3);
          }(this, n2) : (s2 || function(t3, e3, n3, i3) {
            var o3;
            return n3 === null ? o3 = new g() : typeof n3 == "string" || e3.objectMode || (o3 = new p("chunk", ["string", "Buffer"], n3)), !o3 || (k(t3, o3), r2.nextTick(i3, o3), false);
          }(this, o2, t2, n2)) && (o2.pendingcb++, a2 = function(t3, e3, r3, n3, i3, o3) {
            if (!r3) {
              var a3 = function(t4, e4, r4) {
                t4.objectMode || t4.decodeStrings === false || typeof e4 != "string" || (e4 = u.from(e4, r4));
                return e4;
              }(e3, n3, i3);
              n3 !== a3 && (r3 = true, i3 = "buffer", n3 = a3);
            }
            var s3 = e3.objectMode ? 1 : n3.length;
            e3.length += s3;
            var c2 = e3.length < e3.highWaterMark;
            c2 || (e3.needDrain = true);
            if (e3.writing || e3.corked) {
              var f2 = e3.lastBufferedRequest;
              e3.lastBufferedRequest = { chunk: n3, encoding: i3, isBuf: r3, callback: o3, next: null }, f2 ? f2.next = e3.lastBufferedRequest : e3.bufferedRequest = e3.lastBufferedRequest, e3.bufferedRequestCount += 1;
            } else
              j(t3, e3, false, s3, n3, i3, o3);
            return c2;
          }(this, o2, s2, t2, e2, n2)), a2;
        }, O.prototype.cork = function() {
          this._writableState.corked++;
        }, O.prototype.uncork = function() {
          var t2 = this._writableState;
          t2.corked && (t2.corked--, t2.writing || t2.corked || t2.bufferProcessing || !t2.bufferedRequest || R(this, t2));
        }, O.prototype.setDefaultEncoding = function(t2) {
          if (typeof t2 == "string" && (t2 = t2.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((t2 + "").toLowerCase()) > -1))
            throw new _(t2);
          return this._writableState.defaultEncoding = t2, this;
        }, Object.defineProperty(O.prototype, "writableBuffer", { enumerable: false, get: function() {
          return this._writableState && this._writableState.getBuffer();
        } }), Object.defineProperty(O.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
          return this._writableState.highWaterMark;
        } }), O.prototype._write = function(t2, e2, r3) {
          r3(new m("_write()"));
        }, O.prototype._writev = null, O.prototype.end = function(t2, e2, n2) {
          var i2 = this._writableState;
          return typeof t2 == "function" ? (n2 = t2, t2 = null, e2 = null) : typeof e2 == "function" && (n2 = e2, e2 = null), t2 != null && this.write(t2, e2), i2.corked && (i2.corked = 1, this.uncork()), i2.ending || function(t3, e3, n3) {
            e3.ending = true, P(t3, e3), n3 && (e3.finished ? r2.nextTick(n3) : t3.once("finish", n3));
            e3.ended = true, t3.writable = false;
          }(this, i2, n2), this;
        }, Object.defineProperty(O.prototype, "writableLength", { enumerable: false, get: function() {
          return this._writableState.length;
        } }), Object.defineProperty(O.prototype, "destroyed", { enumerable: false, get: function() {
          return this._writableState !== void 0 && this._writableState.destroyed;
        }, set: function(t2) {
          this._writableState && (this._writableState.destroyed = t2);
        } }), O.prototype.destroy = l.destroy, O.prototype._undestroy = l.undestroy, O.prototype._destroy = function(t2, e2) {
          e2(t2);
        };
      }).call(this, t("_process"), typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, { "../errors": 477, "./_stream_duplex": 478, "./internal/streams/destroy": 485, "./internal/streams/state": 489, "./internal/streams/stream": 490, _process: 467, buffer: 216, inherits: 387, "util-deprecate": 522 }], 483: [function(t, e, r) {
      (function(r2) {
        var n;
        function i(t2, e2, r3) {
          return e2 in t2 ? Object.defineProperty(t2, e2, { value: r3, enumerable: true, configurable: true, writable: true }) : t2[e2] = r3, t2;
        }
        var o = t("./end-of-stream"), a = Symbol("lastResolve"), s = Symbol("lastReject"), u = Symbol("error"), c = Symbol("ended"), f = Symbol("lastPromise"), l = Symbol("handlePromise"), h = Symbol("stream");
        function d(t2, e2) {
          return { value: t2, done: e2 };
        }
        function p(t2) {
          var e2 = t2[a];
          if (e2 !== null) {
            var r3 = t2[h].read();
            r3 !== null && (t2[f] = null, t2[a] = null, t2[s] = null, e2(d(r3, false)));
          }
        }
        function m(t2) {
          r2.nextTick(p, t2);
        }
        var y = Object.getPrototypeOf(function() {
        }), b = Object.setPrototypeOf((i(n = { get stream() {
          return this[h];
        }, next: function() {
          var t2 = this, e2 = this[u];
          if (e2 !== null)
            return Promise.reject(e2);
          if (this[c])
            return Promise.resolve(d(void 0, true));
          if (this[h].destroyed)
            return new Promise(function(e3, n3) {
              r2.nextTick(function() {
                t2[u] ? n3(t2[u]) : e3(d(void 0, true));
              });
            });
          var n2, i2 = this[f];
          if (i2)
            n2 = new Promise(function(t3, e3) {
              return function(r3, n3) {
                t3.then(function() {
                  e3[c] ? r3(d(void 0, true)) : e3[l](r3, n3);
                }, n3);
              };
            }(i2, this));
          else {
            var o2 = this[h].read();
            if (o2 !== null)
              return Promise.resolve(d(o2, false));
            n2 = new Promise(this[l]);
          }
          return this[f] = n2, n2;
        } }, Symbol.asyncIterator, function() {
          return this;
        }), i(n, "return", function() {
          var t2 = this;
          return new Promise(function(e2, r3) {
            t2[h].destroy(null, function(t3) {
              t3 ? r3(t3) : e2(d(void 0, true));
            });
          });
        }), n), y);
        e.exports = function(t2) {
          var e2, r3 = Object.create(b, (i(e2 = {}, h, { value: t2, writable: true }), i(e2, a, { value: null, writable: true }), i(e2, s, { value: null, writable: true }), i(e2, u, { value: null, writable: true }), i(e2, c, { value: t2._readableState.endEmitted, writable: true }), i(e2, l, { value: function(t3, e3) {
            var n2 = r3[h].read();
            n2 ? (r3[f] = null, r3[a] = null, r3[s] = null, t3(d(n2, false))) : (r3[a] = t3, r3[s] = e3);
          }, writable: true }), e2));
          return r3[f] = null, o(t2, function(t3) {
            if (t3 && t3.code !== "ERR_STREAM_PREMATURE_CLOSE") {
              var e3 = r3[s];
              return e3 !== null && (r3[f] = null, r3[a] = null, r3[s] = null, e3(t3)), void (r3[u] = t3);
            }
            var n2 = r3[a];
            n2 !== null && (r3[f] = null, r3[a] = null, r3[s] = null, n2(d(void 0, true))), r3[c] = true;
          }), t2.on("readable", m.bind(null, r3)), r3;
        };
      }).call(this, t("_process"));
    }, { "./end-of-stream": 486, _process: 467 }], 484: [function(t, e, r) {
      function n(t2, e2) {
        var r2 = Object.keys(t2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t2);
          e2 && (n2 = n2.filter(function(e3) {
            return Object.getOwnPropertyDescriptor(t2, e3).enumerable;
          })), r2.push.apply(r2, n2);
        }
        return r2;
      }
      function i(t2, e2, r2) {
        return e2 in t2 ? Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }) : t2[e2] = r2, t2;
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      var a = t("buffer").Buffer, s = t("util").inspect, u = s && s.custom || "inspect";
      e.exports = function() {
        function t2() {
          !function(t3, e3) {
            if (!(t3 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, t2), this.head = null, this.tail = null, this.length = 0;
        }
        var e2, r2;
        return e2 = t2, (r2 = [{ key: "push", value: function(t3) {
          var e3 = { data: t3, next: null };
          this.length > 0 ? this.tail.next = e3 : this.head = e3, this.tail = e3, ++this.length;
        } }, { key: "unshift", value: function(t3) {
          var e3 = { data: t3, next: this.head };
          this.length === 0 && (this.tail = e3), this.head = e3, ++this.length;
        } }, { key: "shift", value: function() {
          if (this.length !== 0) {
            var t3 = this.head.data;
            return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, t3;
          }
        } }, { key: "clear", value: function() {
          this.head = this.tail = null, this.length = 0;
        } }, { key: "join", value: function(t3) {
          if (this.length === 0)
            return "";
          for (var e3 = this.head, r3 = "" + e3.data; e3 = e3.next; )
            r3 += t3 + e3.data;
          return r3;
        } }, { key: "concat", value: function(t3) {
          if (this.length === 0)
            return a.alloc(0);
          for (var e3, r3, n2, i2 = a.allocUnsafe(t3 >>> 0), o2 = this.head, s2 = 0; o2; )
            e3 = o2.data, r3 = i2, n2 = s2, a.prototype.copy.call(e3, r3, n2), s2 += o2.data.length, o2 = o2.next;
          return i2;
        } }, { key: "consume", value: function(t3, e3) {
          var r3;
          return t3 < this.head.data.length ? (r3 = this.head.data.slice(0, t3), this.head.data = this.head.data.slice(t3)) : r3 = t3 === this.head.data.length ? this.shift() : e3 ? this._getString(t3) : this._getBuffer(t3), r3;
        } }, { key: "first", value: function() {
          return this.head.data;
        } }, { key: "_getString", value: function(t3) {
          var e3 = this.head, r3 = 1, n2 = e3.data;
          for (t3 -= n2.length; e3 = e3.next; ) {
            var i2 = e3.data, o2 = t3 > i2.length ? i2.length : t3;
            if (o2 === i2.length ? n2 += i2 : n2 += i2.slice(0, t3), (t3 -= o2) == 0) {
              o2 === i2.length ? (++r3, e3.next ? this.head = e3.next : this.head = this.tail = null) : (this.head = e3, e3.data = i2.slice(o2));
              break;
            }
            ++r3;
          }
          return this.length -= r3, n2;
        } }, { key: "_getBuffer", value: function(t3) {
          var e3 = a.allocUnsafe(t3), r3 = this.head, n2 = 1;
          for (r3.data.copy(e3), t3 -= r3.data.length; r3 = r3.next; ) {
            var i2 = r3.data, o2 = t3 > i2.length ? i2.length : t3;
            if (i2.copy(e3, e3.length - t3, 0, o2), (t3 -= o2) == 0) {
              o2 === i2.length ? (++n2, r3.next ? this.head = r3.next : this.head = this.tail = null) : (this.head = r3, r3.data = i2.slice(o2));
              break;
            }
            ++n2;
          }
          return this.length -= n2, e3;
        } }, { key: u, value: function(t3, e3) {
          return s(this, function(t4) {
            for (var e4 = 1; e4 < arguments.length; e4++) {
              var r3 = arguments[e4] != null ? arguments[e4] : {};
              e4 % 2 ? n(Object(r3), true).forEach(function(e5) {
                i(t4, e5, r3[e5]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(r3)) : n(Object(r3)).forEach(function(e5) {
                Object.defineProperty(t4, e5, Object.getOwnPropertyDescriptor(r3, e5));
              });
            }
            return t4;
          }({}, e3, { depth: 0, customInspect: false }));
        } }]) && o(e2.prototype, r2), t2;
      }();
    }, { buffer: 216, util: 185 }], 485: [function(t, e, r) {
      (function(t2) {
        function r2(t3, e2) {
          i(t3, e2), n(t3);
        }
        function n(t3) {
          t3._writableState && !t3._writableState.emitClose || t3._readableState && !t3._readableState.emitClose || t3.emit("close");
        }
        function i(t3, e2) {
          t3.emit("error", e2);
        }
        e.exports = { destroy: function(e2, o) {
          var a = this, s = this._readableState && this._readableState.destroyed, u = this._writableState && this._writableState.destroyed;
          return s || u ? (o ? o(e2) : e2 && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, t2.nextTick(i, this, e2)) : t2.nextTick(i, this, e2)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(e2 || null, function(e3) {
            !o && e3 ? a._writableState ? a._writableState.errorEmitted ? t2.nextTick(n, a) : (a._writableState.errorEmitted = true, t2.nextTick(r2, a, e3)) : t2.nextTick(r2, a, e3) : o ? (t2.nextTick(n, a), o(e3)) : t2.nextTick(n, a);
          }), this);
        }, undestroy: function() {
          this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
        }, errorOrDestroy: function(t3, e2) {
          var r3 = t3._readableState, n2 = t3._writableState;
          r3 && r3.autoDestroy || n2 && n2.autoDestroy ? t3.destroy(e2) : t3.emit("error", e2);
        } };
      }).call(this, t("_process"));
    }, { _process: 467 }], 486: [function(t, e, r) {
      var n = t("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;
      function i() {
      }
      e.exports = function t2(e2, r2, o) {
        if (typeof r2 == "function")
          return t2(e2, null, r2);
        r2 || (r2 = {}), o = function(t3) {
          var e3 = false;
          return function() {
            if (!e3) {
              e3 = true;
              for (var r3 = arguments.length, n2 = new Array(r3), i2 = 0; i2 < r3; i2++)
                n2[i2] = arguments[i2];
              t3.apply(this, n2);
            }
          };
        }(o || i);
        var a = r2.readable || r2.readable !== false && e2.readable, s = r2.writable || r2.writable !== false && e2.writable, u = function() {
          e2.writable || f();
        }, c = e2._writableState && e2._writableState.finished, f = function() {
          s = false, c = true, a || o.call(e2);
        }, l = e2._readableState && e2._readableState.endEmitted, h = function() {
          a = false, l = true, s || o.call(e2);
        }, d = function(t3) {
          o.call(e2, t3);
        }, p = function() {
          var t3;
          return a && !l ? (e2._readableState && e2._readableState.ended || (t3 = new n()), o.call(e2, t3)) : s && !c ? (e2._writableState && e2._writableState.ended || (t3 = new n()), o.call(e2, t3)) : void 0;
        }, m = function() {
          e2.req.on("finish", f);
        };
        return !function(t3) {
          return t3.setHeader && typeof t3.abort == "function";
        }(e2) ? s && !e2._writableState && (e2.on("end", u), e2.on("close", u)) : (e2.on("complete", f), e2.on("abort", p), e2.req ? m() : e2.on("request", m)), e2.on("end", h), e2.on("finish", f), r2.error !== false && e2.on("error", d), e2.on("close", p), function() {
          e2.removeListener("complete", f), e2.removeListener("abort", p), e2.removeListener("request", m), e2.req && e2.req.removeListener("finish", f), e2.removeListener("end", u), e2.removeListener("close", u), e2.removeListener("finish", f), e2.removeListener("end", h), e2.removeListener("error", d), e2.removeListener("close", p);
        };
      };
    }, { "../../../errors": 477 }], 487: [function(t, e, r) {
      e.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }, {}], 488: [function(t, e, r) {
      var n;
      var i = t("../../../errors").codes, o = i.ERR_MISSING_ARGS, a = i.ERR_STREAM_DESTROYED;
      function s(t2) {
        if (t2)
          throw t2;
      }
      function u(e2, r2, i2, o2) {
        o2 = function(t2) {
          var e3 = false;
          return function() {
            e3 || (e3 = true, t2.apply(void 0, arguments));
          };
        }(o2);
        var s2 = false;
        e2.on("close", function() {
          s2 = true;
        }), n === void 0 && (n = t("./end-of-stream")), n(e2, { readable: r2, writable: i2 }, function(t2) {
          if (t2)
            return o2(t2);
          s2 = true, o2();
        });
        var u2 = false;
        return function(t2) {
          if (!s2 && !u2)
            return u2 = true, function(t3) {
              return t3.setHeader && typeof t3.abort == "function";
            }(e2) ? e2.abort() : typeof e2.destroy == "function" ? e2.destroy() : void o2(t2 || new a("pipe"));
        };
      }
      function c(t2) {
        t2();
      }
      function f(t2, e2) {
        return t2.pipe(e2);
      }
      function l(t2) {
        return t2.length ? typeof t2[t2.length - 1] != "function" ? s : t2.pop() : s;
      }
      e.exports = function() {
        for (var t2 = arguments.length, e2 = new Array(t2), r2 = 0; r2 < t2; r2++)
          e2[r2] = arguments[r2];
        var n2, i2 = l(e2);
        if (Array.isArray(e2[0]) && (e2 = e2[0]), e2.length < 2)
          throw new o("streams");
        var a2 = e2.map(function(t3, r3) {
          var o2 = r3 < e2.length - 1;
          return u(t3, o2, r3 > 0, function(t4) {
            n2 || (n2 = t4), t4 && a2.forEach(c), o2 || (a2.forEach(c), i2(n2));
          });
        });
        return e2.reduce(f);
      };
    }, { "../../../errors": 477, "./end-of-stream": 486 }], 489: [function(t, e, r) {
      var n = t("../../../errors").codes.ERR_INVALID_OPT_VALUE;
      e.exports = { getHighWaterMark: function(t2, e2, r2, i) {
        var o = function(t3, e3, r3) {
          return t3.highWaterMark != null ? t3.highWaterMark : e3 ? t3[r3] : null;
        }(e2, i, r2);
        if (o != null) {
          if (!isFinite(o) || Math.floor(o) !== o || o < 0)
            throw new n(i ? r2 : "highWaterMark", o);
          return Math.floor(o);
        }
        return t2.objectMode ? 16 : 16384;
      } };
    }, { "../../../errors": 477 }], 490: [function(t, e, r) {
      e.exports = t("events").EventEmitter;
    }, { events: 367 }], 491: [function(t, e, r) {
      (r = e.exports = t("./lib/_stream_readable.js")).Stream = r, r.Readable = r, r.Writable = t("./lib/_stream_writable.js"), r.Duplex = t("./lib/_stream_duplex.js"), r.Transform = t("./lib/_stream_transform.js"), r.PassThrough = t("./lib/_stream_passthrough.js"), r.finished = t("./lib/internal/streams/end-of-stream.js"), r.pipeline = t("./lib/internal/streams/pipeline.js");
    }, { "./lib/_stream_duplex.js": 478, "./lib/_stream_passthrough.js": 479, "./lib/_stream_readable.js": 480, "./lib/_stream_transform.js": 481, "./lib/_stream_writable.js": 482, "./lib/internal/streams/end-of-stream.js": 486, "./lib/internal/streams/pipeline.js": 488 }], 492: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      var i = function(t2) {
        var e2 = Object.prototype, r2 = e2.hasOwnProperty, i2 = typeof Symbol == "function" ? Symbol : {}, o = i2.iterator || "@@iterator", a = i2.asyncIterator || "@@asyncIterator", s = i2.toStringTag || "@@toStringTag";
        function u(t3, e3, r3) {
          return Object.defineProperty(t3, e3, { value: r3, enumerable: true, configurable: true, writable: true }), t3[e3];
        }
        try {
          u({}, "");
        } catch (t3) {
          u = function(t4, e3, r3) {
            return t4[e3] = r3;
          };
        }
        function c(t3, e3, r3, n2) {
          var i3 = e3 && e3.prototype instanceof h ? e3 : h, o2 = Object.create(i3.prototype), a2 = new S(n2 || []);
          return o2._invoke = function(t4, e4, r4) {
            var n3 = "suspendedStart";
            return function(i4, o3) {
              if (n3 === "executing")
                throw new Error("Generator is already running");
              if (n3 === "completed") {
                if (i4 === "throw")
                  throw o3;
                return j();
              }
              for (r4.method = i4, r4.arg = o3; ; ) {
                var a3 = r4.delegate;
                if (a3) {
                  var s2 = _(a3, r4);
                  if (s2) {
                    if (s2 === l)
                      continue;
                    return s2;
                  }
                }
                if (r4.method === "next")
                  r4.sent = r4._sent = r4.arg;
                else if (r4.method === "throw") {
                  if (n3 === "suspendedStart")
                    throw n3 = "completed", r4.arg;
                  r4.dispatchException(r4.arg);
                } else
                  r4.method === "return" && r4.abrupt("return", r4.arg);
                n3 = "executing";
                var u2 = f(t4, e4, r4);
                if (u2.type === "normal") {
                  if (n3 = r4.done ? "completed" : "suspendedYield", u2.arg === l)
                    continue;
                  return { value: u2.arg, done: r4.done };
                }
                u2.type === "throw" && (n3 = "completed", r4.method = "throw", r4.arg = u2.arg);
              }
            };
          }(t3, r3, a2), o2;
        }
        function f(t3, e3, r3) {
          try {
            return { type: "normal", arg: t3.call(e3, r3) };
          } catch (t4) {
            return { type: "throw", arg: t4 };
          }
        }
        t2.wrap = c;
        var l = {};
        function h() {
        }
        function d() {
        }
        function p() {
        }
        var m = {};
        m[o] = function() {
          return this;
        };
        var y = Object.getPrototypeOf, b = y && y(y(O([])));
        b && b !== e2 && r2.call(b, o) && (m = b);
        var v = p.prototype = h.prototype = Object.create(m);
        function g(t3) {
          ["next", "throw", "return"].forEach(function(e3) {
            u(t3, e3, function(t4) {
              return this._invoke(e3, t4);
            });
          });
        }
        function w(t3, e3) {
          var i3;
          this._invoke = function(o2, a2) {
            function s2() {
              return new e3(function(i4, s3) {
                !function i5(o3, a3, s4, u2) {
                  var c2 = f(t3[o3], t3, a3);
                  if (c2.type !== "throw") {
                    var l2 = c2.arg, h2 = l2.value;
                    return h2 && n(h2) === "object" && r2.call(h2, "__await") ? e3.resolve(h2.__await).then(function(t4) {
                      i5("next", t4, s4, u2);
                    }, function(t4) {
                      i5("throw", t4, s4, u2);
                    }) : e3.resolve(h2).then(function(t4) {
                      l2.value = t4, s4(l2);
                    }, function(t4) {
                      return i5("throw", t4, s4, u2);
                    });
                  }
                  u2(c2.arg);
                }(o2, a2, i4, s3);
              });
            }
            return i3 = i3 ? i3.then(s2, s2) : s2();
          };
        }
        function _(t3, e3) {
          var r3 = t3.iterator[e3.method];
          if (r3 === void 0) {
            if (e3.delegate = null, e3.method === "throw") {
              if (t3.iterator.return && (e3.method = "return", e3.arg = void 0, _(t3, e3), e3.method === "throw"))
                return l;
              e3.method = "throw", e3.arg = new TypeError("The iterator does not provide a 'throw' method");
            }
            return l;
          }
          var n2 = f(r3, t3.iterator, e3.arg);
          if (n2.type === "throw")
            return e3.method = "throw", e3.arg = n2.arg, e3.delegate = null, l;
          var i3 = n2.arg;
          return i3 ? i3.done ? (e3[t3.resultName] = i3.value, e3.next = t3.nextLoc, e3.method !== "return" && (e3.method = "next", e3.arg = void 0), e3.delegate = null, l) : i3 : (e3.method = "throw", e3.arg = new TypeError("iterator result is not an object"), e3.delegate = null, l);
        }
        function k(t3) {
          var e3 = { tryLoc: t3[0] };
          1 in t3 && (e3.catchLoc = t3[1]), 2 in t3 && (e3.finallyLoc = t3[2], e3.afterLoc = t3[3]), this.tryEntries.push(e3);
        }
        function x(t3) {
          var e3 = t3.completion || {};
          e3.type = "normal", delete e3.arg, t3.completion = e3;
        }
        function S(t3) {
          this.tryEntries = [{ tryLoc: "root" }], t3.forEach(k, this), this.reset(true);
        }
        function O(t3) {
          if (t3) {
            var e3 = t3[o];
            if (e3)
              return e3.call(t3);
            if (typeof t3.next == "function")
              return t3;
            if (!isNaN(t3.length)) {
              var n2 = -1, i3 = function e4() {
                for (; ++n2 < t3.length; )
                  if (r2.call(t3, n2))
                    return e4.value = t3[n2], e4.done = false, e4;
                return e4.value = void 0, e4.done = true, e4;
              };
              return i3.next = i3;
            }
          }
          return { next: j };
        }
        function j() {
          return { value: void 0, done: true };
        }
        return d.prototype = v.constructor = p, p.constructor = d, d.displayName = u(p, s, "GeneratorFunction"), t2.isGeneratorFunction = function(t3) {
          var e3 = typeof t3 == "function" && t3.constructor;
          return !!e3 && (e3 === d || (e3.displayName || e3.name) === "GeneratorFunction");
        }, t2.mark = function(t3) {
          return Object.setPrototypeOf ? Object.setPrototypeOf(t3, p) : (t3.__proto__ = p, u(t3, s, "GeneratorFunction")), t3.prototype = Object.create(v), t3;
        }, t2.awrap = function(t3) {
          return { __await: t3 };
        }, g(w.prototype), w.prototype[a] = function() {
          return this;
        }, t2.AsyncIterator = w, t2.async = function(e3, r3, n2, i3, o2) {
          o2 === void 0 && (o2 = Promise);
          var a2 = new w(c(e3, r3, n2, i3), o2);
          return t2.isGeneratorFunction(r3) ? a2 : a2.next().then(function(t3) {
            return t3.done ? t3.value : a2.next();
          });
        }, g(v), u(v, s, "Generator"), v[o] = function() {
          return this;
        }, v.toString = function() {
          return "[object Generator]";
        }, t2.keys = function(t3) {
          var e3 = [];
          for (var r3 in t3)
            e3.push(r3);
          return e3.reverse(), function r4() {
            for (; e3.length; ) {
              var n2 = e3.pop();
              if (n2 in t3)
                return r4.value = n2, r4.done = false, r4;
            }
            return r4.done = true, r4;
          };
        }, t2.values = O, S.prototype = { constructor: S, reset: function(t3) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(x), !t3)
            for (var e3 in this)
              e3.charAt(0) === "t" && r2.call(this, e3) && !isNaN(+e3.slice(1)) && (this[e3] = void 0);
        }, stop: function() {
          this.done = true;
          var t3 = this.tryEntries[0].completion;
          if (t3.type === "throw")
            throw t3.arg;
          return this.rval;
        }, dispatchException: function(t3) {
          if (this.done)
            throw t3;
          var e3 = this;
          function n2(r3, n3) {
            return a2.type = "throw", a2.arg = t3, e3.next = r3, n3 && (e3.method = "next", e3.arg = void 0), !!n3;
          }
          for (var i3 = this.tryEntries.length - 1; i3 >= 0; --i3) {
            var o2 = this.tryEntries[i3], a2 = o2.completion;
            if (o2.tryLoc === "root")
              return n2("end");
            if (o2.tryLoc <= this.prev) {
              var s2 = r2.call(o2, "catchLoc"), u2 = r2.call(o2, "finallyLoc");
              if (s2 && u2) {
                if (this.prev < o2.catchLoc)
                  return n2(o2.catchLoc, true);
                if (this.prev < o2.finallyLoc)
                  return n2(o2.finallyLoc);
              } else if (s2) {
                if (this.prev < o2.catchLoc)
                  return n2(o2.catchLoc, true);
              } else {
                if (!u2)
                  throw new Error("try statement without catch or finally");
                if (this.prev < o2.finallyLoc)
                  return n2(o2.finallyLoc);
              }
            }
          }
        }, abrupt: function(t3, e3) {
          for (var n2 = this.tryEntries.length - 1; n2 >= 0; --n2) {
            var i3 = this.tryEntries[n2];
            if (i3.tryLoc <= this.prev && r2.call(i3, "finallyLoc") && this.prev < i3.finallyLoc) {
              var o2 = i3;
              break;
            }
          }
          o2 && (t3 === "break" || t3 === "continue") && o2.tryLoc <= e3 && e3 <= o2.finallyLoc && (o2 = null);
          var a2 = o2 ? o2.completion : {};
          return a2.type = t3, a2.arg = e3, o2 ? (this.method = "next", this.next = o2.finallyLoc, l) : this.complete(a2);
        }, complete: function(t3, e3) {
          if (t3.type === "throw")
            throw t3.arg;
          return t3.type === "break" || t3.type === "continue" ? this.next = t3.arg : t3.type === "return" ? (this.rval = this.arg = t3.arg, this.method = "return", this.next = "end") : t3.type === "normal" && e3 && (this.next = e3), l;
        }, finish: function(t3) {
          for (var e3 = this.tryEntries.length - 1; e3 >= 0; --e3) {
            var r3 = this.tryEntries[e3];
            if (r3.finallyLoc === t3)
              return this.complete(r3.completion, r3.afterLoc), x(r3), l;
          }
        }, catch: function(t3) {
          for (var e3 = this.tryEntries.length - 1; e3 >= 0; --e3) {
            var r3 = this.tryEntries[e3];
            if (r3.tryLoc === t3) {
              var n2 = r3.completion;
              if (n2.type === "throw") {
                var i3 = n2.arg;
                x(r3);
              }
              return i3;
            }
          }
          throw new Error("illegal catch attempt");
        }, delegateYield: function(t3, e3, r3) {
          return this.delegate = { iterator: O(t3), resultName: e3, nextLoc: r3 }, this.method === "next" && (this.arg = void 0), l;
        } }, t2;
      }((e === void 0 ? "undefined" : n(e)) === "object" ? e.exports : {});
      try {
        regeneratorRuntime = i;
      } catch (t2) {
        Function("r", "regeneratorRuntime = r")(i);
      }
    }, {}], 493: [function(t, e, r) {
      var n = t("buffer").Buffer, i = t("inherits"), o = t("hash-base"), a = new Array(16), s = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], u = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], c = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], f = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11], l = [0, 1518500249, 1859775393, 2400959708, 2840853838], h = [1352829926, 1548603684, 1836072691, 2053994217, 0];
      function d() {
        o.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
      }
      function p(t2, e2) {
        return t2 << e2 | t2 >>> 32 - e2;
      }
      function m(t2, e2, r2, n2, i2, o2, a2, s2) {
        return p(t2 + (e2 ^ r2 ^ n2) + o2 + a2 | 0, s2) + i2 | 0;
      }
      function y(t2, e2, r2, n2, i2, o2, a2, s2) {
        return p(t2 + (e2 & r2 | ~e2 & n2) + o2 + a2 | 0, s2) + i2 | 0;
      }
      function b(t2, e2, r2, n2, i2, o2, a2, s2) {
        return p(t2 + ((e2 | ~r2) ^ n2) + o2 + a2 | 0, s2) + i2 | 0;
      }
      function v(t2, e2, r2, n2, i2, o2, a2, s2) {
        return p(t2 + (e2 & n2 | r2 & ~n2) + o2 + a2 | 0, s2) + i2 | 0;
      }
      function g(t2, e2, r2, n2, i2, o2, a2, s2) {
        return p(t2 + (e2 ^ (r2 | ~n2)) + o2 + a2 | 0, s2) + i2 | 0;
      }
      i(d, o), d.prototype._update = function() {
        for (var t2 = a, e2 = 0; e2 < 16; ++e2)
          t2[e2] = this._block.readInt32LE(4 * e2);
        for (var r2 = 0 | this._a, n2 = 0 | this._b, i2 = 0 | this._c, o2 = 0 | this._d, d2 = 0 | this._e, w = 0 | this._a, _ = 0 | this._b, k = 0 | this._c, x = 0 | this._d, S = 0 | this._e, O = 0; O < 80; O += 1) {
          var j, E;
          O < 16 ? (j = m(r2, n2, i2, o2, d2, t2[s[O]], l[0], c[O]), E = g(w, _, k, x, S, t2[u[O]], h[0], f[O])) : O < 32 ? (j = y(r2, n2, i2, o2, d2, t2[s[O]], l[1], c[O]), E = v(w, _, k, x, S, t2[u[O]], h[1], f[O])) : O < 48 ? (j = b(r2, n2, i2, o2, d2, t2[s[O]], l[2], c[O]), E = b(w, _, k, x, S, t2[u[O]], h[2], f[O])) : O < 64 ? (j = v(r2, n2, i2, o2, d2, t2[s[O]], l[3], c[O]), E = y(w, _, k, x, S, t2[u[O]], h[3], f[O])) : (j = g(r2, n2, i2, o2, d2, t2[s[O]], l[4], c[O]), E = m(w, _, k, x, S, t2[u[O]], h[4], f[O])), r2 = d2, d2 = o2, o2 = p(i2, 10), i2 = n2, n2 = j, w = S, S = x, x = p(k, 10), k = _, _ = E;
        }
        var R = this._b + i2 + x | 0;
        this._b = this._c + o2 + S | 0, this._c = this._d + d2 + w | 0, this._d = this._e + r2 + _ | 0, this._e = this._a + n2 + k | 0, this._a = R;
      }, d.prototype._digest = function() {
        this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
        var t2 = n.alloc ? n.alloc(20) : new n(20);
        return t2.writeInt32LE(this._a, 0), t2.writeInt32LE(this._b, 4), t2.writeInt32LE(this._c, 8), t2.writeInt32LE(this._d, 12), t2.writeInt32LE(this._e, 16), t2;
      }, e.exports = d;
    }, { buffer: 216, "hash-base": 370, inherits: 387 }], 494: [function(t, e, r) {
      var n = t("buffer"), i = n.Buffer;
      function o(t2, e2) {
        for (var r2 in t2)
          e2[r2] = t2[r2];
      }
      function a(t2, e2, r2) {
        return i(t2, e2, r2);
      }
      i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? e.exports = n : (o(n, r), r.Buffer = a), o(i, a), a.from = function(t2, e2, r2) {
        if (typeof t2 == "number")
          throw new TypeError("Argument must not be a number");
        return i(t2, e2, r2);
      }, a.alloc = function(t2, e2, r2) {
        if (typeof t2 != "number")
          throw new TypeError("Argument must be a number");
        var n2 = i(t2);
        return e2 !== void 0 ? typeof r2 == "string" ? n2.fill(e2, r2) : n2.fill(e2) : n2.fill(0), n2;
      }, a.allocUnsafe = function(t2) {
        if (typeof t2 != "number")
          throw new TypeError("Argument must be a number");
        return i(t2);
      }, a.allocUnsafeSlow = function(t2) {
        if (typeof t2 != "number")
          throw new TypeError("Argument must be a number");
        return n.SlowBuffer(t2);
      };
    }, { buffer: 216 }], 495: [function(t, e, r) {
      (function(r2) {
        function n(t2) {
          return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
            return typeof t3;
          } : function(t3) {
            return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
          })(t2);
        }
        var i, o = t("buffer"), a = o.Buffer, s = {};
        for (i in o)
          o.hasOwnProperty(i) && i !== "SlowBuffer" && i !== "Buffer" && (s[i] = o[i]);
        var u = s.Buffer = {};
        for (i in a)
          a.hasOwnProperty(i) && i !== "allocUnsafe" && i !== "allocUnsafeSlow" && (u[i] = a[i]);
        if (s.Buffer.prototype = a.prototype, u.from && u.from !== Uint8Array.from || (u.from = function(t2, e2, r3) {
          if (typeof t2 == "number")
            throw new TypeError('The "value" argument must not be of type number. Received type ' + n(t2));
          if (t2 && t2.length === void 0)
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + n(t2));
          return a(t2, e2, r3);
        }), u.alloc || (u.alloc = function(t2, e2, r3) {
          if (typeof t2 != "number")
            throw new TypeError('The "size" argument must be of type number. Received type ' + n(t2));
          if (t2 < 0 || t2 >= 2 * (1 << 30))
            throw new RangeError('The value "' + t2 + '" is invalid for option "size"');
          var i2 = a(t2);
          return e2 && e2.length !== 0 ? typeof r3 == "string" ? i2.fill(e2, r3) : i2.fill(e2) : i2.fill(0), i2;
        }), !s.kStringMaxLength)
          try {
            s.kStringMaxLength = r2.binding("buffer").kStringMaxLength;
          } catch (t2) {
          }
        s.constants || (s.constants = { MAX_LENGTH: s.kMaxLength }, s.kStringMaxLength && (s.constants.MAX_STRING_LENGTH = s.kStringMaxLength)), e.exports = s;
      }).call(this, t("_process"));
    }, { _process: 467, buffer: 216 }], 496: [function(t, e, r) {
      function n(t2, e2) {
        var r2;
        if (typeof Symbol == "undefined" || t2[Symbol.iterator] == null) {
          if (Array.isArray(t2) || (r2 = s(t2)) || e2 && t2 && typeof t2.length == "number") {
            r2 && (t2 = r2);
            var n2 = 0, i2 = function() {
            };
            return { s: i2, n: function() {
              return n2 >= t2.length ? { done: true } : { done: false, value: t2[n2++] };
            }, e: function(t3) {
              throw t3;
            }, f: i2 };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var o2, a2 = true, u2 = false;
        return { s: function() {
          r2 = t2[Symbol.iterator]();
        }, n: function() {
          var t3 = r2.next();
          return a2 = t3.done, t3;
        }, e: function(t3) {
          u2 = true, o2 = t3;
        }, f: function() {
          try {
            a2 || r2.return == null || r2.return();
          } finally {
            if (u2)
              throw o2;
          }
        } };
      }
      function i(t2) {
        return (i = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function o(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function a(t2) {
        return function(t3) {
          if (Array.isArray(t3))
            return u(t3);
        }(t2) || function(t3) {
          if (typeof Symbol != "undefined" && Symbol.iterator in Object(t3))
            return Array.from(t3);
        }(t2) || s(t2) || function() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function s(t2, e2) {
        if (t2) {
          if (typeof t2 == "string")
            return u(t2, e2);
          var r2 = Object.prototype.toString.call(t2).slice(8, -1);
          return r2 === "Object" && t2.constructor && (r2 = t2.constructor.name), r2 === "Map" || r2 === "Set" ? Array.from(t2) : r2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2) ? u(t2, e2) : void 0;
        }
      }
      function u(t2, e2) {
        (e2 == null || e2 > t2.length) && (e2 = t2.length);
        for (var r2 = 0, n2 = new Array(e2); r2 < e2; r2++)
          n2[r2] = t2[r2];
        return n2;
      }
      Object.defineProperty(r, "__esModule", { value: true });
      var c = t("xmlchars/xml/1.0/ed5"), f = t("xmlchars/xml/1.1/ed2"), l = t("xmlchars/xmlns/1.0/ed3"), h = c.isS, d = c.isChar, p = c.isNameStartChar, m = c.isNameChar, y = c.S_LIST, b = c.NAME_RE, v = f.isChar, g = l.isNCNameStartChar, w = l.isNCNameChar, _ = l.NC_NAME_RE, k = "http://www.w3.org/XML/1998/namespace", x = "http://www.w3.org/2000/xmlns/", S = { __proto__: null, xml: k, xmlns: x }, O = { __proto__: null, amp: "&", gt: ">", lt: "<", quot: '"', apos: "'" }, j = 61, E = 63, R = function(t2) {
        return t2 === 34 || t2 === 39;
      }, T = [34, 39], C = [].concat(T, [91, 62]), P = [].concat(T, [60, 93]), M = [j, E].concat(a(y)), A = [].concat(a(y), [62, 38, 60]);
      function I(t2, e2, r2) {
        switch (e2) {
          case "xml":
            r2 !== k && t2.fail("xml prefix must be bound to ".concat(k, "."));
            break;
          case "xmlns":
            r2 !== x && t2.fail("xmlns prefix must be bound to ".concat(x, "."));
        }
        switch (r2) {
          case x:
            t2.fail(e2 === "" ? "the default namespace may not be set to ".concat(r2, ".") : 'may not assign a prefix (even "xmlns") to the URI '.concat(x, "."));
            break;
          case k:
            switch (e2) {
              case "xml":
                break;
              case "":
                t2.fail("the default namespace may not be set to ".concat(r2, "."));
                break;
              default:
                t2.fail("may not assign the xml namespace to another prefix.");
            }
        }
      }
      var N = function(t2) {
        return _.test(t2);
      }, D = function(t2) {
        return b.test(t2);
      };
      r.EVENTS = ["xmldecl", "text", "processinginstruction", "doctype", "comment", "opentagstart", "attribute", "opentag", "closetag", "cdata", "error", "end", "ready"];
      var B = { xmldecl: "xmldeclHandler", text: "textHandler", processinginstruction: "piHandler", doctype: "doctypeHandler", comment: "commentHandler", opentagstart: "openTagStartHandler", attribute: "attributeHandler", opentag: "openTagHandler", closetag: "closeTagHandler", cdata: "cdataHandler", error: "errorHandler", end: "endHandler", ready: "readyHandler" }, F = function() {
        function t2(e3) {
          !function(t3, e4) {
            if (!(t3 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, t2), this.opt = e3 != null ? e3 : {}, this.fragmentOpt = !!this.opt.fragment;
          var r3 = this.xmlnsOpt = !!this.opt.xmlns;
          if (this.trackPosition = this.opt.position !== false, this.fileName = this.opt.fileName, r3) {
            this.nameStartCheck = g, this.nameCheck = w, this.isName = N, this.processAttribs = this.processAttribsNS, this.pushAttrib = this.pushAttribNS, this.ns = Object.assign({ __proto__: null }, S);
            var n2 = this.opt.additionalNamespaces;
            n2 != null && (!function(t3, e4) {
              for (var r4 = 0, n3 = Object.keys(e4); r4 < n3.length; r4++) {
                var i2 = n3[r4];
                I(t3, i2, e4[i2]);
              }
            }(this, n2), Object.assign(this.ns, n2));
          } else
            this.nameStartCheck = p, this.nameCheck = m, this.isName = D, this.processAttribs = this.processAttribsPlain, this.pushAttrib = this.pushAttribPlain;
          this.stateTable = [this.sBegin, this.sBeginWhitespace, this.sDoctype, this.sDoctypeQuote, this.sDTD, this.sDTDQuoted, this.sDTDOpenWaka, this.sDTDOpenWakaBang, this.sDTDComment, this.sDTDCommentEnding, this.sDTDCommentEnded, this.sDTDPI, this.sDTDPIEnding, this.sText, this.sEntity, this.sOpenWaka, this.sOpenWakaBang, this.sComment, this.sCommentEnding, this.sCommentEnded, this.sCData, this.sCDataEnding, this.sCDataEnding2, this.sPIFirstChar, this.sPIRest, this.sPIBody, this.sPIEnding, this.sXMLDeclNameStart, this.sXMLDeclName, this.sXMLDeclEq, this.sXMLDeclValueStart, this.sXMLDeclValue, this.sXMLDeclSeparator, this.sXMLDeclEnding, this.sOpenTag, this.sOpenTagSlash, this.sAttrib, this.sAttribName, this.sAttribNameSawWhite, this.sAttribValue, this.sAttribValueQuoted, this.sAttribValueClosed, this.sAttribValueUnquoted, this.sCloseTag, this.sCloseTagSawWhite], this._init();
        }
        var e2, r2;
        return e2 = t2, (r2 = [{ key: "_init", value: function() {
          var t3;
          this.openWakaBang = "", this.text = "", this.name = "", this.piTarget = "", this.entity = "", this.q = null, this.tags = [], this.tag = null, this.topNS = null, this.chunk = "", this.chunkPosition = 0, this.i = 0, this.prevI = 0, this.carriedFromPrevious = void 0, this.forbiddenState = 0, this.attribList = [];
          var e3 = this.fragmentOpt;
          this.state = e3 ? 13 : 0, this.reportedTextBeforeRoot = this.reportedTextAfterRoot = this.closedRoot = this.sawRoot = e3, this.xmlDeclPossible = !e3, this.xmlDeclExpects = ["version"], this.entityReturnState = void 0;
          var r3 = this.opt.defaultXMLVersion;
          if (r3 === void 0) {
            if (this.opt.forceXMLVersion === true)
              throw new Error("forceXMLVersion set but defaultXMLVersion is not set");
            r3 = "1.0";
          }
          this.setXMLVersion(r3), this.positionAtNewLine = 0, this.doctype = false, this._closed = false, this.xmlDecl = { version: void 0, encoding: void 0, standalone: void 0 }, this.line = 1, this.column = 0, this.ENTITIES = Object.create(O), (t3 = this.readyHandler) === null || t3 === void 0 || t3.call(this);
        } }, { key: "on", value: function(t3, e3) {
          this[B[t3]] = e3;
        } }, { key: "off", value: function(t3) {
          this[B[t3]] = void 0;
        } }, { key: "makeError", value: function(t3) {
          var e3, r3 = (e3 = this.fileName) !== null && e3 !== void 0 ? e3 : "";
          return this.trackPosition && (r3.length > 0 && (r3 += ":"), r3 += "".concat(this.line, ":").concat(this.column)), r3.length > 0 && (r3 += ": "), new Error(r3 + t3);
        } }, { key: "fail", value: function(t3) {
          var e3 = this.makeError(t3), r3 = this.errorHandler;
          if (r3 === void 0)
            throw e3;
          return r3(e3), this;
        } }, { key: "write", value: function(t3) {
          if (this.closed)
            return this.fail("cannot write after close; assign an onready handler.");
          var e3 = false;
          t3 === null ? (e3 = true, t3 = "") : i(t3) === "object" && (t3 = t3.toString()), this.carriedFromPrevious !== void 0 && (t3 = "".concat(this.carriedFromPrevious).concat(t3), this.carriedFromPrevious = void 0);
          var r3 = t3.length, n2 = t3.charCodeAt(r3 - 1);
          !e3 && (n2 === 13 || n2 >= 55296 && n2 <= 56319) && (this.carriedFromPrevious = t3[r3 - 1], r3--, t3 = t3.slice(0, r3));
          var o2 = this.stateTable;
          for (this.chunk = t3, this.i = 0; this.i < r3; )
            o2[this.state].call(this);
          return this.chunkPosition += r3, e3 ? this.end() : this;
        } }, { key: "close", value: function() {
          return this.write(null);
        } }, { key: "getCode10", value: function() {
          var t3 = this.chunk, e3 = this.i;
          if (this.prevI = e3, this.i = e3 + 1, e3 >= t3.length)
            return -1;
          var r3 = t3.charCodeAt(e3);
          if (this.column++, r3 < 55296) {
            if (r3 >= 32 || r3 === 9)
              return r3;
            switch (r3) {
              case 10:
                return this.line++, this.column = 0, this.positionAtNewLine = this.position, 10;
              case 13:
                return t3.charCodeAt(e3 + 1) === 10 && (this.i = e3 + 2), this.line++, this.column = 0, this.positionAtNewLine = this.position, -2;
              default:
                return this.fail("disallowed character."), r3;
            }
          }
          if (r3 > 56319)
            return r3 >= 57344 && r3 <= 65533 || this.fail("disallowed character."), r3;
          var n2 = 65536 + 1024 * (r3 - 55296) + (t3.charCodeAt(e3 + 1) - 56320);
          return this.i = e3 + 2, n2 > 1114111 && this.fail("disallowed character."), n2;
        } }, { key: "getCode11", value: function() {
          var t3 = this.chunk, e3 = this.i;
          if (this.prevI = e3, this.i = e3 + 1, e3 >= t3.length)
            return -1;
          var r3 = t3.charCodeAt(e3);
          if (this.column++, r3 < 55296) {
            if (r3 > 31 && r3 < 127 || r3 > 159 && r3 !== 8232 || r3 === 9)
              return r3;
            switch (r3) {
              case 10:
                return this.line++, this.column = 0, this.positionAtNewLine = this.position, 10;
              case 13:
                var n2 = t3.charCodeAt(e3 + 1);
                n2 !== 10 && n2 !== 133 || (this.i = e3 + 2);
              case 133:
              case 8232:
                return this.line++, this.column = 0, this.positionAtNewLine = this.position, -2;
              default:
                return this.fail("disallowed character."), r3;
            }
          }
          if (r3 > 56319)
            return r3 >= 57344 && r3 <= 65533 || this.fail("disallowed character."), r3;
          var i2 = 65536 + 1024 * (r3 - 55296) + (t3.charCodeAt(e3 + 1) - 56320);
          return this.i = e3 + 2, i2 > 1114111 && this.fail("disallowed character."), i2;
        } }, { key: "getCodeNorm", value: function() {
          var t3 = this.getCode();
          return t3 === -2 ? 10 : t3;
        } }, { key: "unget", value: function() {
          this.i = this.prevI, this.column--;
        } }, { key: "captureTo", value: function(t3) {
          for (var e3 = this.i, r3 = this.chunk; ; ) {
            var n2 = this.getCode(), i2 = n2 === -2, o2 = i2 ? 10 : n2;
            if (o2 === -1 || t3.includes(o2))
              return this.text += r3.slice(e3, this.prevI), o2;
            i2 && (this.text += "".concat(r3.slice(e3, this.prevI), "\n"), e3 = this.i);
          }
        } }, { key: "captureToChar", value: function(t3) {
          for (var e3 = this.i, r3 = this.chunk; ; ) {
            var n2 = this.getCode();
            switch (n2) {
              case -2:
                this.text += "".concat(r3.slice(e3, this.prevI), "\n"), e3 = this.i, n2 = 10;
                break;
              case -1:
                return this.text += r3.slice(e3), false;
            }
            if (n2 === t3)
              return this.text += r3.slice(e3, this.prevI), true;
          }
        } }, { key: "captureNameChars", value: function() {
          for (var t3 = this.chunk, e3 = this.i; ; ) {
            var r3 = this.getCode();
            if (r3 === -1)
              return this.name += t3.slice(e3), -1;
            if (!m(r3))
              return this.name += t3.slice(e3, this.prevI), r3 === -2 ? 10 : r3;
          }
        } }, { key: "skipSpaces", value: function() {
          for (; ; ) {
            var t3 = this.getCodeNorm();
            if (t3 === -1 || !h(t3))
              return t3;
          }
        } }, { key: "setXMLVersion", value: function(t3) {
          this.currentXMLVersion = t3, t3 === "1.0" ? (this.isChar = d, this.getCode = this.getCode10) : (this.isChar = v, this.getCode = this.getCode11);
        } }, { key: "sBegin", value: function() {
          this.chunk.charCodeAt(0) === 65279 && (this.i++, this.column++), this.state = 1;
        } }, { key: "sBeginWhitespace", value: function() {
          var t3 = this.i, e3 = this.skipSpaces();
          switch (this.prevI !== t3 && (this.xmlDeclPossible = false), e3) {
            case 60:
              if (this.state = 15, this.text.length !== 0)
                throw new Error("no-empty text at start");
              break;
            case -1:
              break;
            default:
              this.unget(), this.state = 13, this.xmlDeclPossible = false;
          }
        } }, { key: "sDoctype", value: function() {
          var t3, e3 = this.captureTo(C);
          switch (e3) {
            case 62:
              (t3 = this.doctypeHandler) === null || t3 === void 0 || t3.call(this, this.text), this.text = "", this.state = 13, this.doctype = true;
              break;
            case -1:
              break;
            default:
              this.text += String.fromCodePoint(e3), e3 === 91 ? this.state = 4 : R(e3) && (this.state = 3, this.q = e3);
          }
        } }, { key: "sDoctypeQuote", value: function() {
          var t3 = this.q;
          this.captureToChar(t3) && (this.text += String.fromCodePoint(t3), this.q = null, this.state = 2);
        } }, { key: "sDTD", value: function() {
          var t3 = this.captureTo(P);
          t3 !== -1 && (this.text += String.fromCodePoint(t3), t3 === 93 ? this.state = 2 : t3 === 60 ? this.state = 6 : R(t3) && (this.state = 5, this.q = t3));
        } }, { key: "sDTDQuoted", value: function() {
          var t3 = this.q;
          this.captureToChar(t3) && (this.text += String.fromCodePoint(t3), this.state = 4, this.q = null);
        } }, { key: "sDTDOpenWaka", value: function() {
          var t3 = this.getCodeNorm();
          switch (this.text += String.fromCodePoint(t3), t3) {
            case 33:
              this.state = 7, this.openWakaBang = "";
              break;
            case E:
              this.state = 11;
              break;
            default:
              this.state = 4;
          }
        } }, { key: "sDTDOpenWakaBang", value: function() {
          var t3 = String.fromCodePoint(this.getCodeNorm()), e3 = this.openWakaBang += t3;
          this.text += t3, e3 !== "-" && (this.state = e3 === "--" ? 8 : 4, this.openWakaBang = "");
        } }, { key: "sDTDComment", value: function() {
          this.captureToChar(45) && (this.text += "-", this.state = 9);
        } }, { key: "sDTDCommentEnding", value: function() {
          var t3 = this.getCodeNorm();
          this.text += String.fromCodePoint(t3), this.state = t3 === 45 ? 10 : 8;
        } }, { key: "sDTDCommentEnded", value: function() {
          var t3 = this.getCodeNorm();
          this.text += String.fromCodePoint(t3), t3 === 62 ? this.state = 4 : (this.fail("malformed comment."), this.state = 8);
        } }, { key: "sDTDPI", value: function() {
          this.captureToChar(E) && (this.text += "?", this.state = 12);
        } }, { key: "sDTDPIEnding", value: function() {
          var t3 = this.getCodeNorm();
          this.text += String.fromCodePoint(t3), t3 === 62 && (this.state = 4);
        } }, { key: "sText", value: function() {
          this.tags.length !== 0 ? this.handleTextInRoot() : this.handleTextOutsideRoot();
        } }, { key: "sEntity", value: function() {
          var t3 = this.i, e3 = this.chunk;
          t:
            for (; ; )
              switch (this.getCode()) {
                case -2:
                  this.entity += "".concat(e3.slice(t3, this.prevI), "\n"), t3 = this.i;
                  break;
                case 59:
                  var r3 = this.entityReturnState, n2 = this.entity + e3.slice(t3, this.prevI);
                  this.state = r3;
                  var i2 = void 0;
                  n2 === "" ? (this.fail("empty entity name."), i2 = "&;") : (i2 = this.parseEntity(n2), this.entity = ""), r3 === 13 && this.textHandler === void 0 || (this.text += i2);
                  break t;
                case -1:
                  this.entity += e3.slice(t3);
                  break t;
              }
        } }, { key: "sOpenWaka", value: function() {
          var t3 = this.getCode();
          if (p(t3))
            this.state = 34, this.unget(), this.xmlDeclPossible = false;
          else
            switch (t3) {
              case 47:
                this.state = 43, this.xmlDeclPossible = false;
                break;
              case 33:
                this.state = 16, this.openWakaBang = "", this.xmlDeclPossible = false;
                break;
              case E:
                this.state = 23;
                break;
              default:
                this.fail("disallowed character in tag name"), this.state = 13, this.xmlDeclPossible = false;
            }
        } }, { key: "sOpenWakaBang", value: function() {
          switch (this.openWakaBang += String.fromCodePoint(this.getCodeNorm()), this.openWakaBang) {
            case "[CDATA[":
              this.sawRoot || this.reportedTextBeforeRoot || (this.fail("text data outside of root node."), this.reportedTextBeforeRoot = true), this.closedRoot && !this.reportedTextAfterRoot && (this.fail("text data outside of root node."), this.reportedTextAfterRoot = true), this.state = 20, this.openWakaBang = "";
              break;
            case "--":
              this.state = 17, this.openWakaBang = "";
              break;
            case "DOCTYPE":
              this.state = 2, (this.doctype || this.sawRoot) && this.fail("inappropriately located doctype declaration."), this.openWakaBang = "";
              break;
            default:
              this.openWakaBang.length >= 7 && this.fail("incorrect syntax.");
          }
        } }, { key: "sComment", value: function() {
          this.captureToChar(45) && (this.state = 18);
        } }, { key: "sCommentEnding", value: function() {
          var t3, e3 = this.getCodeNorm();
          e3 === 45 ? (this.state = 19, (t3 = this.commentHandler) === null || t3 === void 0 || t3.call(this, this.text), this.text = "") : (this.text += "-".concat(String.fromCodePoint(e3)), this.state = 17);
        } }, { key: "sCommentEnded", value: function() {
          var t3 = this.getCodeNorm();
          t3 !== 62 ? (this.fail("malformed comment."), this.text += "--".concat(String.fromCodePoint(t3)), this.state = 17) : this.state = 13;
        } }, { key: "sCData", value: function() {
          this.captureToChar(93) && (this.state = 21);
        } }, { key: "sCDataEnding", value: function() {
          var t3 = this.getCodeNorm();
          t3 === 93 ? this.state = 22 : (this.text += "]".concat(String.fromCodePoint(t3)), this.state = 20);
        } }, { key: "sCDataEnding2", value: function() {
          var t3, e3 = this.getCodeNorm();
          switch (e3) {
            case 62:
              (t3 = this.cdataHandler) === null || t3 === void 0 || t3.call(this, this.text), this.text = "", this.state = 13;
              break;
            case 93:
              this.text += "]";
              break;
            default:
              this.text += "]]".concat(String.fromCodePoint(e3)), this.state = 20;
          }
        } }, { key: "sPIFirstChar", value: function() {
          var t3 = this.getCodeNorm();
          this.nameStartCheck(t3) ? (this.piTarget += String.fromCodePoint(t3), this.state = 24) : t3 === E || h(t3) ? (this.fail("processing instruction without a target."), this.state = t3 === E ? 26 : 25) : (this.fail("disallowed character in processing instruction name."), this.piTarget += String.fromCodePoint(t3), this.state = 24);
        } }, { key: "sPIRest", value: function() {
          for (var t3 = this.chunk, e3 = this.i; ; ) {
            var r3 = this.getCodeNorm();
            if (r3 === -1)
              return void (this.piTarget += t3.slice(e3));
            if (!this.nameCheck(r3)) {
              this.piTarget += t3.slice(e3, this.prevI);
              var n2 = r3 === E;
              n2 || h(r3) ? this.piTarget === "xml" ? (this.xmlDeclPossible || this.fail("an XML declaration must be at the start of the document."), this.state = n2 ? 33 : 27) : this.state = n2 ? 26 : 25 : (this.fail("disallowed character in processing instruction name."), this.piTarget += String.fromCodePoint(r3));
              break;
            }
          }
        } }, { key: "sPIBody", value: function() {
          if (this.text.length === 0) {
            var t3 = this.getCodeNorm();
            t3 === E ? this.state = 26 : h(t3) || (this.text = String.fromCodePoint(t3));
          } else
            this.captureToChar(E) && (this.state = 26);
        } }, { key: "sPIEnding", value: function() {
          var t3, e3 = this.getCodeNorm();
          if (e3 === 62) {
            var r3 = this.piTarget;
            r3.toLowerCase() === "xml" && this.fail("the XML declaration must appear at the start of the document."), (t3 = this.piHandler) === null || t3 === void 0 || t3.call(this, { target: r3, body: this.text }), this.piTarget = this.text = "", this.state = 13;
          } else
            e3 === E ? this.text += "?" : (this.text += "?".concat(String.fromCodePoint(e3)), this.state = 25);
          this.xmlDeclPossible = false;
        } }, { key: "sXMLDeclNameStart", value: function() {
          var t3 = this.skipSpaces();
          t3 !== E ? t3 !== -1 && (this.state = 28, this.name = String.fromCodePoint(t3)) : this.state = 33;
        } }, { key: "sXMLDeclName", value: function() {
          var t3 = this.captureTo(M);
          if (t3 === E)
            return this.state = 33, this.name += this.text, this.text = "", void this.fail("XML declaration is incomplete.");
          if (h(t3) || t3 === j) {
            if (this.name += this.text, this.text = "", !this.xmlDeclExpects.includes(this.name))
              switch (this.name.length) {
                case 0:
                  this.fail("did not expect any more name/value pairs.");
                  break;
                case 1:
                  this.fail("expected the name ".concat(this.xmlDeclExpects[0], "."));
                  break;
                default:
                  this.fail("expected one of ".concat(this.xmlDeclExpects.join(", ")));
              }
            this.state = t3 === j ? 30 : 29;
          }
        } }, { key: "sXMLDeclEq", value: function() {
          var t3 = this.getCodeNorm();
          if (t3 === E)
            return this.state = 33, void this.fail("XML declaration is incomplete.");
          h(t3) || (t3 !== j && this.fail("value required."), this.state = 30);
        } }, { key: "sXMLDeclValueStart", value: function() {
          var t3 = this.getCodeNorm();
          if (t3 === E)
            return this.state = 33, void this.fail("XML declaration is incomplete.");
          h(t3) || (R(t3) ? this.q = t3 : (this.fail("value must be quoted."), this.q = 32), this.state = 31);
        } }, { key: "sXMLDeclValue", value: function() {
          var t3 = this.captureTo([this.q, E]);
          if (t3 === E)
            return this.state = 33, this.text = "", void this.fail("XML declaration is incomplete.");
          if (t3 !== -1) {
            var e3 = this.text;
            switch (this.text = "", this.name) {
              case "version":
                this.xmlDeclExpects = ["encoding", "standalone"];
                var r3 = e3;
                this.xmlDecl.version = r3, /^1\.[0-9]+$/.test(r3) ? this.opt.forceXMLVersion || this.setXMLVersion(r3) : this.fail("version number must match /^1\\.[0-9]+$/.");
                break;
              case "encoding":
                /^[A-Za-z][A-Za-z0-9._-]*$/.test(e3) || this.fail("encoding value must match /^[A-Za-z0-9][A-Za-z0-9._-]*$/."), this.xmlDeclExpects = ["standalone"], this.xmlDecl.encoding = e3;
                break;
              case "standalone":
                e3 !== "yes" && e3 !== "no" && this.fail('standalone value must match "yes" or "no".'), this.xmlDeclExpects = [], this.xmlDecl.standalone = e3;
            }
            this.name = "", this.state = 32;
          }
        } }, { key: "sXMLDeclSeparator", value: function() {
          var t3 = this.getCodeNorm();
          t3 !== E ? (h(t3) || (this.fail("whitespace required."), this.unget()), this.state = 27) : this.state = 33;
        } }, { key: "sXMLDeclEnding", value: function() {
          var t3;
          this.getCodeNorm() === 62 ? (this.piTarget !== "xml" ? this.fail("processing instructions are not allowed before root.") : this.name !== "version" && this.xmlDeclExpects.includes("version") && this.fail("XML declaration must contain a version."), (t3 = this.xmldeclHandler) === null || t3 === void 0 || t3.call(this, this.xmlDecl), this.name = "", this.piTarget = this.text = "", this.state = 13) : this.fail("The character ? is disallowed anywhere in XML declarations."), this.xmlDeclPossible = false;
        } }, { key: "sOpenTag", value: function() {
          var t3, e3 = this.captureNameChars();
          if (e3 !== -1) {
            var r3 = this.tag = { name: this.name, attributes: Object.create(null) };
            switch (this.name = "", this.xmlnsOpt && (this.topNS = r3.ns = Object.create(null)), (t3 = this.openTagStartHandler) === null || t3 === void 0 || t3.call(this, r3), this.sawRoot = true, !this.fragmentOpt && this.closedRoot && this.fail("documents may contain only one root."), e3) {
              case 62:
                this.openTag();
                break;
              case 47:
                this.state = 35;
                break;
              default:
                h(e3) || this.fail("disallowed character in tag name."), this.state = 36;
            }
          }
        } }, { key: "sOpenTagSlash", value: function() {
          this.getCode() === 62 ? this.openSelfClosingTag() : (this.fail("forward-slash in opening tag not followed by >."), this.state = 36);
        } }, { key: "sAttrib", value: function() {
          var t3 = this.skipSpaces();
          t3 !== -1 && (p(t3) ? (this.unget(), this.state = 37) : t3 === 62 ? this.openTag() : t3 === 47 ? this.state = 35 : this.fail("disallowed character in attribute name."));
        } }, { key: "sAttribName", value: function() {
          var t3 = this.captureNameChars();
          t3 === j ? this.state = 39 : h(t3) ? this.state = 38 : t3 === 62 ? (this.fail("attribute without value."), this.pushAttrib(this.name, this.name), this.name = this.text = "", this.openTag()) : t3 !== -1 && this.fail("disallowed character in attribute name.");
        } }, { key: "sAttribNameSawWhite", value: function() {
          var t3 = this.skipSpaces();
          switch (t3) {
            case -1:
              return;
            case j:
              this.state = 39;
              break;
            default:
              this.fail("attribute without value."), this.text = "", this.name = "", t3 === 62 ? this.openTag() : p(t3) ? (this.unget(), this.state = 37) : (this.fail("disallowed character in attribute name."), this.state = 36);
          }
        } }, { key: "sAttribValue", value: function() {
          var t3 = this.getCodeNorm();
          R(t3) ? (this.q = t3, this.state = 40) : h(t3) || (this.fail("unquoted attribute value."), this.state = 42, this.unget());
        } }, { key: "sAttribValueQuoted", value: function() {
          for (var t3 = this.q, e3 = this.chunk, r3 = this.i; ; )
            switch (this.getCode()) {
              case t3:
                return this.pushAttrib(this.name, this.text + e3.slice(r3, this.prevI)), this.name = this.text = "", this.q = null, void (this.state = 41);
              case 38:
                return this.text += e3.slice(r3, this.prevI), this.state = 14, void (this.entityReturnState = 40);
              case 10:
              case -2:
              case 9:
                this.text += "".concat(e3.slice(r3, this.prevI), " "), r3 = this.i;
                break;
              case 60:
                return this.text += e3.slice(r3, this.prevI), void this.fail("disallowed character.");
              case -1:
                return void (this.text += e3.slice(r3));
            }
        } }, { key: "sAttribValueClosed", value: function() {
          var t3 = this.getCodeNorm();
          h(t3) ? this.state = 36 : t3 === 62 ? this.openTag() : t3 === 47 ? this.state = 35 : p(t3) ? (this.fail("no whitespace between attributes."), this.unget(), this.state = 37) : this.fail("disallowed character in attribute name.");
        } }, { key: "sAttribValueUnquoted", value: function() {
          var t3 = this.captureTo(A);
          switch (t3) {
            case 38:
              this.state = 14, this.entityReturnState = 42;
              break;
            case 60:
              this.fail("disallowed character.");
              break;
            case -1:
              break;
            default:
              this.text.includes("]]>") && this.fail('the string "]]>" is disallowed in char data.'), this.pushAttrib(this.name, this.text), this.name = this.text = "", t3 === 62 ? this.openTag() : this.state = 36;
          }
        } }, { key: "sCloseTag", value: function() {
          var t3 = this.captureNameChars();
          t3 === 62 ? this.closeTag() : h(t3) ? this.state = 44 : t3 !== -1 && this.fail("disallowed character in closing tag.");
        } }, { key: "sCloseTagSawWhite", value: function() {
          switch (this.skipSpaces()) {
            case 62:
              this.closeTag();
              break;
            case -1:
              break;
            default:
              this.fail("disallowed character in closing tag.");
          }
        } }, { key: "handleTextInRoot", value: function() {
          var t3 = this.i, e3 = this.forbiddenState, r3 = this.chunk, n2 = this.textHandler;
          t:
            for (; ; )
              switch (this.getCode()) {
                case 60:
                  if (this.state = 15, n2 !== void 0) {
                    var i2 = this.text, o2 = r3.slice(t3, this.prevI);
                    i2.length !== 0 ? (n2(i2 + o2), this.text = "") : o2.length !== 0 && n2(o2);
                  }
                  e3 = 0;
                  break t;
                case 38:
                  this.state = 14, this.entityReturnState = 13, n2 !== void 0 && (this.text += r3.slice(t3, this.prevI)), e3 = 0;
                  break t;
                case 93:
                  switch (e3) {
                    case 0:
                      e3 = 1;
                      break;
                    case 1:
                      e3 = 2;
                      break;
                    case 2:
                      break;
                    default:
                      throw new Error("impossible state");
                  }
                  break;
                case 62:
                  e3 === 2 && this.fail('the string "]]>" is disallowed in char data.'), e3 = 0;
                  break;
                case -2:
                  n2 !== void 0 && (this.text += "".concat(r3.slice(t3, this.prevI), "\n")), t3 = this.i, e3 = 0;
                  break;
                case -1:
                  n2 !== void 0 && (this.text += r3.slice(t3));
                  break t;
                default:
                  e3 = 0;
              }
          this.forbiddenState = e3;
        } }, { key: "handleTextOutsideRoot", value: function() {
          var t3 = this.i, e3 = this.chunk, r3 = this.textHandler, n2 = false;
          t:
            for (; ; ) {
              var i2 = this.getCode();
              switch (i2) {
                case 60:
                  if (this.state = 15, r3 !== void 0) {
                    var o2 = this.text, a3 = e3.slice(t3, this.prevI);
                    o2.length !== 0 ? (r3(o2 + a3), this.text = "") : a3.length !== 0 && r3(a3);
                  }
                  break t;
                case 38:
                  this.state = 14, this.entityReturnState = 13, r3 !== void 0 && (this.text += e3.slice(t3, this.prevI)), n2 = true;
                  break t;
                case -2:
                  r3 !== void 0 && (this.text += "".concat(e3.slice(t3, this.prevI), "\n")), t3 = this.i;
                  break;
                case -1:
                  r3 !== void 0 && (this.text += e3.slice(t3));
                  break t;
                default:
                  h(i2) || (n2 = true);
              }
            }
          n2 && (this.sawRoot || this.reportedTextBeforeRoot || (this.fail("text data outside of root node."), this.reportedTextBeforeRoot = true), this.closedRoot && !this.reportedTextAfterRoot && (this.fail("text data outside of root node."), this.reportedTextAfterRoot = true));
        } }, { key: "pushAttribNS", value: function(t3, e3) {
          var r3, n2 = this.qname(t3), i2 = n2.prefix, o2 = n2.local, a3 = { name: t3, prefix: i2, local: o2, value: e3 };
          if (this.attribList.push(a3), (r3 = this.attributeHandler) === null || r3 === void 0 || r3.call(this, a3), i2 === "xmlns") {
            var s2 = e3.trim();
            this.currentXMLVersion === "1.0" && s2 === "" && this.fail("invalid attempt to undefine prefix in XML 1.0"), this.topNS[o2] = s2, I(this, o2, s2);
          } else if (t3 === "xmlns") {
            var u2 = e3.trim();
            this.topNS[""] = u2, I(this, "", u2);
          }
        } }, { key: "pushAttribPlain", value: function(t3, e3) {
          var r3, n2 = { name: t3, value: e3 };
          this.attribList.push(n2), (r3 = this.attributeHandler) === null || r3 === void 0 || r3.call(this, n2);
        } }, { key: "end", value: function() {
          var t3, e3;
          this.sawRoot || this.fail("document must contain a root element.");
          for (var r3 = this.tags; r3.length > 0; ) {
            var n2 = r3.pop();
            this.fail("unclosed tag: ".concat(n2.name));
          }
          this.state !== 0 && this.state !== 13 && this.fail("unexpected end.");
          var i2 = this.text;
          return i2.length !== 0 && ((t3 = this.textHandler) === null || t3 === void 0 || t3.call(this, i2), this.text = ""), this._closed = true, (e3 = this.endHandler) === null || e3 === void 0 || e3.call(this), this._init(), this;
        } }, { key: "resolve", value: function(t3) {
          var e3, r3, n2 = this.topNS[t3];
          if (n2 !== void 0)
            return n2;
          for (var i2 = this.tags, o2 = i2.length - 1; o2 >= 0; o2--)
            if ((n2 = i2[o2].ns[t3]) !== void 0)
              return n2;
          return (n2 = this.ns[t3]) !== void 0 ? n2 : (r3 = (e3 = this.opt).resolvePrefix) === null || r3 === void 0 ? void 0 : r3.call(e3, t3);
        } }, { key: "qname", value: function(t3) {
          var e3 = t3.indexOf(":");
          if (e3 === -1)
            return { prefix: "", local: t3 };
          var r3 = t3.slice(e3 + 1), n2 = t3.slice(0, e3);
          return (n2 === "" || r3 === "" || r3.includes(":")) && this.fail("malformed name: ".concat(t3, ".")), { prefix: n2, local: r3 };
        } }, { key: "processAttribsNS", value: function() {
          var t3, e3 = this.attribList, r3 = this.tag, i2 = this.qname(r3.name), o2 = i2.prefix, a3 = i2.local;
          r3.prefix = o2, r3.local = a3;
          var s2 = r3.uri = (t3 = this.resolve(o2)) !== null && t3 !== void 0 ? t3 : "";
          if (o2 !== "" && (o2 === "xmlns" && this.fail('tags may not have "xmlns" as prefix.'), s2 === "" && (this.fail("unbound namespace prefix: ".concat(JSON.stringify(o2), ".")), r3.uri = o2)), e3.length !== 0) {
            var u2, c2 = r3.attributes, f2 = new Set(), l2 = n(e3);
            try {
              for (l2.s(); !(u2 = l2.n()).done; ) {
                var h2 = u2.value, d2 = h2.name, p2 = h2.prefix, m2 = h2.local, y2 = void 0, b2 = void 0;
                p2 === "" ? (y2 = d2 === "xmlns" ? x : "", b2 = d2) : ((y2 = this.resolve(p2)) === void 0 && (this.fail("unbound namespace prefix: ".concat(JSON.stringify(p2), ".")), y2 = p2), b2 = "{".concat(y2, "}").concat(m2)), f2.has(b2) && this.fail("duplicate attribute: ".concat(b2, ".")), f2.add(b2), h2.uri = y2, c2[d2] = h2;
              }
            } catch (t4) {
              l2.e(t4);
            } finally {
              l2.f();
            }
            this.attribList = [];
          }
        } }, { key: "processAttribsPlain", value: function() {
          var t3, e3 = this.attribList, r3 = this.tag.attributes, i2 = n(e3);
          try {
            for (i2.s(); !(t3 = i2.n()).done; ) {
              var o2 = t3.value, a3 = o2.name, s2 = o2.value;
              r3[a3] !== void 0 && this.fail("duplicate attribute: ".concat(a3, ".")), r3[a3] = s2;
            }
          } catch (t4) {
            i2.e(t4);
          } finally {
            i2.f();
          }
          this.attribList = [];
        } }, { key: "openTag", value: function() {
          var t3;
          this.processAttribs();
          var e3 = this.tags, r3 = this.tag;
          r3.isSelfClosing = false, (t3 = this.openTagHandler) === null || t3 === void 0 || t3.call(this, r3), e3.push(r3), this.state = 13, this.name = "";
        } }, { key: "openSelfClosingTag", value: function() {
          var t3, e3, r3;
          this.processAttribs();
          var n2 = this.tags, i2 = this.tag;
          i2.isSelfClosing = true, (t3 = this.openTagHandler) === null || t3 === void 0 || t3.call(this, i2), (e3 = this.closeTagHandler) === null || e3 === void 0 || e3.call(this, i2), (this.tag = (r3 = n2[n2.length - 1]) !== null && r3 !== void 0 ? r3 : null) === null && (this.closedRoot = true), this.state = 13, this.name = "";
        } }, { key: "closeTag", value: function() {
          var t3 = this.tags, e3 = this.name;
          if (this.state = 13, this.name = "", e3 === "")
            return this.fail("weird empty close tag."), void (this.text += "</>");
          for (var r3 = this.closeTagHandler, n2 = t3.length; n2-- > 0; ) {
            var i2 = this.tag = t3.pop();
            if (this.topNS = i2.ns, r3 == null || r3(i2), i2.name === e3)
              break;
            this.fail("unexpected close tag.");
          }
          n2 === 0 ? this.closedRoot = true : n2 < 0 && (this.fail("unmatched closing tag: ".concat(e3, ".")), this.text += "</".concat(e3, ">"));
        } }, { key: "parseEntity", value: function(t3) {
          if (t3[0] !== "#") {
            var e3 = this.ENTITIES[t3];
            return e3 !== void 0 ? e3 : (this.fail(this.isName(t3) ? "undefined entity." : "disallowed character in entity name."), "&".concat(t3, ";"));
          }
          var r3 = NaN;
          return t3[1] === "x" && /^#x[0-9a-f]+$/i.test(t3) ? r3 = parseInt(t3.slice(2), 16) : /^#[0-9]+$/.test(t3) && (r3 = parseInt(t3.slice(1), 10)), this.isChar(r3) ? String.fromCodePoint(r3) : (this.fail("malformed character entity."), "&".concat(t3, ";"));
        } }, { key: "closed", get: function() {
          return this._closed;
        } }, { key: "position", get: function() {
          return this.chunkPosition + this.i;
        } }, { key: "columnIndex", get: function() {
          return this.position - this.positionAtNewLine;
        } }]) && o(e2.prototype, r2), t2;
      }();
      r.SaxesParser = F;
    }, { "xmlchars/xml/1.0/ed5": 541, "xmlchars/xml/1.1/ed2": 542, "xmlchars/xmlns/1.0/ed3": 543 }], 497: [function(t, e, r) {
      (function(t2) {
        e.exports = typeof t2 == "function" ? t2 : function() {
          var t3 = [].slice.apply(arguments);
          t3.splice(1, 0, 0), setTimeout.apply(null, t3);
        };
      }).call(this, t("timers").setImmediate);
    }, { timers: 521 }], 498: [function(t, e, r) {
      var n = t("safe-buffer").Buffer;
      function i(t2, e2) {
        this._block = n.alloc(t2), this._finalSize = e2, this._blockSize = t2, this._len = 0;
      }
      i.prototype.update = function(t2, e2) {
        typeof t2 == "string" && (e2 = e2 || "utf8", t2 = n.from(t2, e2));
        for (var r2 = this._block, i2 = this._blockSize, o = t2.length, a = this._len, s = 0; s < o; ) {
          for (var u = a % i2, c = Math.min(o - s, i2 - u), f = 0; f < c; f++)
            r2[u + f] = t2[s + f];
          s += c, (a += c) % i2 == 0 && this._update(r2);
        }
        return this._len += o, this;
      }, i.prototype.digest = function(t2) {
        var e2 = this._len % this._blockSize;
        this._block[e2] = 128, this._block.fill(0, e2 + 1), e2 >= this._finalSize && (this._update(this._block), this._block.fill(0));
        var r2 = 8 * this._len;
        if (r2 <= 4294967295)
          this._block.writeUInt32BE(r2, this._blockSize - 4);
        else {
          var n2 = (4294967295 & r2) >>> 0, i2 = (r2 - n2) / 4294967296;
          this._block.writeUInt32BE(i2, this._blockSize - 8), this._block.writeUInt32BE(n2, this._blockSize - 4);
        }
        this._update(this._block);
        var o = this._hash();
        return t2 ? o.toString(t2) : o;
      }, i.prototype._update = function() {
        throw new Error("_update must be implemented by subclass");
      }, e.exports = i;
    }, { "safe-buffer": 494 }], 499: [function(t, e, r) {
      var n = e.exports = function(t2) {
        t2 = t2.toLowerCase();
        var e2 = n[t2];
        if (!e2)
          throw new Error(t2 + " is not supported (we accept pull requests)");
        return new e2();
      };
      n.sha = t("./sha"), n.sha1 = t("./sha1"), n.sha224 = t("./sha224"), n.sha256 = t("./sha256"), n.sha384 = t("./sha384"), n.sha512 = t("./sha512");
    }, { "./sha": 500, "./sha1": 501, "./sha224": 502, "./sha256": 503, "./sha384": 504, "./sha512": 505 }], 500: [function(t, e, r) {
      var n = t("inherits"), i = t("./hash"), o = t("safe-buffer").Buffer, a = [1518500249, 1859775393, -1894007588, -899497514], s = new Array(80);
      function u() {
        this.init(), this._w = s, i.call(this, 64, 56);
      }
      function c(t2) {
        return t2 << 30 | t2 >>> 2;
      }
      function f(t2, e2, r2, n2) {
        return t2 === 0 ? e2 & r2 | ~e2 & n2 : t2 === 2 ? e2 & r2 | e2 & n2 | r2 & n2 : e2 ^ r2 ^ n2;
      }
      n(u, i), u.prototype.init = function() {
        return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
      }, u.prototype._update = function(t2) {
        for (var e2, r2 = this._w, n2 = 0 | this._a, i2 = 0 | this._b, o2 = 0 | this._c, s2 = 0 | this._d, u2 = 0 | this._e, l = 0; l < 16; ++l)
          r2[l] = t2.readInt32BE(4 * l);
        for (; l < 80; ++l)
          r2[l] = r2[l - 3] ^ r2[l - 8] ^ r2[l - 14] ^ r2[l - 16];
        for (var h = 0; h < 80; ++h) {
          var d = ~~(h / 20), p = 0 | ((e2 = n2) << 5 | e2 >>> 27) + f(d, i2, o2, s2) + u2 + r2[h] + a[d];
          u2 = s2, s2 = o2, o2 = c(i2), i2 = n2, n2 = p;
        }
        this._a = n2 + this._a | 0, this._b = i2 + this._b | 0, this._c = o2 + this._c | 0, this._d = s2 + this._d | 0, this._e = u2 + this._e | 0;
      }, u.prototype._hash = function() {
        var t2 = o.allocUnsafe(20);
        return t2.writeInt32BE(0 | this._a, 0), t2.writeInt32BE(0 | this._b, 4), t2.writeInt32BE(0 | this._c, 8), t2.writeInt32BE(0 | this._d, 12), t2.writeInt32BE(0 | this._e, 16), t2;
      }, e.exports = u;
    }, { "./hash": 498, inherits: 387, "safe-buffer": 494 }], 501: [function(t, e, r) {
      var n = t("inherits"), i = t("./hash"), o = t("safe-buffer").Buffer, a = [1518500249, 1859775393, -1894007588, -899497514], s = new Array(80);
      function u() {
        this.init(), this._w = s, i.call(this, 64, 56);
      }
      function c(t2) {
        return t2 << 5 | t2 >>> 27;
      }
      function f(t2) {
        return t2 << 30 | t2 >>> 2;
      }
      function l(t2, e2, r2, n2) {
        return t2 === 0 ? e2 & r2 | ~e2 & n2 : t2 === 2 ? e2 & r2 | e2 & n2 | r2 & n2 : e2 ^ r2 ^ n2;
      }
      n(u, i), u.prototype.init = function() {
        return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
      }, u.prototype._update = function(t2) {
        for (var e2, r2 = this._w, n2 = 0 | this._a, i2 = 0 | this._b, o2 = 0 | this._c, s2 = 0 | this._d, u2 = 0 | this._e, h = 0; h < 16; ++h)
          r2[h] = t2.readInt32BE(4 * h);
        for (; h < 80; ++h)
          r2[h] = (e2 = r2[h - 3] ^ r2[h - 8] ^ r2[h - 14] ^ r2[h - 16]) << 1 | e2 >>> 31;
        for (var d = 0; d < 80; ++d) {
          var p = ~~(d / 20), m = c(n2) + l(p, i2, o2, s2) + u2 + r2[d] + a[p] | 0;
          u2 = s2, s2 = o2, o2 = f(i2), i2 = n2, n2 = m;
        }
        this._a = n2 + this._a | 0, this._b = i2 + this._b | 0, this._c = o2 + this._c | 0, this._d = s2 + this._d | 0, this._e = u2 + this._e | 0;
      }, u.prototype._hash = function() {
        var t2 = o.allocUnsafe(20);
        return t2.writeInt32BE(0 | this._a, 0), t2.writeInt32BE(0 | this._b, 4), t2.writeInt32BE(0 | this._c, 8), t2.writeInt32BE(0 | this._d, 12), t2.writeInt32BE(0 | this._e, 16), t2;
      }, e.exports = u;
    }, { "./hash": 498, inherits: 387, "safe-buffer": 494 }], 502: [function(t, e, r) {
      var n = t("inherits"), i = t("./sha256"), o = t("./hash"), a = t("safe-buffer").Buffer, s = new Array(64);
      function u() {
        this.init(), this._w = s, o.call(this, 64, 56);
      }
      n(u, i), u.prototype.init = function() {
        return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
      }, u.prototype._hash = function() {
        var t2 = a.allocUnsafe(28);
        return t2.writeInt32BE(this._a, 0), t2.writeInt32BE(this._b, 4), t2.writeInt32BE(this._c, 8), t2.writeInt32BE(this._d, 12), t2.writeInt32BE(this._e, 16), t2.writeInt32BE(this._f, 20), t2.writeInt32BE(this._g, 24), t2;
      }, e.exports = u;
    }, { "./hash": 498, "./sha256": 503, inherits: 387, "safe-buffer": 494 }], 503: [function(t, e, r) {
      var n = t("inherits"), i = t("./hash"), o = t("safe-buffer").Buffer, a = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], s = new Array(64);
      function u() {
        this.init(), this._w = s, i.call(this, 64, 56);
      }
      function c(t2, e2, r2) {
        return r2 ^ t2 & (e2 ^ r2);
      }
      function f(t2, e2, r2) {
        return t2 & e2 | r2 & (t2 | e2);
      }
      function l(t2) {
        return (t2 >>> 2 | t2 << 30) ^ (t2 >>> 13 | t2 << 19) ^ (t2 >>> 22 | t2 << 10);
      }
      function h(t2) {
        return (t2 >>> 6 | t2 << 26) ^ (t2 >>> 11 | t2 << 21) ^ (t2 >>> 25 | t2 << 7);
      }
      function d(t2) {
        return (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;
      }
      n(u, i), u.prototype.init = function() {
        return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
      }, u.prototype._update = function(t2) {
        for (var e2, r2 = this._w, n2 = 0 | this._a, i2 = 0 | this._b, o2 = 0 | this._c, s2 = 0 | this._d, u2 = 0 | this._e, p = 0 | this._f, m = 0 | this._g, y = 0 | this._h, b = 0; b < 16; ++b)
          r2[b] = t2.readInt32BE(4 * b);
        for (; b < 64; ++b)
          r2[b] = 0 | (((e2 = r2[b - 2]) >>> 17 | e2 << 15) ^ (e2 >>> 19 | e2 << 13) ^ e2 >>> 10) + r2[b - 7] + d(r2[b - 15]) + r2[b - 16];
        for (var v = 0; v < 64; ++v) {
          var g = y + h(u2) + c(u2, p, m) + a[v] + r2[v] | 0, w = l(n2) + f(n2, i2, o2) | 0;
          y = m, m = p, p = u2, u2 = s2 + g | 0, s2 = o2, o2 = i2, i2 = n2, n2 = g + w | 0;
        }
        this._a = n2 + this._a | 0, this._b = i2 + this._b | 0, this._c = o2 + this._c | 0, this._d = s2 + this._d | 0, this._e = u2 + this._e | 0, this._f = p + this._f | 0, this._g = m + this._g | 0, this._h = y + this._h | 0;
      }, u.prototype._hash = function() {
        var t2 = o.allocUnsafe(32);
        return t2.writeInt32BE(this._a, 0), t2.writeInt32BE(this._b, 4), t2.writeInt32BE(this._c, 8), t2.writeInt32BE(this._d, 12), t2.writeInt32BE(this._e, 16), t2.writeInt32BE(this._f, 20), t2.writeInt32BE(this._g, 24), t2.writeInt32BE(this._h, 28), t2;
      }, e.exports = u;
    }, { "./hash": 498, inherits: 387, "safe-buffer": 494 }], 504: [function(t, e, r) {
      var n = t("inherits"), i = t("./sha512"), o = t("./hash"), a = t("safe-buffer").Buffer, s = new Array(160);
      function u() {
        this.init(), this._w = s, o.call(this, 128, 112);
      }
      n(u, i), u.prototype.init = function() {
        return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
      }, u.prototype._hash = function() {
        var t2 = a.allocUnsafe(48);
        function e2(e3, r2, n2) {
          t2.writeInt32BE(e3, n2), t2.writeInt32BE(r2, n2 + 4);
        }
        return e2(this._ah, this._al, 0), e2(this._bh, this._bl, 8), e2(this._ch, this._cl, 16), e2(this._dh, this._dl, 24), e2(this._eh, this._el, 32), e2(this._fh, this._fl, 40), t2;
      }, e.exports = u;
    }, { "./hash": 498, "./sha512": 505, inherits: 387, "safe-buffer": 494 }], 505: [function(t, e, r) {
      var n = t("inherits"), i = t("./hash"), o = t("safe-buffer").Buffer, a = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591], s = new Array(160);
      function u() {
        this.init(), this._w = s, i.call(this, 128, 112);
      }
      function c(t2, e2, r2) {
        return r2 ^ t2 & (e2 ^ r2);
      }
      function f(t2, e2, r2) {
        return t2 & e2 | r2 & (t2 | e2);
      }
      function l(t2, e2) {
        return (t2 >>> 28 | e2 << 4) ^ (e2 >>> 2 | t2 << 30) ^ (e2 >>> 7 | t2 << 25);
      }
      function h(t2, e2) {
        return (t2 >>> 14 | e2 << 18) ^ (t2 >>> 18 | e2 << 14) ^ (e2 >>> 9 | t2 << 23);
      }
      function d(t2, e2) {
        return (t2 >>> 1 | e2 << 31) ^ (t2 >>> 8 | e2 << 24) ^ t2 >>> 7;
      }
      function p(t2, e2) {
        return (t2 >>> 1 | e2 << 31) ^ (t2 >>> 8 | e2 << 24) ^ (t2 >>> 7 | e2 << 25);
      }
      function m(t2, e2) {
        return (t2 >>> 19 | e2 << 13) ^ (e2 >>> 29 | t2 << 3) ^ t2 >>> 6;
      }
      function y(t2, e2) {
        return (t2 >>> 19 | e2 << 13) ^ (e2 >>> 29 | t2 << 3) ^ (t2 >>> 6 | e2 << 26);
      }
      function b(t2, e2) {
        return t2 >>> 0 < e2 >>> 0 ? 1 : 0;
      }
      n(u, i), u.prototype.init = function() {
        return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
      }, u.prototype._update = function(t2) {
        for (var e2 = this._w, r2 = 0 | this._ah, n2 = 0 | this._bh, i2 = 0 | this._ch, o2 = 0 | this._dh, s2 = 0 | this._eh, u2 = 0 | this._fh, v = 0 | this._gh, g = 0 | this._hh, w = 0 | this._al, _ = 0 | this._bl, k = 0 | this._cl, x = 0 | this._dl, S = 0 | this._el, O = 0 | this._fl, j = 0 | this._gl, E = 0 | this._hl, R = 0; R < 32; R += 2)
          e2[R] = t2.readInt32BE(4 * R), e2[R + 1] = t2.readInt32BE(4 * R + 4);
        for (; R < 160; R += 2) {
          var T = e2[R - 30], C = e2[R - 30 + 1], P = d(T, C), M = p(C, T), A = m(T = e2[R - 4], C = e2[R - 4 + 1]), I = y(C, T), N = e2[R - 14], D = e2[R - 14 + 1], B = e2[R - 32], F = e2[R - 32 + 1], L = M + D | 0, z = P + N + b(L, M) | 0;
          z = (z = z + A + b(L = L + I | 0, I) | 0) + B + b(L = L + F | 0, F) | 0, e2[R] = z, e2[R + 1] = L;
        }
        for (var U = 0; U < 160; U += 2) {
          z = e2[U], L = e2[U + 1];
          var H = f(r2, n2, i2), V = f(w, _, k), q = l(r2, w), W = l(w, r2), $ = h(s2, S), X = h(S, s2), K = a[U], Z = a[U + 1], Y = c(s2, u2, v), G = c(S, O, j), J = E + X | 0, Q = g + $ + b(J, E) | 0;
          Q = (Q = (Q = Q + Y + b(J = J + G | 0, G) | 0) + K + b(J = J + Z | 0, Z) | 0) + z + b(J = J + L | 0, L) | 0;
          var tt = W + V | 0, et = q + H + b(tt, W) | 0;
          g = v, E = j, v = u2, j = O, u2 = s2, O = S, s2 = o2 + Q + b(S = x + J | 0, x) | 0, o2 = i2, x = k, i2 = n2, k = _, n2 = r2, _ = w, r2 = Q + et + b(w = J + tt | 0, J) | 0;
        }
        this._al = this._al + w | 0, this._bl = this._bl + _ | 0, this._cl = this._cl + k | 0, this._dl = this._dl + x | 0, this._el = this._el + S | 0, this._fl = this._fl + O | 0, this._gl = this._gl + j | 0, this._hl = this._hl + E | 0, this._ah = this._ah + r2 + b(this._al, w) | 0, this._bh = this._bh + n2 + b(this._bl, _) | 0, this._ch = this._ch + i2 + b(this._cl, k) | 0, this._dh = this._dh + o2 + b(this._dl, x) | 0, this._eh = this._eh + s2 + b(this._el, S) | 0, this._fh = this._fh + u2 + b(this._fl, O) | 0, this._gh = this._gh + v + b(this._gl, j) | 0, this._hh = this._hh + g + b(this._hl, E) | 0;
      }, u.prototype._hash = function() {
        var t2 = o.allocUnsafe(64);
        function e2(e3, r2, n2) {
          t2.writeInt32BE(e3, n2), t2.writeInt32BE(r2, n2 + 4);
        }
        return e2(this._ah, this._al, 0), e2(this._bh, this._bl, 8), e2(this._ch, this._cl, 16), e2(this._dh, this._dl, 24), e2(this._eh, this._el, 32), e2(this._fh, this._fl, 40), e2(this._gh, this._gl, 48), e2(this._hh, this._hl, 56), t2;
      }, e.exports = u;
    }, { "./hash": 498, inherits: 387, "safe-buffer": 494 }], 506: [function(t, e, r) {
      e.exports = i;
      var n = t("events").EventEmitter;
      function i() {
        n.call(this);
      }
      t("inherits")(i, n), i.Readable = t("readable-stream/readable.js"), i.Writable = t("readable-stream/writable.js"), i.Duplex = t("readable-stream/duplex.js"), i.Transform = t("readable-stream/transform.js"), i.PassThrough = t("readable-stream/passthrough.js"), i.Stream = i, i.prototype.pipe = function(t2, e2) {
        var r2 = this;
        function i2(e3) {
          t2.writable && t2.write(e3) === false && r2.pause && r2.pause();
        }
        function o() {
          r2.readable && r2.resume && r2.resume();
        }
        r2.on("data", i2), t2.on("drain", o), t2._isStdio || e2 && e2.end === false || (r2.on("end", s), r2.on("close", u));
        var a = false;
        function s() {
          a || (a = true, t2.end());
        }
        function u() {
          a || (a = true, typeof t2.destroy == "function" && t2.destroy());
        }
        function c(t3) {
          if (f(), n.listenerCount(this, "error") === 0)
            throw t3;
        }
        function f() {
          r2.removeListener("data", i2), t2.removeListener("drain", o), r2.removeListener("end", s), r2.removeListener("close", u), r2.removeListener("error", c), t2.removeListener("error", c), r2.removeListener("end", f), r2.removeListener("close", f), t2.removeListener("close", f);
        }
        return r2.on("error", c), t2.on("error", c), r2.on("end", f), r2.on("close", f), t2.on("close", f), t2.emit("pipe", r2), t2;
      };
    }, { events: 367, inherits: 387, "readable-stream/duplex.js": 507, "readable-stream/passthrough.js": 516, "readable-stream/readable.js": 517, "readable-stream/transform.js": 518, "readable-stream/writable.js": 519 }], 507: [function(t, e, r) {
      e.exports = t("./lib/_stream_duplex.js");
    }, { "./lib/_stream_duplex.js": 508 }], 508: [function(t, e, r) {
      var n = t("process-nextick-args"), i = Object.keys || function(t2) {
        var e2 = [];
        for (var r2 in t2)
          e2.push(r2);
        return e2;
      };
      e.exports = l;
      var o = Object.create(t("core-util-is"));
      o.inherits = t("inherits");
      var a = t("./_stream_readable"), s = t("./_stream_writable");
      o.inherits(l, a);
      for (var u = i(s.prototype), c = 0; c < u.length; c++) {
        var f = u[c];
        l.prototype[f] || (l.prototype[f] = s.prototype[f]);
      }
      function l(t2) {
        if (!(this instanceof l))
          return new l(t2);
        a.call(this, t2), s.call(this, t2), t2 && t2.readable === false && (this.readable = false), t2 && t2.writable === false && (this.writable = false), this.allowHalfOpen = true, t2 && t2.allowHalfOpen === false && (this.allowHalfOpen = false), this.once("end", h);
      }
      function h() {
        this.allowHalfOpen || this._writableState.ended || n.nextTick(d, this);
      }
      function d(t2) {
        t2.end();
      }
      Object.defineProperty(l.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
        return this._writableState.highWaterMark;
      } }), Object.defineProperty(l.prototype, "destroyed", { get: function() {
        return this._readableState !== void 0 && this._writableState !== void 0 && (this._readableState.destroyed && this._writableState.destroyed);
      }, set: function(t2) {
        this._readableState !== void 0 && this._writableState !== void 0 && (this._readableState.destroyed = t2, this._writableState.destroyed = t2);
      } }), l.prototype._destroy = function(t2, e2) {
        this.push(null), this.end(), n.nextTick(e2, t2);
      };
    }, { "./_stream_readable": 510, "./_stream_writable": 512, "core-util-is": 328, inherits: 387, "process-nextick-args": 466 }], 509: [function(t, e, r) {
      e.exports = o;
      var n = t("./_stream_transform"), i = Object.create(t("core-util-is"));
      function o(t2) {
        if (!(this instanceof o))
          return new o(t2);
        n.call(this, t2);
      }
      i.inherits = t("inherits"), i.inherits(o, n), o.prototype._transform = function(t2, e2, r2) {
        r2(null, t2);
      };
    }, { "./_stream_transform": 511, "core-util-is": 328, inherits: 387 }], 510: [function(t, e, r) {
      (function(r2, n) {
        var i = t("process-nextick-args");
        e.exports = g;
        var o, a = t("isarray");
        g.ReadableState = v;
        t("events").EventEmitter;
        var s = function(t2, e2) {
          return t2.listeners(e2).length;
        }, u = t("./internal/streams/stream"), c = t("safe-buffer").Buffer, f = n.Uint8Array || function() {
        };
        var l = Object.create(t("core-util-is"));
        l.inherits = t("inherits");
        var h = t("util"), d = void 0;
        d = h && h.debuglog ? h.debuglog("stream") : function() {
        };
        var p, m = t("./internal/streams/BufferList"), y = t("./internal/streams/destroy");
        l.inherits(g, u);
        var b = ["error", "close", "destroy", "pause", "resume"];
        function v(e2, r3) {
          e2 = e2 || {};
          var n2 = r3 instanceof (o = o || t("./_stream_duplex"));
          this.objectMode = !!e2.objectMode, n2 && (this.objectMode = this.objectMode || !!e2.readableObjectMode);
          var i2 = e2.highWaterMark, a2 = e2.readableHighWaterMark, s2 = this.objectMode ? 16 : 16384;
          this.highWaterMark = i2 || i2 === 0 ? i2 : n2 && (a2 || a2 === 0) ? a2 : s2, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new m(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.destroyed = false, this.defaultEncoding = e2.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, e2.encoding && (p || (p = t("string_decoder/").StringDecoder), this.decoder = new p(e2.encoding), this.encoding = e2.encoding);
        }
        function g(e2) {
          if (o = o || t("./_stream_duplex"), !(this instanceof g))
            return new g(e2);
          this._readableState = new v(e2, this), this.readable = true, e2 && (typeof e2.read == "function" && (this._read = e2.read), typeof e2.destroy == "function" && (this._destroy = e2.destroy)), u.call(this);
        }
        function w(t2, e2, r3, n2, i2) {
          var o2, a2 = t2._readableState;
          e2 === null ? (a2.reading = false, function(t3, e3) {
            if (e3.ended)
              return;
            if (e3.decoder) {
              var r4 = e3.decoder.end();
              r4 && r4.length && (e3.buffer.push(r4), e3.length += e3.objectMode ? 1 : r4.length);
            }
            e3.ended = true, x(t3);
          }(t2, a2)) : (i2 || (o2 = function(t3, e3) {
            var r4;
            n3 = e3, c.isBuffer(n3) || n3 instanceof f || typeof e3 == "string" || e3 === void 0 || t3.objectMode || (r4 = new TypeError("Invalid non-string/buffer chunk"));
            var n3;
            return r4;
          }(a2, e2)), o2 ? t2.emit("error", o2) : a2.objectMode || e2 && e2.length > 0 ? (typeof e2 == "string" || a2.objectMode || Object.getPrototypeOf(e2) === c.prototype || (e2 = function(t3) {
            return c.from(t3);
          }(e2)), n2 ? a2.endEmitted ? t2.emit("error", new Error("stream.unshift() after end event")) : _(t2, a2, e2, true) : a2.ended ? t2.emit("error", new Error("stream.push() after EOF")) : (a2.reading = false, a2.decoder && !r3 ? (e2 = a2.decoder.write(e2), a2.objectMode || e2.length !== 0 ? _(t2, a2, e2, false) : O(t2, a2)) : _(t2, a2, e2, false))) : n2 || (a2.reading = false));
          return function(t3) {
            return !t3.ended && (t3.needReadable || t3.length < t3.highWaterMark || t3.length === 0);
          }(a2);
        }
        function _(t2, e2, r3, n2) {
          e2.flowing && e2.length === 0 && !e2.sync ? (t2.emit("data", r3), t2.read(0)) : (e2.length += e2.objectMode ? 1 : r3.length, n2 ? e2.buffer.unshift(r3) : e2.buffer.push(r3), e2.needReadable && x(t2)), O(t2, e2);
        }
        Object.defineProperty(g.prototype, "destroyed", { get: function() {
          return this._readableState !== void 0 && this._readableState.destroyed;
        }, set: function(t2) {
          this._readableState && (this._readableState.destroyed = t2);
        } }), g.prototype.destroy = y.destroy, g.prototype._undestroy = y.undestroy, g.prototype._destroy = function(t2, e2) {
          this.push(null), e2(t2);
        }, g.prototype.push = function(t2, e2) {
          var r3, n2 = this._readableState;
          return n2.objectMode ? r3 = true : typeof t2 == "string" && ((e2 = e2 || n2.defaultEncoding) !== n2.encoding && (t2 = c.from(t2, e2), e2 = ""), r3 = true), w(this, t2, e2, false, r3);
        }, g.prototype.unshift = function(t2) {
          return w(this, t2, null, true, false);
        }, g.prototype.isPaused = function() {
          return this._readableState.flowing === false;
        }, g.prototype.setEncoding = function(e2) {
          return p || (p = t("string_decoder/").StringDecoder), this._readableState.decoder = new p(e2), this._readableState.encoding = e2, this;
        };
        function k(t2, e2) {
          return t2 <= 0 || e2.length === 0 && e2.ended ? 0 : e2.objectMode ? 1 : t2 != t2 ? e2.flowing && e2.length ? e2.buffer.head.data.length : e2.length : (t2 > e2.highWaterMark && (e2.highWaterMark = function(t3) {
            return t3 >= 8388608 ? t3 = 8388608 : (t3--, t3 |= t3 >>> 1, t3 |= t3 >>> 2, t3 |= t3 >>> 4, t3 |= t3 >>> 8, t3 |= t3 >>> 16, t3++), t3;
          }(t2)), t2 <= e2.length ? t2 : e2.ended ? e2.length : (e2.needReadable = true, 0));
        }
        function x(t2) {
          var e2 = t2._readableState;
          e2.needReadable = false, e2.emittedReadable || (d("emitReadable", e2.flowing), e2.emittedReadable = true, e2.sync ? i.nextTick(S, t2) : S(t2));
        }
        function S(t2) {
          d("emit readable"), t2.emit("readable"), T(t2);
        }
        function O(t2, e2) {
          e2.readingMore || (e2.readingMore = true, i.nextTick(j, t2, e2));
        }
        function j(t2, e2) {
          for (var r3 = e2.length; !e2.reading && !e2.flowing && !e2.ended && e2.length < e2.highWaterMark && (d("maybeReadMore read 0"), t2.read(0), r3 !== e2.length); )
            r3 = e2.length;
          e2.readingMore = false;
        }
        function E(t2) {
          d("readable nexttick read 0"), t2.read(0);
        }
        function R(t2, e2) {
          e2.reading || (d("resume read 0"), t2.read(0)), e2.resumeScheduled = false, e2.awaitDrain = 0, t2.emit("resume"), T(t2), e2.flowing && !e2.reading && t2.read(0);
        }
        function T(t2) {
          var e2 = t2._readableState;
          for (d("flow", e2.flowing); e2.flowing && t2.read() !== null; )
            ;
        }
        function C(t2, e2) {
          return e2.length === 0 ? null : (e2.objectMode ? r3 = e2.buffer.shift() : !t2 || t2 >= e2.length ? (r3 = e2.decoder ? e2.buffer.join("") : e2.buffer.length === 1 ? e2.buffer.head.data : e2.buffer.concat(e2.length), e2.buffer.clear()) : r3 = function(t3, e3, r4) {
            var n2;
            t3 < e3.head.data.length ? (n2 = e3.head.data.slice(0, t3), e3.head.data = e3.head.data.slice(t3)) : n2 = t3 === e3.head.data.length ? e3.shift() : r4 ? function(t4, e4) {
              var r5 = e4.head, n3 = 1, i2 = r5.data;
              t4 -= i2.length;
              for (; r5 = r5.next; ) {
                var o2 = r5.data, a2 = t4 > o2.length ? o2.length : t4;
                if (a2 === o2.length ? i2 += o2 : i2 += o2.slice(0, t4), (t4 -= a2) === 0) {
                  a2 === o2.length ? (++n3, r5.next ? e4.head = r5.next : e4.head = e4.tail = null) : (e4.head = r5, r5.data = o2.slice(a2));
                  break;
                }
                ++n3;
              }
              return e4.length -= n3, i2;
            }(t3, e3) : function(t4, e4) {
              var r5 = c.allocUnsafe(t4), n3 = e4.head, i2 = 1;
              n3.data.copy(r5), t4 -= n3.data.length;
              for (; n3 = n3.next; ) {
                var o2 = n3.data, a2 = t4 > o2.length ? o2.length : t4;
                if (o2.copy(r5, r5.length - t4, 0, a2), (t4 -= a2) === 0) {
                  a2 === o2.length ? (++i2, n3.next ? e4.head = n3.next : e4.head = e4.tail = null) : (e4.head = n3, n3.data = o2.slice(a2));
                  break;
                }
                ++i2;
              }
              return e4.length -= i2, r5;
            }(t3, e3);
            return n2;
          }(t2, e2.buffer, e2.decoder), r3);
          var r3;
        }
        function P(t2) {
          var e2 = t2._readableState;
          if (e2.length > 0)
            throw new Error('"endReadable()" called on non-empty stream');
          e2.endEmitted || (e2.ended = true, i.nextTick(M, e2, t2));
        }
        function M(t2, e2) {
          t2.endEmitted || t2.length !== 0 || (t2.endEmitted = true, e2.readable = false, e2.emit("end"));
        }
        function A(t2, e2) {
          for (var r3 = 0, n2 = t2.length; r3 < n2; r3++)
            if (t2[r3] === e2)
              return r3;
          return -1;
        }
        g.prototype.read = function(t2) {
          d("read", t2), t2 = parseInt(t2, 10);
          var e2 = this._readableState, r3 = t2;
          if (t2 !== 0 && (e2.emittedReadable = false), t2 === 0 && e2.needReadable && (e2.length >= e2.highWaterMark || e2.ended))
            return d("read: emitReadable", e2.length, e2.ended), e2.length === 0 && e2.ended ? P(this) : x(this), null;
          if ((t2 = k(t2, e2)) === 0 && e2.ended)
            return e2.length === 0 && P(this), null;
          var n2, i2 = e2.needReadable;
          return d("need readable", i2), (e2.length === 0 || e2.length - t2 < e2.highWaterMark) && d("length less than watermark", i2 = true), e2.ended || e2.reading ? d("reading or ended", i2 = false) : i2 && (d("do read"), e2.reading = true, e2.sync = true, e2.length === 0 && (e2.needReadable = true), this._read(e2.highWaterMark), e2.sync = false, e2.reading || (t2 = k(r3, e2))), (n2 = t2 > 0 ? C(t2, e2) : null) === null ? (e2.needReadable = true, t2 = 0) : e2.length -= t2, e2.length === 0 && (e2.ended || (e2.needReadable = true), r3 !== t2 && e2.ended && P(this)), n2 !== null && this.emit("data", n2), n2;
        }, g.prototype._read = function(t2) {
          this.emit("error", new Error("_read() is not implemented"));
        }, g.prototype.pipe = function(t2, e2) {
          var n2 = this, o2 = this._readableState;
          switch (o2.pipesCount) {
            case 0:
              o2.pipes = t2;
              break;
            case 1:
              o2.pipes = [o2.pipes, t2];
              break;
            default:
              o2.pipes.push(t2);
          }
          o2.pipesCount += 1, d("pipe count=%d opts=%j", o2.pipesCount, e2);
          var u2 = (!e2 || e2.end !== false) && t2 !== r2.stdout && t2 !== r2.stderr ? f2 : g2;
          function c2(e3, r3) {
            d("onunpipe"), e3 === n2 && r3 && r3.hasUnpiped === false && (r3.hasUnpiped = true, d("cleanup"), t2.removeListener("close", b2), t2.removeListener("finish", v2), t2.removeListener("drain", l2), t2.removeListener("error", y2), t2.removeListener("unpipe", c2), n2.removeListener("end", f2), n2.removeListener("end", g2), n2.removeListener("data", m2), h2 = true, !o2.awaitDrain || t2._writableState && !t2._writableState.needDrain || l2());
          }
          function f2() {
            d("onend"), t2.end();
          }
          o2.endEmitted ? i.nextTick(u2) : n2.once("end", u2), t2.on("unpipe", c2);
          var l2 = function(t3) {
            return function() {
              var e3 = t3._readableState;
              d("pipeOnDrain", e3.awaitDrain), e3.awaitDrain && e3.awaitDrain--, e3.awaitDrain === 0 && s(t3, "data") && (e3.flowing = true, T(t3));
            };
          }(n2);
          t2.on("drain", l2);
          var h2 = false;
          var p2 = false;
          function m2(e3) {
            d("ondata"), p2 = false, t2.write(e3) !== false || p2 || ((o2.pipesCount === 1 && o2.pipes === t2 || o2.pipesCount > 1 && A(o2.pipes, t2) !== -1) && !h2 && (d("false write response, pause", n2._readableState.awaitDrain), n2._readableState.awaitDrain++, p2 = true), n2.pause());
          }
          function y2(e3) {
            d("onerror", e3), g2(), t2.removeListener("error", y2), s(t2, "error") === 0 && t2.emit("error", e3);
          }
          function b2() {
            t2.removeListener("finish", v2), g2();
          }
          function v2() {
            d("onfinish"), t2.removeListener("close", b2), g2();
          }
          function g2() {
            d("unpipe"), n2.unpipe(t2);
          }
          return n2.on("data", m2), function(t3, e3, r3) {
            if (typeof t3.prependListener == "function")
              return t3.prependListener(e3, r3);
            t3._events && t3._events[e3] ? a(t3._events[e3]) ? t3._events[e3].unshift(r3) : t3._events[e3] = [r3, t3._events[e3]] : t3.on(e3, r3);
          }(t2, "error", y2), t2.once("close", b2), t2.once("finish", v2), t2.emit("pipe", n2), o2.flowing || (d("pipe resume"), n2.resume()), t2;
        }, g.prototype.unpipe = function(t2) {
          var e2 = this._readableState, r3 = { hasUnpiped: false };
          if (e2.pipesCount === 0)
            return this;
          if (e2.pipesCount === 1)
            return t2 && t2 !== e2.pipes || (t2 || (t2 = e2.pipes), e2.pipes = null, e2.pipesCount = 0, e2.flowing = false, t2 && t2.emit("unpipe", this, r3)), this;
          if (!t2) {
            var n2 = e2.pipes, i2 = e2.pipesCount;
            e2.pipes = null, e2.pipesCount = 0, e2.flowing = false;
            for (var o2 = 0; o2 < i2; o2++)
              n2[o2].emit("unpipe", this, r3);
            return this;
          }
          var a2 = A(e2.pipes, t2);
          return a2 === -1 || (e2.pipes.splice(a2, 1), e2.pipesCount -= 1, e2.pipesCount === 1 && (e2.pipes = e2.pipes[0]), t2.emit("unpipe", this, r3)), this;
        }, g.prototype.on = function(t2, e2) {
          var r3 = u.prototype.on.call(this, t2, e2);
          if (t2 === "data")
            this._readableState.flowing !== false && this.resume();
          else if (t2 === "readable") {
            var n2 = this._readableState;
            n2.endEmitted || n2.readableListening || (n2.readableListening = n2.needReadable = true, n2.emittedReadable = false, n2.reading ? n2.length && x(this) : i.nextTick(E, this));
          }
          return r3;
        }, g.prototype.addListener = g.prototype.on, g.prototype.resume = function() {
          var t2 = this._readableState;
          return t2.flowing || (d("resume"), t2.flowing = true, function(t3, e2) {
            e2.resumeScheduled || (e2.resumeScheduled = true, i.nextTick(R, t3, e2));
          }(this, t2)), this;
        }, g.prototype.pause = function() {
          return d("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (d("pause"), this._readableState.flowing = false, this.emit("pause")), this;
        }, g.prototype.wrap = function(t2) {
          var e2 = this, r3 = this._readableState, n2 = false;
          for (var i2 in t2.on("end", function() {
            if (d("wrapped end"), r3.decoder && !r3.ended) {
              var t3 = r3.decoder.end();
              t3 && t3.length && e2.push(t3);
            }
            e2.push(null);
          }), t2.on("data", function(i3) {
            (d("wrapped data"), r3.decoder && (i3 = r3.decoder.write(i3)), r3.objectMode && i3 == null) || (r3.objectMode || i3 && i3.length) && (e2.push(i3) || (n2 = true, t2.pause()));
          }), t2)
            this[i2] === void 0 && typeof t2[i2] == "function" && (this[i2] = function(e3) {
              return function() {
                return t2[e3].apply(t2, arguments);
              };
            }(i2));
          for (var o2 = 0; o2 < b.length; o2++)
            t2.on(b[o2], this.emit.bind(this, b[o2]));
          return this._read = function(e3) {
            d("wrapped _read", e3), n2 && (n2 = false, t2.resume());
          }, this;
        }, Object.defineProperty(g.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
          return this._readableState.highWaterMark;
        } }), g._fromList = C;
      }).call(this, t("_process"), typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, { "./_stream_duplex": 508, "./internal/streams/BufferList": 513, "./internal/streams/destroy": 514, "./internal/streams/stream": 515, _process: 467, "core-util-is": 328, events: 367, inherits: 387, isarray: 389, "process-nextick-args": 466, "safe-buffer": 494, "string_decoder/": 520, util: 185 }], 511: [function(t, e, r) {
      e.exports = a;
      var n = t("./_stream_duplex"), i = Object.create(t("core-util-is"));
      function o(t2, e2) {
        var r2 = this._transformState;
        r2.transforming = false;
        var n2 = r2.writecb;
        if (!n2)
          return this.emit("error", new Error("write callback called multiple times"));
        r2.writechunk = null, r2.writecb = null, e2 != null && this.push(e2), n2(t2);
        var i2 = this._readableState;
        i2.reading = false, (i2.needReadable || i2.length < i2.highWaterMark) && this._read(i2.highWaterMark);
      }
      function a(t2) {
        if (!(this instanceof a))
          return new a(t2);
        n.call(this, t2), this._transformState = { afterTransform: o.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, t2 && (typeof t2.transform == "function" && (this._transform = t2.transform), typeof t2.flush == "function" && (this._flush = t2.flush)), this.on("prefinish", s);
      }
      function s() {
        var t2 = this;
        typeof this._flush == "function" ? this._flush(function(e2, r2) {
          u(t2, e2, r2);
        }) : u(this, null, null);
      }
      function u(t2, e2, r2) {
        if (e2)
          return t2.emit("error", e2);
        if (r2 != null && t2.push(r2), t2._writableState.length)
          throw new Error("Calling transform done when ws.length != 0");
        if (t2._transformState.transforming)
          throw new Error("Calling transform done when still transforming");
        return t2.push(null);
      }
      i.inherits = t("inherits"), i.inherits(a, n), a.prototype.push = function(t2, e2) {
        return this._transformState.needTransform = false, n.prototype.push.call(this, t2, e2);
      }, a.prototype._transform = function(t2, e2, r2) {
        throw new Error("_transform() is not implemented");
      }, a.prototype._write = function(t2, e2, r2) {
        var n2 = this._transformState;
        if (n2.writecb = r2, n2.writechunk = t2, n2.writeencoding = e2, !n2.transforming) {
          var i2 = this._readableState;
          (n2.needTransform || i2.needReadable || i2.length < i2.highWaterMark) && this._read(i2.highWaterMark);
        }
      }, a.prototype._read = function(t2) {
        var e2 = this._transformState;
        e2.writechunk !== null && e2.writecb && !e2.transforming ? (e2.transforming = true, this._transform(e2.writechunk, e2.writeencoding, e2.afterTransform)) : e2.needTransform = true;
      }, a.prototype._destroy = function(t2, e2) {
        var r2 = this;
        n.prototype._destroy.call(this, t2, function(t3) {
          e2(t3), r2.emit("close");
        });
      };
    }, { "./_stream_duplex": 508, "core-util-is": 328, inherits: 387 }], 512: [function(t, e, r) {
      (function(r2, n, i) {
        var o = t("process-nextick-args");
        function a(t2) {
          var e2 = this;
          this.next = null, this.entry = null, this.finish = function() {
            !function(t3, e3, r3) {
              var n2 = t3.entry;
              t3.entry = null;
              for (; n2; ) {
                var i2 = n2.callback;
                e3.pendingcb--, i2(r3), n2 = n2.next;
              }
              e3.corkedRequestsFree ? e3.corkedRequestsFree.next = t3 : e3.corkedRequestsFree = t3;
            }(e2, t2);
          };
        }
        e.exports = v;
        var s, u = !r2.browser && ["v0.10", "v0.9."].indexOf(r2.version.slice(0, 5)) > -1 ? i : o.nextTick;
        v.WritableState = b;
        var c = Object.create(t("core-util-is"));
        c.inherits = t("inherits");
        var f = { deprecate: t("util-deprecate") }, l = t("./internal/streams/stream"), h = t("safe-buffer").Buffer, d = n.Uint8Array || function() {
        };
        var p, m = t("./internal/streams/destroy");
        function y() {
        }
        function b(e2, r3) {
          s = s || t("./_stream_duplex"), e2 = e2 || {};
          var n2 = r3 instanceof s;
          this.objectMode = !!e2.objectMode, n2 && (this.objectMode = this.objectMode || !!e2.writableObjectMode);
          var i2 = e2.highWaterMark, c2 = e2.writableHighWaterMark, f2 = this.objectMode ? 16 : 16384;
          this.highWaterMark = i2 || i2 === 0 ? i2 : n2 && (c2 || c2 === 0) ? c2 : f2, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
          var l2 = e2.decodeStrings === false;
          this.decodeStrings = !l2, this.defaultEncoding = e2.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(t2) {
            !function(t3, e3) {
              var r4 = t3._writableState, n3 = r4.sync, i3 = r4.writecb;
              if (function(t4) {
                t4.writing = false, t4.writecb = null, t4.length -= t4.writelen, t4.writelen = 0;
              }(r4), e3)
                !function(t4, e4, r5, n4, i4) {
                  --e4.pendingcb, r5 ? (o.nextTick(i4, n4), o.nextTick(S, t4, e4), t4._writableState.errorEmitted = true, t4.emit("error", n4)) : (i4(n4), t4._writableState.errorEmitted = true, t4.emit("error", n4), S(t4, e4));
                }(t3, r4, n3, e3, i3);
              else {
                var a2 = k(r4);
                a2 || r4.corked || r4.bufferProcessing || !r4.bufferedRequest || _(t3, r4), n3 ? u(w, t3, r4, a2, i3) : w(t3, r4, a2, i3);
              }
            }(r3, t2);
          }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.bufferedRequestCount = 0, this.corkedRequestsFree = new a(this);
        }
        function v(e2) {
          if (s = s || t("./_stream_duplex"), !(p.call(v, this) || this instanceof s))
            return new v(e2);
          this._writableState = new b(e2, this), this.writable = true, e2 && (typeof e2.write == "function" && (this._write = e2.write), typeof e2.writev == "function" && (this._writev = e2.writev), typeof e2.destroy == "function" && (this._destroy = e2.destroy), typeof e2.final == "function" && (this._final = e2.final)), l.call(this);
        }
        function g(t2, e2, r3, n2, i2, o2, a2) {
          e2.writelen = n2, e2.writecb = a2, e2.writing = true, e2.sync = true, r3 ? t2._writev(i2, e2.onwrite) : t2._write(i2, o2, e2.onwrite), e2.sync = false;
        }
        function w(t2, e2, r3, n2) {
          r3 || function(t3, e3) {
            e3.length === 0 && e3.needDrain && (e3.needDrain = false, t3.emit("drain"));
          }(t2, e2), e2.pendingcb--, n2(), S(t2, e2);
        }
        function _(t2, e2) {
          e2.bufferProcessing = true;
          var r3 = e2.bufferedRequest;
          if (t2._writev && r3 && r3.next) {
            var n2 = e2.bufferedRequestCount, i2 = new Array(n2), o2 = e2.corkedRequestsFree;
            o2.entry = r3;
            for (var s2 = 0, u2 = true; r3; )
              i2[s2] = r3, r3.isBuf || (u2 = false), r3 = r3.next, s2 += 1;
            i2.allBuffers = u2, g(t2, e2, true, e2.length, i2, "", o2.finish), e2.pendingcb++, e2.lastBufferedRequest = null, o2.next ? (e2.corkedRequestsFree = o2.next, o2.next = null) : e2.corkedRequestsFree = new a(e2), e2.bufferedRequestCount = 0;
          } else {
            for (; r3; ) {
              var c2 = r3.chunk, f2 = r3.encoding, l2 = r3.callback;
              if (g(t2, e2, false, e2.objectMode ? 1 : c2.length, c2, f2, l2), r3 = r3.next, e2.bufferedRequestCount--, e2.writing)
                break;
            }
            r3 === null && (e2.lastBufferedRequest = null);
          }
          e2.bufferedRequest = r3, e2.bufferProcessing = false;
        }
        function k(t2) {
          return t2.ending && t2.length === 0 && t2.bufferedRequest === null && !t2.finished && !t2.writing;
        }
        function x(t2, e2) {
          t2._final(function(r3) {
            e2.pendingcb--, r3 && t2.emit("error", r3), e2.prefinished = true, t2.emit("prefinish"), S(t2, e2);
          });
        }
        function S(t2, e2) {
          var r3 = k(e2);
          return r3 && (!function(t3, e3) {
            e3.prefinished || e3.finalCalled || (typeof t3._final == "function" ? (e3.pendingcb++, e3.finalCalled = true, o.nextTick(x, t3, e3)) : (e3.prefinished = true, t3.emit("prefinish")));
          }(t2, e2), e2.pendingcb === 0 && (e2.finished = true, t2.emit("finish"))), r3;
        }
        c.inherits(v, l), b.prototype.getBuffer = function() {
          for (var t2 = this.bufferedRequest, e2 = []; t2; )
            e2.push(t2), t2 = t2.next;
          return e2;
        }, function() {
          try {
            Object.defineProperty(b.prototype, "buffer", { get: f.deprecate(function() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
          } catch (t2) {
          }
        }(), typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (p = Function.prototype[Symbol.hasInstance], Object.defineProperty(v, Symbol.hasInstance, { value: function(t2) {
          return !!p.call(this, t2) || this === v && (t2 && t2._writableState instanceof b);
        } })) : p = function(t2) {
          return t2 instanceof this;
        }, v.prototype.pipe = function() {
          this.emit("error", new Error("Cannot pipe, not readable"));
        }, v.prototype.write = function(t2, e2, r3) {
          var n2, i2 = this._writableState, a2 = false, s2 = !i2.objectMode && (n2 = t2, h.isBuffer(n2) || n2 instanceof d);
          return s2 && !h.isBuffer(t2) && (t2 = function(t3) {
            return h.from(t3);
          }(t2)), typeof e2 == "function" && (r3 = e2, e2 = null), s2 ? e2 = "buffer" : e2 || (e2 = i2.defaultEncoding), typeof r3 != "function" && (r3 = y), i2.ended ? function(t3, e3) {
            var r4 = new Error("write after end");
            t3.emit("error", r4), o.nextTick(e3, r4);
          }(this, r3) : (s2 || function(t3, e3, r4, n3) {
            var i3 = true, a3 = false;
            return r4 === null ? a3 = new TypeError("May not write null values to stream") : typeof r4 == "string" || r4 === void 0 || e3.objectMode || (a3 = new TypeError("Invalid non-string/buffer chunk")), a3 && (t3.emit("error", a3), o.nextTick(n3, a3), i3 = false), i3;
          }(this, i2, t2, r3)) && (i2.pendingcb++, a2 = function(t3, e3, r4, n3, i3, o2) {
            if (!r4) {
              var a3 = function(t4, e4, r5) {
                t4.objectMode || t4.decodeStrings === false || typeof e4 != "string" || (e4 = h.from(e4, r5));
                return e4;
              }(e3, n3, i3);
              n3 !== a3 && (r4 = true, i3 = "buffer", n3 = a3);
            }
            var s3 = e3.objectMode ? 1 : n3.length;
            e3.length += s3;
            var u2 = e3.length < e3.highWaterMark;
            u2 || (e3.needDrain = true);
            if (e3.writing || e3.corked) {
              var c2 = e3.lastBufferedRequest;
              e3.lastBufferedRequest = { chunk: n3, encoding: i3, isBuf: r4, callback: o2, next: null }, c2 ? c2.next = e3.lastBufferedRequest : e3.bufferedRequest = e3.lastBufferedRequest, e3.bufferedRequestCount += 1;
            } else
              g(t3, e3, false, s3, n3, i3, o2);
            return u2;
          }(this, i2, s2, t2, e2, r3)), a2;
        }, v.prototype.cork = function() {
          this._writableState.corked++;
        }, v.prototype.uncork = function() {
          var t2 = this._writableState;
          t2.corked && (t2.corked--, t2.writing || t2.corked || t2.finished || t2.bufferProcessing || !t2.bufferedRequest || _(this, t2));
        }, v.prototype.setDefaultEncoding = function(t2) {
          if (typeof t2 == "string" && (t2 = t2.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((t2 + "").toLowerCase()) > -1))
            throw new TypeError("Unknown encoding: " + t2);
          return this._writableState.defaultEncoding = t2, this;
        }, Object.defineProperty(v.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
          return this._writableState.highWaterMark;
        } }), v.prototype._write = function(t2, e2, r3) {
          r3(new Error("_write() is not implemented"));
        }, v.prototype._writev = null, v.prototype.end = function(t2, e2, r3) {
          var n2 = this._writableState;
          typeof t2 == "function" ? (r3 = t2, t2 = null, e2 = null) : typeof e2 == "function" && (r3 = e2, e2 = null), t2 != null && this.write(t2, e2), n2.corked && (n2.corked = 1, this.uncork()), n2.ending || n2.finished || function(t3, e3, r4) {
            e3.ending = true, S(t3, e3), r4 && (e3.finished ? o.nextTick(r4) : t3.once("finish", r4));
            e3.ended = true, t3.writable = false;
          }(this, n2, r3);
        }, Object.defineProperty(v.prototype, "destroyed", { get: function() {
          return this._writableState !== void 0 && this._writableState.destroyed;
        }, set: function(t2) {
          this._writableState && (this._writableState.destroyed = t2);
        } }), v.prototype.destroy = m.destroy, v.prototype._undestroy = m.undestroy, v.prototype._destroy = function(t2, e2) {
          this.end(), e2(t2);
        };
      }).call(this, t("_process"), typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {}, t("timers").setImmediate);
    }, { "./_stream_duplex": 508, "./internal/streams/destroy": 514, "./internal/streams/stream": 515, _process: 467, "core-util-is": 328, inherits: 387, "process-nextick-args": 466, "safe-buffer": 494, timers: 521, "util-deprecate": 522 }], 513: [function(t, e, r) {
      var n = t("safe-buffer").Buffer, i = t("util");
      e.exports = function() {
        function t2() {
          !function(t3, e2) {
            if (!(t3 instanceof e2))
              throw new TypeError("Cannot call a class as a function");
          }(this, t2), this.head = null, this.tail = null, this.length = 0;
        }
        return t2.prototype.push = function(t3) {
          var e2 = { data: t3, next: null };
          this.length > 0 ? this.tail.next = e2 : this.head = e2, this.tail = e2, ++this.length;
        }, t2.prototype.unshift = function(t3) {
          var e2 = { data: t3, next: this.head };
          this.length === 0 && (this.tail = e2), this.head = e2, ++this.length;
        }, t2.prototype.shift = function() {
          if (this.length !== 0) {
            var t3 = this.head.data;
            return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, t3;
          }
        }, t2.prototype.clear = function() {
          this.head = this.tail = null, this.length = 0;
        }, t2.prototype.join = function(t3) {
          if (this.length === 0)
            return "";
          for (var e2 = this.head, r2 = "" + e2.data; e2 = e2.next; )
            r2 += t3 + e2.data;
          return r2;
        }, t2.prototype.concat = function(t3) {
          if (this.length === 0)
            return n.alloc(0);
          if (this.length === 1)
            return this.head.data;
          for (var e2, r2, i2, o = n.allocUnsafe(t3 >>> 0), a = this.head, s = 0; a; )
            e2 = a.data, r2 = o, i2 = s, e2.copy(r2, i2), s += a.data.length, a = a.next;
          return o;
        }, t2;
      }(), i && i.inspect && i.inspect.custom && (e.exports.prototype[i.inspect.custom] = function() {
        var t2 = i.inspect({ length: this.length });
        return this.constructor.name + " " + t2;
      });
    }, { "safe-buffer": 494, util: 185 }], 514: [function(t, e, r) {
      var n = t("process-nextick-args");
      function i(t2, e2) {
        t2.emit("error", e2);
      }
      e.exports = { destroy: function(t2, e2) {
        var r2 = this, o = this._readableState && this._readableState.destroyed, a = this._writableState && this._writableState.destroyed;
        return o || a ? (e2 ? e2(t2) : !t2 || this._writableState && this._writableState.errorEmitted || n.nextTick(i, this, t2), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t2 || null, function(t3) {
          !e2 && t3 ? (n.nextTick(i, r2, t3), r2._writableState && (r2._writableState.errorEmitted = true)) : e2 && e2(t3);
        }), this);
      }, undestroy: function() {
        this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
      } };
    }, { "process-nextick-args": 466 }], 515: [function(t, e, r) {
      arguments[4][490][0].apply(r, arguments);
    }, { dup: 490, events: 367 }], 516: [function(t, e, r) {
      e.exports = t("./readable").PassThrough;
    }, { "./readable": 517 }], 517: [function(t, e, r) {
      (r = e.exports = t("./lib/_stream_readable.js")).Stream = r, r.Readable = r, r.Writable = t("./lib/_stream_writable.js"), r.Duplex = t("./lib/_stream_duplex.js"), r.Transform = t("./lib/_stream_transform.js"), r.PassThrough = t("./lib/_stream_passthrough.js");
    }, { "./lib/_stream_duplex.js": 508, "./lib/_stream_passthrough.js": 509, "./lib/_stream_readable.js": 510, "./lib/_stream_transform.js": 511, "./lib/_stream_writable.js": 512 }], 518: [function(t, e, r) {
      e.exports = t("./readable").Transform;
    }, { "./readable": 517 }], 519: [function(t, e, r) {
      e.exports = t("./lib/_stream_writable.js");
    }, { "./lib/_stream_writable.js": 512 }], 520: [function(t, e, r) {
      var n = t("safe-buffer").Buffer, i = n.isEncoding || function(t2) {
        switch ((t2 = "" + t2) && t2.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true;
          default:
            return false;
        }
      };
      function o(t2) {
        var e2;
        switch (this.encoding = function(t3) {
          var e3 = function(t4) {
            if (!t4)
              return "utf8";
            for (var e4; ; )
              switch (t4) {
                case "utf8":
                case "utf-8":
                  return "utf8";
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return "utf16le";
                case "latin1":
                case "binary":
                  return "latin1";
                case "base64":
                case "ascii":
                case "hex":
                  return t4;
                default:
                  if (e4)
                    return;
                  t4 = ("" + t4).toLowerCase(), e4 = true;
              }
          }(t3);
          if (typeof e3 != "string" && (n.isEncoding === i || !i(t3)))
            throw new Error("Unknown encoding: " + t3);
          return e3 || t3;
        }(t2), this.encoding) {
          case "utf16le":
            this.text = u, this.end = c, e2 = 4;
            break;
          case "utf8":
            this.fillLast = s, e2 = 4;
            break;
          case "base64":
            this.text = f, this.end = l, e2 = 3;
            break;
          default:
            return this.write = h, void (this.end = d);
        }
        this.lastNeed = 0, this.lastTotal = 0, this.lastChar = n.allocUnsafe(e2);
      }
      function a(t2) {
        return t2 <= 127 ? 0 : t2 >> 5 == 6 ? 2 : t2 >> 4 == 14 ? 3 : t2 >> 3 == 30 ? 4 : t2 >> 6 == 2 ? -1 : -2;
      }
      function s(t2) {
        var e2 = this.lastTotal - this.lastNeed, r2 = function(t3, e3, r3) {
          if ((192 & e3[0]) != 128)
            return t3.lastNeed = 0, "\uFFFD";
          if (t3.lastNeed > 1 && e3.length > 1) {
            if ((192 & e3[1]) != 128)
              return t3.lastNeed = 1, "\uFFFD";
            if (t3.lastNeed > 2 && e3.length > 2 && (192 & e3[2]) != 128)
              return t3.lastNeed = 2, "\uFFFD";
          }
        }(this, t2);
        return r2 !== void 0 ? r2 : this.lastNeed <= t2.length ? (t2.copy(this.lastChar, e2, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (t2.copy(this.lastChar, e2, 0, t2.length), void (this.lastNeed -= t2.length));
      }
      function u(t2, e2) {
        if ((t2.length - e2) % 2 == 0) {
          var r2 = t2.toString("utf16le", e2);
          if (r2) {
            var n2 = r2.charCodeAt(r2.length - 1);
            if (n2 >= 55296 && n2 <= 56319)
              return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t2[t2.length - 2], this.lastChar[1] = t2[t2.length - 1], r2.slice(0, -1);
          }
          return r2;
        }
        return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t2[t2.length - 1], t2.toString("utf16le", e2, t2.length - 1);
      }
      function c(t2) {
        var e2 = t2 && t2.length ? this.write(t2) : "";
        if (this.lastNeed) {
          var r2 = this.lastTotal - this.lastNeed;
          return e2 + this.lastChar.toString("utf16le", 0, r2);
        }
        return e2;
      }
      function f(t2, e2) {
        var r2 = (t2.length - e2) % 3;
        return r2 === 0 ? t2.toString("base64", e2) : (this.lastNeed = 3 - r2, this.lastTotal = 3, r2 === 1 ? this.lastChar[0] = t2[t2.length - 1] : (this.lastChar[0] = t2[t2.length - 2], this.lastChar[1] = t2[t2.length - 1]), t2.toString("base64", e2, t2.length - r2));
      }
      function l(t2) {
        var e2 = t2 && t2.length ? this.write(t2) : "";
        return this.lastNeed ? e2 + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e2;
      }
      function h(t2) {
        return t2.toString(this.encoding);
      }
      function d(t2) {
        return t2 && t2.length ? this.write(t2) : "";
      }
      r.StringDecoder = o, o.prototype.write = function(t2) {
        if (t2.length === 0)
          return "";
        var e2, r2;
        if (this.lastNeed) {
          if ((e2 = this.fillLast(t2)) === void 0)
            return "";
          r2 = this.lastNeed, this.lastNeed = 0;
        } else
          r2 = 0;
        return r2 < t2.length ? e2 ? e2 + this.text(t2, r2) : this.text(t2, r2) : e2 || "";
      }, o.prototype.end = function(t2) {
        var e2 = t2 && t2.length ? this.write(t2) : "";
        return this.lastNeed ? e2 + "\uFFFD" : e2;
      }, o.prototype.text = function(t2, e2) {
        var r2 = function(t3, e3, r3) {
          var n3 = e3.length - 1;
          if (n3 < r3)
            return 0;
          var i2 = a(e3[n3]);
          if (i2 >= 0)
            return i2 > 0 && (t3.lastNeed = i2 - 1), i2;
          if (--n3 < r3 || i2 === -2)
            return 0;
          if ((i2 = a(e3[n3])) >= 0)
            return i2 > 0 && (t3.lastNeed = i2 - 2), i2;
          if (--n3 < r3 || i2 === -2)
            return 0;
          if ((i2 = a(e3[n3])) >= 0)
            return i2 > 0 && (i2 === 2 ? i2 = 0 : t3.lastNeed = i2 - 3), i2;
          return 0;
        }(this, t2, e2);
        if (!this.lastNeed)
          return t2.toString("utf8", e2);
        this.lastTotal = r2;
        var n2 = t2.length - (r2 - this.lastNeed);
        return t2.copy(this.lastChar, 0, n2), t2.toString("utf8", e2, n2);
      }, o.prototype.fillLast = function(t2) {
        if (this.lastNeed <= t2.length)
          return t2.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        t2.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t2.length), this.lastNeed -= t2.length;
      };
    }, { "safe-buffer": 494 }], 521: [function(t, e, r) {
      (function(e2, n) {
        var i = t("process/browser.js").nextTick, o = Function.prototype.apply, a = Array.prototype.slice, s = {}, u = 0;
        function c(t2, e3) {
          this._id = t2, this._clearFn = e3;
        }
        r.setTimeout = function() {
          return new c(o.call(setTimeout, window, arguments), clearTimeout);
        }, r.setInterval = function() {
          return new c(o.call(setInterval, window, arguments), clearInterval);
        }, r.clearTimeout = r.clearInterval = function(t2) {
          t2.close();
        }, c.prototype.unref = c.prototype.ref = function() {
        }, c.prototype.close = function() {
          this._clearFn.call(window, this._id);
        }, r.enroll = function(t2, e3) {
          clearTimeout(t2._idleTimeoutId), t2._idleTimeout = e3;
        }, r.unenroll = function(t2) {
          clearTimeout(t2._idleTimeoutId), t2._idleTimeout = -1;
        }, r._unrefActive = r.active = function(t2) {
          clearTimeout(t2._idleTimeoutId);
          var e3 = t2._idleTimeout;
          e3 >= 0 && (t2._idleTimeoutId = setTimeout(function() {
            t2._onTimeout && t2._onTimeout();
          }, e3));
        }, r.setImmediate = typeof e2 == "function" ? e2 : function(t2) {
          var e3 = u++, n2 = !(arguments.length < 2) && a.call(arguments, 1);
          return s[e3] = true, i(function() {
            s[e3] && (n2 ? t2.apply(null, n2) : t2.call(null), r.clearImmediate(e3));
          }), e3;
        }, r.clearImmediate = typeof n == "function" ? n : function(t2) {
          delete s[t2];
        };
      }).call(this, t("timers").setImmediate, t("timers").clearImmediate);
    }, { "process/browser.js": 467, timers: 521 }], 522: [function(t, e, r) {
      (function(t2) {
        function r2(e2) {
          try {
            if (!t2.localStorage)
              return false;
          } catch (t3) {
            return false;
          }
          var r3 = t2.localStorage[e2];
          return r3 != null && String(r3).toLowerCase() === "true";
        }
        e.exports = function(t3, e2) {
          if (r2("noDeprecation"))
            return t3;
          var n = false;
          return function() {
            if (!n) {
              if (r2("throwDeprecation"))
                throw new Error(e2);
              r2("traceDeprecation") ? console.trace(e2) : console.warn(e2), n = true;
            }
            return t3.apply(this, arguments);
          };
        };
      }).call(this, typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, {}], 523: [function(t, e, r) {
      typeof Object.create == "function" ? e.exports = function(t2, e2) {
        t2.super_ = e2, t2.prototype = Object.create(e2.prototype, { constructor: { value: t2, enumerable: false, writable: true, configurable: true } });
      } : e.exports = function(t2, e2) {
        t2.super_ = e2;
        var r2 = function() {
        };
        r2.prototype = e2.prototype, t2.prototype = new r2(), t2.prototype.constructor = t2;
      };
    }, {}], 524: [function(t, e, r) {
      function n(t2) {
        return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      e.exports = function(t2) {
        return t2 && n(t2) === "object" && typeof t2.copy == "function" && typeof t2.fill == "function" && typeof t2.readUInt8 == "function";
      };
    }, {}], 525: [function(t, e, r) {
      (function(e2, n) {
        function i(t2) {
          return (i = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
            return typeof t3;
          } : function(t3) {
            return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
          })(t2);
        }
        var o = /%[sdj%]/g;
        r.format = function(t2) {
          if (!v(t2)) {
            for (var e3 = [], r2 = 0; r2 < arguments.length; r2++)
              e3.push(u(arguments[r2]));
            return e3.join(" ");
          }
          r2 = 1;
          for (var n2 = arguments, i2 = n2.length, a2 = String(t2).replace(o, function(t3) {
            if (t3 === "%%")
              return "%";
            if (r2 >= i2)
              return t3;
            switch (t3) {
              case "%s":
                return String(n2[r2++]);
              case "%d":
                return Number(n2[r2++]);
              case "%j":
                try {
                  return JSON.stringify(n2[r2++]);
                } catch (t4) {
                  return "[Circular]";
                }
              default:
                return t3;
            }
          }), s2 = n2[r2]; r2 < i2; s2 = n2[++r2])
            y(s2) || !_(s2) ? a2 += " " + s2 : a2 += " " + u(s2);
          return a2;
        }, r.deprecate = function(t2, i2) {
          if (g(n.process))
            return function() {
              return r.deprecate(t2, i2).apply(this, arguments);
            };
          if (e2.noDeprecation === true)
            return t2;
          var o2 = false;
          return function() {
            if (!o2) {
              if (e2.throwDeprecation)
                throw new Error(i2);
              e2.traceDeprecation ? console.trace(i2) : console.error(i2), o2 = true;
            }
            return t2.apply(this, arguments);
          };
        };
        var a, s = {};
        function u(t2, e3) {
          var n2 = { seen: [], stylize: f };
          return arguments.length >= 3 && (n2.depth = arguments[2]), arguments.length >= 4 && (n2.colors = arguments[3]), m(e3) ? n2.showHidden = e3 : e3 && r._extend(n2, e3), g(n2.showHidden) && (n2.showHidden = false), g(n2.depth) && (n2.depth = 2), g(n2.colors) && (n2.colors = false), g(n2.customInspect) && (n2.customInspect = true), n2.colors && (n2.stylize = c), l(n2, t2, n2.depth);
        }
        function c(t2, e3) {
          var r2 = u.styles[e3];
          return r2 ? "[" + u.colors[r2][0] + "m" + t2 + "[" + u.colors[r2][1] + "m" : t2;
        }
        function f(t2, e3) {
          return t2;
        }
        function l(t2, e3, n2) {
          if (t2.customInspect && e3 && S(e3.inspect) && e3.inspect !== r.inspect && (!e3.constructor || e3.constructor.prototype !== e3)) {
            var i2 = e3.inspect(n2, t2);
            return v(i2) || (i2 = l(t2, i2, n2)), i2;
          }
          var o2 = function(t3, e4) {
            if (g(e4))
              return t3.stylize("undefined", "undefined");
            if (v(e4)) {
              var r2 = "'" + JSON.stringify(e4).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
              return t3.stylize(r2, "string");
            }
            if (b(e4))
              return t3.stylize("" + e4, "number");
            if (m(e4))
              return t3.stylize("" + e4, "boolean");
            if (y(e4))
              return t3.stylize("null", "null");
          }(t2, e3);
          if (o2)
            return o2;
          var a2 = Object.keys(e3), s2 = function(t3) {
            var e4 = {};
            return t3.forEach(function(t4, r2) {
              e4[t4] = true;
            }), e4;
          }(a2);
          if (t2.showHidden && (a2 = Object.getOwnPropertyNames(e3)), x(e3) && (a2.indexOf("message") >= 0 || a2.indexOf("description") >= 0))
            return h(e3);
          if (a2.length === 0) {
            if (S(e3)) {
              var u2 = e3.name ? ": " + e3.name : "";
              return t2.stylize("[Function" + u2 + "]", "special");
            }
            if (w(e3))
              return t2.stylize(RegExp.prototype.toString.call(e3), "regexp");
            if (k(e3))
              return t2.stylize(Date.prototype.toString.call(e3), "date");
            if (x(e3))
              return h(e3);
          }
          var c2, f2 = "", _2 = false, O2 = ["{", "}"];
          (p(e3) && (_2 = true, O2 = ["[", "]"]), S(e3)) && (f2 = " [Function" + (e3.name ? ": " + e3.name : "") + "]");
          return w(e3) && (f2 = " " + RegExp.prototype.toString.call(e3)), k(e3) && (f2 = " " + Date.prototype.toUTCString.call(e3)), x(e3) && (f2 = " " + h(e3)), a2.length !== 0 || _2 && e3.length != 0 ? n2 < 0 ? w(e3) ? t2.stylize(RegExp.prototype.toString.call(e3), "regexp") : t2.stylize("[Object]", "special") : (t2.seen.push(e3), c2 = _2 ? function(t3, e4, r2, n3, i3) {
            for (var o3 = [], a3 = 0, s3 = e4.length; a3 < s3; ++a3)
              T(e4, String(a3)) ? o3.push(d(t3, e4, r2, n3, String(a3), true)) : o3.push("");
            return i3.forEach(function(i4) {
              i4.match(/^\d+$/) || o3.push(d(t3, e4, r2, n3, i4, true));
            }), o3;
          }(t2, e3, n2, s2, a2) : a2.map(function(r2) {
            return d(t2, e3, n2, s2, r2, _2);
          }), t2.seen.pop(), function(t3, e4, r2) {
            if (t3.reduce(function(t4, e5) {
              return e5.indexOf("\n") >= 0 && 0, t4 + e5.replace(/\u001b\[\d\d?m/g, "").length + 1;
            }, 0) > 60)
              return r2[0] + (e4 === "" ? "" : e4 + "\n ") + " " + t3.join(",\n  ") + " " + r2[1];
            return r2[0] + e4 + " " + t3.join(", ") + " " + r2[1];
          }(c2, f2, O2)) : O2[0] + f2 + O2[1];
        }
        function h(t2) {
          return "[" + Error.prototype.toString.call(t2) + "]";
        }
        function d(t2, e3, r2, n2, i2, o2) {
          var a2, s2, u2;
          if ((u2 = Object.getOwnPropertyDescriptor(e3, i2) || { value: e3[i2] }).get ? s2 = u2.set ? t2.stylize("[Getter/Setter]", "special") : t2.stylize("[Getter]", "special") : u2.set && (s2 = t2.stylize("[Setter]", "special")), T(n2, i2) || (a2 = "[" + i2 + "]"), s2 || (t2.seen.indexOf(u2.value) < 0 ? (s2 = y(r2) ? l(t2, u2.value, null) : l(t2, u2.value, r2 - 1)).indexOf("\n") > -1 && (s2 = o2 ? s2.split("\n").map(function(t3) {
            return "  " + t3;
          }).join("\n").substr(2) : "\n" + s2.split("\n").map(function(t3) {
            return "   " + t3;
          }).join("\n")) : s2 = t2.stylize("[Circular]", "special")), g(a2)) {
            if (o2 && i2.match(/^\d+$/))
              return s2;
            (a2 = JSON.stringify("" + i2)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (a2 = a2.substr(1, a2.length - 2), a2 = t2.stylize(a2, "name")) : (a2 = a2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), a2 = t2.stylize(a2, "string"));
          }
          return a2 + ": " + s2;
        }
        function p(t2) {
          return Array.isArray(t2);
        }
        function m(t2) {
          return typeof t2 == "boolean";
        }
        function y(t2) {
          return t2 === null;
        }
        function b(t2) {
          return typeof t2 == "number";
        }
        function v(t2) {
          return typeof t2 == "string";
        }
        function g(t2) {
          return t2 === void 0;
        }
        function w(t2) {
          return _(t2) && O(t2) === "[object RegExp]";
        }
        function _(t2) {
          return i(t2) === "object" && t2 !== null;
        }
        function k(t2) {
          return _(t2) && O(t2) === "[object Date]";
        }
        function x(t2) {
          return _(t2) && (O(t2) === "[object Error]" || t2 instanceof Error);
        }
        function S(t2) {
          return typeof t2 == "function";
        }
        function O(t2) {
          return Object.prototype.toString.call(t2);
        }
        function j(t2) {
          return t2 < 10 ? "0" + t2.toString(10) : t2.toString(10);
        }
        r.debuglog = function(t2) {
          if (g(a) && (a = e2.env.NODE_DEBUG || ""), t2 = t2.toUpperCase(), !s[t2])
            if (new RegExp("\\b" + t2 + "\\b", "i").test(a)) {
              var n2 = e2.pid;
              s[t2] = function() {
                var e3 = r.format.apply(r, arguments);
                console.error("%s %d: %s", t2, n2, e3);
              };
            } else
              s[t2] = function() {
              };
          return s[t2];
        }, r.inspect = u, u.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, u.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, r.isArray = p, r.isBoolean = m, r.isNull = y, r.isNullOrUndefined = function(t2) {
          return t2 == null;
        }, r.isNumber = b, r.isString = v, r.isSymbol = function(t2) {
          return i(t2) === "symbol";
        }, r.isUndefined = g, r.isRegExp = w, r.isObject = _, r.isDate = k, r.isError = x, r.isFunction = S, r.isPrimitive = function(t2) {
          return t2 === null || typeof t2 == "boolean" || typeof t2 == "number" || typeof t2 == "string" || i(t2) === "symbol" || t2 === void 0;
        }, r.isBuffer = t("./support/isBuffer");
        var E = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        function R() {
          var t2 = new Date(), e3 = [j(t2.getHours()), j(t2.getMinutes()), j(t2.getSeconds())].join(":");
          return [t2.getDate(), E[t2.getMonth()], e3].join(" ");
        }
        function T(t2, e3) {
          return Object.prototype.hasOwnProperty.call(t2, e3);
        }
        r.log = function() {
          console.log("%s - %s", R(), r.format.apply(r, arguments));
        }, r.inherits = t("inherits"), r._extend = function(t2, e3) {
          if (!e3 || !_(e3))
            return t2;
          for (var r2 = Object.keys(e3), n2 = r2.length; n2--; )
            t2[r2[n2]] = e3[r2[n2]];
          return t2;
        };
      }).call(this, t("_process"), typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, { "./support/isBuffer": 524, _process: 467, inherits: 523 }], 526: [function(t, e, r) {
      Object.defineProperty(r, "__esModule", { value: true }), Object.defineProperty(r, "v1", { enumerable: true, get: function() {
        return n.default;
      } }), Object.defineProperty(r, "v3", { enumerable: true, get: function() {
        return i.default;
      } }), Object.defineProperty(r, "v4", { enumerable: true, get: function() {
        return o.default;
      } }), Object.defineProperty(r, "v5", { enumerable: true, get: function() {
        return a.default;
      } }), Object.defineProperty(r, "NIL", { enumerable: true, get: function() {
        return s.default;
      } }), Object.defineProperty(r, "version", { enumerable: true, get: function() {
        return u.default;
      } }), Object.defineProperty(r, "validate", { enumerable: true, get: function() {
        return c.default;
      } }), Object.defineProperty(r, "stringify", { enumerable: true, get: function() {
        return f.default;
      } }), Object.defineProperty(r, "parse", { enumerable: true, get: function() {
        return l.default;
      } });
      var n = h(t("./v1.js")), i = h(t("./v3.js")), o = h(t("./v4.js")), a = h(t("./v5.js")), s = h(t("./nil.js")), u = h(t("./version.js")), c = h(t("./validate.js")), f = h(t("./stringify.js")), l = h(t("./parse.js"));
      function h(t2) {
        return t2 && t2.__esModule ? t2 : { default: t2 };
      }
    }, { "./nil.js": 528, "./parse.js": 529, "./stringify.js": 533, "./v1.js": 534, "./v3.js": 535, "./v4.js": 537, "./v5.js": 538, "./validate.js": 539, "./version.js": 540 }], 527: [function(t, e, r) {
      function n(t2) {
        return 14 + (t2 + 64 >>> 9 << 4) + 1;
      }
      function i(t2, e2) {
        var r2 = (65535 & t2) + (65535 & e2);
        return (t2 >> 16) + (e2 >> 16) + (r2 >> 16) << 16 | 65535 & r2;
      }
      function o(t2, e2, r2, n2, o2, a2) {
        return i((s2 = i(i(e2, t2), i(n2, a2))) << (u2 = o2) | s2 >>> 32 - u2, r2);
        var s2, u2;
      }
      function a(t2, e2, r2, n2, i2, a2, s2) {
        return o(e2 & r2 | ~e2 & n2, t2, e2, i2, a2, s2);
      }
      function s(t2, e2, r2, n2, i2, a2, s2) {
        return o(e2 & n2 | r2 & ~n2, t2, e2, i2, a2, s2);
      }
      function u(t2, e2, r2, n2, i2, a2, s2) {
        return o(e2 ^ r2 ^ n2, t2, e2, i2, a2, s2);
      }
      function c(t2, e2, r2, n2, i2, a2, s2) {
        return o(r2 ^ (e2 | ~n2), t2, e2, i2, a2, s2);
      }
      Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
      var f = function(t2) {
        if (typeof t2 == "string") {
          var e2 = unescape(encodeURIComponent(t2));
          t2 = new Uint8Array(e2.length);
          for (var r2 = 0; r2 < e2.length; ++r2)
            t2[r2] = e2.charCodeAt(r2);
        }
        return function(t3) {
          for (var e3 = [], r3 = 32 * t3.length, n2 = 0; n2 < r3; n2 += 8) {
            var i2 = t3[n2 >> 5] >>> n2 % 32 & 255, o2 = parseInt("0123456789abcdef".charAt(i2 >>> 4 & 15) + "0123456789abcdef".charAt(15 & i2), 16);
            e3.push(o2);
          }
          return e3;
        }(function(t3, e3) {
          t3[e3 >> 5] |= 128 << e3 % 32, t3[n(e3) - 1] = e3;
          for (var r3 = 1732584193, o2 = -271733879, f2 = -1732584194, l = 271733878, h = 0; h < t3.length; h += 16) {
            var d = r3, p = o2, m = f2, y = l;
            r3 = a(r3, o2, f2, l, t3[h], 7, -680876936), l = a(l, r3, o2, f2, t3[h + 1], 12, -389564586), f2 = a(f2, l, r3, o2, t3[h + 2], 17, 606105819), o2 = a(o2, f2, l, r3, t3[h + 3], 22, -1044525330), r3 = a(r3, o2, f2, l, t3[h + 4], 7, -176418897), l = a(l, r3, o2, f2, t3[h + 5], 12, 1200080426), f2 = a(f2, l, r3, o2, t3[h + 6], 17, -1473231341), o2 = a(o2, f2, l, r3, t3[h + 7], 22, -45705983), r3 = a(r3, o2, f2, l, t3[h + 8], 7, 1770035416), l = a(l, r3, o2, f2, t3[h + 9], 12, -1958414417), f2 = a(f2, l, r3, o2, t3[h + 10], 17, -42063), o2 = a(o2, f2, l, r3, t3[h + 11], 22, -1990404162), r3 = a(r3, o2, f2, l, t3[h + 12], 7, 1804603682), l = a(l, r3, o2, f2, t3[h + 13], 12, -40341101), f2 = a(f2, l, r3, o2, t3[h + 14], 17, -1502002290), o2 = a(o2, f2, l, r3, t3[h + 15], 22, 1236535329), r3 = s(r3, o2, f2, l, t3[h + 1], 5, -165796510), l = s(l, r3, o2, f2, t3[h + 6], 9, -1069501632), f2 = s(f2, l, r3, o2, t3[h + 11], 14, 643717713), o2 = s(o2, f2, l, r3, t3[h], 20, -373897302), r3 = s(r3, o2, f2, l, t3[h + 5], 5, -701558691), l = s(l, r3, o2, f2, t3[h + 10], 9, 38016083), f2 = s(f2, l, r3, o2, t3[h + 15], 14, -660478335), o2 = s(o2, f2, l, r3, t3[h + 4], 20, -405537848), r3 = s(r3, o2, f2, l, t3[h + 9], 5, 568446438), l = s(l, r3, o2, f2, t3[h + 14], 9, -1019803690), f2 = s(f2, l, r3, o2, t3[h + 3], 14, -187363961), o2 = s(o2, f2, l, r3, t3[h + 8], 20, 1163531501), r3 = s(r3, o2, f2, l, t3[h + 13], 5, -1444681467), l = s(l, r3, o2, f2, t3[h + 2], 9, -51403784), f2 = s(f2, l, r3, o2, t3[h + 7], 14, 1735328473), o2 = s(o2, f2, l, r3, t3[h + 12], 20, -1926607734), r3 = u(r3, o2, f2, l, t3[h + 5], 4, -378558), l = u(l, r3, o2, f2, t3[h + 8], 11, -2022574463), f2 = u(f2, l, r3, o2, t3[h + 11], 16, 1839030562), o2 = u(o2, f2, l, r3, t3[h + 14], 23, -35309556), r3 = u(r3, o2, f2, l, t3[h + 1], 4, -1530992060), l = u(l, r3, o2, f2, t3[h + 4], 11, 1272893353), f2 = u(f2, l, r3, o2, t3[h + 7], 16, -155497632), o2 = u(o2, f2, l, r3, t3[h + 10], 23, -1094730640), r3 = u(r3, o2, f2, l, t3[h + 13], 4, 681279174), l = u(l, r3, o2, f2, t3[h], 11, -358537222), f2 = u(f2, l, r3, o2, t3[h + 3], 16, -722521979), o2 = u(o2, f2, l, r3, t3[h + 6], 23, 76029189), r3 = u(r3, o2, f2, l, t3[h + 9], 4, -640364487), l = u(l, r3, o2, f2, t3[h + 12], 11, -421815835), f2 = u(f2, l, r3, o2, t3[h + 15], 16, 530742520), o2 = u(o2, f2, l, r3, t3[h + 2], 23, -995338651), r3 = c(r3, o2, f2, l, t3[h], 6, -198630844), l = c(l, r3, o2, f2, t3[h + 7], 10, 1126891415), f2 = c(f2, l, r3, o2, t3[h + 14], 15, -1416354905), o2 = c(o2, f2, l, r3, t3[h + 5], 21, -57434055), r3 = c(r3, o2, f2, l, t3[h + 12], 6, 1700485571), l = c(l, r3, o2, f2, t3[h + 3], 10, -1894986606), f2 = c(f2, l, r3, o2, t3[h + 10], 15, -1051523), o2 = c(o2, f2, l, r3, t3[h + 1], 21, -2054922799), r3 = c(r3, o2, f2, l, t3[h + 8], 6, 1873313359), l = c(l, r3, o2, f2, t3[h + 15], 10, -30611744), f2 = c(f2, l, r3, o2, t3[h + 6], 15, -1560198380), o2 = c(o2, f2, l, r3, t3[h + 13], 21, 1309151649), r3 = c(r3, o2, f2, l, t3[h + 4], 6, -145523070), l = c(l, r3, o2, f2, t3[h + 11], 10, -1120210379), f2 = c(f2, l, r3, o2, t3[h + 2], 15, 718787259), o2 = c(o2, f2, l, r3, t3[h + 9], 21, -343485551), r3 = i(r3, d), o2 = i(o2, p), f2 = i(f2, m), l = i(l, y);
          }
          return [r3, o2, f2, l];
        }(function(t3) {
          if (t3.length === 0)
            return [];
          for (var e3 = 8 * t3.length, r3 = new Uint32Array(n(e3)), i2 = 0; i2 < e3; i2 += 8)
            r3[i2 >> 5] |= (255 & t3[i2 / 8]) << i2 % 32;
          return r3;
        }(t2), 8 * t2.length));
      };
      r.default = f;
    }, {}], 528: [function(t, e, r) {
      Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
      r.default = "00000000-0000-0000-0000-000000000000";
    }, {}], 529: [function(t, e, r) {
      Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
      var n, i = (n = t("./validate.js")) && n.__esModule ? n : { default: n };
      var o = function(t2) {
        if (!(0, i.default)(t2))
          throw TypeError("Invalid UUID");
        var e2, r2 = new Uint8Array(16);
        return r2[0] = (e2 = parseInt(t2.slice(0, 8), 16)) >>> 24, r2[1] = e2 >>> 16 & 255, r2[2] = e2 >>> 8 & 255, r2[3] = 255 & e2, r2[4] = (e2 = parseInt(t2.slice(9, 13), 16)) >>> 8, r2[5] = 255 & e2, r2[6] = (e2 = parseInt(t2.slice(14, 18), 16)) >>> 8, r2[7] = 255 & e2, r2[8] = (e2 = parseInt(t2.slice(19, 23), 16)) >>> 8, r2[9] = 255 & e2, r2[10] = (e2 = parseInt(t2.slice(24, 36), 16)) / 1099511627776 & 255, r2[11] = e2 / 4294967296 & 255, r2[12] = e2 >>> 24 & 255, r2[13] = e2 >>> 16 & 255, r2[14] = e2 >>> 8 & 255, r2[15] = 255 & e2, r2;
      };
      r.default = o;
    }, { "./validate.js": 539 }], 530: [function(t, e, r) {
      Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
      r.default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    }, {}], 531: [function(t, e, r) {
      Object.defineProperty(r, "__esModule", { value: true }), r.default = function() {
        if (!n)
          throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        return n(i);
      };
      var n = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != "undefined" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), i = new Uint8Array(16);
    }, {}], 532: [function(t, e, r) {
      function n(t2, e2, r2, n2) {
        switch (t2) {
          case 0:
            return e2 & r2 ^ ~e2 & n2;
          case 1:
            return e2 ^ r2 ^ n2;
          case 2:
            return e2 & r2 ^ e2 & n2 ^ r2 & n2;
          case 3:
            return e2 ^ r2 ^ n2;
        }
      }
      function i(t2, e2) {
        return t2 << e2 | t2 >>> 32 - e2;
      }
      Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
      var o = function(t2) {
        var e2 = [1518500249, 1859775393, 2400959708, 3395469782], r2 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
        if (typeof t2 == "string") {
          var o2 = unescape(encodeURIComponent(t2));
          t2 = [];
          for (var a = 0; a < o2.length; ++a)
            t2.push(o2.charCodeAt(a));
        } else
          Array.isArray(t2) || (t2 = Array.prototype.slice.call(t2));
        t2.push(128);
        for (var s = t2.length / 4 + 2, u = Math.ceil(s / 16), c = new Array(u), f = 0; f < u; ++f) {
          for (var l = new Uint32Array(16), h = 0; h < 16; ++h)
            l[h] = t2[64 * f + 4 * h] << 24 | t2[64 * f + 4 * h + 1] << 16 | t2[64 * f + 4 * h + 2] << 8 | t2[64 * f + 4 * h + 3];
          c[f] = l;
        }
        c[u - 1][14] = 8 * (t2.length - 1) / Math.pow(2, 32), c[u - 1][14] = Math.floor(c[u - 1][14]), c[u - 1][15] = 8 * (t2.length - 1) & 4294967295;
        for (var d = 0; d < u; ++d) {
          for (var p = new Uint32Array(80), m = 0; m < 16; ++m)
            p[m] = c[d][m];
          for (var y = 16; y < 80; ++y)
            p[y] = i(p[y - 3] ^ p[y - 8] ^ p[y - 14] ^ p[y - 16], 1);
          for (var b = r2[0], v = r2[1], g = r2[2], w = r2[3], _ = r2[4], k = 0; k < 80; ++k) {
            var x = Math.floor(k / 20), S = i(b, 5) + n(x, v, g, w) + _ + e2[x] + p[k] >>> 0;
            _ = w, w = g, g = i(v, 30) >>> 0, v = b, b = S;
          }
          r2[0] = r2[0] + b >>> 0, r2[1] = r2[1] + v >>> 0, r2[2] = r2[2] + g >>> 0, r2[3] = r2[3] + w >>> 0, r2[4] = r2[4] + _ >>> 0;
        }
        return [r2[0] >> 24 & 255, r2[0] >> 16 & 255, r2[0] >> 8 & 255, 255 & r2[0], r2[1] >> 24 & 255, r2[1] >> 16 & 255, r2[1] >> 8 & 255, 255 & r2[1], r2[2] >> 24 & 255, r2[2] >> 16 & 255, r2[2] >> 8 & 255, 255 & r2[2], r2[3] >> 24 & 255, r2[3] >> 16 & 255, r2[3] >> 8 & 255, 255 & r2[3], r2[4] >> 24 & 255, r2[4] >> 16 & 255, r2[4] >> 8 & 255, 255 & r2[4]];
      };
      r.default = o;
    }, {}], 533: [function(t, e, r) {
      Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
      var n, i = (n = t("./validate.js")) && n.__esModule ? n : { default: n };
      for (var o = [], a = 0; a < 256; ++a)
        o.push((a + 256).toString(16).substr(1));
      var s = function(t2) {
        var e2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, r2 = (o[t2[e2 + 0]] + o[t2[e2 + 1]] + o[t2[e2 + 2]] + o[t2[e2 + 3]] + "-" + o[t2[e2 + 4]] + o[t2[e2 + 5]] + "-" + o[t2[e2 + 6]] + o[t2[e2 + 7]] + "-" + o[t2[e2 + 8]] + o[t2[e2 + 9]] + "-" + o[t2[e2 + 10]] + o[t2[e2 + 11]] + o[t2[e2 + 12]] + o[t2[e2 + 13]] + o[t2[e2 + 14]] + o[t2[e2 + 15]]).toLowerCase();
        if (!(0, i.default)(r2))
          throw TypeError("Stringified UUID is invalid");
        return r2;
      };
      r.default = s;
    }, { "./validate.js": 539 }], 534: [function(t, e, r) {
      Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
      var n, i, o = s(t("./rng.js")), a = s(t("./stringify.js"));
      function s(t2) {
        return t2 && t2.__esModule ? t2 : { default: t2 };
      }
      var u = 0, c = 0;
      var f = function(t2, e2, r2) {
        var s2 = e2 && r2 || 0, f2 = e2 || new Array(16), l = (t2 = t2 || {}).node || n, h = t2.clockseq !== void 0 ? t2.clockseq : i;
        if (l == null || h == null) {
          var d = t2.random || (t2.rng || o.default)();
          l == null && (l = n = [1 | d[0], d[1], d[2], d[3], d[4], d[5]]), h == null && (h = i = 16383 & (d[6] << 8 | d[7]));
        }
        var p = t2.msecs !== void 0 ? t2.msecs : Date.now(), m = t2.nsecs !== void 0 ? t2.nsecs : c + 1, y = p - u + (m - c) / 1e4;
        if (y < 0 && t2.clockseq === void 0 && (h = h + 1 & 16383), (y < 0 || p > u) && t2.nsecs === void 0 && (m = 0), m >= 1e4)
          throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
        u = p, c = m, i = h;
        var b = (1e4 * (268435455 & (p += 122192928e5)) + m) % 4294967296;
        f2[s2++] = b >>> 24 & 255, f2[s2++] = b >>> 16 & 255, f2[s2++] = b >>> 8 & 255, f2[s2++] = 255 & b;
        var v = p / 4294967296 * 1e4 & 268435455;
        f2[s2++] = v >>> 8 & 255, f2[s2++] = 255 & v, f2[s2++] = v >>> 24 & 15 | 16, f2[s2++] = v >>> 16 & 255, f2[s2++] = h >>> 8 | 128, f2[s2++] = 255 & h;
        for (var g = 0; g < 6; ++g)
          f2[s2 + g] = l[g];
        return e2 || (0, a.default)(f2);
      };
      r.default = f;
    }, { "./rng.js": 531, "./stringify.js": 533 }], 535: [function(t, e, r) {
      Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
      var n = o(t("./v35.js")), i = o(t("./md5.js"));
      function o(t2) {
        return t2 && t2.__esModule ? t2 : { default: t2 };
      }
      var a = (0, n.default)("v3", 48, i.default);
      r.default = a;
    }, { "./md5.js": 527, "./v35.js": 536 }], 536: [function(t, e, r) {
      Object.defineProperty(r, "__esModule", { value: true }), r.default = function(t2, e2, r2) {
        function o2(t3, o3, a2, s2) {
          if (typeof t3 == "string" && (t3 = function(t4) {
            t4 = unescape(encodeURIComponent(t4));
            for (var e3 = [], r3 = 0; r3 < t4.length; ++r3)
              e3.push(t4.charCodeAt(r3));
            return e3;
          }(t3)), typeof o3 == "string" && (o3 = (0, i.default)(o3)), o3.length !== 16)
            throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
          var u = new Uint8Array(16 + t3.length);
          if (u.set(o3), u.set(t3, o3.length), (u = r2(u))[6] = 15 & u[6] | e2, u[8] = 63 & u[8] | 128, a2) {
            s2 = s2 || 0;
            for (var c = 0; c < 16; ++c)
              a2[s2 + c] = u[c];
            return a2;
          }
          return (0, n.default)(u);
        }
        try {
          o2.name = t2;
        } catch (t3) {
        }
        return o2.DNS = a, o2.URL = s, o2;
      }, r.URL = r.DNS = void 0;
      var n = o(t("./stringify.js")), i = o(t("./parse.js"));
      function o(t2) {
        return t2 && t2.__esModule ? t2 : { default: t2 };
      }
      var a = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
      r.DNS = a;
      var s = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
      r.URL = s;
    }, { "./parse.js": 529, "./stringify.js": 533 }], 537: [function(t, e, r) {
      Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
      var n = o(t("./rng.js")), i = o(t("./stringify.js"));
      function o(t2) {
        return t2 && t2.__esModule ? t2 : { default: t2 };
      }
      var a = function(t2, e2, r2) {
        var o2 = (t2 = t2 || {}).random || (t2.rng || n.default)();
        if (o2[6] = 15 & o2[6] | 64, o2[8] = 63 & o2[8] | 128, e2) {
          r2 = r2 || 0;
          for (var a2 = 0; a2 < 16; ++a2)
            e2[r2 + a2] = o2[a2];
          return e2;
        }
        return (0, i.default)(o2);
      };
      r.default = a;
    }, { "./rng.js": 531, "./stringify.js": 533 }], 538: [function(t, e, r) {
      Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
      var n = o(t("./v35.js")), i = o(t("./sha1.js"));
      function o(t2) {
        return t2 && t2.__esModule ? t2 : { default: t2 };
      }
      var a = (0, n.default)("v5", 80, i.default);
      r.default = a;
    }, { "./sha1.js": 532, "./v35.js": 536 }], 539: [function(t, e, r) {
      Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
      var n, i = (n = t("./regex.js")) && n.__esModule ? n : { default: n };
      var o = function(t2) {
        return typeof t2 == "string" && i.default.test(t2);
      };
      r.default = o;
    }, { "./regex.js": 530 }], 540: [function(t, e, r) {
      Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
      var n, i = (n = t("./validate.js")) && n.__esModule ? n : { default: n };
      var o = function(t2) {
        if (!(0, i.default)(t2))
          throw TypeError("Invalid UUID");
        return parseInt(t2.substr(14, 1), 16);
      };
      r.default = o;
    }, { "./validate.js": 539 }], 541: [function(t, e, r) {
      /**
       * Character classes and associated utilities for the 5th edition of XML 1.0.
       *
       * @author Louis-Dominique Dubeau
       * @license MIT
       * @copyright Louis-Dominique Dubeau
       */
      Object.defineProperty(r, "__esModule", { value: true }), r.CHAR = "	\n\r -\uD7FF\uE000-\uFFFD\u{10000}-\u{10FFFF}", r.S = " 	\r\n", r.NAME_START_CHAR = ":A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u{10000}-\u{EFFFF}", r.NAME_CHAR = "-" + r.NAME_START_CHAR + ".0-9\xB7\u0300-\u036F\u203F-\u2040", r.CHAR_RE = new RegExp("^[" + r.CHAR + "]$", "u"), r.S_RE = new RegExp("^[" + r.S + "]+$", "u"), r.NAME_START_CHAR_RE = new RegExp("^[" + r.NAME_START_CHAR + "]$", "u"), r.NAME_CHAR_RE = new RegExp("^[" + r.NAME_CHAR + "]$", "u"), r.NAME_RE = new RegExp("^[" + r.NAME_START_CHAR + "][" + r.NAME_CHAR + "]*$", "u"), r.NMTOKEN_RE = new RegExp("^[" + r.NAME_CHAR + "]+$", "u");
      function n(t2) {
        return t2 >= 65 && t2 <= 90 || t2 >= 97 && t2 <= 122 || t2 === 58 || t2 === 95 || t2 === 8204 || t2 === 8205 || t2 >= 192 && t2 <= 214 || t2 >= 216 && t2 <= 246 || t2 >= 248 && t2 <= 767 || t2 >= 880 && t2 <= 893 || t2 >= 895 && t2 <= 8191 || t2 >= 8304 && t2 <= 8591 || t2 >= 11264 && t2 <= 12271 || t2 >= 12289 && t2 <= 55295 || t2 >= 63744 && t2 <= 64975 || t2 >= 65008 && t2 <= 65533 || t2 >= 65536 && t2 <= 983039;
      }
      r.S_LIST = [32, 10, 13, 9], r.isChar = function(t2) {
        return t2 >= 32 && t2 <= 55295 || t2 === 10 || t2 === 13 || t2 === 9 || t2 >= 57344 && t2 <= 65533 || t2 >= 65536 && t2 <= 1114111;
      }, r.isS = function(t2) {
        return t2 === 32 || t2 === 10 || t2 === 13 || t2 === 9;
      }, r.isNameStartChar = n, r.isNameChar = function(t2) {
        return n(t2) || t2 >= 48 && t2 <= 57 || t2 === 45 || t2 === 46 || t2 === 183 || t2 >= 768 && t2 <= 879 || t2 >= 8255 && t2 <= 8256;
      };
    }, {}], 542: [function(t, e, r) {
      /**
       * Character classes and associated utilities for the 2nd edition of XML 1.1.
       *
       * @author Louis-Dominique Dubeau
       * @license MIT
       * @copyright Louis-Dominique Dubeau
       */
      Object.defineProperty(r, "__esModule", { value: true }), r.CHAR = "-\uD7FF\uE000-\uFFFD\u{10000}-\u{10FFFF}", r.RESTRICTED_CHAR = "-\b\v\f-\x7F-\x84\x86-\x9F", r.S = " 	\r\n", r.NAME_START_CHAR = ":A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u{10000}-\u{EFFFF}", r.NAME_CHAR = "-" + r.NAME_START_CHAR + ".0-9\xB7\u0300-\u036F\u203F-\u2040", r.CHAR_RE = new RegExp("^[" + r.CHAR + "]$", "u"), r.RESTRICTED_CHAR_RE = new RegExp("^[" + r.RESTRICTED_CHAR + "]$", "u"), r.S_RE = new RegExp("^[" + r.S + "]+$", "u"), r.NAME_START_CHAR_RE = new RegExp("^[" + r.NAME_START_CHAR + "]$", "u"), r.NAME_CHAR_RE = new RegExp("^[" + r.NAME_CHAR + "]$", "u"), r.NAME_RE = new RegExp("^[" + r.NAME_START_CHAR + "][" + r.NAME_CHAR + "]*$", "u"), r.NMTOKEN_RE = new RegExp("^[" + r.NAME_CHAR + "]+$", "u");
      function n(t2) {
        return t2 >= 65 && t2 <= 90 || t2 >= 97 && t2 <= 122 || t2 === 58 || t2 === 95 || t2 === 8204 || t2 === 8205 || t2 >= 192 && t2 <= 214 || t2 >= 216 && t2 <= 246 || t2 >= 248 && t2 <= 767 || t2 >= 880 && t2 <= 893 || t2 >= 895 && t2 <= 8191 || t2 >= 8304 && t2 <= 8591 || t2 >= 11264 && t2 <= 12271 || t2 >= 12289 && t2 <= 55295 || t2 >= 63744 && t2 <= 64975 || t2 >= 65008 && t2 <= 65533 || t2 >= 65536 && t2 <= 983039;
      }
      r.S_LIST = [32, 10, 13, 9], r.isChar = function(t2) {
        return t2 >= 1 && t2 <= 55295 || t2 >= 57344 && t2 <= 65533 || t2 >= 65536 && t2 <= 1114111;
      }, r.isRestrictedChar = function(t2) {
        return t2 >= 1 && t2 <= 8 || t2 === 11 || t2 === 12 || t2 >= 14 && t2 <= 31 || t2 >= 127 && t2 <= 132 || t2 >= 134 && t2 <= 159;
      }, r.isCharAndNotRestricted = function(t2) {
        return t2 === 9 || t2 === 10 || t2 === 13 || t2 > 31 && t2 < 127 || t2 === 133 || t2 > 159 && t2 <= 55295 || t2 >= 57344 && t2 <= 65533 || t2 >= 65536 && t2 <= 1114111;
      }, r.isS = function(t2) {
        return t2 === 32 || t2 === 10 || t2 === 13 || t2 === 9;
      }, r.isNameStartChar = n, r.isNameChar = function(t2) {
        return n(t2) || t2 >= 48 && t2 <= 57 || t2 === 45 || t2 === 46 || t2 === 183 || t2 >= 768 && t2 <= 879 || t2 >= 8255 && t2 <= 8256;
      };
    }, {}], 543: [function(t, e, r) {
      /**
       * Character class utilities for XML NS 1.0 edition 3.
       *
       * @author Louis-Dominique Dubeau
       * @license MIT
       * @copyright Louis-Dominique Dubeau
       */
      function n(t2) {
        return t2 >= 65 && t2 <= 90 || t2 === 95 || t2 >= 97 && t2 <= 122 || t2 >= 192 && t2 <= 214 || t2 >= 216 && t2 <= 246 || t2 >= 248 && t2 <= 767 || t2 >= 880 && t2 <= 893 || t2 >= 895 && t2 <= 8191 || t2 >= 8204 && t2 <= 8205 || t2 >= 8304 && t2 <= 8591 || t2 >= 11264 && t2 <= 12271 || t2 >= 12289 && t2 <= 55295 || t2 >= 63744 && t2 <= 64975 || t2 >= 65008 && t2 <= 65533 || t2 >= 65536 && t2 <= 983039;
      }
      Object.defineProperty(r, "__esModule", { value: true }), r.NC_NAME_START_CHAR = "A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u{10000}-\u{EFFFF}", r.NC_NAME_CHAR = "-" + r.NC_NAME_START_CHAR + ".0-9\xB7\u0300-\u036F\u203F-\u2040", r.NC_NAME_START_CHAR_RE = new RegExp("^[" + r.NC_NAME_START_CHAR + "]$", "u"), r.NC_NAME_CHAR_RE = new RegExp("^[" + r.NC_NAME_CHAR + "]$", "u"), r.NC_NAME_RE = new RegExp("^[" + r.NC_NAME_START_CHAR + "][" + r.NC_NAME_CHAR + "]*$", "u"), r.isNCNameStartChar = n, r.isNCNameChar = function(t2) {
        return n(t2) || t2 === 45 || t2 === 46 || t2 >= 48 && t2 <= 57 || t2 === 183 || t2 >= 768 && t2 <= 879 || t2 >= 8255 && t2 <= 8256;
      };
    }, {}] }, {}, [15])(15);
  });
})(exceljs_min);

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq$3(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq$3(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

var freeGlobal$1 = freeGlobal;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal$1 || freeSelf || Function('return this')();

var root$1 = root;

/** Built-in value references. */
var Symbol$1 = root$1.Symbol;

var Symbol$2 = Symbol$1;

/** Used for built-in method references. */
var objectProto$c = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$9 = objectProto$c.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$c.toString;

/** Built-in value references. */
var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty$9.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$b = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto$b.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag$2 = '[object Function]',
    genTag$1 = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}

/** Used to detect overreaching core-js shims. */
var coreJsData = root$1['__core-js_shared__'];

var coreJsData$1 = coreJsData;

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/** Used for built-in method references. */
var funcProto$1 = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$1 = funcProto$1.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto$a = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty$8).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/* Built-in method references that are verified to be native. */
var Map$1 = getNative(root$1, 'Map');

var Map$2 = Map$1;

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

var nativeCreate$1 = nativeCreate;

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto$9 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$7 = objectProto$9.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate$1) {
    var result = data[key];
    return result === HASH_UNDEFINED$1 ? undefined : result;
  }
  return hasOwnProperty$7.call(data, key) ? data[key] : undefined;
}

/** Used for built-in method references. */
var objectProto$8 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$6 = objectProto$8.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate$1 ? (data[key] !== undefined) : hasOwnProperty$6.call(data, key);
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate$1 && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map$2 || ListCache),
    'string': new Hash
  };
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$2 || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

var defineProperty$1 = defineProperty;

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty$1) {
    defineProperty$1(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/** Used for built-in method references. */
var objectProto$7 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$5 = objectProto$7.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$5.call(object, key) && eq$3(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/** `Object#toString` result references. */
var argsTag$2 = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$2;
}

/** Used for built-in method references. */
var objectProto$6 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$4 = objectProto$6.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$4.call(value, 'callee') &&
    !propertyIsEnumerable$1.call(value, 'callee');
};

var isArguments$1 = isArguments;

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

var isArray$1 = isArray;

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

/** Detect free variable `exports`. */
var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;

/** Built-in value references. */
var Buffer$3 = moduleExports$2 ? root$1.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer$3 ? Buffer$3.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

var isBuffer$1 = isBuffer;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$3 = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$3 : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$2 = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$2;
}

/** `Object#toString` result references. */
var argsTag$1 = '[object Arguments]',
    arrayTag$1 = '[object Array]',
    boolTag$2 = '[object Boolean]',
    dateTag$2 = '[object Date]',
    errorTag$1 = '[object Error]',
    funcTag$1 = '[object Function]',
    mapTag$4 = '[object Map]',
    numberTag$2 = '[object Number]',
    objectTag$2 = '[object Object]',
    regexpTag$2 = '[object RegExp]',
    setTag$4 = '[object Set]',
    stringTag$2 = '[object String]',
    weakMapTag$2 = '[object WeakMap]';

var arrayBufferTag$2 = '[object ArrayBuffer]',
    dataViewTag$3 = '[object DataView]',
    float32Tag$2 = '[object Float32Array]',
    float64Tag$2 = '[object Float64Array]',
    int8Tag$2 = '[object Int8Array]',
    int16Tag$2 = '[object Int16Array]',
    int32Tag$2 = '[object Int32Array]',
    uint8Tag$2 = '[object Uint8Array]',
    uint8ClampedTag$2 = '[object Uint8ClampedArray]',
    uint16Tag$2 = '[object Uint16Array]',
    uint32Tag$2 = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] =
typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] =
typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] =
typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] =
typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] =
typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] =
typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] =
typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] =
typedArrayTags[mapTag$4] = typedArrayTags[numberTag$2] =
typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$2] =
typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] =
typedArrayTags[weakMapTag$2] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/** Detect free variable `exports`. */
var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports$1 && freeGlobal$1.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

var nodeUtil$1 = nodeUtil;

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

var isTypedArray$1 = isTypedArray;

/** Used for built-in method references. */
var objectProto$5 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$5.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray$1(value),
      isArg = !isArr && isArguments$1(value),
      isBuff = !isArr && !isArg && isBuffer$1(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray$1(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$3.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$4 = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$4;

  return value === proto;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

var nativeKeys$1 = nativeKeys;

/** Used for built-in method references. */
var objectProto$3 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys$1(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$2.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$2 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty$1.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer$2 = moduleExports ? root$1.Buffer : undefined,
    allocUnsafe = Buffer$2 ? Buffer$2.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto$1.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

var getSymbols$1 = getSymbols;

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols$1(source), object);
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

var getPrototype$1 = getPrototype;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols$1(object));
    object = getPrototype$1(object);
  }
  return result;
};

var getSymbolsIn$1 = getSymbolsIn;

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn$1(source), object);
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols$1);
}

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn$1);
}

/* Built-in method references that are verified to be native. */
var DataView$1 = getNative(root$1, 'DataView');

var DataView$2 = DataView$1;

/* Built-in method references that are verified to be native. */
var Promise$1 = getNative(root$1, 'Promise');

var Promise$2 = Promise$1;

/* Built-in method references that are verified to be native. */
var Set$1 = getNative(root$1, 'Set');

var Set$2 = Set$1;

/* Built-in method references that are verified to be native. */
var WeakMap$1 = getNative(root$1, 'WeakMap');

var WeakMap$2 = WeakMap$1;

/** `Object#toString` result references. */
var mapTag$3 = '[object Map]',
    objectTag$1 = '[object Object]',
    promiseTag = '[object Promise]',
    setTag$3 = '[object Set]',
    weakMapTag$1 = '[object WeakMap]';

var dataViewTag$2 = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView$2),
    mapCtorString = toSource(Map$2),
    promiseCtorString = toSource(Promise$2),
    setCtorString = toSource(Set$2),
    weakMapCtorString = toSource(WeakMap$2);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView$2 && getTag(new DataView$2(new ArrayBuffer(1))) != dataViewTag$2) ||
    (Map$2 && getTag(new Map$2) != mapTag$3) ||
    (Promise$2 && getTag(Promise$2.resolve()) != promiseTag) ||
    (Set$2 && getTag(new Set$2) != setTag$3) ||
    (WeakMap$2 && getTag(new WeakMap$2) != weakMapTag$1)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag$1 ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag$2;
        case mapCtorString: return mapTag$3;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag$3;
        case weakMapCtorString: return weakMapTag$1;
      }
    }
    return result;
  };
}

var getTag$1 = getTag;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

/** Built-in value references. */
var Uint8Array$1 = root$1.Uint8Array;

var Uint8Array$2 = Uint8Array$1;

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol$2 ? Symbol$2.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/** `Object#toString` result references. */
var boolTag$1 = '[object Boolean]',
    dateTag$1 = '[object Date]',
    mapTag$2 = '[object Map]',
    numberTag$1 = '[object Number]',
    regexpTag$1 = '[object RegExp]',
    setTag$2 = '[object Set]',
    stringTag$1 = '[object String]',
    symbolTag$1 = '[object Symbol]';

var arrayBufferTag$1 = '[object ArrayBuffer]',
    dataViewTag$1 = '[object DataView]',
    float32Tag$1 = '[object Float32Array]',
    float64Tag$1 = '[object Float64Array]',
    int8Tag$1 = '[object Int8Array]',
    int16Tag$1 = '[object Int16Array]',
    int32Tag$1 = '[object Int32Array]',
    uint8Tag$1 = '[object Uint8Array]',
    uint8ClampedTag$1 = '[object Uint8ClampedArray]',
    uint16Tag$1 = '[object Uint16Array]',
    uint32Tag$1 = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$1:
      return cloneArrayBuffer(object);

    case boolTag$1:
    case dateTag$1:
      return new Ctor(+object);

    case dataViewTag$1:
      return cloneDataView(object, isDeep);

    case float32Tag$1: case float64Tag$1:
    case int8Tag$1: case int16Tag$1: case int32Tag$1:
    case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:
      return cloneTypedArray(object, isDeep);

    case mapTag$2:
      return new Ctor;

    case numberTag$1:
    case stringTag$1:
      return new Ctor(object);

    case regexpTag$1:
      return cloneRegExp(object);

    case setTag$2:
      return new Ctor;

    case symbolTag$1:
      return cloneSymbol(object);
  }
}

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

var baseCreate$1 = baseCreate;

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate$1(getPrototype$1(object))
    : {};
}

/** `Object#toString` result references. */
var mapTag$1 = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag$1(value) == mapTag$1;
}

/* Node.js helper references. */
var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

var isMap$1 = isMap;

/** `Object#toString` result references. */
var setTag$1 = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag$1(value) == setTag$1;
}

/* Node.js helper references. */
var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

var isSet$1 = isSet;

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG$1 = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG$1 = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG$1,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG$1;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray$1(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag$1(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer$1(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet$1(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap$1(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep$1(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

var cloneDeep$2 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	'default': cloneDeep$1
});

var require$$6 = /*@__PURE__*/getAugmentedNamespace(cloneDeep$2);

const ExcelJS = exceljs_min.exports;
const getData$2 = getData$3.getData;
const { app: app$3, ipcMain: ipcMain$2, dialog: dialog$1 } = require$$0__default$4["default"];
const fs$5 = lib$1;
const path$3 = require$$1__default["default"];
const i18n$1 = i18n_1;
const cloneDeep = require$$6.default;
function pad(num) {
  return `${num}`.padStart(2, "0");
}
function getTimeString$1() {
  const d = new Date();
  const YYYY = d.getFullYear();
  const MM = pad(d.getMonth() + 1);
  const DD = pad(d.getDate());
  const HH = pad(d.getHours());
  const mm = pad(d.getMinutes());
  const ss = pad(d.getSeconds());
  return `${YYYY}${MM}${DD}_${HH}${mm}${ss}`;
}
const start$1 = async () => {
  const { header, customFont, filePrefix, fileType, wish2 } = i18n$1.excel;
  const { dataMap, current } = await getData$2();
  const data = dataMap.get(current);
  const workbook = new ExcelJS.Workbook();
  for (let [key, value] of data.result) {
    const name = data.typeMap.get(key);
    const sheet = workbook.addWorksheet(name, { views: [{ state: "frozen", ySplit: 1 }] });
    let width = [24, 14, 8, 8, 8, 8, 8];
    if (!data.lang.includes("zh-")) {
      width = [24, 32, 16, 12, 12, 12, 8];
    }
    const excelKeys = ["time", "name", "type", "rank", "total", "pity", "remark"];
    sheet.columns = excelKeys.map((key2, index) => {
      return {
        header: header[key2],
        key: key2,
        width: width[index]
      };
    });
    const logs = cloneDeep(value);
    let total = 0;
    let pity = 0;
    for (let log of logs) {
      total += 1;
      pity += 1;
      let gachaType = log[4];
      log[4] = total;
      log[5] = pity;
      if (log[3] === 5) {
        pity = 0;
      }
      if (key === "301") {
        if (gachaType === "400") {
          log.push(wish2);
        }
      }
    }
    sheet.addRows(logs);
    ["A", "B", "C", "D", "E", "F", "G"].forEach((v) => {
      sheet.getCell(`${v}1`).border = {
        top: { style: "thin", color: { argb: "ffc4c2bf" } },
        left: { style: "thin", color: { argb: "ffc4c2bf" } },
        bottom: { style: "thin", color: { argb: "ffc4c2bf" } },
        right: { style: "thin", color: { argb: "ffc4c2bf" } }
      };
      sheet.getCell(`${v}1`).fill = {
        type: "pattern",
        pattern: "solid",
        fgColor: { argb: "ffdbd7d3" }
      };
      sheet.getCell(`${v}1`).font = {
        name: customFont,
        color: { argb: "ff757575" },
        bold: true
      };
    });
    logs.forEach((v, i) => {
      ["A", "B", "C", "D", "E", "F", "G"].forEach((c) => {
        sheet.getCell(`${c}${i + 2}`).border = {
          top: { style: "thin", color: { argb: "ffc4c2bf" } },
          left: { style: "thin", color: { argb: "ffc4c2bf" } },
          bottom: { style: "thin", color: { argb: "ffc4c2bf" } },
          right: { style: "thin", color: { argb: "ffc4c2bf" } }
        };
        sheet.getCell(`${c}${i + 2}`).fill = {
          type: "pattern",
          pattern: "solid",
          fgColor: { argb: "ffebebeb" }
        };
        const rankColor = {
          3: "ff8e8e8e",
          4: "ffa256e1",
          5: "ffbd6932"
        };
        sheet.getCell(`${c}${i + 2}`).font = {
          name: customFont,
          color: { argb: rankColor[v[3]] },
          bold: v[3] != "3"
        };
      });
    });
  }
  const buffer = await workbook.xlsx.writeBuffer();
  const filePath = dialog$1.showSaveDialogSync({
    defaultPath: path$3.join(app$3.getPath("downloads"), `${filePrefix}_${getTimeString$1()}`),
    filters: [
      { name: fileType, extensions: ["xlsx"] }
    ]
  });
  if (filePath) {
    await fs$5.ensureFile(filePath);
    await fs$5.writeFile(filePath, buffer);
  }
};
ipcMain$2.handle("SAVE_EXCEL", async () => {
  await start$1();
});

var name = "genshin-wish-export";
var version$2 = "0.11.9";
var main = "./dist/electron/main/main.js";
var author = "biuuu <https://github.com/biuuu>";
var homepage = "https://github.com/biuuu/genshin-wish-export";
var license = "MIT";
var scripts = {
	dev: "node .electron-vite/dev-runner.js",
	build: "cross-env BUILD_TARGET=clean node .electron-vite/build.js  && electron-builder",
	"build:win32": "cross-env BUILD_TARGET=clean node .electron-vite/build.js  && electron-builder --win  --ia32",
	"build:win64": "cross-env BUILD_TARGET=clean node .electron-vite/build.js  && electron-builder --win  --x64",
	"build:linux": "cross-env BUILD_TARGET=clean node .electron-vite/build.js && electron-builder --linux",
	"build:mac": "cross-env BUILD_TARGET=clean node .electron-vite/build.js  && electron-builder --mac",
	"build:dir": "cross-env BUILD_TARGET=clean node .electron-vite/build.js  && electron-builder --dir",
	"build:clean": "cross-env BUILD_TARGET=onlyClean node .electron-vite/build.js",
	"build:web": "cross-env BUILD_TARGET=web node .electron-vite/build.js",
	"dev:web": "cross-env TARGET=web node .electron-vite/dev-runner.js",
	start: "electron ./src/main/main.js",
	"build-update": "node .electron-vite/update.js",
	"dep:upgrade": "yarn upgrade-interactive --latest",
	postinstall: "electron-builder install-app-deps"
};
var build = {
	nsis: {
		oneClick: false,
		allowToChangeInstallationDirectory: true
	},
	asar: false,
	extraFiles: [
	],
	publish: [
		{
			provider: "generic",
			url: "http://127.0.0.1"
		}
	],
	productName: "Genshin Wish Export",
	appId: "org.biuuu.genshin-wish-export",
	directories: {
		output: "build"
	},
	files: [
		"dist/electron/**/*"
	],
	dmg: {
		contents: [
			{
				x: 410,
				y: 150,
				type: "link",
				path: "/Applications"
			},
			{
				x: 130,
				y: 150,
				type: "file"
			}
		]
	},
	mac: {
		icon: "build/icons/icon.icns"
	},
	win: {
		icon: "build/icons/icon.ico",
		target: "zip"
	},
	linux: {
		target: "deb",
		icon: "build/icons"
	}
};
var dependencies$1 = {
};
var devDependencies = {
	"@element-plus/icons-vue": "^0.2.6",
	"@rollup/plugin-alias": "^3.1.9",
	"@rollup/plugin-commonjs": "^21.0.1",
	"@rollup/plugin-json": "^4.1.0",
	"@rollup/plugin-node-resolve": "^13.1.3",
	"@types/node": "^17.0.10",
	"@vitejs/plugin-vue": "2.1.0",
	"@vue/compiler-sfc": "^3.2.29",
	"adm-zip": "^0.5.9",
	ajv: "6",
	autoprefixer: "^10.4.2",
	cfonts: "^2.10.0",
	chalk: "^4.1.0",
	"cross-env": "^7.0.3",
	del: "^6.0.0",
	echarts: "^5.2.2",
	electron: "^16.0.7",
	"electron-builder": "^23.0.2",
	"electron-fetch": "^1.7.4",
	"electron-unhandled": "^3.0.2",
	"electron-window-state": "^5.0.3",
	"element-plus": "^1.3.0-beta.7",
	"fs-extra": "^10.0.0",
	"get-stream": "^6.0.1",
	glob: "^10.3.1",
	"lodash-es": "^4.17.21",
	moment: "^2.29.1",
	multispinner: "^0.2.1",
	ora: "^5.3.0",
	portfinder: "^1.0.28",
	postcss: "^8.4.5",
	"rollup-plugin-esbuild": "^4.8.2",
	semver: "^7.3.5",
	tailwindcss: "^3.0.16",
	vite: "2.7.13",
	vue: "^3.2.29",
	winreg: "^1.2.4",
	yauzl: "^2.10.0"
};
var keywords = [
	"vite",
	"electron",
	"vue3",
	"rollup"
];
var require$$7 = {
	name: name,
	version: version$2,
	main: main,
	author: author,
	homepage: homepage,
	license: license,
	scripts: scripts,
	build: build,
	dependencies: dependencies$1,
	devDependencies: devDependencies,
	keywords: keywords
};

var uri_all = {exports: {}};

/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */

(function (module, exports) {
(function (global, factory) {
	factory(exports) ;
}(commonjsGlobal, (function (exports) {
function merge() {
    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
        sets[_key] = arguments[_key];
    }

    if (sets.length > 1) {
        sets[0] = sets[0].slice(0, -1);
        var xl = sets.length - 1;
        for (var x = 1; x < xl; ++x) {
            sets[x] = sets[x].slice(1, -1);
        }
        sets[xl] = sets[xl].slice(1);
        return sets.join('');
    } else {
        return sets[0];
    }
}
function subexp(str) {
    return "(?:" + str + ")";
}
function typeOf(o) {
    return o === undefined ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
}
function toUpperCase(str) {
    return str.toUpperCase();
}
function toArray(obj) {
    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
}
function assign(target, source) {
    var obj = target;
    if (source) {
        for (var key in source) {
            obj[key] = source[key];
        }
    }
    return obj;
}

function buildExps(isIRI) {
    var ALPHA$$ = "[A-Za-z]",
        DIGIT$$ = "[0-9]",
        HEXDIG$$ = merge(DIGIT$$, "[A-Fa-f]"),
        PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)),
        //expanded
    GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]",
        SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),
        UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]",
        //subset, excludes bidi control characters
    IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]",
        //subset
    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$);
        subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*");
        subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]")) + "*");
        var DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$),
        //relaxed parsing rules
    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$),
        H16$ = subexp(HEXDIG$$ + "{1,4}"),
        LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$),
        IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$),
        //                           6( h16 ":" ) ls32
    IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$),
        //                      "::" 5( h16 ":" ) ls32
    IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$),
        //[               h16 ] "::" 4( h16 ":" ) ls32
    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$),
        //[ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$),
        //[ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$),
        //[ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$),
        //[ *4( h16 ":" ) h16 ] "::"              ls32
    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$),
        //[ *5( h16 ":" ) h16 ] "::"              h16
    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"),
        //[ *6( h16 ":" ) h16 ] "::"
    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")),
        ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+");
        //RFC 6874, with relaxed parsing rules
    subexp("[vV]" + HEXDIG$$ + "+\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") + "+");
        //RFC 6874
    subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*");
        var PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@]"));
        subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\@]")) + "+");
        subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*");
    return {
        NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
        NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        UNRESERVED: new RegExp(UNRESERVED$$, "g"),
        OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$, RESERVED$$), "g"),
        PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
        IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$") //RFC 6874, with relaxed parsing rules
    };
}
var URI_PROTOCOL = buildExps(false);

var IRI_PROTOCOL = buildExps(true);

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/** Highest positive signed 32-bit float value */

var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

/** Bootstring parameters */
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128; // 0x80
var delimiter = '-'; // '\x2D'

/** Regular expressions */
var regexPunycode = /^xn--/;
var regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

/** Error messages */
var errors = {
	'overflow': 'Overflow: input needs wider integers to process',
	'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
	'invalid-input': 'Invalid input'
};

/** Convenience shortcuts */
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;

/*--------------------------------------------------------------------------*/

/**
 * A generic error utility function.
 * @private
 * @param {String} type The error type.
 * @returns {Error} Throws a `RangeError` with the applicable error message.
 */
function error$1(type) {
	throw new RangeError(errors[type]);
}

/**
 * A generic `Array#map` utility function.
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} callback The function that gets called for every array
 * item.
 * @returns {Array} A new array of values returned by the callback function.
 */
function map(array, fn) {
	var result = [];
	var length = array.length;
	while (length--) {
		result[length] = fn(array[length]);
	}
	return result;
}

/**
 * A simple `Array#map`-like wrapper to work with domain name strings or email
 * addresses.
 * @private
 * @param {String} domain The domain name or email address.
 * @param {Function} callback The function that gets called for every
 * character.
 * @returns {Array} A new string of characters returned by the callback
 * function.
 */
function mapDomain(string, fn) {
	var parts = string.split('@');
	var result = '';
	if (parts.length > 1) {
		// In email addresses, only the domain name should be punycoded. Leave
		// the local part (i.e. everything up to `@`) intact.
		result = parts[0] + '@';
		string = parts[1];
	}
	// Avoid `split(regex)` for IE8 compatibility. See #17.
	string = string.replace(regexSeparators, '\x2E');
	var labels = string.split('.');
	var encoded = map(labels, fn).join('.');
	return result + encoded;
}

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see `punycode.ucs2.encode`
 * @see <https://mathiasbynens.be/notes/javascript-encoding>
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */
function ucs2decode(string) {
	var output = [];
	var counter = 0;
	var length = string.length;
	while (counter < length) {
		var value = string.charCodeAt(counter++);
		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
			// It's a high surrogate, and there is a next character.
			var extra = string.charCodeAt(counter++);
			if ((extra & 0xFC00) == 0xDC00) {
				// Low surrogate.
				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
			} else {
				// It's an unmatched surrogate; only append this code unit, in case the
				// next code unit is the high surrogate of a surrogate pair.
				output.push(value);
				counter--;
			}
		} else {
			output.push(value);
		}
	}
	return output;
}

/**
 * Creates a string based on an array of numeric code points.
 * @see `punycode.ucs2.decode`
 * @memberOf punycode.ucs2
 * @name encode
 * @param {Array} codePoints The array of numeric code points.
 * @returns {String} The new Unicode string (UCS-2).
 */
var ucs2encode = function ucs2encode(array) {
	return String.fromCodePoint.apply(String, toConsumableArray(array));
};

/**
 * Converts a basic code point into a digit/integer.
 * @see `digitToBasic()`
 * @private
 * @param {Number} codePoint The basic numeric code point value.
 * @returns {Number} The numeric value of a basic code point (for use in
 * representing integers) in the range `0` to `base - 1`, or `base` if
 * the code point does not represent a value.
 */
var basicToDigit = function basicToDigit(codePoint) {
	if (codePoint - 0x30 < 0x0A) {
		return codePoint - 0x16;
	}
	if (codePoint - 0x41 < 0x1A) {
		return codePoint - 0x41;
	}
	if (codePoint - 0x61 < 0x1A) {
		return codePoint - 0x61;
	}
	return base;
};

/**
 * Converts a digit/integer into a basic code point.
 * @see `basicToDigit()`
 * @private
 * @param {Number} digit The numeric value of a basic code point.
 * @returns {Number} The basic code point whose value (when used for
 * representing integers) is `digit`, which needs to be in the range
 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
 * used; else, the lowercase form is used. The behavior is undefined
 * if `flag` is non-zero and `digit` has no uppercase form.
 */
var digitToBasic = function digitToBasic(digit, flag) {
	//  0..25 map to ASCII a..z or A..Z
	// 26..35 map to ASCII 0..9
	return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 * @private
 */
var adapt = function adapt(delta, numPoints, firstTime) {
	var k = 0;
	delta = firstTime ? floor(delta / damp) : delta >> 1;
	delta += floor(delta / numPoints);
	for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
		delta = floor(delta / baseMinusTMin);
	}
	return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
 * symbols.
 * @memberOf punycode
 * @param {String} input The Punycode string of ASCII-only symbols.
 * @returns {String} The resulting string of Unicode symbols.
 */
var decode = function decode(input) {
	// Don't use UCS-2.
	var output = [];
	var inputLength = input.length;
	var i = 0;
	var n = initialN;
	var bias = initialBias;

	// Handle the basic code points: let `basic` be the number of input code
	// points before the last delimiter, or `0` if there is none, then copy
	// the first basic code points to the output.

	var basic = input.lastIndexOf(delimiter);
	if (basic < 0) {
		basic = 0;
	}

	for (var j = 0; j < basic; ++j) {
		// if it's not a basic code point
		if (input.charCodeAt(j) >= 0x80) {
			error$1('not-basic');
		}
		output.push(input.charCodeAt(j));
	}

	// Main decoding loop: start just after the last delimiter if any basic code
	// points were copied; start at the beginning otherwise.

	for (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

		// `index` is the index of the next character to be consumed.
		// Decode a generalized variable-length integer into `delta`,
		// which gets added to `i`. The overflow checking is easier
		// if we increase `i` as we go, then subtract off its starting
		// value at the end to obtain `delta`.
		var oldi = i;
		for (var w = 1, k = base;; /* no condition */k += base) {

			if (index >= inputLength) {
				error$1('invalid-input');
			}

			var digit = basicToDigit(input.charCodeAt(index++));

			if (digit >= base || digit > floor((maxInt - i) / w)) {
				error$1('overflow');
			}

			i += digit * w;
			var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

			if (digit < t) {
				break;
			}

			var baseMinusT = base - t;
			if (w > floor(maxInt / baseMinusT)) {
				error$1('overflow');
			}

			w *= baseMinusT;
		}

		var out = output.length + 1;
		bias = adapt(i - oldi, out, oldi == 0);

		// `i` was supposed to wrap around from `out` to `0`,
		// incrementing `n` each time, so we'll fix that now:
		if (floor(i / out) > maxInt - n) {
			error$1('overflow');
		}

		n += floor(i / out);
		i %= out;

		// Insert `n` at position `i` of the output.
		output.splice(i++, 0, n);
	}

	return String.fromCodePoint.apply(String, output);
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */
var encode = function encode(input) {
	var output = [];

	// Convert the input in UCS-2 to an array of Unicode code points.
	input = ucs2decode(input);

	// Cache the length.
	var inputLength = input.length;

	// Initialize the state.
	var n = initialN;
	var delta = 0;
	var bias = initialBias;

	// Handle the basic code points.
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var _currentValue2 = _step.value;

			if (_currentValue2 < 0x80) {
				output.push(stringFromCharCode(_currentValue2));
			}
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	var basicLength = output.length;
	var handledCPCount = basicLength;

	// `handledCPCount` is the number of code points that have been handled;
	// `basicLength` is the number of basic code points.

	// Finish the basic string with a delimiter unless it's empty.
	if (basicLength) {
		output.push(delimiter);
	}

	// Main encoding loop:
	while (handledCPCount < inputLength) {

		// All non-basic code points < n have been handled already. Find the next
		// larger one:
		var m = maxInt;
		var _iteratorNormalCompletion2 = true;
		var _didIteratorError2 = false;
		var _iteratorError2 = undefined;

		try {
			for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
				var currentValue = _step2.value;

				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow.
		} catch (err) {
			_didIteratorError2 = true;
			_iteratorError2 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion2 && _iterator2.return) {
					_iterator2.return();
				}
			} finally {
				if (_didIteratorError2) {
					throw _iteratorError2;
				}
			}
		}

		var handledCPCountPlusOne = handledCPCount + 1;
		if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
			error$1('overflow');
		}

		delta += (m - n) * handledCPCountPlusOne;
		n = m;

		var _iteratorNormalCompletion3 = true;
		var _didIteratorError3 = false;
		var _iteratorError3 = undefined;

		try {
			for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
				var _currentValue = _step3.value;

				if (_currentValue < n && ++delta > maxInt) {
					error$1('overflow');
				}
				if (_currentValue == n) {
					// Represent delta as a generalized variable-length integer.
					var q = delta;
					for (var k = base;; /* no condition */k += base) {
						var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
						if (q < t) {
							break;
						}
						var qMinusT = q - t;
						var baseMinusT = base - t;
						output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}
		} catch (err) {
			_didIteratorError3 = true;
			_iteratorError3 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion3 && _iterator3.return) {
					_iterator3.return();
				}
			} finally {
				if (_didIteratorError3) {
					throw _iteratorError3;
				}
			}
		}

		++delta;
		++n;
	}
	return output.join('');
};

/**
 * Converts a Punycode string representing a domain name or an email address
 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
 * it doesn't matter if you call it on a string that has already been
 * converted to Unicode.
 * @memberOf punycode
 * @param {String} input The Punycoded domain name or email address to
 * convert to Unicode.
 * @returns {String} The Unicode representation of the given Punycode
 * string.
 */
var toUnicode = function toUnicode(input) {
	return mapDomain(input, function (string) {
		return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
	});
};

/**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */
var toASCII = function toASCII(input) {
	return mapDomain(input, function (string) {
		return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
	});
};

/*--------------------------------------------------------------------------*/

/** Define the public API */
var punycode = {
	/**
  * A string representing the current Punycode.js version number.
  * @memberOf punycode
  * @type String
  */
	'version': '2.1.0',
	/**
  * An object of methods to convert from JavaScript's internal character
  * representation (UCS-2) to Unicode code points, and back.
  * @see <https://mathiasbynens.be/notes/javascript-encoding>
  * @memberOf punycode
  * @type Object
  */
	'ucs2': {
		'decode': ucs2decode,
		'encode': ucs2encode
	},
	'decode': decode,
	'encode': encode,
	'toASCII': toASCII,
	'toUnicode': toUnicode
};

/**
 * URI.js
 *
 * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/uri-js
 */
/**
 * Copyright 2011 Gary Court. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 *    1. Redistributions of source code must retain the above copyright notice, this list of
 *       conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
 *       of conditions and the following disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are those of the
 * authors and should not be interpreted as representing official policies, either expressed
 * or implied, of Gary Court.
 */
var SCHEMES = {};
function pctEncChar(chr) {
    var c = chr.charCodeAt(0);
    var e = void 0;
    if (c < 16) e = "%0" + c.toString(16).toUpperCase();else if (c < 128) e = "%" + c.toString(16).toUpperCase();else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
    return e;
}
function pctDecChars(str) {
    var newStr = "";
    var i = 0;
    var il = str.length;
    while (i < il) {
        var c = parseInt(str.substr(i + 1, 2), 16);
        if (c < 128) {
            newStr += String.fromCharCode(c);
            i += 3;
        } else if (c >= 194 && c < 224) {
            if (il - i >= 6) {
                var c2 = parseInt(str.substr(i + 4, 2), 16);
                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
            } else {
                newStr += str.substr(i, 6);
            }
            i += 6;
        } else if (c >= 224) {
            if (il - i >= 9) {
                var _c = parseInt(str.substr(i + 4, 2), 16);
                var c3 = parseInt(str.substr(i + 7, 2), 16);
                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
            } else {
                newStr += str.substr(i, 9);
            }
            i += 9;
        } else {
            newStr += str.substr(i, 3);
            i += 3;
        }
    }
    return newStr;
}
function _normalizeComponentEncoding(components, protocol) {
    function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(protocol.UNRESERVED) ? str : decStr;
    }
    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "");
    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    return components;
}

function _stripLeadingZeros(str) {
    return str.replace(/^0*(.*)/, "$1") || "0";
}
function _normalizeIPv4(host, protocol) {
    var matches = host.match(protocol.IPV4ADDRESS) || [];

    var _matches = slicedToArray(matches, 2),
        address = _matches[1];

    if (address) {
        return address.split(".").map(_stripLeadingZeros).join(".");
    } else {
        return host;
    }
}
function _normalizeIPv6(host, protocol) {
    var matches = host.match(protocol.IPV6ADDRESS) || [];

    var _matches2 = slicedToArray(matches, 3),
        address = _matches2[1],
        zone = _matches2[2];

    if (address) {
        var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),
            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),
            last = _address$toLowerCase$2[0],
            first = _address$toLowerCase$2[1];

        var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
        var lastFields = last.split(":").map(_stripLeadingZeros);
        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
        var lastFieldsStart = lastFields.length - fieldCount;
        var fields = Array(fieldCount);
        for (var x = 0; x < fieldCount; ++x) {
            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';
        }
        if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
        }
        var allZeroFields = fields.reduce(function (acc, field, index) {
            if (!field || field === "0") {
                var lastLongest = acc[acc.length - 1];
                if (lastLongest && lastLongest.index + lastLongest.length === index) {
                    lastLongest.length++;
                } else {
                    acc.push({ index: index, length: 1 });
                }
            }
            return acc;
        }, []);
        var longestZeroFields = allZeroFields.sort(function (a, b) {
            return b.length - a.length;
        })[0];
        var newHost = void 0;
        if (longestZeroFields && longestZeroFields.length > 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(":") + "::" + newLast.join(":");
        } else {
            newHost = fields.join(":");
        }
        if (zone) {
            newHost += "%" + zone;
        }
        return newHost;
    } else {
        return host;
    }
}
var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;
function parse(uriString) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var components = {};
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
    var matches = uriString.match(URI_PARSE);
    if (matches) {
        if (NO_MATCH_IS_UNDEFINED) {
            //store each component
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = matches[7];
            components.fragment = matches[8];
            //fix port number
            if (isNaN(components.port)) {
                components.port = matches[5];
            }
        } else {
            //IE FIX for improper RegExp matching
            //store each component
            components.scheme = matches[1] || undefined;
            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : undefined;
            components.host = uriString.indexOf("//") !== -1 ? matches[4] : undefined;
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = uriString.indexOf("?") !== -1 ? matches[7] : undefined;
            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : undefined;
            //fix port number
            if (isNaN(components.port)) {
                components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined;
            }
        }
        if (components.host) {
            //normalize IP hosts
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
        }
        //determine reference type
        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {
            components.reference = "same-document";
        } else if (components.scheme === undefined) {
            components.reference = "relative";
        } else if (components.fragment === undefined) {
            components.reference = "absolute";
        } else {
            components.reference = "uri";
        }
        //check for reference errors
        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
            components.error = components.error || "URI is not a " + options.reference + " reference.";
        }
        //find scheme handler
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        //check if scheme can't handle IRIs
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            //if host component is a domain name
            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
                //convert Unicode IDN -> ASCII IDN
                try {
                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
                } catch (e) {
                    components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
                }
            }
            //convert IRI -> URI
            _normalizeComponentEncoding(components, URI_PROTOCOL);
        } else {
            //normalize encodings
            _normalizeComponentEncoding(components, protocol);
        }
        //perform scheme specific parsing
        if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
        }
    } else {
        components.error = components.error || "URI can not be parsed.";
    }
    return components;
}

function _recomposeAuthority(components, options) {
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];
    if (components.userinfo !== undefined) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
    }
    if (components.host !== undefined) {
        //normalize IP hosts, add brackets and escape zone separator for IPv6
        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {
            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
        }));
    }
    if (typeof components.port === "number" || typeof components.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(components.port));
    }
    return uriTokens.length ? uriTokens.join("") : undefined;
}

var RDS1 = /^\.\.?\//;
var RDS2 = /^\/\.(\/|$)/;
var RDS3 = /^\/\.\.(\/|$)/;
var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
function removeDotSegments(input) {
    var output = [];
    while (input.length) {
        if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
        } else if (input === "." || input === "..") {
            input = "";
        } else {
            var im = input.match(RDS5);
            if (im) {
                var s = im[0];
                input = input.slice(s.length);
                output.push(s);
            } else {
                throw new Error("Unexpected dot segment condition");
            }
        }
    }
    return output.join("");
}

function serialize(components) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];
    //find scheme handler
    var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
    //perform scheme specific serialization
    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
    if (components.host) {
        //if host component is an IPv6 address
        if (protocol.IPV6ADDRESS.test(components.host)) ;
        //TODO: normalize IPv6 address as per RFC 5952

        //if host component is a domain name
        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
                //convert IDN via punycode
                try {
                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
                } catch (e) {
                    components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                }
            }
    }
    //normalize encoding
    _normalizeComponentEncoding(components, protocol);
    if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme);
        uriTokens.push(":");
    }
    var authority = _recomposeAuthority(components, options);
    if (authority !== undefined) {
        if (options.reference !== "suffix") {
            uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
        }
    }
    if (components.path !== undefined) {
        var s = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
        }
        if (authority === undefined) {
            s = s.replace(/^\/\//, "/%2F"); //don't allow the path to start with "//"
        }
        uriTokens.push(s);
    }
    if (components.query !== undefined) {
        uriTokens.push("?");
        uriTokens.push(components.query);
    }
    if (components.fragment !== undefined) {
        uriTokens.push("#");
        uriTokens.push(components.fragment);
    }
    return uriTokens.join(""); //merge tokens into a string
}

function resolveComponents(base, relative) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var skipNormalization = arguments[3];

    var target = {};
    if (!skipNormalization) {
        base = parse(serialize(base, options), options); //normalize base components
        relative = parse(serialize(relative, options), options); //normalize relative components
    }
    options = options || {};
    if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        //target.authority = relative.authority;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
    } else {
        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
            //target.authority = relative.authority;
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
        } else {
            if (!relative.path) {
                target.path = base.path;
                if (relative.query !== undefined) {
                    target.query = relative.query;
                } else {
                    target.query = base.query;
                }
            } else {
                if (relative.path.charAt(0) === "/") {
                    target.path = removeDotSegments(relative.path);
                } else {
                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
                        target.path = "/" + relative.path;
                    } else if (!base.path) {
                        target.path = relative.path;
                    } else {
                        target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
                    }
                    target.path = removeDotSegments(target.path);
                }
                target.query = relative.query;
            }
            //target.authority = base.authority;
            target.userinfo = base.userinfo;
            target.host = base.host;
            target.port = base.port;
        }
        target.scheme = base.scheme;
    }
    target.fragment = relative.fragment;
    return target;
}

function resolve(baseURI, relativeURI, options) {
    var schemelessOptions = assign({ scheme: 'null' }, options);
    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
}

function normalize(uri, options) {
    if (typeof uri === "string") {
        uri = serialize(parse(uri, options), options);
    } else if (typeOf(uri) === "object") {
        uri = parse(serialize(uri, options), options);
    }
    return uri;
}

function equal(uriA, uriB, options) {
    if (typeof uriA === "string") {
        uriA = serialize(parse(uriA, options), options);
    } else if (typeOf(uriA) === "object") {
        uriA = serialize(uriA, options);
    }
    if (typeof uriB === "string") {
        uriB = serialize(parse(uriB, options), options);
    } else if (typeOf(uriB) === "object") {
        uriB = serialize(uriB, options);
    }
    return uriA === uriB;
}

function escapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
}

function unescapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
}

var handler = {
    scheme: "http",
    domainHost: true,
    parse: function parse(components, options) {
        //report missing host
        if (!components.host) {
            components.error = components.error || "HTTP URIs must have a host.";
        }
        return components;
    },
    serialize: function serialize(components, options) {
        var secure = String(components.scheme).toLowerCase() === "https";
        //normalize the default port
        if (components.port === (secure ? 443 : 80) || components.port === "") {
            components.port = undefined;
        }
        //normalize the empty path
        if (!components.path) {
            components.path = "/";
        }
        //NOTE: We do not parse query strings for HTTP URIs
        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
        //and not the HTTP spec.
        return components;
    }
};

var handler$1 = {
    scheme: "https",
    domainHost: handler.domainHost,
    parse: handler.parse,
    serialize: handler.serialize
};

function isSecure(wsComponents) {
    return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
}
//RFC 6455
var handler$2 = {
    scheme: "ws",
    domainHost: true,
    parse: function parse(components, options) {
        var wsComponents = components;
        //indicate if the secure flag is set
        wsComponents.secure = isSecure(wsComponents);
        //construct resouce name
        wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');
        wsComponents.path = undefined;
        wsComponents.query = undefined;
        return wsComponents;
    },
    serialize: function serialize(wsComponents, options) {
        //normalize the default port
        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
            wsComponents.port = undefined;
        }
        //ensure scheme matches secure flag
        if (typeof wsComponents.secure === 'boolean') {
            wsComponents.scheme = wsComponents.secure ? 'wss' : 'ws';
            wsComponents.secure = undefined;
        }
        //reconstruct path from resource name
        if (wsComponents.resourceName) {
            var _wsComponents$resourc = wsComponents.resourceName.split('?'),
                _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2),
                path = _wsComponents$resourc2[0],
                query = _wsComponents$resourc2[1];

            wsComponents.path = path && path !== '/' ? path : undefined;
            wsComponents.query = query;
            wsComponents.resourceName = undefined;
        }
        //forbid fragment component
        wsComponents.fragment = undefined;
        return wsComponents;
    }
};

var handler$3 = {
    scheme: "wss",
    domainHost: handler$2.domainHost,
    parse: handler$2.parse,
    serialize: handler$2.serialize
};

var O = {};
//RFC 3986
var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + ("\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" ) + "]";
var HEXDIG$$ = "[0-9A-Fa-f]"; //case-insensitive
var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)); //expanded
//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =
//const ATEXT$$ = "[A-Za-z0-9\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]";
//const WSP$$ = "[\\x20\\x09]";
//const OBS_QTEXT$$ = "[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)
//const QTEXT$$ = merge("[\\x21\\x23-\\x5B\\x5D-\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
//const VCHAR$$ = "[\\x21-\\x7E]";
//const WSP$$ = "[\\x20\\x09]";
//const OBS_QP$ = subexp("\\\\" + merge("[\\x00\\x0D\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
//const FWS$ = subexp(subexp(WSP$$ + "*" + "\\x0D\\x0A") + "?" + WSP$$ + "+");
//const QUOTED_PAIR$ = subexp(subexp("\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);
//const QUOTED_STRING$ = subexp('\\"' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + '\\"');
var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
var VCHAR$$ = merge(QTEXT$$, "[\\\"\\\\]");
var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
var UNRESERVED = new RegExp(UNRESERVED$$, "g");
var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
var NOT_HFVALUE = NOT_HFNAME;
function decodeUnreserved(str) {
    var decStr = pctDecChars(str);
    return !decStr.match(UNRESERVED) ? str : decStr;
}
var handler$4 = {
    scheme: "mailto",
    parse: function parse$$1(components, options) {
        var mailtoComponents = components;
        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
        mailtoComponents.path = undefined;
        if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split("&");
            for (var x = 0, xl = hfields.length; x < xl; ++x) {
                var hfield = hfields[x].split("=");
                switch (hfield[0]) {
                    case "to":
                        var toAddrs = hfield[1].split(",");
                        for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                            to.push(toAddrs[_x]);
                        }
                        break;
                    case "subject":
                        mailtoComponents.subject = unescapeComponent(hfield[1], options);
                        break;
                    case "body":
                        mailtoComponents.body = unescapeComponent(hfield[1], options);
                        break;
                    default:
                        unknownHeaders = true;
                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                        break;
                }
            }
            if (unknownHeaders) mailtoComponents.headers = headers;
        }
        mailtoComponents.query = undefined;
        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
            var addr = to[_x2].split("@");
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
                //convert Unicode IDN -> ASCII IDN
                try {
                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
                } catch (e) {
                    mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
                }
            } else {
                addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to[_x2] = addr.join("@");
        }
        return mailtoComponents;
    },
    serialize: function serialize$$1(mailtoComponents, options) {
        var components = mailtoComponents;
        var to = toArray(mailtoComponents.to);
        if (to) {
            for (var x = 0, xl = to.length; x < xl; ++x) {
                var toAddr = String(to[x]);
                var atIdx = toAddr.lastIndexOf("@");
                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
                var domain = toAddr.slice(atIdx + 1);
                //convert IDN via punycode
                try {
                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
                } catch (e) {
                    components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                }
                to[x] = localPart + "@" + domain;
            }
            components.path = to.join(",");
        }
        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
        if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
        if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
        var fields = [];
        for (var name in headers) {
            if (headers[name] !== O[name]) {
                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
        }
        if (fields.length) {
            components.query = fields.join("&");
        }
        return components;
    }
};

var URN_PARSE = /^([^\:]+)\:(.*)/;
//RFC 2141
var handler$5 = {
    scheme: "urn",
    parse: function parse$$1(components, options) {
        var matches = components.path && components.path.match(URN_PARSE);
        var urnComponents = components;
        if (matches) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = matches[1].toLowerCase();
            var nss = matches[2];
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = undefined;
            if (schemeHandler) {
                urnComponents = schemeHandler.parse(urnComponents, options);
            }
        } else {
            urnComponents.error = urnComponents.error || "URN can not be parsed.";
        }
        return urnComponents;
    },
    serialize: function serialize$$1(urnComponents, options) {
        var scheme = options.scheme || urnComponents.scheme || "urn";
        var nid = urnComponents.nid;
        var urnScheme = scheme + ":" + (options.nid || nid);
        var schemeHandler = SCHEMES[urnScheme];
        if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
        }
        var uriComponents = urnComponents;
        var nss = urnComponents.nss;
        uriComponents.path = (nid || options.nid) + ":" + nss;
        return uriComponents;
    }
};

var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
//RFC 4122
var handler$6 = {
    scheme: "urn:uuid",
    parse: function parse(urnComponents, options) {
        var uuidComponents = urnComponents;
        uuidComponents.uuid = uuidComponents.nss;
        uuidComponents.nss = undefined;
        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
        }
        return uuidComponents;
    },
    serialize: function serialize(uuidComponents, options) {
        var urnComponents = uuidComponents;
        //normalize UUID
        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
        return urnComponents;
    }
};

SCHEMES[handler.scheme] = handler;
SCHEMES[handler$1.scheme] = handler$1;
SCHEMES[handler$2.scheme] = handler$2;
SCHEMES[handler$3.scheme] = handler$3;
SCHEMES[handler$4.scheme] = handler$4;
SCHEMES[handler$5.scheme] = handler$5;
SCHEMES[handler$6.scheme] = handler$6;

exports.SCHEMES = SCHEMES;
exports.pctEncChar = pctEncChar;
exports.pctDecChars = pctDecChars;
exports.parse = parse;
exports.removeDotSegments = removeDotSegments;
exports.serialize = serialize;
exports.resolveComponents = resolveComponents;
exports.resolve = resolve;
exports.normalize = normalize;
exports.equal = equal;
exports.escapeComponent = escapeComponent;
exports.unescapeComponent = unescapeComponent;

Object.defineProperty(exports, '__esModule', { value: true });

})));

}(uri_all, uri_all.exports));

// do not edit .js files directly - edit src/index.jst



var fastDeepEqual = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};

// https://mathiasbynens.be/notes/javascript-encoding
// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
var ucs2length$1 = function ucs2length(str) {
  var length = 0
    , len = str.length
    , pos = 0
    , value;
  while (pos < len) {
    length++;
    value = str.charCodeAt(pos++);
    if (value >= 0xD800 && value <= 0xDBFF && pos < len) {
      // high surrogate, and there is a next character
      value = str.charCodeAt(pos);
      if ((value & 0xFC00) == 0xDC00) pos++; // low surrogate
    }
  }
  return length;
};

var util$8 = {
  copy: copy,
  checkDataType: checkDataType,
  checkDataTypes: checkDataTypes,
  coerceToTypes: coerceToTypes,
  toHash: toHash$1,
  getProperty: getProperty,
  escapeQuotes: escapeQuotes,
  equal: fastDeepEqual,
  ucs2length: ucs2length$1,
  varOccurences: varOccurences,
  varReplace: varReplace,
  schemaHasRules: schemaHasRules,
  schemaHasRulesExcept: schemaHasRulesExcept,
  schemaUnknownRules: schemaUnknownRules,
  toQuotedString: toQuotedString,
  getPathExpr: getPathExpr,
  getPath: getPath,
  getData: getData$1,
  unescapeFragment: unescapeFragment,
  unescapeJsonPointer: unescapeJsonPointer,
  escapeFragment: escapeFragment,
  escapeJsonPointer: escapeJsonPointer
};


function copy(o, to) {
  to = to || {};
  for (var key in o) to[key] = o[key];
  return to;
}


function checkDataType(dataType, data, strictNumbers, negate) {
  var EQUAL = negate ? ' !== ' : ' === '
    , AND = negate ? ' || ' : ' && '
    , OK = negate ? '!' : ''
    , NOT = negate ? '' : '!';
  switch (dataType) {
    case 'null': return data + EQUAL + 'null';
    case 'array': return OK + 'Array.isArray(' + data + ')';
    case 'object': return '(' + OK + data + AND +
                          'typeof ' + data + EQUAL + '"object"' + AND +
                          NOT + 'Array.isArray(' + data + '))';
    case 'integer': return '(typeof ' + data + EQUAL + '"number"' + AND +
                           NOT + '(' + data + ' % 1)' +
                           AND + data + EQUAL + data +
                           (strictNumbers ? (AND + OK + 'isFinite(' + data + ')') : '') + ')';
    case 'number': return '(typeof ' + data + EQUAL + '"' + dataType + '"' +
                          (strictNumbers ? (AND + OK + 'isFinite(' + data + ')') : '') + ')';
    default: return 'typeof ' + data + EQUAL + '"' + dataType + '"';
  }
}


function checkDataTypes(dataTypes, data, strictNumbers) {
  switch (dataTypes.length) {
    case 1: return checkDataType(dataTypes[0], data, strictNumbers, true);
    default:
      var code = '';
      var types = toHash$1(dataTypes);
      if (types.array && types.object) {
        code = types.null ? '(': '(!' + data + ' || ';
        code += 'typeof ' + data + ' !== "object")';
        delete types.null;
        delete types.array;
        delete types.object;
      }
      if (types.number) delete types.integer;
      for (var t in types)
        code += (code ? ' && ' : '' ) + checkDataType(t, data, strictNumbers, true);

      return code;
  }
}


var COERCE_TO_TYPES = toHash$1([ 'string', 'number', 'integer', 'boolean', 'null' ]);
function coerceToTypes(optionCoerceTypes, dataTypes) {
  if (Array.isArray(dataTypes)) {
    var types = [];
    for (var i=0; i<dataTypes.length; i++) {
      var t = dataTypes[i];
      if (COERCE_TO_TYPES[t]) types[types.length] = t;
      else if (optionCoerceTypes === 'array' && t === 'array') types[types.length] = t;
    }
    if (types.length) return types;
  } else if (COERCE_TO_TYPES[dataTypes]) {
    return [dataTypes];
  } else if (optionCoerceTypes === 'array' && dataTypes === 'array') {
    return ['array'];
  }
}


function toHash$1(arr) {
  var hash = {};
  for (var i=0; i<arr.length; i++) hash[arr[i]] = true;
  return hash;
}


var IDENTIFIER$1 = /^[a-z$_][a-z$_0-9]*$/i;
var SINGLE_QUOTE = /'|\\/g;
function getProperty(key) {
  return typeof key == 'number'
          ? '[' + key + ']'
          : IDENTIFIER$1.test(key)
            ? '.' + key
            : "['" + escapeQuotes(key) + "']";
}


function escapeQuotes(str) {
  return str.replace(SINGLE_QUOTE, '\\$&')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/\f/g, '\\f')
            .replace(/\t/g, '\\t');
}


function varOccurences(str, dataVar) {
  dataVar += '[^0-9]';
  var matches = str.match(new RegExp(dataVar, 'g'));
  return matches ? matches.length : 0;
}


function varReplace(str, dataVar, expr) {
  dataVar += '([^0-9])';
  expr = expr.replace(/\$/g, '$$$$');
  return str.replace(new RegExp(dataVar, 'g'), expr + '$1');
}


function schemaHasRules(schema, rules) {
  if (typeof schema == 'boolean') return !schema;
  for (var key in schema) if (rules[key]) return true;
}


function schemaHasRulesExcept(schema, rules, exceptKeyword) {
  if (typeof schema == 'boolean') return !schema && exceptKeyword != 'not';
  for (var key in schema) if (key != exceptKeyword && rules[key]) return true;
}


function schemaUnknownRules(schema, rules) {
  if (typeof schema == 'boolean') return;
  for (var key in schema) if (!rules[key]) return key;
}


function toQuotedString(str) {
  return '\'' + escapeQuotes(str) + '\'';
}


function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
  var path = jsonPointers // false by default
              ? '\'/\' + ' + expr + (isNumber ? '' : '.replace(/~/g, \'~0\').replace(/\\//g, \'~1\')')
              : (isNumber ? '\'[\' + ' + expr + ' + \']\'' : '\'[\\\'\' + ' + expr + ' + \'\\\']\'');
  return joinPaths(currentPath, path);
}


function getPath(currentPath, prop, jsonPointers) {
  var path = jsonPointers // false by default
              ? toQuotedString('/' + escapeJsonPointer(prop))
              : toQuotedString(getProperty(prop));
  return joinPaths(currentPath, path);
}


var JSON_POINTER$1 = /^\/(?:[^~]|~0|~1)*$/;
var RELATIVE_JSON_POINTER$1 = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData$1($data, lvl, paths) {
  var up, jsonPointer, data, matches;
  if ($data === '') return 'rootData';
  if ($data[0] == '/') {
    if (!JSON_POINTER$1.test($data)) throw new Error('Invalid JSON-pointer: ' + $data);
    jsonPointer = $data;
    data = 'rootData';
  } else {
    matches = $data.match(RELATIVE_JSON_POINTER$1);
    if (!matches) throw new Error('Invalid JSON-pointer: ' + $data);
    up = +matches[1];
    jsonPointer = matches[2];
    if (jsonPointer == '#') {
      if (up >= lvl) throw new Error('Cannot access property/index ' + up + ' levels up, current level is ' + lvl);
      return paths[lvl - up];
    }

    if (up > lvl) throw new Error('Cannot access data ' + up + ' levels up, current level is ' + lvl);
    data = 'data' + ((lvl - up) || '');
    if (!jsonPointer) return data;
  }

  var expr = data;
  var segments = jsonPointer.split('/');
  for (var i=0; i<segments.length; i++) {
    var segment = segments[i];
    if (segment) {
      data += getProperty(unescapeJsonPointer(segment));
      expr += ' && ' + data;
    }
  }
  return expr;
}


function joinPaths (a, b) {
  if (a == '""') return b;
  return (a + ' + ' + b).replace(/([^\\])' \+ '/g, '$1');
}


function unescapeFragment(str) {
  return unescapeJsonPointer(decodeURIComponent(str));
}


function escapeFragment(str) {
  return encodeURIComponent(escapeJsonPointer(str));
}


function escapeJsonPointer(str) {
  return str.replace(/~/g, '~0').replace(/\//g, '~1');
}


function unescapeJsonPointer(str) {
  return str.replace(/~1/g, '/').replace(/~0/g, '~');
}

var util$7 = util$8;

var schema_obj = SchemaObject$2;

function SchemaObject$2(obj) {
  util$7.copy(obj, this);
}

var jsonSchemaTraverse = {exports: {}};

var traverse$1 = jsonSchemaTraverse.exports = function (schema, opts, cb) {
  // Legacy support for v0.3.1 and earlier.
  if (typeof opts == 'function') {
    cb = opts;
    opts = {};
  }

  cb = opts.cb || cb;
  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};
  var post = cb.post || function() {};

  _traverse(opts, pre, post, schema, '', schema);
};


traverse$1.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true
};

traverse$1.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};

traverse$1.propsKeywords = {
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};

traverse$1.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};


function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema) {
      var sch = schema[key];
      if (Array.isArray(sch)) {
        if (key in traverse$1.arrayKeywords) {
          for (var i=0; i<sch.length; i++)
            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
        }
      } else if (key in traverse$1.propsKeywords) {
        if (sch && typeof sch == 'object') {
          for (var prop in sch)
            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
        }
      } else if (key in traverse$1.keywords || (opts.allKeys && !(key in traverse$1.skipKeywords))) {
        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
      }
    }
    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}


function escapeJsonPtr(str) {
  return str.replace(/~/g, '~0').replace(/\//g, '~1');
}

var URI$1 = uri_all.exports
  , equal$1 = fastDeepEqual
  , util$6 = util$8
  , SchemaObject$1 = schema_obj
  , traverse = jsonSchemaTraverse.exports;

var resolve_1 = resolve$3;

resolve$3.normalizeId = normalizeId;
resolve$3.fullPath = getFullPath;
resolve$3.url = resolveUrl;
resolve$3.ids = resolveIds;
resolve$3.inlineRef = inlineRef;
resolve$3.schema = resolveSchema;

/**
 * [resolve and compile the references ($ref)]
 * @this   Ajv
 * @param  {Function} compile reference to schema compilation funciton (localCompile)
 * @param  {Object} root object with information about the root schema for the current schema
 * @param  {String} ref reference to resolve
 * @return {Object|Function} schema object (if the schema can be inlined) or validation function
 */
function resolve$3(compile, root, ref) {
  /* jshint validthis: true */
  var refVal = this._refs[ref];
  if (typeof refVal == 'string') {
    if (this._refs[refVal]) refVal = this._refs[refVal];
    else return resolve$3.call(this, compile, root, refVal);
  }

  refVal = refVal || this._schemas[ref];
  if (refVal instanceof SchemaObject$1) {
    return inlineRef(refVal.schema, this._opts.inlineRefs)
            ? refVal.schema
            : refVal.validate || this._compile(refVal);
  }

  var res = resolveSchema.call(this, root, ref);
  var schema, v, baseId;
  if (res) {
    schema = res.schema;
    root = res.root;
    baseId = res.baseId;
  }

  if (schema instanceof SchemaObject$1) {
    v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);
  } else if (schema !== undefined) {
    v = inlineRef(schema, this._opts.inlineRefs)
        ? schema
        : compile.call(this, schema, root, undefined, baseId);
  }

  return v;
}


/**
 * Resolve schema, its root and baseId
 * @this Ajv
 * @param  {Object} root root object with properties schema, refVal, refs
 * @param  {String} ref  reference to resolve
 * @return {Object} object with properties schema, root, baseId
 */
function resolveSchema(root, ref) {
  /* jshint validthis: true */
  var p = URI$1.parse(ref)
    , refPath = _getFullPath(p)
    , baseId = getFullPath(this._getId(root.schema));
  if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
    var id = normalizeId(refPath);
    var refVal = this._refs[id];
    if (typeof refVal == 'string') {
      return resolveRecursive.call(this, root, refVal, p);
    } else if (refVal instanceof SchemaObject$1) {
      if (!refVal.validate) this._compile(refVal);
      root = refVal;
    } else {
      refVal = this._schemas[id];
      if (refVal instanceof SchemaObject$1) {
        if (!refVal.validate) this._compile(refVal);
        if (id == normalizeId(ref))
          return { schema: refVal, root: root, baseId: baseId };
        root = refVal;
      } else {
        return;
      }
    }
    if (!root.schema) return;
    baseId = getFullPath(this._getId(root.schema));
  }
  return getJsonPointer.call(this, p, baseId, root.schema, root);
}


/* @this Ajv */
function resolveRecursive(root, ref, parsedRef) {
  /* jshint validthis: true */
  var res = resolveSchema.call(this, root, ref);
  if (res) {
    var schema = res.schema;
    var baseId = res.baseId;
    root = res.root;
    var id = this._getId(schema);
    if (id) baseId = resolveUrl(baseId, id);
    return getJsonPointer.call(this, parsedRef, baseId, schema, root);
  }
}


var PREVENT_SCOPE_CHANGE = util$6.toHash(['properties', 'patternProperties', 'enum', 'dependencies', 'definitions']);
/* @this Ajv */
function getJsonPointer(parsedRef, baseId, schema, root) {
  /* jshint validthis: true */
  parsedRef.fragment = parsedRef.fragment || '';
  if (parsedRef.fragment.slice(0,1) != '/') return;
  var parts = parsedRef.fragment.split('/');

  for (var i = 1; i < parts.length; i++) {
    var part = parts[i];
    if (part) {
      part = util$6.unescapeFragment(part);
      schema = schema[part];
      if (schema === undefined) break;
      var id;
      if (!PREVENT_SCOPE_CHANGE[part]) {
        id = this._getId(schema);
        if (id) baseId = resolveUrl(baseId, id);
        if (schema.$ref) {
          var $ref = resolveUrl(baseId, schema.$ref);
          var res = resolveSchema.call(this, root, $ref);
          if (res) {
            schema = res.schema;
            root = res.root;
            baseId = res.baseId;
          }
        }
      }
    }
  }
  if (schema !== undefined && schema !== root.schema)
    return { schema: schema, root: root, baseId: baseId };
}


var SIMPLE_INLINED = util$6.toHash([
  'type', 'format', 'pattern',
  'maxLength', 'minLength',
  'maxProperties', 'minProperties',
  'maxItems', 'minItems',
  'maximum', 'minimum',
  'uniqueItems', 'multipleOf',
  'required', 'enum'
]);
function inlineRef(schema, limit) {
  if (limit === false) return false;
  if (limit === undefined || limit === true) return checkNoRef(schema);
  else if (limit) return countKeys(schema) <= limit;
}


function checkNoRef(schema) {
  var item;
  if (Array.isArray(schema)) {
    for (var i=0; i<schema.length; i++) {
      item = schema[i];
      if (typeof item == 'object' && !checkNoRef(item)) return false;
    }
  } else {
    for (var key in schema) {
      if (key == '$ref') return false;
      item = schema[key];
      if (typeof item == 'object' && !checkNoRef(item)) return false;
    }
  }
  return true;
}


function countKeys(schema) {
  var count = 0, item;
  if (Array.isArray(schema)) {
    for (var i=0; i<schema.length; i++) {
      item = schema[i];
      if (typeof item == 'object') count += countKeys(item);
      if (count == Infinity) return Infinity;
    }
  } else {
    for (var key in schema) {
      if (key == '$ref') return Infinity;
      if (SIMPLE_INLINED[key]) {
        count++;
      } else {
        item = schema[key];
        if (typeof item == 'object') count += countKeys(item) + 1;
        if (count == Infinity) return Infinity;
      }
    }
  }
  return count;
}


function getFullPath(id, normalize) {
  if (normalize !== false) id = normalizeId(id);
  var p = URI$1.parse(id);
  return _getFullPath(p);
}


function _getFullPath(p) {
  return URI$1.serialize(p).split('#')[0] + '#';
}


var TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id) {
  return id ? id.replace(TRAILING_SLASH_HASH, '') : '';
}


function resolveUrl(baseId, id) {
  id = normalizeId(id);
  return URI$1.resolve(baseId, id);
}


/* @this Ajv */
function resolveIds(schema) {
  var schemaId = normalizeId(this._getId(schema));
  var baseIds = {'': schemaId};
  var fullPaths = {'': getFullPath(schemaId, false)};
  var localRefs = {};
  var self = this;

  traverse(schema, {allKeys: true}, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (jsonPtr === '') return;
    var id = self._getId(sch);
    var baseId = baseIds[parentJsonPtr];
    var fullPath = fullPaths[parentJsonPtr] + '/' + parentKeyword;
    if (keyIndex !== undefined)
      fullPath += '/' + (typeof keyIndex == 'number' ? keyIndex : util$6.escapeFragment(keyIndex));

    if (typeof id == 'string') {
      id = baseId = normalizeId(baseId ? URI$1.resolve(baseId, id) : id);

      var refVal = self._refs[id];
      if (typeof refVal == 'string') refVal = self._refs[refVal];
      if (refVal && refVal.schema) {
        if (!equal$1(sch, refVal.schema))
          throw new Error('id "' + id + '" resolves to more than one schema');
      } else if (id != normalizeId(fullPath)) {
        if (id[0] == '#') {
          if (localRefs[id] && !equal$1(sch, localRefs[id]))
            throw new Error('id "' + id + '" resolves to more than one schema');
          localRefs[id] = sch;
        } else {
          self._refs[id] = fullPath;
        }
      }
    }
    baseIds[jsonPtr] = baseId;
    fullPaths[jsonPtr] = fullPath;
  });

  return localRefs;
}

var resolve$2 = resolve_1;

var error_classes = {
  Validation: errorSubclass(ValidationError$1),
  MissingRef: errorSubclass(MissingRefError$1)
};


function ValidationError$1(errors) {
  this.message = 'validation failed';
  this.errors = errors;
  this.ajv = this.validation = true;
}


MissingRefError$1.message = function (baseId, ref) {
  return 'can\'t resolve reference ' + ref + ' from id ' + baseId;
};


function MissingRefError$1(baseId, ref, message) {
  this.message = message || MissingRefError$1.message(baseId, ref);
  this.missingRef = resolve$2.url(baseId, ref);
  this.missingSchema = resolve$2.normalizeId(resolve$2.fullPath(this.missingRef));
}


function errorSubclass(Subclass) {
  Subclass.prototype = Object.create(Error.prototype);
  Subclass.prototype.constructor = Subclass;
  return Subclass;
}

var fastJsonStableStringify = function (data, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = { cmp: opts };
    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;

    var cmp = opts.cmp && (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (node) {
        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }

        if (node === undefined) return;
        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';
        if (typeof node !== 'object') return JSON.stringify(node);

        var i, out;
        if (Array.isArray(node)) {
            out = '[';
            for (i = 0; i < node.length; i++) {
                if (i) out += ',';
                out += stringify(node[i]) || 'null';
            }
            return out + ']';
        }

        if (node === null) return 'null';

        if (seen.indexOf(node) !== -1) {
            if (cycles) return JSON.stringify('__cycle__');
            throw new TypeError('Converting circular structure to JSON');
        }

        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = '';
        for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = stringify(node[key]);

            if (!value) continue;
            if (out) out += ',';
            out += JSON.stringify(key) + ':' + value;
        }
        seen.splice(seenIndex, 1);
        return '{' + out + '}';
    })(data);
};

var validate$1 = function generate_validate(it, $keyword, $ruleType) {
  var out = '';
  var $async = it.schema.$async === true,
    $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, '$ref'),
    $id = it.self._getId(it.schema);
  if (it.opts.strictKeywords) {
    var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
    if ($unknownKwd) {
      var $keywordsMsg = 'unknown keyword: ' + $unknownKwd;
      if (it.opts.strictKeywords === 'log') it.logger.warn($keywordsMsg);
      else throw new Error($keywordsMsg);
    }
  }
  if (it.isTop) {
    out += ' var validate = ';
    if ($async) {
      it.async = true;
      out += 'async ';
    }
    out += 'function(data, dataPath, parentData, parentDataProperty, rootData) { \'use strict\'; ';
    if ($id && (it.opts.sourceCode || it.opts.processCode)) {
      out += ' ' + ('/\*# sourceURL=' + $id + ' */') + ' ';
    }
  }
  if (typeof it.schema == 'boolean' || !($refKeywords || it.schema.$ref)) {
    var $keyword = 'false schema';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = 'data' + ($dataLvl || '');
    var $valid = 'valid' + $lvl;
    if (it.schema === false) {
      if (it.isTop) {
        $breakOnError = true;
      } else {
        out += ' var ' + ($valid) + ' = false; ';
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || 'false schema') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
        if (it.opts.messages !== false) {
          out += ' , message: \'boolean schema is false\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
    } else {
      if (it.isTop) {
        if ($async) {
          out += ' return data; ';
        } else {
          out += ' validate.errors = null; return true; ';
        }
      } else {
        out += ' var ' + ($valid) + ' = true; ';
      }
    }
    if (it.isTop) {
      out += ' }; return validate; ';
    }
    return out;
  }
  if (it.isTop) {
    var $top = it.isTop,
      $lvl = it.level = 0,
      $dataLvl = it.dataLevel = 0,
      $data = 'data';
    it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
    it.baseId = it.baseId || it.rootId;
    delete it.isTop;
    it.dataPathArr = [""];
    if (it.schema.default !== undefined && it.opts.useDefaults && it.opts.strictDefaults) {
      var $defaultMsg = 'default is ignored in the schema root';
      if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
      else throw new Error($defaultMsg);
    }
    out += ' var vErrors = null; ';
    out += ' var errors = 0;     ';
    out += ' if (rootData === undefined) rootData = data; ';
  } else {
    var $lvl = it.level,
      $dataLvl = it.dataLevel,
      $data = 'data' + ($dataLvl || '');
    if ($id) it.baseId = it.resolve.url(it.baseId, $id);
    if ($async && !it.async) throw new Error('async schema in sync schema');
    out += ' var errs_' + ($lvl) + ' = errors;';
  }
  var $valid = 'valid' + $lvl,
    $breakOnError = !it.opts.allErrors,
    $closingBraces1 = '',
    $closingBraces2 = '';
  var $errorKeyword;
  var $typeSchema = it.schema.type,
    $typeIsArray = Array.isArray($typeSchema);
  if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
    if ($typeIsArray) {
      if ($typeSchema.indexOf('null') == -1) $typeSchema = $typeSchema.concat('null');
    } else if ($typeSchema != 'null') {
      $typeSchema = [$typeSchema, 'null'];
      $typeIsArray = true;
    }
  }
  if ($typeIsArray && $typeSchema.length == 1) {
    $typeSchema = $typeSchema[0];
    $typeIsArray = false;
  }
  if (it.schema.$ref && $refKeywords) {
    if (it.opts.extendRefs == 'fail') {
      throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
    } else if (it.opts.extendRefs !== true) {
      $refKeywords = false;
      it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
    }
  }
  if (it.schema.$comment && it.opts.$comment) {
    out += ' ' + (it.RULES.all.$comment.code(it, '$comment'));
  }
  if ($typeSchema) {
    if (it.opts.coerceTypes) {
      var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
    }
    var $rulesGroup = it.RULES.types[$typeSchema];
    if ($coerceToTypes || $typeIsArray || $rulesGroup === true || ($rulesGroup && !$shouldUseGroup($rulesGroup))) {
      var $schemaPath = it.schemaPath + '.type',
        $errSchemaPath = it.errSchemaPath + '/type';
      var $schemaPath = it.schemaPath + '.type',
        $errSchemaPath = it.errSchemaPath + '/type',
        $method = $typeIsArray ? 'checkDataTypes' : 'checkDataType';
      out += ' if (' + (it.util[$method]($typeSchema, $data, it.opts.strictNumbers, true)) + ') { ';
      if ($coerceToTypes) {
        var $dataType = 'dataType' + $lvl,
          $coerced = 'coerced' + $lvl;
        out += ' var ' + ($dataType) + ' = typeof ' + ($data) + '; var ' + ($coerced) + ' = undefined; ';
        if (it.opts.coerceTypes == 'array') {
          out += ' if (' + ($dataType) + ' == \'object\' && Array.isArray(' + ($data) + ') && ' + ($data) + '.length == 1) { ' + ($data) + ' = ' + ($data) + '[0]; ' + ($dataType) + ' = typeof ' + ($data) + '; if (' + (it.util.checkDataType(it.schema.type, $data, it.opts.strictNumbers)) + ') ' + ($coerced) + ' = ' + ($data) + '; } ';
        }
        out += ' if (' + ($coerced) + ' !== undefined) ; ';
        var arr1 = $coerceToTypes;
        if (arr1) {
          var $type, $i = -1,
            l1 = arr1.length - 1;
          while ($i < l1) {
            $type = arr1[$i += 1];
            if ($type == 'string') {
              out += ' else if (' + ($dataType) + ' == \'number\' || ' + ($dataType) + ' == \'boolean\') ' + ($coerced) + ' = \'\' + ' + ($data) + '; else if (' + ($data) + ' === null) ' + ($coerced) + ' = \'\'; ';
            } else if ($type == 'number' || $type == 'integer') {
              out += ' else if (' + ($dataType) + ' == \'boolean\' || ' + ($data) + ' === null || (' + ($dataType) + ' == \'string\' && ' + ($data) + ' && ' + ($data) + ' == +' + ($data) + ' ';
              if ($type == 'integer') {
                out += ' && !(' + ($data) + ' % 1)';
              }
              out += ')) ' + ($coerced) + ' = +' + ($data) + '; ';
            } else if ($type == 'boolean') {
              out += ' else if (' + ($data) + ' === \'false\' || ' + ($data) + ' === 0 || ' + ($data) + ' === null) ' + ($coerced) + ' = false; else if (' + ($data) + ' === \'true\' || ' + ($data) + ' === 1) ' + ($coerced) + ' = true; ';
            } else if ($type == 'null') {
              out += ' else if (' + ($data) + ' === \'\' || ' + ($data) + ' === 0 || ' + ($data) + ' === false) ' + ($coerced) + ' = null; ';
            } else if (it.opts.coerceTypes == 'array' && $type == 'array') {
              out += ' else if (' + ($dataType) + ' == \'string\' || ' + ($dataType) + ' == \'number\' || ' + ($dataType) + ' == \'boolean\' || ' + ($data) + ' == null) ' + ($coerced) + ' = [' + ($data) + ']; ';
            }
          }
        }
        out += ' else {   ';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
          if ($typeIsArray) {
            out += '' + ($typeSchema.join(","));
          } else {
            out += '' + ($typeSchema);
          }
          out += '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should be ';
            if ($typeIsArray) {
              out += '' + ($typeSchema.join(","));
            } else {
              out += '' + ($typeSchema);
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } if (' + ($coerced) + ' !== undefined) {  ';
        var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
          $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
        out += ' ' + ($data) + ' = ' + ($coerced) + '; ';
        if (!$dataLvl) {
          out += 'if (' + ($parentData) + ' !== undefined)';
        }
        out += ' ' + ($parentData) + '[' + ($parentDataProperty) + '] = ' + ($coerced) + '; } ';
      } else {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
          if ($typeIsArray) {
            out += '' + ($typeSchema.join(","));
          } else {
            out += '' + ($typeSchema);
          }
          out += '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should be ';
            if ($typeIsArray) {
              out += '' + ($typeSchema.join(","));
            } else {
              out += '' + ($typeSchema);
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
      }
      out += ' } ';
    }
  }
  if (it.schema.$ref && !$refKeywords) {
    out += ' ' + (it.RULES.all.$ref.code(it, '$ref')) + ' ';
    if ($breakOnError) {
      out += ' } if (errors === ';
      if ($top) {
        out += '0';
      } else {
        out += 'errs_' + ($lvl);
      }
      out += ') { ';
      $closingBraces2 += '}';
    }
  } else {
    var arr2 = it.RULES;
    if (arr2) {
      var $rulesGroup, i2 = -1,
        l2 = arr2.length - 1;
      while (i2 < l2) {
        $rulesGroup = arr2[i2 += 1];
        if ($shouldUseGroup($rulesGroup)) {
          if ($rulesGroup.type) {
            out += ' if (' + (it.util.checkDataType($rulesGroup.type, $data, it.opts.strictNumbers)) + ') { ';
          }
          if (it.opts.useDefaults) {
            if ($rulesGroup.type == 'object' && it.schema.properties) {
              var $schema = it.schema.properties,
                $schemaKeys = Object.keys($schema);
              var arr3 = $schemaKeys;
              if (arr3) {
                var $propertyKey, i3 = -1,
                  l3 = arr3.length - 1;
                while (i3 < l3) {
                  $propertyKey = arr3[i3 += 1];
                  var $sch = $schema[$propertyKey];
                  if ($sch.default !== undefined) {
                    var $passData = $data + it.util.getProperty($propertyKey);
                    if (it.compositeRule) {
                      if (it.opts.strictDefaults) {
                        var $defaultMsg = 'default is ignored for: ' + $passData;
                        if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
                        else throw new Error($defaultMsg);
                      }
                    } else {
                      out += ' if (' + ($passData) + ' === undefined ';
                      if (it.opts.useDefaults == 'empty') {
                        out += ' || ' + ($passData) + ' === null || ' + ($passData) + ' === \'\' ';
                      }
                      out += ' ) ' + ($passData) + ' = ';
                      if (it.opts.useDefaults == 'shared') {
                        out += ' ' + (it.useDefault($sch.default)) + ' ';
                      } else {
                        out += ' ' + (JSON.stringify($sch.default)) + ' ';
                      }
                      out += '; ';
                    }
                  }
                }
              }
            } else if ($rulesGroup.type == 'array' && Array.isArray(it.schema.items)) {
              var arr4 = it.schema.items;
              if (arr4) {
                var $sch, $i = -1,
                  l4 = arr4.length - 1;
                while ($i < l4) {
                  $sch = arr4[$i += 1];
                  if ($sch.default !== undefined) {
                    var $passData = $data + '[' + $i + ']';
                    if (it.compositeRule) {
                      if (it.opts.strictDefaults) {
                        var $defaultMsg = 'default is ignored for: ' + $passData;
                        if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
                        else throw new Error($defaultMsg);
                      }
                    } else {
                      out += ' if (' + ($passData) + ' === undefined ';
                      if (it.opts.useDefaults == 'empty') {
                        out += ' || ' + ($passData) + ' === null || ' + ($passData) + ' === \'\' ';
                      }
                      out += ' ) ' + ($passData) + ' = ';
                      if (it.opts.useDefaults == 'shared') {
                        out += ' ' + (it.useDefault($sch.default)) + ' ';
                      } else {
                        out += ' ' + (JSON.stringify($sch.default)) + ' ';
                      }
                      out += '; ';
                    }
                  }
                }
              }
            }
          }
          var arr5 = $rulesGroup.rules;
          if (arr5) {
            var $rule, i5 = -1,
              l5 = arr5.length - 1;
            while (i5 < l5) {
              $rule = arr5[i5 += 1];
              if ($shouldUseRule($rule)) {
                var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                if ($code) {
                  out += ' ' + ($code) + ' ';
                  if ($breakOnError) {
                    $closingBraces1 += '}';
                  }
                }
              }
            }
          }
          if ($breakOnError) {
            out += ' ' + ($closingBraces1) + ' ';
            $closingBraces1 = '';
          }
          if ($rulesGroup.type) {
            out += ' } ';
            if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
              out += ' else { ';
              var $schemaPath = it.schemaPath + '.type',
                $errSchemaPath = it.errSchemaPath + '/type';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
                if ($typeIsArray) {
                  out += '' + ($typeSchema.join(","));
                } else {
                  out += '' + ($typeSchema);
                }
                out += '\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \'should be ';
                  if ($typeIsArray) {
                    out += '' + ($typeSchema.join(","));
                  } else {
                    out += '' + ($typeSchema);
                  }
                  out += '\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + (__err) + ']); ';
                } else {
                  out += ' validate.errors = [' + (__err) + ']; return false; ';
                }
              } else {
                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }
              out += ' } ';
            }
          }
          if ($breakOnError) {
            out += ' if (errors === ';
            if ($top) {
              out += '0';
            } else {
              out += 'errs_' + ($lvl);
            }
            out += ') { ';
            $closingBraces2 += '}';
          }
        }
      }
    }
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces2) + ' ';
  }
  if ($top) {
    if ($async) {
      out += ' if (errors === 0) return data;           ';
      out += ' else throw new ValidationError(vErrors); ';
    } else {
      out += ' validate.errors = vErrors; ';
      out += ' return errors === 0;       ';
    }
    out += ' }; return validate;';
  } else {
    out += ' var ' + ($valid) + ' = errors === errs_' + ($lvl) + ';';
  }

  function $shouldUseGroup($rulesGroup) {
    var rules = $rulesGroup.rules;
    for (var i = 0; i < rules.length; i++)
      if ($shouldUseRule(rules[i])) return true;
  }

  function $shouldUseRule($rule) {
    return it.schema[$rule.keyword] !== undefined || ($rule.implements && $ruleImplementsSomeKeyword($rule));
  }

  function $ruleImplementsSomeKeyword($rule) {
    var impl = $rule.implements;
    for (var i = 0; i < impl.length; i++)
      if (it.schema[impl[i]] !== undefined) return true;
  }
  return out;
};

var resolve$1 = resolve_1
  , util$5 = util$8
  , errorClasses$1 = error_classes
  , stableStringify$1 = fastJsonStableStringify;

var validateGenerator = validate$1;

/**
 * Functions below are used inside compiled validations function
 */

var ucs2length = util$5.ucs2length;
var equal = fastDeepEqual;

// this error is thrown by async schemas to return validation errors via exception
var ValidationError = errorClasses$1.Validation;

var compile_1 = compile$1;


/**
 * Compiles schema to validation function
 * @this   Ajv
 * @param  {Object} schema schema object
 * @param  {Object} root object with information about the root schema for this schema
 * @param  {Object} localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution
 * @param  {String} baseId base ID for IDs in the schema
 * @return {Function} validation function
 */
function compile$1(schema, root, localRefs, baseId) {
  /* jshint validthis: true, evil: true */
  /* eslint no-shadow: 0 */
  var self = this
    , opts = this._opts
    , refVal = [ undefined ]
    , refs = {}
    , patterns = []
    , patternsHash = {}
    , defaults = []
    , defaultsHash = {}
    , customRules = [];

  root = root || { schema: schema, refVal: refVal, refs: refs };

  var c = checkCompiling.call(this, schema, root, baseId);
  var compilation = this._compilations[c.index];
  if (c.compiling) return (compilation.callValidate = callValidate);

  var formats = this._formats;
  var RULES = this.RULES;

  try {
    var v = localCompile(schema, root, localRefs, baseId);
    compilation.validate = v;
    var cv = compilation.callValidate;
    if (cv) {
      cv.schema = v.schema;
      cv.errors = null;
      cv.refs = v.refs;
      cv.refVal = v.refVal;
      cv.root = v.root;
      cv.$async = v.$async;
      if (opts.sourceCode) cv.source = v.source;
    }
    return v;
  } finally {
    endCompiling.call(this, schema, root, baseId);
  }

  /* @this   {*} - custom context, see passContext option */
  function callValidate() {
    /* jshint validthis: true */
    var validate = compilation.validate;
    var result = validate.apply(this, arguments);
    callValidate.errors = validate.errors;
    return result;
  }

  function localCompile(_schema, _root, localRefs, baseId) {
    var isRoot = !_root || (_root && _root.schema == _schema);
    if (_root.schema != root.schema)
      return compile$1.call(self, _schema, _root, localRefs, baseId);

    var $async = _schema.$async === true;

    var sourceCode = validateGenerator({
      isTop: true,
      schema: _schema,
      isRoot: isRoot,
      baseId: baseId,
      root: _root,
      schemaPath: '',
      errSchemaPath: '#',
      errorPath: '""',
      MissingRefError: errorClasses$1.MissingRef,
      RULES: RULES,
      validate: validateGenerator,
      util: util$5,
      resolve: resolve$1,
      resolveRef: resolveRef,
      usePattern: usePattern,
      useDefault: useDefault,
      useCustomRule: useCustomRule,
      opts: opts,
      formats: formats,
      logger: self.logger,
      self: self
    });

    sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode)
                   + vars(defaults, defaultCode) + vars(customRules, customRuleCode$1)
                   + sourceCode;

    if (opts.processCode) sourceCode = opts.processCode(sourceCode, _schema);
    // console.log('\n\n\n *** \n', JSON.stringify(sourceCode));
    var validate;
    try {
      var makeValidate = new Function(
        'self',
        'RULES',
        'formats',
        'root',
        'refVal',
        'defaults',
        'customRules',
        'equal',
        'ucs2length',
        'ValidationError',
        sourceCode
      );

      validate = makeValidate(
        self,
        RULES,
        formats,
        root,
        refVal,
        defaults,
        customRules,
        equal,
        ucs2length,
        ValidationError
      );

      refVal[0] = validate;
    } catch(e) {
      self.logger.error('Error compiling schema, function code:', sourceCode);
      throw e;
    }

    validate.schema = _schema;
    validate.errors = null;
    validate.refs = refs;
    validate.refVal = refVal;
    validate.root = isRoot ? validate : _root;
    if ($async) validate.$async = true;
    if (opts.sourceCode === true) {
      validate.source = {
        code: sourceCode,
        patterns: patterns,
        defaults: defaults
      };
    }

    return validate;
  }

  function resolveRef(baseId, ref, isRoot) {
    ref = resolve$1.url(baseId, ref);
    var refIndex = refs[ref];
    var _refVal, refCode;
    if (refIndex !== undefined) {
      _refVal = refVal[refIndex];
      refCode = 'refVal[' + refIndex + ']';
      return resolvedRef(_refVal, refCode);
    }
    if (!isRoot && root.refs) {
      var rootRefId = root.refs[ref];
      if (rootRefId !== undefined) {
        _refVal = root.refVal[rootRefId];
        refCode = addLocalRef(ref, _refVal);
        return resolvedRef(_refVal, refCode);
      }
    }

    refCode = addLocalRef(ref);
    var v = resolve$1.call(self, localCompile, root, ref);
    if (v === undefined) {
      var localSchema = localRefs && localRefs[ref];
      if (localSchema) {
        v = resolve$1.inlineRef(localSchema, opts.inlineRefs)
            ? localSchema
            : compile$1.call(self, localSchema, root, localRefs, baseId);
      }
    }

    if (v === undefined) {
      removeLocalRef(ref);
    } else {
      replaceLocalRef(ref, v);
      return resolvedRef(v, refCode);
    }
  }

  function addLocalRef(ref, v) {
    var refId = refVal.length;
    refVal[refId] = v;
    refs[ref] = refId;
    return 'refVal' + refId;
  }

  function removeLocalRef(ref) {
    delete refs[ref];
  }

  function replaceLocalRef(ref, v) {
    var refId = refs[ref];
    refVal[refId] = v;
  }

  function resolvedRef(refVal, code) {
    return typeof refVal == 'object' || typeof refVal == 'boolean'
            ? { code: code, schema: refVal, inline: true }
            : { code: code, $async: refVal && !!refVal.$async };
  }

  function usePattern(regexStr) {
    var index = patternsHash[regexStr];
    if (index === undefined) {
      index = patternsHash[regexStr] = patterns.length;
      patterns[index] = regexStr;
    }
    return 'pattern' + index;
  }

  function useDefault(value) {
    switch (typeof value) {
      case 'boolean':
      case 'number':
        return '' + value;
      case 'string':
        return util$5.toQuotedString(value);
      case 'object':
        if (value === null) return 'null';
        var valueStr = stableStringify$1(value);
        var index = defaultsHash[valueStr];
        if (index === undefined) {
          index = defaultsHash[valueStr] = defaults.length;
          defaults[index] = value;
        }
        return 'default' + index;
    }
  }

  function useCustomRule(rule, schema, parentSchema, it) {
    if (self._opts.validateSchema !== false) {
      var deps = rule.definition.dependencies;
      if (deps && !deps.every(function(keyword) {
        return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
      }))
        throw new Error('parent schema must have all required keywords: ' + deps.join(','));

      var validateSchema = rule.definition.validateSchema;
      if (validateSchema) {
        var valid = validateSchema(schema);
        if (!valid) {
          var message = 'keyword schema is invalid: ' + self.errorsText(validateSchema.errors);
          if (self._opts.validateSchema == 'log') self.logger.error(message);
          else throw new Error(message);
        }
      }
    }

    var compile = rule.definition.compile
      , inline = rule.definition.inline
      , macro = rule.definition.macro;

    var validate;
    if (compile) {
      validate = compile.call(self, schema, parentSchema, it);
    } else if (macro) {
      validate = macro.call(self, schema, parentSchema, it);
      if (opts.validateSchema !== false) self.validateSchema(validate, true);
    } else if (inline) {
      validate = inline.call(self, it, rule.keyword, schema, parentSchema);
    } else {
      validate = rule.definition.validate;
      if (!validate) return;
    }

    if (validate === undefined)
      throw new Error('custom keyword "' + rule.keyword + '"failed to compile');

    var index = customRules.length;
    customRules[index] = validate;

    return {
      code: 'customRule' + index,
      validate: validate
    };
  }
}


/**
 * Checks if the schema is currently compiled
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 * @return {Object} object with properties "index" (compilation index) and "compiling" (boolean)
 */
function checkCompiling(schema, root, baseId) {
  /* jshint validthis: true */
  var index = compIndex.call(this, schema, root, baseId);
  if (index >= 0) return { index: index, compiling: true };
  index = this._compilations.length;
  this._compilations[index] = {
    schema: schema,
    root: root,
    baseId: baseId
  };
  return { index: index, compiling: false };
}


/**
 * Removes the schema from the currently compiled list
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 */
function endCompiling(schema, root, baseId) {
  /* jshint validthis: true */
  var i = compIndex.call(this, schema, root, baseId);
  if (i >= 0) this._compilations.splice(i, 1);
}


/**
 * Index of schema compilation in the currently compiled list
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 * @return {Integer} compilation index
 */
function compIndex(schema, root, baseId) {
  /* jshint validthis: true */
  for (var i=0; i<this._compilations.length; i++) {
    var c = this._compilations[i];
    if (c.schema == schema && c.root == root && c.baseId == baseId) return i;
  }
  return -1;
}


function patternCode(i, patterns) {
  return 'var pattern' + i + ' = new RegExp(' + util$5.toQuotedString(patterns[i]) + ');';
}


function defaultCode(i) {
  return 'var default' + i + ' = defaults[' + i + '];';
}


function refValCode(i, refVal) {
  return refVal[i] === undefined ? '' : 'var refVal' + i + ' = refVal[' + i + '];';
}


function customRuleCode$1(i) {
  return 'var customRule' + i + ' = customRules[' + i + '];';
}


function vars(arr, statement) {
  if (!arr.length) return '';
  var code = '';
  for (var i=0; i<arr.length; i++)
    code += statement(i, arr);
  return code;
}

var cache$1 = {exports: {}};

var Cache$1 = cache$1.exports = function Cache() {
  this._cache = {};
};


Cache$1.prototype.put = function Cache_put(key, value) {
  this._cache[key] = value;
};


Cache$1.prototype.get = function Cache_get(key) {
  return this._cache[key];
};


Cache$1.prototype.del = function Cache_del(key) {
  delete this._cache[key];
};


Cache$1.prototype.clear = function Cache_clear() {
  this._cache = {};
};

var util$4 = util$8;

var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var DAYS = [0,31,28,31,30,31,30,31,31,30,31,30,31];
var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
// uri-template: https://tools.ietf.org/html/rfc6570
var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
// For the source: https://gist.github.com/dperini/729294
// For test cases: https://mathiasbynens.be/demo/url-regex
// @todo Delete current URL in favour of the commented out URL rule when this issue is fixed https://github.com/eslint/eslint/issues/7983.
// var URL = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u{00a1}-\u{ffff}0-9]+-)*[a-z\u{00a1}-\u{ffff}0-9]+)(?:\.(?:[a-z\u{00a1}-\u{ffff}0-9]+-)*[a-z\u{00a1}-\u{ffff}0-9]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu;
var URL$1 = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;


var formats_1 = formats$1;

function formats$1(mode) {
  mode = mode == 'full' ? 'full' : 'fast';
  return util$4.copy(formats$1[mode]);
}


formats$1.fast = {
  // date: http://tools.ietf.org/html/rfc3339#section-5.6
  date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
  // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
  time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
  'date-time': /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
  // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
  uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
  'uri-reference': /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
  'uri-template': URITEMPLATE,
  url: URL$1,
  // email (sources from jsen validator):
  // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
  // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
  email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
  hostname: HOSTNAME,
  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex: regex,
  // uuid: http://tools.ietf.org/html/rfc4122
  uuid: UUID,
  // JSON-pointer: https://tools.ietf.org/html/rfc6901
  // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
  'json-pointer': JSON_POINTER,
  'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,
  // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
  'relative-json-pointer': RELATIVE_JSON_POINTER
};


formats$1.full = {
  date: date,
  time: time,
  'date-time': date_time,
  uri: uri,
  'uri-reference': URIREF,
  'uri-template': URITEMPLATE,
  url: URL$1,
  email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
  hostname: HOSTNAME,
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex: regex,
  uuid: UUID,
  'json-pointer': JSON_POINTER,
  'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,
  'relative-json-pointer': RELATIVE_JSON_POINTER
};


function isLeapYear(year) {
  // https://tools.ietf.org/html/rfc3339#appendix-C
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}


function date(str) {
  // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
  var matches = str.match(DATE);
  if (!matches) return false;

  var year = +matches[1];
  var month = +matches[2];
  var day = +matches[3];

  return month >= 1 && month <= 12 && day >= 1 &&
          day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
}


function time(str, full) {
  var matches = str.match(TIME);
  if (!matches) return false;

  var hour = matches[1];
  var minute = matches[2];
  var second = matches[3];
  var timeZone = matches[5];
  return ((hour <= 23 && minute <= 59 && second <= 59) ||
          (hour == 23 && minute == 59 && second == 60)) &&
         (!full || timeZone);
}


var DATE_TIME_SEPARATOR = /t|\s/i;
function date_time(str) {
  // http://tools.ietf.org/html/rfc3339#section-5.6
  var dateTime = str.split(DATE_TIME_SEPARATOR);
  return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
}


var NOT_URI_FRAGMENT = /\/|:/;
function uri(str) {
  // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required "."
  return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}


var Z_ANCHOR = /[^\\]\\Z/;
function regex(str) {
  if (Z_ANCHOR.test(str)) return false;
  try {
    new RegExp(str);
    return true;
  } catch(e) {
    return false;
  }
}

var ref = function generate_ref(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $async, $refCode;
  if ($schema == '#' || $schema == '#/') {
    if (it.isRoot) {
      $async = it.async;
      $refCode = 'validate';
    } else {
      $async = it.root.schema.$async === true;
      $refCode = 'root.refVal[0]';
    }
  } else {
    var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
    if ($refVal === undefined) {
      var $message = it.MissingRefError.message(it.baseId, $schema);
      if (it.opts.missingRefs == 'fail') {
        it.logger.error($message);
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('$ref') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { ref: \'' + (it.util.escapeQuotes($schema)) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'can\\\'t resolve reference ' + (it.util.escapeQuotes($schema)) + '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        if ($breakOnError) {
          out += ' if (false) { ';
        }
      } else if (it.opts.missingRefs == 'ignore') {
        it.logger.warn($message);
        if ($breakOnError) {
          out += ' if (true) { ';
        }
      } else {
        throw new it.MissingRefError(it.baseId, $schema, $message);
      }
    } else if ($refVal.inline) {
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      $it.schema = $refVal.schema;
      $it.schemaPath = '';
      $it.errSchemaPath = $schema;
      var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
      out += ' ' + ($code) + ' ';
      if ($breakOnError) {
        out += ' if (' + ($nextValid) + ') { ';
      }
    } else {
      $async = $refVal.$async === true || (it.async && $refVal.$async !== false);
      $refCode = $refVal.code;
    }
  }
  if ($refCode) {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    if (it.opts.passContext) {
      out += ' ' + ($refCode) + '.call(this, ';
    } else {
      out += ' ' + ($refCode) + '( ';
    }
    out += ' ' + ($data) + ', (dataPath || \'\')';
    if (it.errorPath != '""') {
      out += ' + ' + (it.errorPath);
    }
    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ', rootData)  ';
    var __callValidate = out;
    out = $$outStack.pop();
    if ($async) {
      if (!it.async) throw new Error('async schema referenced by sync schema');
      if ($breakOnError) {
        out += ' var ' + ($valid) + '; ';
      }
      out += ' try { await ' + (__callValidate) + '; ';
      if ($breakOnError) {
        out += ' ' + ($valid) + ' = true; ';
      }
      out += ' } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ';
      if ($breakOnError) {
        out += ' ' + ($valid) + ' = false; ';
      }
      out += ' } ';
      if ($breakOnError) {
        out += ' if (' + ($valid) + ') { ';
      }
    } else {
      out += ' if (!' + (__callValidate) + ') { if (vErrors === null) vErrors = ' + ($refCode) + '.errors; else vErrors = vErrors.concat(' + ($refCode) + '.errors); errors = vErrors.length; } ';
      if ($breakOnError) {
        out += ' else { ';
      }
    }
  }
  return out;
};

var allOf = function generate_allOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $currentBaseId = $it.baseId,
    $allSchemasEmpty = true;
  var arr1 = $schema;
  if (arr1) {
    var $sch, $i = -1,
      l1 = arr1.length - 1;
    while ($i < l1) {
      $sch = arr1[$i += 1];
      if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {
        $allSchemasEmpty = false;
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
        if ($breakOnError) {
          out += ' if (' + ($nextValid) + ') { ';
          $closingBraces += '}';
        }
      }
    }
  }
  if ($breakOnError) {
    if ($allSchemasEmpty) {
      out += ' if (true) { ';
    } else {
      out += ' ' + ($closingBraces.slice(0, -1)) + ' ';
    }
  }
  return out;
};

var anyOf = function generate_anyOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $noEmptySchema = $schema.every(function($sch) {
    return (it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all));
  });
  if ($noEmptySchema) {
    var $currentBaseId = $it.baseId;
    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = false;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var arr1 = $schema;
    if (arr1) {
      var $sch, $i = -1,
        l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
        out += ' ' + ($valid) + ' = ' + ($valid) + ' || ' + ($nextValid) + '; if (!' + ($valid) + ') { ';
        $closingBraces += '}';
      }
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($closingBraces) + ' if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('anyOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should match some schema in anyOf\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }
    out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
    if (it.opts.allErrors) {
      out += ' } ';
    }
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
};

var comment = function generate_comment(it, $keyword, $ruleType) {
  var out = ' ';
  var $schema = it.schema[$keyword];
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  !it.opts.allErrors;
  var $comment = it.util.toQuotedString($schema);
  if (it.opts.$comment === true) {
    out += ' console.log(' + ($comment) + ');';
  } else if (typeof it.opts.$comment == 'function') {
    out += ' self._opts.$comment(' + ($comment) + ', ' + (it.util.toQuotedString($errSchemaPath)) + ', validate.root.schema);';
  }
  return out;
};

var _const = function generate_const(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
  }
  if (!$isData) {
    out += ' var schema' + ($lvl) + ' = validate.schema' + ($schemaPath) + ';';
  }
  out += 'var ' + ($valid) + ' = equal(' + ($data) + ', schema' + ($lvl) + '); if (!' + ($valid) + ') {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('const') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValue: schema' + ($lvl) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be equal to constant\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' }';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
};

var contains = function generate_contains(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $idx = 'i' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $currentBaseId = it.baseId,
    $nonEmptySchema = (it.opts.strictKeywords ? (typeof $schema == 'object' && Object.keys($schema).length > 0) || $schema === false : it.util.schemaHasRules($schema, it.RULES.all));
  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
  if ($nonEmptySchema) {
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + ($nextValid) + ' = false; for (var ' + ($idx) + ' = 0; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + '[' + $idx + ']';
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
    } else {
      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
    }
    out += ' if (' + ($nextValid) + ') break; }  ';
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($closingBraces) + ' if (!' + ($nextValid) + ') {';
  } else {
    out += ' if (' + ($data) + '.length == 0) {';
  }
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('contains') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should contain a valid item\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } else { ';
  if ($nonEmptySchema) {
    out += '  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
  }
  if (it.opts.allErrors) {
    out += ' } ';
  }
  return out;
};

var dependencies = function generate_dependencies(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $schemaDeps = {},
    $propertyDeps = {},
    $ownProperties = it.opts.ownProperties;
  for ($property in $schema) {
    if ($property == '__proto__') continue;
    var $sch = $schema[$property];
    var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
    $deps[$property] = $sch;
  }
  out += 'var ' + ($errs) + ' = errors;';
  var $currentErrorPath = it.errorPath;
  out += 'var missing' + ($lvl) + ';';
  for (var $property in $propertyDeps) {
    $deps = $propertyDeps[$property];
    if ($deps.length) {
      out += ' if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';
      if ($ownProperties) {
        out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($property)) + '\') ';
      }
      if ($breakOnError) {
        out += ' && ( ';
        var arr1 = $deps;
        if (arr1) {
          var $propertyKey, $i = -1,
            l1 = arr1.length - 1;
          while ($i < l1) {
            $propertyKey = arr1[$i += 1];
            if ($i) {
              out += ' || ';
            }
            var $prop = it.util.getProperty($propertyKey),
              $useData = $data + $prop;
            out += ' ( ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
            }
            out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';
          }
        }
        out += ')) {  ';
        var $propertyPath = 'missing' + $lvl,
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('dependencies') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \'' + (it.util.escapeQuotes($property)) + '\', missingProperty: \'' + ($missingProperty) + '\', depsCount: ' + ($deps.length) + ', deps: \'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", "))) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should have ';
            if ($deps.length == 1) {
              out += 'property ' + (it.util.escapeQuotes($deps[0]));
            } else {
              out += 'properties ' + (it.util.escapeQuotes($deps.join(", ")));
            }
            out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
      } else {
        out += ' ) { ';
        var arr2 = $deps;
        if (arr2) {
          var $propertyKey, i2 = -1,
            l2 = arr2.length - 1;
          while (i2 < l2) {
            $propertyKey = arr2[i2 += 1];
            var $prop = it.util.getProperty($propertyKey),
              $missingProperty = it.util.escapeQuotes($propertyKey),
              $useData = $data + $prop;
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
            }
            out += ' if ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
            }
            out += ') {  var err =   '; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ('dependencies') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \'' + (it.util.escapeQuotes($property)) + '\', missingProperty: \'' + ($missingProperty) + '\', depsCount: ' + ($deps.length) + ', deps: \'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", "))) + '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'should have ';
                if ($deps.length == 1) {
                  out += 'property ' + (it.util.escapeQuotes($deps[0]));
                } else {
                  out += 'properties ' + (it.util.escapeQuotes($deps.join(", ")));
                }
                out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
          }
        }
      }
      out += ' }   ';
      if ($breakOnError) {
        $closingBraces += '}';
        out += ' else { ';
      }
    }
  }
  it.errorPath = $currentErrorPath;
  var $currentBaseId = $it.baseId;
  for (var $property in $schemaDeps) {
    var $sch = $schemaDeps[$property];
    if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {
      out += ' ' + ($nextValid) + ' = true; if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';
      if ($ownProperties) {
        out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($property)) + '\') ';
      }
      out += ') { ';
      $it.schema = $sch;
      $it.schemaPath = $schemaPath + it.util.getProperty($property);
      $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($property);
      out += '  ' + (it.validate($it)) + ' ';
      $it.baseId = $currentBaseId;
      out += ' }  ';
      if ($breakOnError) {
        out += ' if (' + ($nextValid) + ') { ';
        $closingBraces += '}';
      }
    }
  }
  if ($breakOnError) {
    out += '   ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  return out;
};

var _enum = function generate_enum(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
  }
  var $i = 'i' + $lvl,
    $vSchema = 'schema' + $lvl;
  if (!$isData) {
    out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + ';';
  }
  out += 'var ' + ($valid) + ';';
  if ($isData) {
    out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';
  }
  out += '' + ($valid) + ' = false;for (var ' + ($i) + '=0; ' + ($i) + '<' + ($vSchema) + '.length; ' + ($i) + '++) if (equal(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + '])) { ' + ($valid) + ' = true; break; }';
  if ($isData) {
    out += '  }  ';
  }
  out += ' if (!' + ($valid) + ') {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('enum') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValues: schema' + ($lvl) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be equal to one of the allowed values\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' }';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
};

var format = function generate_format(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  if (it.opts.format === false) {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
    return out;
  }
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $unknownFormats = it.opts.unknownFormats,
    $allowUnknown = Array.isArray($unknownFormats);
  if ($isData) {
    var $format = 'format' + $lvl,
      $isObject = 'isObject' + $lvl,
      $formatType = 'formatType' + $lvl;
    out += ' var ' + ($format) + ' = formats[' + ($schemaValue) + ']; var ' + ($isObject) + ' = typeof ' + ($format) + ' == \'object\' && !(' + ($format) + ' instanceof RegExp) && ' + ($format) + '.validate; var ' + ($formatType) + ' = ' + ($isObject) + ' && ' + ($format) + '.type || \'string\'; if (' + ($isObject) + ') { ';
    if (it.async) {
      out += ' var async' + ($lvl) + ' = ' + ($format) + '.async; ';
    }
    out += ' ' + ($format) + ' = ' + ($format) + '.validate; } if (  ';
    if ($isData) {
      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'string\') || ';
    }
    out += ' (';
    if ($unknownFormats != 'ignore') {
      out += ' (' + ($schemaValue) + ' && !' + ($format) + ' ';
      if ($allowUnknown) {
        out += ' && self._opts.unknownFormats.indexOf(' + ($schemaValue) + ') == -1 ';
      }
      out += ') || ';
    }
    out += ' (' + ($format) + ' && ' + ($formatType) + ' == \'' + ($ruleType) + '\' && !(typeof ' + ($format) + ' == \'function\' ? ';
    if (it.async) {
      out += ' (async' + ($lvl) + ' ? await ' + ($format) + '(' + ($data) + ') : ' + ($format) + '(' + ($data) + ')) ';
    } else {
      out += ' ' + ($format) + '(' + ($data) + ') ';
    }
    out += ' : ' + ($format) + '.test(' + ($data) + '))))) {';
  } else {
    var $format = it.formats[$schema];
    if (!$format) {
      if ($unknownFormats == 'ignore') {
        it.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');
        if ($breakOnError) {
          out += ' if (true) { ';
        }
        return out;
      } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
        if ($breakOnError) {
          out += ' if (true) { ';
        }
        return out;
      } else {
        throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
      }
    }
    var $isObject = typeof $format == 'object' && !($format instanceof RegExp) && $format.validate;
    var $formatType = $isObject && $format.type || 'string';
    if ($isObject) {
      var $async = $format.async === true;
      $format = $format.validate;
    }
    if ($formatType != $ruleType) {
      if ($breakOnError) {
        out += ' if (true) { ';
      }
      return out;
    }
    if ($async) {
      if (!it.async) throw new Error('async format in sync schema');
      var $formatRef = 'formats' + it.util.getProperty($schema) + '.validate';
      out += ' if (!(await ' + ($formatRef) + '(' + ($data) + '))) { ';
    } else {
      out += ' if (! ';
      var $formatRef = 'formats' + it.util.getProperty($schema);
      if ($isObject) $formatRef += '.validate';
      if (typeof $format == 'function') {
        out += ' ' + ($formatRef) + '(' + ($data) + ') ';
      } else {
        out += ' ' + ($formatRef) + '.test(' + ($data) + ') ';
      }
      out += ') { ';
    }
  }
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('format') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { format:  ';
    if ($isData) {
      out += '' + ($schemaValue);
    } else {
      out += '' + (it.util.toQuotedString($schema));
    }
    out += '  } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should match format "';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + (it.util.escapeQuotes($schema));
      }
      out += '"\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + (it.util.toQuotedString($schema));
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
};

var _if = function generate_if(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $thenSch = it.schema['then'],
    $elseSch = it.schema['else'],
    $thenPresent = $thenSch !== undefined && (it.opts.strictKeywords ? (typeof $thenSch == 'object' && Object.keys($thenSch).length > 0) || $thenSch === false : it.util.schemaHasRules($thenSch, it.RULES.all)),
    $elsePresent = $elseSch !== undefined && (it.opts.strictKeywords ? (typeof $elseSch == 'object' && Object.keys($elseSch).length > 0) || $elseSch === false : it.util.schemaHasRules($elseSch, it.RULES.all)),
    $currentBaseId = $it.baseId;
  if ($thenPresent || $elsePresent) {
    var $ifClause;
    $it.createErrors = false;
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = true;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    out += '  ' + (it.validate($it)) + ' ';
    $it.baseId = $currentBaseId;
    $it.createErrors = true;
    out += '  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }  ';
    it.compositeRule = $it.compositeRule = $wasComposite;
    if ($thenPresent) {
      out += ' if (' + ($nextValid) + ') {  ';
      $it.schema = it.schema['then'];
      $it.schemaPath = it.schemaPath + '.then';
      $it.errSchemaPath = it.errSchemaPath + '/then';
      out += '  ' + (it.validate($it)) + ' ';
      $it.baseId = $currentBaseId;
      out += ' ' + ($valid) + ' = ' + ($nextValid) + '; ';
      if ($thenPresent && $elsePresent) {
        $ifClause = 'ifClause' + $lvl;
        out += ' var ' + ($ifClause) + ' = \'then\'; ';
      } else {
        $ifClause = '\'then\'';
      }
      out += ' } ';
      if ($elsePresent) {
        out += ' else { ';
      }
    } else {
      out += ' if (!' + ($nextValid) + ') { ';
    }
    if ($elsePresent) {
      $it.schema = it.schema['else'];
      $it.schemaPath = it.schemaPath + '.else';
      $it.errSchemaPath = it.errSchemaPath + '/else';
      out += '  ' + (it.validate($it)) + ' ';
      $it.baseId = $currentBaseId;
      out += ' ' + ($valid) + ' = ' + ($nextValid) + '; ';
      if ($thenPresent && $elsePresent) {
        $ifClause = 'ifClause' + $lvl;
        out += ' var ' + ($ifClause) + ' = \'else\'; ';
      } else {
        $ifClause = '\'else\'';
      }
      out += ' } ';
    }
    out += ' if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('if') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { failingKeyword: ' + ($ifClause) + ' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should match "\' + ' + ($ifClause) + ' + \'" schema\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }
    out += ' }   ';
    if ($breakOnError) {
      out += ' else { ';
    }
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
};

var items = function generate_items(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $idx = 'i' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $currentBaseId = it.baseId;
  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
  if (Array.isArray($schema)) {
    var $additionalItems = it.schema.additionalItems;
    if ($additionalItems === false) {
      out += ' ' + ($valid) + ' = ' + ($data) + '.length <= ' + ($schema.length) + '; ';
      var $currErrSchemaPath = $errSchemaPath;
      $errSchemaPath = it.errSchemaPath + '/additionalItems';
      out += '  if (!' + ($valid) + ') {   ';
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ('additionalItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schema.length) + ' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should NOT have more than ' + ($schema.length) + ' items\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += ' } ';
      $errSchemaPath = $currErrSchemaPath;
      if ($breakOnError) {
        $closingBraces += '}';
        out += ' else { ';
      }
    }
    var arr1 = $schema;
    if (arr1) {
      var $sch, $i = -1,
        l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {
          out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($i) + ') { ';
          var $passData = $data + '[' + $i + ']';
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + '[' + $i + ']';
          $it.errSchemaPath = $errSchemaPath + '/' + $i;
          $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
          $it.dataPathArr[$dataNxt] = $i;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          out += ' }  ';
          if ($breakOnError) {
            out += ' if (' + ($nextValid) + ') { ';
            $closingBraces += '}';
          }
        }
      }
    }
    if (typeof $additionalItems == 'object' && (it.opts.strictKeywords ? (typeof $additionalItems == 'object' && Object.keys($additionalItems).length > 0) || $additionalItems === false : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
      $it.schema = $additionalItems;
      $it.schemaPath = it.schemaPath + '.additionalItems';
      $it.errSchemaPath = it.errSchemaPath + '/additionalItems';
      out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($schema.length) + ') {  for (var ' + ($idx) + ' = ' + ($schema.length) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
      var $passData = $data + '[' + $idx + ']';
      $it.dataPathArr[$dataNxt] = $idx;
      var $code = it.validate($it);
      $it.baseId = $currentBaseId;
      if (it.util.varOccurences($code, $nextData) < 2) {
        out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
      } else {
        out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
      }
      if ($breakOnError) {
        out += ' if (!' + ($nextValid) + ') break; ';
      }
      out += ' } }  ';
      if ($breakOnError) {
        out += ' if (' + ($nextValid) + ') { ';
        $closingBraces += '}';
      }
    }
  } else if ((it.opts.strictKeywords ? (typeof $schema == 'object' && Object.keys($schema).length > 0) || $schema === false : it.util.schemaHasRules($schema, it.RULES.all))) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += '  for (var ' + ($idx) + ' = ' + (0) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + '[' + $idx + ']';
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
    } else {
      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
    }
    if ($breakOnError) {
      out += ' if (!' + ($nextValid) + ') break; ';
    }
    out += ' }';
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  return out;
};

var _limit = function generate__limit(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $isMax = $keyword == 'maximum',
    $exclusiveKeyword = $isMax ? 'exclusiveMaximum' : 'exclusiveMinimum',
    $schemaExcl = it.schema[$exclusiveKeyword],
    $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data,
    $op = $isMax ? '<' : '>',
    $notOp = $isMax ? '>' : '<',
    $errorKeyword = undefined;
  if (!($isData || typeof $schema == 'number' || $schema === undefined)) {
    throw new Error($keyword + ' must be number');
  }
  if (!($isDataExcl || $schemaExcl === undefined || typeof $schemaExcl == 'number' || typeof $schemaExcl == 'boolean')) {
    throw new Error($exclusiveKeyword + ' must be number or boolean');
  }
  if ($isDataExcl) {
    var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),
      $exclusive = 'exclusive' + $lvl,
      $exclType = 'exclType' + $lvl,
      $exclIsNumber = 'exclIsNumber' + $lvl,
      $opExpr = 'op' + $lvl,
      $opStr = '\' + ' + $opExpr + ' + \'';
    out += ' var schemaExcl' + ($lvl) + ' = ' + ($schemaValueExcl) + '; ';
    $schemaValueExcl = 'schemaExcl' + $lvl;
    out += ' var ' + ($exclusive) + '; var ' + ($exclType) + ' = typeof ' + ($schemaValueExcl) + '; if (' + ($exclType) + ' != \'boolean\' && ' + ($exclType) + ' != \'undefined\' && ' + ($exclType) + ' != \'number\') { ';
    var $errorKeyword = $exclusiveKeyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ($errorKeyword || '_exclusiveLimit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'' + ($exclusiveKeyword) + ' should be boolean\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } else if ( ';
    if ($isData) {
      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
    }
    out += ' ' + ($exclType) + ' == \'number\' ? ( (' + ($exclusive) + ' = ' + ($schemaValue) + ' === undefined || ' + ($schemaValueExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ') ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValueExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) : ( (' + ($exclusive) + ' = ' + ($schemaValueExcl) + ' === true) ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValue) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') { var op' + ($lvl) + ' = ' + ($exclusive) + ' ? \'' + ($op) + '\' : \'' + ($op) + '=\'; ';
    if ($schema === undefined) {
      $errorKeyword = $exclusiveKeyword;
      $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
      $schemaValue = $schemaValueExcl;
      $isData = $isDataExcl;
    }
  } else {
    var $exclIsNumber = typeof $schemaExcl == 'number',
      $opStr = $op;
    if ($exclIsNumber && $isData) {
      var $opExpr = '\'' + $opStr + '\'';
      out += ' if ( ';
      if ($isData) {
        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
      }
      out += ' ( ' + ($schemaValue) + ' === undefined || ' + ($schemaExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ' ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') { ';
    } else {
      if ($exclIsNumber && $schema === undefined) {
        $exclusive = true;
        $errorKeyword = $exclusiveKeyword;
        $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
        $schemaValue = $schemaExcl;
        $notOp += '=';
      } else {
        if ($exclIsNumber) $schemaValue = Math[$isMax ? 'min' : 'max']($schemaExcl, $schema);
        if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
          $exclusive = true;
          $errorKeyword = $exclusiveKeyword;
          $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
          $notOp += '=';
        } else {
          $exclusive = false;
          $opStr += '=';
        }
      }
      var $opExpr = '\'' + $opStr + '\'';
      out += ' if ( ';
      if ($isData) {
        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
      }
      out += ' ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' || ' + ($data) + ' !== ' + ($data) + ') { ';
    }
  }
  $errorKeyword = $errorKeyword || $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { comparison: ' + ($opExpr) + ', limit: ' + ($schemaValue) + ', exclusive: ' + ($exclusive) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be ' + ($opStr) + ' ';
      if ($isData) {
        out += '\' + ' + ($schemaValue);
      } else {
        out += '' + ($schemaValue) + '\'';
      }
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
};

var _limitItems = function generate__limitItems(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (!($isData || typeof $schema == 'number')) {
    throw new Error($keyword + ' must be number');
  }
  var $op = $keyword == 'maxItems' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
  }
  out += ' ' + ($data) + '.length ' + ($op) + ' ' + ($schemaValue) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limitItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should NOT have ';
      if ($keyword == 'maxItems') {
        out += 'more';
      } else {
        out += 'fewer';
      }
      out += ' than ';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + ($schema);
      }
      out += ' items\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
};

var _limitLength = function generate__limitLength(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (!($isData || typeof $schema == 'number')) {
    throw new Error($keyword + ' must be number');
  }
  var $op = $keyword == 'maxLength' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
  }
  if (it.opts.unicode === false) {
    out += ' ' + ($data) + '.length ';
  } else {
    out += ' ucs2length(' + ($data) + ') ';
  }
  out += ' ' + ($op) + ' ' + ($schemaValue) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limitLength') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should NOT be ';
      if ($keyword == 'maxLength') {
        out += 'longer';
      } else {
        out += 'shorter';
      }
      out += ' than ';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + ($schema);
      }
      out += ' characters\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
};

var _limitProperties = function generate__limitProperties(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (!($isData || typeof $schema == 'number')) {
    throw new Error($keyword + ' must be number');
  }
  var $op = $keyword == 'maxProperties' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
  }
  out += ' Object.keys(' + ($data) + ').length ' + ($op) + ' ' + ($schemaValue) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limitProperties') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should NOT have ';
      if ($keyword == 'maxProperties') {
        out += 'more';
      } else {
        out += 'fewer';
      }
      out += ' than ';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + ($schema);
      }
      out += ' properties\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
};

var multipleOf = function generate_multipleOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (!($isData || typeof $schema == 'number')) {
    throw new Error($keyword + ' must be number');
  }
  out += 'var division' + ($lvl) + ';if (';
  if ($isData) {
    out += ' ' + ($schemaValue) + ' !== undefined && ( typeof ' + ($schemaValue) + ' != \'number\' || ';
  }
  out += ' (division' + ($lvl) + ' = ' + ($data) + ' / ' + ($schemaValue) + ', ';
  if (it.opts.multipleOfPrecision) {
    out += ' Math.abs(Math.round(division' + ($lvl) + ') - division' + ($lvl) + ') > 1e-' + (it.opts.multipleOfPrecision) + ' ';
  } else {
    out += ' division' + ($lvl) + ' !== parseInt(division' + ($lvl) + ') ';
  }
  out += ' ) ';
  if ($isData) {
    out += '  )  ';
  }
  out += ' ) {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('multipleOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { multipleOf: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be multiple of ';
      if ($isData) {
        out += '\' + ' + ($schemaValue);
      } else {
        out += '' + ($schemaValue) + '\'';
      }
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
};

var not = function generate_not(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  if ((it.opts.strictKeywords ? (typeof $schema == 'object' && Object.keys($schema).length > 0) || $schema === false : it.util.schemaHasRules($schema, it.RULES.all))) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + ($errs) + ' = errors;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.createErrors = false;
    var $allErrorsOption;
    if ($it.opts.allErrors) {
      $allErrorsOption = $it.opts.allErrors;
      $it.opts.allErrors = false;
    }
    out += ' ' + (it.validate($it)) + ' ';
    $it.createErrors = true;
    if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' if (' + ($nextValid) + ') {   ';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('not') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should NOT be valid\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
    if (it.opts.allErrors) {
      out += ' } ';
    }
  } else {
    out += '  var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('not') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should NOT be valid\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if ($breakOnError) {
      out += ' if (false) { ';
    }
  }
  return out;
};

var oneOf = function generate_oneOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $currentBaseId = $it.baseId,
    $prevValid = 'prevValid' + $lvl,
    $passingSchemas = 'passingSchemas' + $lvl;
  out += 'var ' + ($errs) + ' = errors , ' + ($prevValid) + ' = false , ' + ($valid) + ' = false , ' + ($passingSchemas) + ' = null; ';
  var $wasComposite = it.compositeRule;
  it.compositeRule = $it.compositeRule = true;
  var arr1 = $schema;
  if (arr1) {
    var $sch, $i = -1,
      l1 = arr1.length - 1;
    while ($i < l1) {
      $sch = arr1[$i += 1];
      if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
      } else {
        out += ' var ' + ($nextValid) + ' = true; ';
      }
      if ($i) {
        out += ' if (' + ($nextValid) + ' && ' + ($prevValid) + ') { ' + ($valid) + ' = false; ' + ($passingSchemas) + ' = [' + ($passingSchemas) + ', ' + ($i) + ']; } else { ';
        $closingBraces += '}';
      }
      out += ' if (' + ($nextValid) + ') { ' + ($valid) + ' = ' + ($prevValid) + ' = true; ' + ($passingSchemas) + ' = ' + ($i) + '; }';
    }
  }
  it.compositeRule = $it.compositeRule = $wasComposite;
  out += '' + ($closingBraces) + 'if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('oneOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { passingSchemas: ' + ($passingSchemas) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should match exactly one schema in oneOf\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError(vErrors); ';
    } else {
      out += ' validate.errors = vErrors; return false; ';
    }
  }
  out += '} else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }';
  if (it.opts.allErrors) {
    out += ' } ';
  }
  return out;
};

var pattern = function generate_pattern(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $regexp = $isData ? '(new RegExp(' + $schemaValue + '))' : it.usePattern($schema);
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'string\') || ';
  }
  out += ' !' + ($regexp) + '.test(' + ($data) + ') ) {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('pattern') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { pattern:  ';
    if ($isData) {
      out += '' + ($schemaValue);
    } else {
      out += '' + (it.util.toQuotedString($schema));
    }
    out += '  } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should match pattern "';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + (it.util.escapeQuotes($schema));
      }
      out += '"\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + (it.util.toQuotedString($schema));
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
};

var properties$4 = function generate_properties(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $key = 'key' + $lvl,
    $idx = 'idx' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $dataProperties = 'dataProperties' + $lvl;
  var $schemaKeys = Object.keys($schema || {}).filter(notProto),
    $pProperties = it.schema.patternProperties || {},
    $pPropertyKeys = Object.keys($pProperties).filter(notProto),
    $aProperties = it.schema.additionalProperties,
    $someProperties = $schemaKeys.length || $pPropertyKeys.length,
    $noAdditional = $aProperties === false,
    $additionalIsSchema = typeof $aProperties == 'object' && Object.keys($aProperties).length,
    $removeAdditional = it.opts.removeAdditional,
    $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional,
    $ownProperties = it.opts.ownProperties,
    $currentBaseId = it.baseId;
  var $required = it.schema.required;
  if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) {
    var $requiredHash = it.util.toHash($required);
  }

  function notProto(p) {
    return p !== '__proto__';
  }
  out += 'var ' + ($errs) + ' = errors;var ' + ($nextValid) + ' = true;';
  if ($ownProperties) {
    out += ' var ' + ($dataProperties) + ' = undefined;';
  }
  if ($checkAdditional) {
    if ($ownProperties) {
      out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
    } else {
      out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
    }
    if ($someProperties) {
      out += ' var isAdditional' + ($lvl) + ' = !(false ';
      if ($schemaKeys.length) {
        if ($schemaKeys.length > 8) {
          out += ' || validate.schema' + ($schemaPath) + '.hasOwnProperty(' + ($key) + ') ';
        } else {
          var arr1 = $schemaKeys;
          if (arr1) {
            var $propertyKey, i1 = -1,
              l1 = arr1.length - 1;
            while (i1 < l1) {
              $propertyKey = arr1[i1 += 1];
              out += ' || ' + ($key) + ' == ' + (it.util.toQuotedString($propertyKey)) + ' ';
            }
          }
        }
      }
      if ($pPropertyKeys.length) {
        var arr2 = $pPropertyKeys;
        if (arr2) {
          var $pProperty, $i = -1,
            l2 = arr2.length - 1;
          while ($i < l2) {
            $pProperty = arr2[$i += 1];
            out += ' || ' + (it.usePattern($pProperty)) + '.test(' + ($key) + ') ';
          }
        }
      }
      out += ' ); if (isAdditional' + ($lvl) + ') { ';
    }
    if ($removeAdditional == 'all') {
      out += ' delete ' + ($data) + '[' + ($key) + ']; ';
    } else {
      var $currentErrorPath = it.errorPath;
      var $additionalProperty = '\' + ' + $key + ' + \'';
      if (it.opts._errorDataPathProperty) {
        it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
      }
      if ($noAdditional) {
        if ($removeAdditional) {
          out += ' delete ' + ($data) + '[' + ($key) + ']; ';
        } else {
          out += ' ' + ($nextValid) + ' = false; ';
          var $currErrSchemaPath = $errSchemaPath;
          $errSchemaPath = it.errSchemaPath + '/additionalProperties';
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = ''; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ('additionalProperties') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { additionalProperty: \'' + ($additionalProperty) + '\' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'';
              if (it.opts._errorDataPathProperty) {
                out += 'is an invalid additional property';
              } else {
                out += 'should NOT have additional properties';
              }
              out += '\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            /* istanbul ignore if */
            if (it.async) {
              out += ' throw new ValidationError([' + (__err) + ']); ';
            } else {
              out += ' validate.errors = [' + (__err) + ']; return false; ';
            }
          } else {
            out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }
          $errSchemaPath = $currErrSchemaPath;
          if ($breakOnError) {
            out += ' break; ';
          }
        }
      } else if ($additionalIsSchema) {
        if ($removeAdditional == 'failing') {
          out += ' var ' + ($errs) + ' = errors;  ';
          var $wasComposite = it.compositeRule;
          it.compositeRule = $it.compositeRule = true;
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + '.additionalProperties';
          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          out += ' if (!' + ($nextValid) + ') { errors = ' + ($errs) + '; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete ' + ($data) + '[' + ($key) + ']; }  ';
          it.compositeRule = $it.compositeRule = $wasComposite;
        } else {
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + '.additionalProperties';
          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          if ($breakOnError) {
            out += ' if (!' + ($nextValid) + ') break; ';
          }
        }
      }
      it.errorPath = $currentErrorPath;
    }
    if ($someProperties) {
      out += ' } ';
    }
    out += ' }  ';
    if ($breakOnError) {
      out += ' if (' + ($nextValid) + ') { ';
      $closingBraces += '}';
    }
  }
  var $useDefaults = it.opts.useDefaults && !it.compositeRule;
  if ($schemaKeys.length) {
    var arr3 = $schemaKeys;
    if (arr3) {
      var $propertyKey, i3 = -1,
        l3 = arr3.length - 1;
      while (i3 < l3) {
        $propertyKey = arr3[i3 += 1];
        var $sch = $schema[$propertyKey];
        if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {
          var $prop = it.util.getProperty($propertyKey),
            $passData = $data + $prop,
            $hasDefault = $useDefaults && $sch.default !== undefined;
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + $prop;
          $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($propertyKey);
          $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
          $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            $code = it.util.varReplace($code, $nextData, $passData);
            var $useData = $passData;
          } else {
            var $useData = $nextData;
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ';
          }
          if ($hasDefault) {
            out += ' ' + ($code) + ' ';
          } else {
            if ($requiredHash && $requiredHash[$propertyKey]) {
              out += ' if ( ' + ($useData) + ' === undefined ';
              if ($ownProperties) {
                out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
              }
              out += ') { ' + ($nextValid) + ' = false; ';
              var $currentErrorPath = it.errorPath,
                $currErrSchemaPath = $errSchemaPath,
                $missingProperty = it.util.escapeQuotes($propertyKey);
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
              }
              $errSchemaPath = it.errSchemaPath + '/required';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \'';
                  if (it.opts._errorDataPathProperty) {
                    out += 'is a required property';
                  } else {
                    out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                  }
                  out += '\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + (__err) + ']); ';
                } else {
                  out += ' validate.errors = [' + (__err) + ']; return false; ';
                }
              } else {
                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }
              $errSchemaPath = $currErrSchemaPath;
              it.errorPath = $currentErrorPath;
              out += ' } else { ';
            } else {
              if ($breakOnError) {
                out += ' if ( ' + ($useData) + ' === undefined ';
                if ($ownProperties) {
                  out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
                }
                out += ') { ' + ($nextValid) + ' = true; } else { ';
              } else {
                out += ' if (' + ($useData) + ' !== undefined ';
                if ($ownProperties) {
                  out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
                }
                out += ' ) { ';
              }
            }
            out += ' ' + ($code) + ' } ';
          }
        }
        if ($breakOnError) {
          out += ' if (' + ($nextValid) + ') { ';
          $closingBraces += '}';
        }
      }
    }
  }
  if ($pPropertyKeys.length) {
    var arr4 = $pPropertyKeys;
    if (arr4) {
      var $pProperty, i4 = -1,
        l4 = arr4.length - 1;
      while (i4 < l4) {
        $pProperty = arr4[i4 += 1];
        var $sch = $pProperties[$pProperty];
        if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {
          $it.schema = $sch;
          $it.schemaPath = it.schemaPath + '.patternProperties' + it.util.getProperty($pProperty);
          $it.errSchemaPath = it.errSchemaPath + '/patternProperties/' + it.util.escapeFragment($pProperty);
          if ($ownProperties) {
            out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
          } else {
            out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
          }
          out += ' if (' + (it.usePattern($pProperty)) + '.test(' + ($key) + ')) { ';
          $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          if ($breakOnError) {
            out += ' if (!' + ($nextValid) + ') break; ';
          }
          out += ' } ';
          if ($breakOnError) {
            out += ' else ' + ($nextValid) + ' = true; ';
          }
          out += ' }  ';
          if ($breakOnError) {
            out += ' if (' + ($nextValid) + ') { ';
            $closingBraces += '}';
          }
        }
      }
    }
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  return out;
};

var propertyNames = function generate_propertyNames(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  out += 'var ' + ($errs) + ' = errors;';
  if ((it.opts.strictKeywords ? (typeof $schema == 'object' && Object.keys($schema).length > 0) || $schema === false : it.util.schemaHasRules($schema, it.RULES.all))) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    var $key = 'key' + $lvl,
      $idx = 'idx' + $lvl,
      $i = 'i' + $lvl,
      $invalidName = '\' + ' + $key + ' + \'',
      $dataNxt = $it.dataLevel = it.dataLevel + 1,
      $nextData = 'data' + $dataNxt,
      $dataProperties = 'dataProperties' + $lvl,
      $ownProperties = it.opts.ownProperties,
      $currentBaseId = it.baseId;
    if ($ownProperties) {
      out += ' var ' + ($dataProperties) + ' = undefined; ';
    }
    if ($ownProperties) {
      out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
    } else {
      out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
    }
    out += ' var startErrs' + ($lvl) + ' = errors; ';
    var $passData = $key;
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
    } else {
      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' if (!' + ($nextValid) + ') { for (var ' + ($i) + '=startErrs' + ($lvl) + '; ' + ($i) + '<errors; ' + ($i) + '++) { vErrors[' + ($i) + '].propertyName = ' + ($key) + '; }   var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('propertyNames') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { propertyName: \'' + ($invalidName) + '\' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'property name \\\'' + ($invalidName) + '\\\' is invalid\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }
    if ($breakOnError) {
      out += ' break; ';
    }
    out += ' } }';
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  return out;
};

var required$3 = function generate_required(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
  }
  var $vSchema = 'schema' + $lvl;
  if (!$isData) {
    if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
      var $required = [];
      var arr1 = $schema;
      if (arr1) {
        var $property, i1 = -1,
          l1 = arr1.length - 1;
        while (i1 < l1) {
          $property = arr1[i1 += 1];
          var $propertySch = it.schema.properties[$property];
          if (!($propertySch && (it.opts.strictKeywords ? (typeof $propertySch == 'object' && Object.keys($propertySch).length > 0) || $propertySch === false : it.util.schemaHasRules($propertySch, it.RULES.all)))) {
            $required[$required.length] = $property;
          }
        }
      }
    } else {
      var $required = $schema;
    }
  }
  if ($isData || $required.length) {
    var $currentErrorPath = it.errorPath,
      $loopRequired = $isData || $required.length >= it.opts.loopRequired,
      $ownProperties = it.opts.ownProperties;
    if ($breakOnError) {
      out += ' var missing' + ($lvl) + '; ';
      if ($loopRequired) {
        if (!$isData) {
          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';
        }
        var $i = 'i' + $lvl,
          $propertyPath = 'schema' + $lvl + '[' + $i + ']',
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }
        out += ' var ' + ($valid) + ' = true; ';
        if ($isData) {
          out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';
        }
        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { ' + ($valid) + ' = ' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] !== undefined ';
        if ($ownProperties) {
          out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';
        }
        out += '; if (!' + ($valid) + ') break; } ';
        if ($isData) {
          out += '  }  ';
        }
        out += '  if (!' + ($valid) + ') {   ';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else { ';
      } else {
        out += ' if ( ';
        var arr2 = $required;
        if (arr2) {
          var $propertyKey, $i = -1,
            l2 = arr2.length - 1;
          while ($i < l2) {
            $propertyKey = arr2[$i += 1];
            if ($i) {
              out += ' || ';
            }
            var $prop = it.util.getProperty($propertyKey),
              $useData = $data + $prop;
            out += ' ( ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
            }
            out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';
          }
        }
        out += ') {  ';
        var $propertyPath = 'missing' + $lvl,
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else { ';
      }
    } else {
      if ($loopRequired) {
        if (!$isData) {
          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';
        }
        var $i = 'i' + $lvl,
          $propertyPath = 'schema' + $lvl + '[' + $i + ']',
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }
        if ($isData) {
          out += ' if (' + ($vSchema) + ' && !Array.isArray(' + ($vSchema) + ')) {  var err =   '; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'';
              if (it.opts._errorDataPathProperty) {
                out += 'is a required property';
              } else {
                out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
              }
              out += '\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (' + ($vSchema) + ' !== undefined) { ';
        }
        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { if (' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] === undefined ';
        if ($ownProperties) {
          out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';
        }
        out += ') {  var err =   '; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ';
        if ($isData) {
          out += '  }  ';
        }
      } else {
        var arr3 = $required;
        if (arr3) {
          var $propertyKey, i3 = -1,
            l3 = arr3.length - 1;
          while (i3 < l3) {
            $propertyKey = arr3[i3 += 1];
            var $prop = it.util.getProperty($propertyKey),
              $missingProperty = it.util.escapeQuotes($propertyKey),
              $useData = $data + $prop;
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
            }
            out += ' if ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
            }
            out += ') {  var err =   '; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'';
                if (it.opts._errorDataPathProperty) {
                  out += 'is a required property';
                } else {
                  out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                }
                out += '\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
          }
        }
      }
    }
    it.errorPath = $currentErrorPath;
  } else if ($breakOnError) {
    out += ' if (true) {';
  }
  return out;
};

var uniqueItems = function generate_uniqueItems(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (($schema || $isData) && it.opts.uniqueItems !== false) {
    if ($isData) {
      out += ' var ' + ($valid) + '; if (' + ($schemaValue) + ' === false || ' + ($schemaValue) + ' === undefined) ' + ($valid) + ' = true; else if (typeof ' + ($schemaValue) + ' != \'boolean\') ' + ($valid) + ' = false; else { ';
    }
    out += ' var i = ' + ($data) + '.length , ' + ($valid) + ' = true , j; if (i > 1) { ';
    var $itemType = it.schema.items && it.schema.items.type,
      $typeIsArray = Array.isArray($itemType);
    if (!$itemType || $itemType == 'object' || $itemType == 'array' || ($typeIsArray && ($itemType.indexOf('object') >= 0 || $itemType.indexOf('array') >= 0))) {
      out += ' outer: for (;i--;) { for (j = i; j--;) { if (equal(' + ($data) + '[i], ' + ($data) + '[j])) { ' + ($valid) + ' = false; break outer; } } } ';
    } else {
      out += ' var itemIndices = {}, item; for (;i--;) { var item = ' + ($data) + '[i]; ';
      var $method = 'checkDataType' + ($typeIsArray ? 's' : '');
      out += ' if (' + (it.util[$method]($itemType, 'item', it.opts.strictNumbers, true)) + ') continue; ';
      if ($typeIsArray) {
        out += ' if (typeof item == \'string\') item = \'"\' + item; ';
      }
      out += ' if (typeof itemIndices[item] == \'number\') { ' + ($valid) + ' = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ';
    }
    out += ' } ';
    if ($isData) {
      out += '  }  ';
    }
    out += ' if (!' + ($valid) + ') {   ';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('uniqueItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { i: i, j: j } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should NOT have duplicate items (items ## \' + j + \' and \' + i + \' are identical)\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema:  ';
        if ($isData) {
          out += 'validate.schema' + ($schemaPath);
        } else {
          out += '' + ($schema);
        }
        out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } ';
    if ($breakOnError) {
      out += ' else { ';
    }
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
};

//all requires must be explicit because browserify won't work with dynamic requires
var dotjs = {
  '$ref': ref,
  allOf: allOf,
  anyOf: anyOf,
  '$comment': comment,
  const: _const,
  contains: contains,
  dependencies: dependencies,
  'enum': _enum,
  format: format,
  'if': _if,
  items: items,
  maximum: _limit,
  minimum: _limit,
  maxItems: _limitItems,
  minItems: _limitItems,
  maxLength: _limitLength,
  minLength: _limitLength,
  maxProperties: _limitProperties,
  minProperties: _limitProperties,
  multipleOf: multipleOf,
  not: not,
  oneOf: oneOf,
  pattern: pattern,
  properties: properties$4,
  propertyNames: propertyNames,
  required: required$3,
  uniqueItems: uniqueItems,
  validate: validate$1
};

var ruleModules = dotjs
  , toHash = util$8.toHash;

var rules$1 = function rules() {
  var RULES = [
    { type: 'number',
      rules: [ { 'maximum': ['exclusiveMaximum'] },
               { 'minimum': ['exclusiveMinimum'] }, 'multipleOf', 'format'] },
    { type: 'string',
      rules: [ 'maxLength', 'minLength', 'pattern', 'format' ] },
    { type: 'array',
      rules: [ 'maxItems', 'minItems', 'items', 'contains', 'uniqueItems' ] },
    { type: 'object',
      rules: [ 'maxProperties', 'minProperties', 'required', 'dependencies', 'propertyNames',
               { 'properties': ['additionalProperties', 'patternProperties'] } ] },
    { rules: [ '$ref', 'const', 'enum', 'not', 'anyOf', 'oneOf', 'allOf', 'if' ] }
  ];

  var ALL = [ 'type', '$comment' ];
  var KEYWORDS = [
    '$schema', '$id', 'id', '$data', '$async', 'title',
    'description', 'default', 'definitions',
    'examples', 'readOnly', 'writeOnly',
    'contentMediaType', 'contentEncoding',
    'additionalItems', 'then', 'else'
  ];
  var TYPES = [ 'number', 'integer', 'string', 'array', 'object', 'boolean', 'null' ];
  RULES.all = toHash(ALL);
  RULES.types = toHash(TYPES);

  RULES.forEach(function (group) {
    group.rules = group.rules.map(function (keyword) {
      var implKeywords;
      if (typeof keyword == 'object') {
        var key = Object.keys(keyword)[0];
        implKeywords = keyword[key];
        keyword = key;
        implKeywords.forEach(function (k) {
          ALL.push(k);
          RULES.all[k] = true;
        });
      }
      ALL.push(keyword);
      var rule = RULES.all[keyword] = {
        keyword: keyword,
        code: ruleModules[keyword],
        implements: implKeywords
      };
      return rule;
    });

    RULES.all.$comment = {
      keyword: '$comment',
      code: ruleModules.$comment
    };

    if (group.type) RULES.types[group.type] = group;
  });

  RULES.keywords = toHash(ALL.concat(KEYWORDS));
  RULES.custom = {};

  return RULES;
};

var KEYWORDS = [
  'multipleOf',
  'maximum',
  'exclusiveMaximum',
  'minimum',
  'exclusiveMinimum',
  'maxLength',
  'minLength',
  'pattern',
  'additionalItems',
  'maxItems',
  'minItems',
  'uniqueItems',
  'maxProperties',
  'minProperties',
  'required',
  'additionalProperties',
  'enum',
  'format',
  'const'
];

var data = function (metaSchema, keywordsJsonPointers) {
  for (var i=0; i<keywordsJsonPointers.length; i++) {
    metaSchema = JSON.parse(JSON.stringify(metaSchema));
    var segments = keywordsJsonPointers[i].split('/');
    var keywords = metaSchema;
    var j;
    for (j=1; j<segments.length; j++)
      keywords = keywords[segments[j]];

    for (j=0; j<KEYWORDS.length; j++) {
      var key = KEYWORDS[j];
      var schema = keywords[key];
      if (schema) {
        keywords[key] = {
          anyOf: [
            schema,
            { $ref: 'https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#' }
          ]
        };
      }
    }
  }

  return metaSchema;
};

var MissingRefError = error_classes.MissingRef;

var async = compileAsync;


/**
 * Creates validating function for passed schema with asynchronous loading of missing schemas.
 * `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.
 * @this  Ajv
 * @param {Object}   schema schema object
 * @param {Boolean}  meta optional true to compile meta-schema; this parameter can be skipped
 * @param {Function} callback an optional node-style callback, it is called with 2 parameters: error (or null) and validating function.
 * @return {Promise} promise that resolves with a validating function.
 */
function compileAsync(schema, meta, callback) {
  /* eslint no-shadow: 0 */
  /* global Promise */
  /* jshint validthis: true */
  var self = this;
  if (typeof this._opts.loadSchema != 'function')
    throw new Error('options.loadSchema should be a function');

  if (typeof meta == 'function') {
    callback = meta;
    meta = undefined;
  }

  var p = loadMetaSchemaOf(schema).then(function () {
    var schemaObj = self._addSchema(schema, undefined, meta);
    return schemaObj.validate || _compileAsync(schemaObj);
  });

  if (callback) {
    p.then(
      function(v) { callback(null, v); },
      callback
    );
  }

  return p;


  function loadMetaSchemaOf(sch) {
    var $schema = sch.$schema;
    return $schema && !self.getSchema($schema)
            ? compileAsync.call(self, { $ref: $schema }, true)
            : Promise.resolve();
  }


  function _compileAsync(schemaObj) {
    try { return self._compile(schemaObj); }
    catch(e) {
      if (e instanceof MissingRefError) return loadMissingSchema(e);
      throw e;
    }


    function loadMissingSchema(e) {
      var ref = e.missingSchema;
      if (added(ref)) throw new Error('Schema ' + ref + ' is loaded but ' + e.missingRef + ' cannot be resolved');

      var schemaPromise = self._loadingSchemas[ref];
      if (!schemaPromise) {
        schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref);
        schemaPromise.then(removePromise, removePromise);
      }

      return schemaPromise.then(function (sch) {
        if (!added(ref)) {
          return loadMetaSchemaOf(sch).then(function () {
            if (!added(ref)) self.addSchema(sch, ref, undefined, meta);
          });
        }
      }).then(function() {
        return _compileAsync(schemaObj);
      });

      function removePromise() {
        delete self._loadingSchemas[ref];
      }

      function added(ref) {
        return self._refs[ref] || self._schemas[ref];
      }
    }
  }
}

var custom = function generate_custom(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $rule = this,
    $definition = 'definition' + $lvl,
    $rDef = $rule.definition,
    $closingBraces = '';
  var $compile, $inline, $macro, $ruleValidate, $validateCode;
  if ($isData && $rDef.$data) {
    $validateCode = 'keywordValidate' + $lvl;
    var $validateSchema = $rDef.validateSchema;
    out += ' var ' + ($definition) + ' = RULES.custom[\'' + ($keyword) + '\'].definition; var ' + ($validateCode) + ' = ' + ($definition) + '.validate;';
  } else {
    $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
    if (!$ruleValidate) return;
    $schemaValue = 'validate.schema' + $schemaPath;
    $validateCode = $ruleValidate.code;
    $compile = $rDef.compile;
    $inline = $rDef.inline;
    $macro = $rDef.macro;
  }
  var $ruleErrs = $validateCode + '.errors',
    $i = 'i' + $lvl,
    $ruleErr = 'ruleErr' + $lvl,
    $asyncKeyword = $rDef.async;
  if ($asyncKeyword && !it.async) throw new Error('async keyword in sync schema');
  if (!($inline || $macro)) {
    out += '' + ($ruleErrs) + ' = null;';
  }
  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
  if ($isData && $rDef.$data) {
    $closingBraces += '}';
    out += ' if (' + ($schemaValue) + ' === undefined) { ' + ($valid) + ' = true; } else { ';
    if ($validateSchema) {
      $closingBraces += '}';
      out += ' ' + ($valid) + ' = ' + ($definition) + '.validateSchema(' + ($schemaValue) + '); if (' + ($valid) + ') { ';
    }
  }
  if ($inline) {
    if ($rDef.statements) {
      out += ' ' + ($ruleValidate.validate) + ' ';
    } else {
      out += ' ' + ($valid) + ' = ' + ($ruleValidate.validate) + '; ';
    }
  } else if ($macro) {
    var $it = it.util.copy(it);
    var $closingBraces = '';
    $it.level++;
    var $nextValid = 'valid' + $it.level;
    $it.schema = $ruleValidate.validate;
    $it.schemaPath = '';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($code);
  } else {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    out += '  ' + ($validateCode) + '.call( ';
    if (it.opts.passContext) {
      out += 'this';
    } else {
      out += 'self';
    }
    if ($compile || $rDef.schema === false) {
      out += ' , ' + ($data) + ' ';
    } else {
      out += ' , ' + ($schemaValue) + ' , ' + ($data) + ' , validate.schema' + (it.schemaPath) + ' ';
    }
    out += ' , (dataPath || \'\')';
    if (it.errorPath != '""') {
      out += ' + ' + (it.errorPath);
    }
    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ' , rootData )  ';
    var def_callRuleValidate = out;
    out = $$outStack.pop();
    if ($rDef.errors === false) {
      out += ' ' + ($valid) + ' = ';
      if ($asyncKeyword) {
        out += 'await ';
      }
      out += '' + (def_callRuleValidate) + '; ';
    } else {
      if ($asyncKeyword) {
        $ruleErrs = 'customErrors' + $lvl;
        out += ' var ' + ($ruleErrs) + ' = null; try { ' + ($valid) + ' = await ' + (def_callRuleValidate) + '; } catch (e) { ' + ($valid) + ' = false; if (e instanceof ValidationError) ' + ($ruleErrs) + ' = e.errors; else throw e; } ';
      } else {
        out += ' ' + ($ruleErrs) + ' = null; ' + ($valid) + ' = ' + (def_callRuleValidate) + '; ';
      }
    }
  }
  if ($rDef.modifying) {
    out += ' if (' + ($parentData) + ') ' + ($data) + ' = ' + ($parentData) + '[' + ($parentDataProperty) + '];';
  }
  out += '' + ($closingBraces);
  if ($rDef.valid) {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  } else {
    out += ' if ( ';
    if ($rDef.valid === undefined) {
      out += ' !';
      if ($macro) {
        out += '' + ($nextValid);
      } else {
        out += '' + ($valid);
      }
    } else {
      out += ' ' + (!$rDef.valid) + ' ';
    }
    out += ') { ';
    $errorKeyword = $rule.keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \'' + ($rule.keyword) + '\' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should pass "' + ($rule.keyword) + '" keyword validation\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    var def_customError = out;
    out = $$outStack.pop();
    if ($inline) {
      if ($rDef.errors) {
        if ($rDef.errors != 'full') {
          out += '  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '"; } ';
          if (it.opts.verbose) {
            out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
          }
          out += ' } ';
        }
      } else {
        if ($rDef.errors === false) {
          out += ' ' + (def_customError) + ' ';
        } else {
          out += ' if (' + ($errs) + ' == errors) { ' + (def_customError) + ' } else {  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '"; } ';
          if (it.opts.verbose) {
            out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
          }
          out += ' } } ';
        }
      }
    } else if ($macro) {
      out += '   var err =   '; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \'' + ($rule.keyword) + '\' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should pass "' + ($rule.keyword) + '" keyword validation\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError(vErrors); ';
        } else {
          out += ' validate.errors = vErrors; return false; ';
        }
      }
    } else {
      if ($rDef.errors === false) {
        out += ' ' + (def_customError) + ' ';
      } else {
        out += ' if (Array.isArray(' + ($ruleErrs) + ')) { if (vErrors === null) vErrors = ' + ($ruleErrs) + '; else vErrors = vErrors.concat(' + ($ruleErrs) + '); errors = vErrors.length;  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + ';  ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '";  ';
        if (it.opts.verbose) {
          out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
        }
        out += ' } } else { ' + (def_customError) + ' } ';
      }
    }
    out += ' } ';
    if ($breakOnError) {
      out += ' else { ';
    }
  }
  return out;
};

var $schema$1 = "http://json-schema.org/draft-07/schema#";
var $id$1 = "http://json-schema.org/draft-07/schema#";
var title$1 = "Core schema meta-schema";
var definitions = {
	schemaArray: {
		type: "array",
		minItems: 1,
		items: {
			$ref: "#"
		}
	},
	nonNegativeInteger: {
		type: "integer",
		minimum: 0
	},
	nonNegativeIntegerDefault0: {
		allOf: [
			{
				$ref: "#/definitions/nonNegativeInteger"
			},
			{
				"default": 0
			}
		]
	},
	simpleTypes: {
		"enum": [
			"array",
			"boolean",
			"integer",
			"null",
			"number",
			"object",
			"string"
		]
	},
	stringArray: {
		type: "array",
		items: {
			type: "string"
		},
		uniqueItems: true,
		"default": [
		]
	}
};
var type$3 = [
	"object",
	"boolean"
];
var properties$3 = {
	$id: {
		type: "string",
		format: "uri-reference"
	},
	$schema: {
		type: "string",
		format: "uri"
	},
	$ref: {
		type: "string",
		format: "uri-reference"
	},
	$comment: {
		type: "string"
	},
	title: {
		type: "string"
	},
	description: {
		type: "string"
	},
	"default": true,
	readOnly: {
		type: "boolean",
		"default": false
	},
	examples: {
		type: "array",
		items: true
	},
	multipleOf: {
		type: "number",
		exclusiveMinimum: 0
	},
	maximum: {
		type: "number"
	},
	exclusiveMaximum: {
		type: "number"
	},
	minimum: {
		type: "number"
	},
	exclusiveMinimum: {
		type: "number"
	},
	maxLength: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minLength: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	pattern: {
		type: "string",
		format: "regex"
	},
	additionalItems: {
		$ref: "#"
	},
	items: {
		anyOf: [
			{
				$ref: "#"
			},
			{
				$ref: "#/definitions/schemaArray"
			}
		],
		"default": true
	},
	maxItems: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minItems: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	uniqueItems: {
		type: "boolean",
		"default": false
	},
	contains: {
		$ref: "#"
	},
	maxProperties: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minProperties: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	required: {
		$ref: "#/definitions/stringArray"
	},
	additionalProperties: {
		$ref: "#"
	},
	definitions: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	properties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	patternProperties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		propertyNames: {
			format: "regex"
		},
		"default": {
		}
	},
	dependencies: {
		type: "object",
		additionalProperties: {
			anyOf: [
				{
					$ref: "#"
				},
				{
					$ref: "#/definitions/stringArray"
				}
			]
		}
	},
	propertyNames: {
		$ref: "#"
	},
	"const": true,
	"enum": {
		type: "array",
		items: true,
		minItems: 1,
		uniqueItems: true
	},
	type: {
		anyOf: [
			{
				$ref: "#/definitions/simpleTypes"
			},
			{
				type: "array",
				items: {
					$ref: "#/definitions/simpleTypes"
				},
				minItems: 1,
				uniqueItems: true
			}
		]
	},
	format: {
		type: "string"
	},
	contentMediaType: {
		type: "string"
	},
	contentEncoding: {
		type: "string"
	},
	"if": {
		$ref: "#"
	},
	then: {
		$ref: "#"
	},
	"else": {
		$ref: "#"
	},
	allOf: {
		$ref: "#/definitions/schemaArray"
	},
	anyOf: {
		$ref: "#/definitions/schemaArray"
	},
	oneOf: {
		$ref: "#/definitions/schemaArray"
	},
	not: {
		$ref: "#"
	}
};
var require$$13 = {
	$schema: $schema$1,
	$id: $id$1,
	title: title$1,
	definitions: definitions,
	type: type$3,
	properties: properties$3,
	"default": true
};

var metaSchema = require$$13;

var definition_schema = {
  $id: 'https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js',
  definitions: {
    simpleTypes: metaSchema.definitions.simpleTypes
  },
  type: 'object',
  dependencies: {
    schema: ['validate'],
    $data: ['validate'],
    statements: ['inline'],
    valid: {not: {required: ['macro']}}
  },
  properties: {
    type: metaSchema.properties.type,
    schema: {type: 'boolean'},
    statements: {type: 'boolean'},
    dependencies: {
      type: 'array',
      items: {type: 'string'}
    },
    metaSchema: {type: 'object'},
    modifying: {type: 'boolean'},
    valid: {type: 'boolean'},
    $data: {type: 'boolean'},
    async: {type: 'boolean'},
    errors: {
      anyOf: [
        {type: 'boolean'},
        {const: 'full'}
      ]
    }
  }
};

var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
var customRuleCode = custom;
var definitionSchema = definition_schema;

var keyword = {
  add: addKeyword,
  get: getKeyword,
  remove: removeKeyword,
  validate: validateKeyword
};


/**
 * Define custom keyword
 * @this  Ajv
 * @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).
 * @param {Object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.
 * @return {Ajv} this for method chaining
 */
function addKeyword(keyword, definition) {
  /* jshint validthis: true */
  /* eslint no-shadow: 0 */
  var RULES = this.RULES;
  if (RULES.keywords[keyword])
    throw new Error('Keyword ' + keyword + ' is already defined');

  if (!IDENTIFIER.test(keyword))
    throw new Error('Keyword ' + keyword + ' is not a valid identifier');

  if (definition) {
    this.validateKeyword(definition, true);

    var dataType = definition.type;
    if (Array.isArray(dataType)) {
      for (var i=0; i<dataType.length; i++)
        _addRule(keyword, dataType[i], definition);
    } else {
      _addRule(keyword, dataType, definition);
    }

    var metaSchema = definition.metaSchema;
    if (metaSchema) {
      if (definition.$data && this._opts.$data) {
        metaSchema = {
          anyOf: [
            metaSchema,
            { '$ref': 'https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#' }
          ]
        };
      }
      definition.validateSchema = this.compile(metaSchema, true);
    }
  }

  RULES.keywords[keyword] = RULES.all[keyword] = true;


  function _addRule(keyword, dataType, definition) {
    var ruleGroup;
    for (var i=0; i<RULES.length; i++) {
      var rg = RULES[i];
      if (rg.type == dataType) {
        ruleGroup = rg;
        break;
      }
    }

    if (!ruleGroup) {
      ruleGroup = { type: dataType, rules: [] };
      RULES.push(ruleGroup);
    }

    var rule = {
      keyword: keyword,
      definition: definition,
      custom: true,
      code: customRuleCode,
      implements: definition.implements
    };
    ruleGroup.rules.push(rule);
    RULES.custom[keyword] = rule;
  }

  return this;
}


/**
 * Get keyword
 * @this  Ajv
 * @param {String} keyword pre-defined or custom keyword.
 * @return {Object|Boolean} custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.
 */
function getKeyword(keyword) {
  /* jshint validthis: true */
  var rule = this.RULES.custom[keyword];
  return rule ? rule.definition : this.RULES.keywords[keyword] || false;
}


/**
 * Remove keyword
 * @this  Ajv
 * @param {String} keyword pre-defined or custom keyword.
 * @return {Ajv} this for method chaining
 */
function removeKeyword(keyword) {
  /* jshint validthis: true */
  var RULES = this.RULES;
  delete RULES.keywords[keyword];
  delete RULES.all[keyword];
  delete RULES.custom[keyword];
  for (var i=0; i<RULES.length; i++) {
    var rules = RULES[i].rules;
    for (var j=0; j<rules.length; j++) {
      if (rules[j].keyword == keyword) {
        rules.splice(j, 1);
        break;
      }
    }
  }
  return this;
}


/**
 * Validate keyword definition
 * @this  Ajv
 * @param {Object} definition keyword definition object.
 * @param {Boolean} throwError true to throw exception if definition is invalid
 * @return {boolean} validation result
 */
function validateKeyword(definition, throwError) {
  validateKeyword.errors = null;
  var v = this._validateKeyword = this._validateKeyword
                                  || this.compile(definitionSchema, true);

  if (v(definition)) return true;
  validateKeyword.errors = v.errors;
  if (throwError)
    throw new Error('custom keyword definition is invalid: '  + this.errorsText(v.errors));
  else
    return false;
}

var $schema = "http://json-schema.org/draft-07/schema#";
var $id = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
var description = "Meta-schema for $data reference (JSON Schema extension proposal)";
var type$2 = "object";
var required$2 = [
	"$data"
];
var properties$2 = {
	$data: {
		type: "string",
		anyOf: [
			{
				format: "relative-json-pointer"
			},
			{
				format: "json-pointer"
			}
		]
	}
};
var additionalProperties = false;
var require$$12 = {
	$schema: $schema,
	$id: $id,
	description: description,
	type: type$2,
	required: required$2,
	properties: properties$2,
	additionalProperties: additionalProperties
};

var compileSchema = compile_1
  , resolve = resolve_1
  , Cache = cache$1.exports
  , SchemaObject = schema_obj
  , stableStringify = fastJsonStableStringify
  , formats = formats_1
  , rules = rules$1
  , $dataMetaSchema = data
  , util$3 = util$8;

var ajv = Ajv$1;

Ajv$1.prototype.validate = validate;
Ajv$1.prototype.compile = compile;
Ajv$1.prototype.addSchema = addSchema;
Ajv$1.prototype.addMetaSchema = addMetaSchema;
Ajv$1.prototype.validateSchema = validateSchema;
Ajv$1.prototype.getSchema = getSchema;
Ajv$1.prototype.removeSchema = removeSchema;
Ajv$1.prototype.addFormat = addFormat;
Ajv$1.prototype.errorsText = errorsText;

Ajv$1.prototype._addSchema = _addSchema;
Ajv$1.prototype._compile = _compile;

Ajv$1.prototype.compileAsync = async;
var customKeyword = keyword;
Ajv$1.prototype.addKeyword = customKeyword.add;
Ajv$1.prototype.getKeyword = customKeyword.get;
Ajv$1.prototype.removeKeyword = customKeyword.remove;
Ajv$1.prototype.validateKeyword = customKeyword.validate;

var errorClasses = error_classes;
Ajv$1.ValidationError = errorClasses.Validation;
Ajv$1.MissingRefError = errorClasses.MissingRef;
Ajv$1.$dataMetaSchema = $dataMetaSchema;

var META_SCHEMA_ID = 'http://json-schema.org/draft-07/schema';

var META_IGNORE_OPTIONS = [ 'removeAdditional', 'useDefaults', 'coerceTypes', 'strictDefaults' ];
var META_SUPPORT_DATA = ['/properties'];

/**
 * Creates validator instance.
 * Usage: `Ajv(opts)`
 * @param {Object} opts optional options
 * @return {Object} ajv instance
 */
function Ajv$1(opts) {
  if (!(this instanceof Ajv$1)) return new Ajv$1(opts);
  opts = this._opts = util$3.copy(opts) || {};
  setLogger(this);
  this._schemas = {};
  this._refs = {};
  this._fragments = {};
  this._formats = formats(opts.format);

  this._cache = opts.cache || new Cache;
  this._loadingSchemas = {};
  this._compilations = [];
  this.RULES = rules();
  this._getId = chooseGetId(opts);

  opts.loopRequired = opts.loopRequired || Infinity;
  if (opts.errorDataPath == 'property') opts._errorDataPathProperty = true;
  if (opts.serialize === undefined) opts.serialize = stableStringify;
  this._metaOpts = getMetaSchemaOptions(this);

  if (opts.formats) addInitialFormats(this);
  if (opts.keywords) addInitialKeywords(this);
  addDefaultMetaSchema(this);
  if (typeof opts.meta == 'object') this.addMetaSchema(opts.meta);
  if (opts.nullable) this.addKeyword('nullable', {metaSchema: {type: 'boolean'}});
  addInitialSchemas(this);
}



/**
 * Validate data using schema
 * Schema will be compiled and cached (using serialized JSON as key. [fast-json-stable-stringify](https://github.com/epoberezkin/fast-json-stable-stringify) is used to serialize.
 * @this   Ajv
 * @param  {String|Object} schemaKeyRef key, ref or schema object
 * @param  {Any} data to be validated
 * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).
 */
function validate(schemaKeyRef, data) {
  var v;
  if (typeof schemaKeyRef == 'string') {
    v = this.getSchema(schemaKeyRef);
    if (!v) throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
  } else {
    var schemaObj = this._addSchema(schemaKeyRef);
    v = schemaObj.validate || this._compile(schemaObj);
  }

  var valid = v(data);
  if (v.$async !== true) this.errors = v.errors;
  return valid;
}


/**
 * Create validating function for passed schema.
 * @this   Ajv
 * @param  {Object} schema schema object
 * @param  {Boolean} _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.
 * @return {Function} validating function
 */
function compile(schema, _meta) {
  var schemaObj = this._addSchema(schema, undefined, _meta);
  return schemaObj.validate || this._compile(schemaObj);
}


/**
 * Adds schema to the instance.
 * @this   Ajv
 * @param {Object|Array} schema schema or array of schemas. If array is passed, `key` and other parameters will be ignored.
 * @param {String} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
 * @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.
 * @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
 * @return {Ajv} this for method chaining
 */
function addSchema(schema, key, _skipValidation, _meta) {
  if (Array.isArray(schema)){
    for (var i=0; i<schema.length; i++) this.addSchema(schema[i], undefined, _skipValidation, _meta);
    return this;
  }
  var id = this._getId(schema);
  if (id !== undefined && typeof id != 'string')
    throw new Error('schema id must be string');
  key = resolve.normalizeId(key || id);
  checkUnique(this, key);
  this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
  return this;
}


/**
 * Add schema that will be used to validate other schemas
 * options in META_IGNORE_OPTIONS are alway set to false
 * @this   Ajv
 * @param {Object} schema schema object
 * @param {String} key optional schema key
 * @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema
 * @return {Ajv} this for method chaining
 */
function addMetaSchema(schema, key, skipValidation) {
  this.addSchema(schema, key, skipValidation, true);
  return this;
}


/**
 * Validate schema
 * @this   Ajv
 * @param {Object} schema schema to validate
 * @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid
 * @return {Boolean} true if schema is valid
 */
function validateSchema(schema, throwOrLogError) {
  var $schema = schema.$schema;
  if ($schema !== undefined && typeof $schema != 'string')
    throw new Error('$schema must be a string');
  $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
  if (!$schema) {
    this.logger.warn('meta-schema not available');
    this.errors = null;
    return true;
  }
  var valid = this.validate($schema, schema);
  if (!valid && throwOrLogError) {
    var message = 'schema is invalid: ' + this.errorsText();
    if (this._opts.validateSchema == 'log') this.logger.error(message);
    else throw new Error(message);
  }
  return valid;
}


function defaultMeta(self) {
  var meta = self._opts.meta;
  self._opts.defaultMeta = typeof meta == 'object'
                            ? self._getId(meta) || meta
                            : self.getSchema(META_SCHEMA_ID)
                              ? META_SCHEMA_ID
                              : undefined;
  return self._opts.defaultMeta;
}


/**
 * Get compiled schema from the instance by `key` or `ref`.
 * @this   Ajv
 * @param  {String} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).
 * @return {Function} schema validating function (with property `schema`).
 */
function getSchema(keyRef) {
  var schemaObj = _getSchemaObj(this, keyRef);
  switch (typeof schemaObj) {
    case 'object': return schemaObj.validate || this._compile(schemaObj);
    case 'string': return this.getSchema(schemaObj);
    case 'undefined': return _getSchemaFragment(this, keyRef);
  }
}


function _getSchemaFragment(self, ref) {
  var res = resolve.schema.call(self, { schema: {} }, ref);
  if (res) {
    var schema = res.schema
      , root = res.root
      , baseId = res.baseId;
    var v = compileSchema.call(self, schema, root, undefined, baseId);
    self._fragments[ref] = new SchemaObject({
      ref: ref,
      fragment: true,
      schema: schema,
      root: root,
      baseId: baseId,
      validate: v
    });
    return v;
  }
}


function _getSchemaObj(self, keyRef) {
  keyRef = resolve.normalizeId(keyRef);
  return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];
}


/**
 * Remove cached schema(s).
 * If no parameter is passed all schemas but meta-schemas are removed.
 * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
 * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
 * @this   Ajv
 * @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object
 * @return {Ajv} this for method chaining
 */
function removeSchema(schemaKeyRef) {
  if (schemaKeyRef instanceof RegExp) {
    _removeAllSchemas(this, this._schemas, schemaKeyRef);
    _removeAllSchemas(this, this._refs, schemaKeyRef);
    return this;
  }
  switch (typeof schemaKeyRef) {
    case 'undefined':
      _removeAllSchemas(this, this._schemas);
      _removeAllSchemas(this, this._refs);
      this._cache.clear();
      return this;
    case 'string':
      var schemaObj = _getSchemaObj(this, schemaKeyRef);
      if (schemaObj) this._cache.del(schemaObj.cacheKey);
      delete this._schemas[schemaKeyRef];
      delete this._refs[schemaKeyRef];
      return this;
    case 'object':
      var serialize = this._opts.serialize;
      var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
      this._cache.del(cacheKey);
      var id = this._getId(schemaKeyRef);
      if (id) {
        id = resolve.normalizeId(id);
        delete this._schemas[id];
        delete this._refs[id];
      }
  }
  return this;
}


function _removeAllSchemas(self, schemas, regex) {
  for (var keyRef in schemas) {
    var schemaObj = schemas[keyRef];
    if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
      self._cache.del(schemaObj.cacheKey);
      delete schemas[keyRef];
    }
  }
}


/* @this   Ajv */
function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
  if (typeof schema != 'object' && typeof schema != 'boolean')
    throw new Error('schema should be object or boolean');
  var serialize = this._opts.serialize;
  var cacheKey = serialize ? serialize(schema) : schema;
  var cached = this._cache.get(cacheKey);
  if (cached) return cached;

  shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;

  var id = resolve.normalizeId(this._getId(schema));
  if (id && shouldAddSchema) checkUnique(this, id);

  var willValidate = this._opts.validateSchema !== false && !skipValidation;
  var recursiveMeta;
  if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))
    this.validateSchema(schema, true);

  var localRefs = resolve.ids.call(this, schema);

  var schemaObj = new SchemaObject({
    id: id,
    schema: schema,
    localRefs: localRefs,
    cacheKey: cacheKey,
    meta: meta
  });

  if (id[0] != '#' && shouldAddSchema) this._refs[id] = schemaObj;
  this._cache.put(cacheKey, schemaObj);

  if (willValidate && recursiveMeta) this.validateSchema(schema, true);

  return schemaObj;
}


/* @this   Ajv */
function _compile(schemaObj, root) {
  if (schemaObj.compiling) {
    schemaObj.validate = callValidate;
    callValidate.schema = schemaObj.schema;
    callValidate.errors = null;
    callValidate.root = root ? root : callValidate;
    if (schemaObj.schema.$async === true)
      callValidate.$async = true;
    return callValidate;
  }
  schemaObj.compiling = true;

  var currentOpts;
  if (schemaObj.meta) {
    currentOpts = this._opts;
    this._opts = this._metaOpts;
  }

  var v;
  try { v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs); }
  catch(e) {
    delete schemaObj.validate;
    throw e;
  }
  finally {
    schemaObj.compiling = false;
    if (schemaObj.meta) this._opts = currentOpts;
  }

  schemaObj.validate = v;
  schemaObj.refs = v.refs;
  schemaObj.refVal = v.refVal;
  schemaObj.root = v.root;
  return v;


  /* @this   {*} - custom context, see passContext option */
  function callValidate() {
    /* jshint validthis: true */
    var _validate = schemaObj.validate;
    var result = _validate.apply(this, arguments);
    callValidate.errors = _validate.errors;
    return result;
  }
}


function chooseGetId(opts) {
  switch (opts.schemaId) {
    case 'auto': return _get$IdOrId;
    case 'id': return _getId;
    default: return _get$Id;
  }
}

/* @this   Ajv */
function _getId(schema) {
  if (schema.$id) this.logger.warn('schema $id ignored', schema.$id);
  return schema.id;
}

/* @this   Ajv */
function _get$Id(schema) {
  if (schema.id) this.logger.warn('schema id ignored', schema.id);
  return schema.$id;
}


function _get$IdOrId(schema) {
  if (schema.$id && schema.id && schema.$id != schema.id)
    throw new Error('schema $id is different from id');
  return schema.$id || schema.id;
}


/**
 * Convert array of error message objects to string
 * @this   Ajv
 * @param  {Array<Object>} errors optional array of validation errors, if not passed errors from the instance are used.
 * @param  {Object} options optional options with properties `separator` and `dataVar`.
 * @return {String} human readable string with all errors descriptions
 */
function errorsText(errors, options) {
  errors = errors || this.errors;
  if (!errors) return 'No errors';
  options = options || {};
  var separator = options.separator === undefined ? ', ' : options.separator;
  var dataVar = options.dataVar === undefined ? 'data' : options.dataVar;

  var text = '';
  for (var i=0; i<errors.length; i++) {
    var e = errors[i];
    if (e) text += dataVar + e.dataPath + ' ' + e.message + separator;
  }
  return text.slice(0, -separator.length);
}


/**
 * Add custom format
 * @this   Ajv
 * @param {String} name format name
 * @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)
 * @return {Ajv} this for method chaining
 */
function addFormat(name, format) {
  if (typeof format == 'string') format = new RegExp(format);
  this._formats[name] = format;
  return this;
}


function addDefaultMetaSchema(self) {
  var $dataSchema;
  if (self._opts.$data) {
    $dataSchema = require$$12;
    self.addMetaSchema($dataSchema, $dataSchema.$id, true);
  }
  if (self._opts.meta === false) return;
  var metaSchema = require$$13;
  if (self._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
  self.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
  self._refs['http://json-schema.org/schema'] = META_SCHEMA_ID;
}


function addInitialSchemas(self) {
  var optsSchemas = self._opts.schemas;
  if (!optsSchemas) return;
  if (Array.isArray(optsSchemas)) self.addSchema(optsSchemas);
  else for (var key in optsSchemas) self.addSchema(optsSchemas[key], key);
}


function addInitialFormats(self) {
  for (var name in self._opts.formats) {
    var format = self._opts.formats[name];
    self.addFormat(name, format);
  }
}


function addInitialKeywords(self) {
  for (var name in self._opts.keywords) {
    var keyword = self._opts.keywords[name];
    self.addKeyword(name, keyword);
  }
}


function checkUnique(self, id) {
  if (self._schemas[id] || self._refs[id])
    throw new Error('schema with key or id "' + id + '" already exists');
}


function getMetaSchemaOptions(self) {
  var metaOpts = util$3.copy(self._opts);
  for (var i=0; i<META_IGNORE_OPTIONS.length; i++)
    delete metaOpts[META_IGNORE_OPTIONS[i]];
  return metaOpts;
}


function setLogger(self) {
  var logger = self._opts.logger;
  if (logger === false) {
    self.logger = {log: noop, warn: noop, error: noop};
  } else {
    if (logger === undefined) logger = console;
    if (!(typeof logger == 'object' && logger.log && logger.warn && logger.error))
      throw new Error('logger must implement log, warn and error methods');
    self.logger = logger;
  }
}


function noop() {}

var _version = "2.4";
var type$1 = "object";
var properties$1 = {
	info: {
		type: "object",
		properties: {
			uid: {
				type: "string",
				title: " UID"
			},
			lang: {
				type: "string",
				title: " languagecode2-country/regioncode2"
			},
			export_timestamp: {
				type: "number",
				title: " UNIX "
			},
			export_time: {
				type: "string",
				title: "",
				description: "yyyy-MM-dd HH:mm:ss"
			},
			export_app: {
				type: "string",
				title: " App "
			},
			export_app_version: {
				type: "string",
				title: " App "
			},
			uigf_version: {
				type: "string",
				title: "UIGF ",
				pattern: "v\\d+\\.\\d+"
			},
			region_time_zone: {
				type: "number",
				title: ""
			}
		},
		required: [
			"uid",
			"uigf_version"
		],
		title: "UIGF "
	},
	list: {
		type: "array",
		items: {
			type: "object",
			properties: {
				uigf_gacha_type: {
					type: "string",
					title: "UIGF ",
					description: ""
				},
				gacha_type: {
					type: "string",
					title: ""
				},
				item_id: {
					type: "string",
					title: " ID"
				},
				count: {
					type: "string",
					title: "1"
				},
				time: {
					type: "string",
					title: ""
				},
				name: {
					type: "string",
					title: ""
				},
				item_type: {
					type: "string",
					title: ""
				},
				rank_type: {
					type: "string",
					title: ""
				},
				id: {
					type: "string",
					title: " ID"
				}
			},
			required: [
				"uigf_gacha_type",
				"gacha_type",
				"id",
				"item_id",
				"time"
			],
			title: "UIGF "
		},
		title: ""
	}
};
var required$1 = [
	"info",
	"list"
];
var title = "UIGF ";
var require$$10 = {
	_version: _version,
	type: type$1,
	properties: properties$1,
	required: required$1,
	title: title
};

var type = "object";
var properties = {
	time: {
		type: "number",
		title: ""
	},
	uid: {
		type: "string",
		title: "UID"
	},
	lang: {
		type: "string",
		title: ""
	},
	typeMap: {
		type: "array",
		items: {
			type: "array",
			items: {
				type: "string",
				minItems: 2
			}
		},
		minItems: 4
	},
	result: {
		type: "array",
		items: {
			type: "array",
			items: [
				{
					type: "string"
				},
				{
					type: "array",
					items: {
						type: "array",
						items: [
							{
								type: "string"
							},
							{
								type: "string"
							},
							{
								type: "string"
							},
							{
								type: "integer"
							}
						],
						additionalItems: {
							type: "string"
						}
					}
				}
			],
			additionalItems: false
		}
	}
};
var required = [
	"uid",
	"lang",
	"typeMap",
	"result"
];
var require$$11 = {
	type: type,
	properties: properties,
	required: required
};

const { app: app$2, ipcMain: ipcMain$1, dialog } = require$$0__default$4["default"];
const fs$4 = lib$1;
const path$2 = require$$1__default["default"];
const { getData, saveData, changeCurrent } = getData$3;
const getItemTypeNameMap = gachaTypeMap.getItemTypeNameMap;
const { version: version$1 } = require$$7;
const config$1 = config_1;
const fetch$1 = require$$1$1.default;
const { readJSON, saveJSON, existsFile, userDataPath, fixLocalMap } = utils;
const Ajv = ajv;
const validateUigfJson = new Ajv().compile(require$$10);
const validateLocalJson = new Ajv().compile(require$$11);
const uigfLangMap = new Map([
  ["zh-cn", "chs"],
  ["zh-tw", "cht"],
  ["de-de", "de"],
  ["en-us", "en"],
  ["es-es", "es"],
  ["fr-fr", "fr"],
  ["id-id", "id"],
  ["ja-jp", "ja"],
  ["ko-kr", "kr"],
  ["pt-pt", "pt"],
  ["ru-ru", "ru"],
  ["th-th", "th"],
  ["vi-vn", "vi"]
]);
const getTimeString = () => {
  return new Date().toLocaleString("sv").replace(/[- :]/g, "").slice(0, -2);
};
const formatDate = (date) => {
  let y = date.getFullYear();
  let m = `${date.getMonth() + 1}`.padStart(2, "0");
  let d = `${date.getDate()}`.padStart(2, "0");
  return `${y}-${m}-${d} ${date.toLocaleString("zh-cn", { hour12: false }).slice(-8)}`;
};
const fakeIdFn = () => {
  let id = 1000000000000000000n;
  return () => {
    id = id + 1n;
    return id.toString();
  };
};
const shouldBeString = (value) => {
  if (typeof value !== "string") {
    return "";
  }
  return value;
};
const itemIdDict = new Map();
let itemIdDictMd5 = null;
const itemIdDictFileName = "item-id-dict.json";
const fetchItemIdDict = async (lang = "all") => {
  const response = await fetch$1(`https://api.uigf.org/dict/genshin/${lang}.json`);
  Object.entries(await response.json()).forEach(([lang2, table]) => itemIdDict.set(lang2, new Map(Object.entries(table).map(([name, id]) => [name, String(id)]))));
};
const fetchItemIdDictMd5 = async (lang = "all") => {
  const response = await fetch$1("https://api.uigf.org/md5/genshin");
  const responseJson = await response.json();
  return responseJson[lang];
};
const initLookupTable = async () => {
  if (itemIdDictMd5) {
    return;
  }
  try {
    itemIdDictMd5 = await fetchItemIdDictMd5();
  } catch (e) {
    console.log(`Unable to fetch latest item id dictionary md5 due to: ${e}`);
  }
  if (!existsFile(itemIdDictFileName)) {
    await fetchItemIdDict();
    return;
  }
  const data = await readJSON(itemIdDictFileName);
  if (!itemIdDictMd5 && data)
    itemIdDictMd5 = data.md5;
  if (!data || data.md5 !== itemIdDictMd5) {
    await fetchItemIdDict();
    return;
  }
  data.lang.forEach(([lang, table]) => itemIdDict.set(lang, new Map(table)));
};
const saveLookupTable = async () => {
  await saveJSON(itemIdDictFileName, { lang: itemIdDict, md5: itemIdDictMd5 });
};
const getItemId = async (lang, name) => {
  if (!itemIdDict.has(lang) || !itemIdDict.get(lang).has(name)) {
    const response = await fetch$1(`https://api.uigf.org/identify/genshin/${name}`);
    const responseJson = await response.json();
    if (!responseJson.item_id) {
      throw new Error(`Couldn't find the item_id for the ${name}.`);
    }
    itemIdDict.get(lang).set(name, responseJson.item_id.toString());
  }
  return itemIdDict.get(lang).get(name);
};
const fixUigfJson = (importData) => {
  importData.list.forEach((e) => {
    if (!e.item_id) {
      e.item_id = "";
    }
  });
};
const uigfJson = async () => {
  const { dataMap, current } = getData();
  const data = dataMap.get(current);
  if (!data?.result.size) {
    throw new Error("\u6570\u636E\u4E3A\u7A7A");
  }
  const fakeId = fakeIdFn();
  const result = {
    info: {
      uid: data.uid,
      lang: data.lang,
      export_time: formatDate(new Date()),
      export_timestamp: Math.round(Date.now() / 1e3),
      export_app: "genshin-wish-export",
      export_app_version: `v${version$1}`,
      uigf_version: "v3.0",
      region_time_zone: data.uid.startsWith("6") ? -5 : data.uid.startsWith("7") ? 1 : 8
    },
    list: []
  };
  const listTemp = [];
  const uigfLang = uigfLangMap.get(data.lang) || uigfLangMap.get(fixLocalMap.get(data.lang));
  for (let [type, arr] of data.result) {
    for (let item of arr) {
      listTemp.push({
        gacha_type: shouldBeString(item[4]) || type,
        time: item[0],
        timestamp: new Date(item[0]).getTime(),
        name: item[1],
        item_type: item[2],
        item_id: await getItemId(uigfLang, item[1]),
        rank_type: `${item[3]}`,
        id: shouldBeString(item[5]) || "",
        uigf_gacha_type: type
      });
    }
  }
  listTemp.sort((a, b) => a.timestamp - b.timestamp);
  listTemp.forEach((item) => {
    delete item.timestamp;
    result.list.push({
      ...item,
      id: item.id || fakeId()
    });
  });
  return result;
};
const start = async () => {
  await initLookupTable();
  const result = await uigfJson();
  await saveLookupTable();
  const filePath = dialog.showSaveDialogSync({
    defaultPath: path$2.join(app$2.getPath("downloads"), `UIGF_${result.info.uid}_${getTimeString()}`),
    filters: [
      { name: "JSON", extensions: ["json"] }
    ]
  });
  if (filePath) {
    await fs$4.ensureFile(filePath);
    await fs$4.writeFile(filePath, JSON.stringify(result, null, config$1.readableJSON ? "	" : null));
  }
};
const saveAndBackup = async (data) => {
  if (existsFile(`gacha-list-${data.uid}.json`)) {
    const backupDir = path$2.join(userDataPath, "backup", data.uid);
    await fs$4.ensureDir(backupDir);
    await fs$4.copyFile(path$2.join(userDataPath, `gacha-list-${data.uid}.json`), path$2.join(backupDir, `gacha-list-${data.uid}-${getTimeString()}.json`));
  }
  await saveData(data);
  await changeCurrent(data.uid);
};
const importJson = async () => {
  const filePathArr = dialog.showOpenDialogSync({
    defaultPath: app$2.getPath("downloads"),
    filters: [
      { name: "JSON", extensions: ["json"] }
    ]
  });
  if (filePathArr) {
    const filePath = filePathArr[0];
    const jsonStr = await fs$4.readFile(filePath, "utf8");
    const importData = JSON.parse(jsonStr);
    if (validateLocalJson(importData)) {
      await saveAndBackup(importData);
    } else {
      fixUigfJson(importData);
      if (validateUigfJson(importData)) {
        const gachaData = {
          result: new Map(),
          time: Date.now(),
          typeMap: getItemTypeNameMap(importData.info.lang),
          uid: importData.info.uid,
          lang: importData.info.lang
        };
        gachaData.typeMap.forEach((_, k) => gachaData.result.set(k, []));
        importData.list.sort((a, b) => parseInt(BigInt(a.id) - BigInt(b.id)));
        for (const item of importData.list) {
          gachaData.result.get(item.uigf_gacha_type).push([item.time, item.name, item.item_type, parseInt(item.rank_type), item.gacha_type, item.id]);
        }
        await saveAndBackup(gachaData);
      } else {
        throw new Error(`JSON format error`);
      }
    }
  } else {
    return "canceled";
  }
};
ipcMain$1.handle("EXPORT_UIGF_JSON", async () => {
  await start();
});
ipcMain$1.handle("IMPORT_UIGF_JSON", async () => {
  return await importJson();
});

var update$1 = {};

var re$5 = {exports: {}};

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = '2.0.0';

const MAX_LENGTH$2 = 256;
const MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991;

// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16;

var constants = {
  SEMVER_SPEC_VERSION,
  MAX_LENGTH: MAX_LENGTH$2,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
  MAX_SAFE_COMPONENT_LENGTH
};

const debug$3 = (
  typeof process === 'object' &&
  process.env &&
  process.env.NODE_DEBUG &&
  /\bsemver\b/i.test(process.env.NODE_DEBUG)
) ? (...args) => console.error('SEMVER', ...args)
  : () => {};

var debug_1 = debug$3;

(function (module, exports) {
const { MAX_SAFE_COMPONENT_LENGTH } = constants;
const debug = debug_1;
exports = module.exports = {};

// The actual regexps go on exports.re
const re = exports.re = [];
const src = exports.src = [];
const t = exports.t = {};
let R = 0;

const createToken = (name, value, isGlobal) => {
  const index = R++;
  debug(index, value);
  t[name] = index;
  src[index] = value;
  re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
};

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+');

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

createToken('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*');

// ## Main Version
// Three dot-separated numeric identifiers.

createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})`);

createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`);

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]
}|${src[t.NONNUMERICIDENTIFIER]})`);

createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]
}|${src[t.NONNUMERICIDENTIFIER]})`);

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);

createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+');

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
}${src[t.PRERELEASE]}?${
  src[t.BUILD]}?`);

createToken('FULL', `^${src[t.FULLPLAIN]}$`);

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
}${src[t.PRERELEASELOOSE]}?${
  src[t.BUILD]}?`);

createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`);

createToken('GTLT', '((?:<|>)?=?)');

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);

createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:${src[t.PRERELEASE]})?${
                     src[t.BUILD]}?` +
                   `)?)?`);

createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:${src[t.PRERELEASELOOSE]})?${
                          src[t.BUILD]}?` +
                        `)?)?`);

createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
createToken('COERCE', `${'(^|[^\\d])' +
              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:$|[^\\d])`);
createToken('COERCERTL', src[t.COERCE], true);

// Tilde ranges.
// Meaning is "reasonably at or greater than"
createToken('LONETILDE', '(?:~>?)');

createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true);
exports.tildeTrimReplace = '$1~';

createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);

// Caret ranges.
// Meaning is "at least and backwards compatible with"
createToken('LONECARET', '(?:\\^)');

createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true);
exports.caretTrimReplace = '$1^';

createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);

// A simple gt/lt/eq thing, or just "" to indicate "any version"
createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
exports.comparatorTrimReplace = '$1$2$3';

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
                   `\\s+-\\s+` +
                   `(${src[t.XRANGEPLAIN]})` +
                   `\\s*$`);

createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s+-\\s+` +
                        `(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s*$`);

// Star ranges basically just allow anything at all.
createToken('STAR', '(<|>)?=?\\s*\\*');
// >=0.0.0 is like a star
createToken('GTE0', '^\\s*>=\\s*0\.0\.0\\s*$');
createToken('GTE0PRE', '^\\s*>=\\s*0\.0\.0-0\\s*$');
}(re$5, re$5.exports));

// parse out just the options we care about so we always get a consistent
// obj with keys in a consistent order.
const opts = ['includePrerelease', 'loose', 'rtl'];
const parseOptions$4 = options =>
  !options ? {}
  : typeof options !== 'object' ? { loose: true }
  : opts.filter(k => options[k]).reduce((options, k) => {
    options[k] = true;
    return options
  }, {});
var parseOptions_1 = parseOptions$4;

const numeric = /^[0-9]+$/;
const compareIdentifiers$1 = (a, b) => {
  const anum = numeric.test(a);
  const bnum = numeric.test(b);

  if (anum && bnum) {
    a = +a;
    b = +b;
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
};

const rcompareIdentifiers = (a, b) => compareIdentifiers$1(b, a);

var identifiers = {
  compareIdentifiers: compareIdentifiers$1,
  rcompareIdentifiers
};

const debug$2 = debug_1;
const { MAX_LENGTH: MAX_LENGTH$1, MAX_SAFE_INTEGER } = constants;
const { re: re$4, t: t$4 } = re$5.exports;

const parseOptions$3 = parseOptions_1;
const { compareIdentifiers } = identifiers;
class SemVer$e {
  constructor (version, options) {
    options = parseOptions$3(options);

    if (version instanceof SemVer$e) {
      if (version.loose === !!options.loose &&
          version.includePrerelease === !!options.includePrerelease) {
        return version
      } else {
        version = version.version;
      }
    } else if (typeof version !== 'string') {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    if (version.length > MAX_LENGTH$1) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH$1} characters`
      )
    }

    debug$2('SemVer', version, options);
    this.options = options;
    this.loose = !!options.loose;
    // this isn't actually relevant for versions, but keep it so that we
    // don't run into trouble passing this.options around.
    this.includePrerelease = !!options.includePrerelease;

    const m = version.trim().match(options.loose ? re$4[t$4.LOOSE] : re$4[t$4.FULL]);

    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    this.raw = version;

    // these are actually numbers
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];

    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version')
    }

    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version')
    }

    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version')
    }

    // numberify any prerelease numeric ids
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split('.').map((id) => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num
          }
        }
        return id
      });
    }

    this.build = m[5] ? m[5].split('.') : [];
    this.format();
  }

  format () {
    this.version = `${this.major}.${this.minor}.${this.patch}`;
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join('.')}`;
    }
    return this.version
  }

  toString () {
    return this.version
  }

  compare (other) {
    debug$2('SemVer.compare', this.version, this.options, other);
    if (!(other instanceof SemVer$e)) {
      if (typeof other === 'string' && other === this.version) {
        return 0
      }
      other = new SemVer$e(other, this.options);
    }

    if (other.version === this.version) {
      return 0
    }

    return this.compareMain(other) || this.comparePre(other)
  }

  compareMain (other) {
    if (!(other instanceof SemVer$e)) {
      other = new SemVer$e(other, this.options);
    }

    return (
      compareIdentifiers(this.major, other.major) ||
      compareIdentifiers(this.minor, other.minor) ||
      compareIdentifiers(this.patch, other.patch)
    )
  }

  comparePre (other) {
    if (!(other instanceof SemVer$e)) {
      other = new SemVer$e(other, this.options);
    }

    // NOT having a prerelease is > having one
    if (this.prerelease.length && !other.prerelease.length) {
      return -1
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0
    }

    let i = 0;
    do {
      const a = this.prerelease[i];
      const b = other.prerelease[i];
      debug$2('prerelease compare', i, a, b);
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  compareBuild (other) {
    if (!(other instanceof SemVer$e)) {
      other = new SemVer$e(other, this.options);
    }

    let i = 0;
    do {
      const a = this.build[i];
      const b = other.build[i];
      debug$2('prerelease compare', i, a, b);
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc (release, identifier) {
    switch (release) {
      case 'premajor':
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc('pre', identifier);
        break
      case 'preminor':
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc('pre', identifier);
        break
      case 'prepatch':
        // If this is already a prerelease, it will bump to the next version
        // drop any prereleases that might already exist, since they are not
        // relevant at this point.
        this.prerelease.length = 0;
        this.inc('patch', identifier);
        this.inc('pre', identifier);
        break
      // If the input is a non-prerelease version, this acts the same as
      // prepatch.
      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier);
        }
        this.inc('pre', identifier);
        break

      case 'major':
        // If this is a pre-major version, bump up to the same major version.
        // Otherwise increment major.
        // 1.0.0-5 bumps to 1.0.0
        // 1.1.0 bumps to 2.0.0
        if (
          this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0
        ) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break
      case 'minor':
        // If this is a pre-minor version, bump up to the same minor version.
        // Otherwise increment minor.
        // 1.2.0-5 bumps to 1.2.0
        // 1.2.1 bumps to 1.3.0
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break
      case 'patch':
        // If this is not a pre-release version, it will increment the patch.
        // If it is a pre-release it will bump up to the same patch version.
        // 1.2.0-5 patches to 1.2.0
        // 1.2.0 patches to 1.2.1
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break
      // This probably shouldn't be used publicly.
      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
      case 'pre':
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          let i = this.prerelease.length;
          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++;
              i = -2;
            }
          }
          if (i === -1) {
            // didn't increment anything
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break

      default:
        throw new Error(`invalid increment argument: ${release}`)
    }
    this.format();
    this.raw = this.version;
    return this
  }
}

var semver$2 = SemVer$e;

const {MAX_LENGTH} = constants;
const { re: re$3, t: t$3 } = re$5.exports;
const SemVer$d = semver$2;

const parseOptions$2 = parseOptions_1;
const parse$5 = (version, options) => {
  options = parseOptions$2(options);

  if (version instanceof SemVer$d) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  const r = options.loose ? re$3[t$3.LOOSE] : re$3[t$3.FULL];
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer$d(version, options)
  } catch (er) {
    return null
  }
};

var parse_1 = parse$5;

const parse$4 = parse_1;
const valid$1 = (version, options) => {
  const v = parse$4(version, options);
  return v ? v.version : null
};
var valid_1 = valid$1;

const parse$3 = parse_1;
const clean = (version, options) => {
  const s = parse$3(version.trim().replace(/^[=v]+/, ''), options);
  return s ? s.version : null
};
var clean_1 = clean;

const SemVer$c = semver$2;

const inc = (version, release, options, identifier) => {
  if (typeof (options) === 'string') {
    identifier = options;
    options = undefined;
  }

  try {
    return new SemVer$c(version, options).inc(release, identifier).version
  } catch (er) {
    return null
  }
};
var inc_1 = inc;

const SemVer$b = semver$2;
const compare$a = (a, b, loose) =>
  new SemVer$b(a, loose).compare(new SemVer$b(b, loose));

var compare_1 = compare$a;

const compare$9 = compare_1;
const eq$2 = (a, b, loose) => compare$9(a, b, loose) === 0;
var eq_1 = eq$2;

const parse$2 = parse_1;
const eq$1 = eq_1;

const diff = (version1, version2) => {
  if (eq$1(version1, version2)) {
    return null
  } else {
    const v1 = parse$2(version1);
    const v2 = parse$2(version2);
    const hasPre = v1.prerelease.length || v2.prerelease.length;
    const prefix = hasPre ? 'pre' : '';
    const defaultResult = hasPre ? 'prerelease' : '';
    for (const key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
};
var diff_1 = diff;

const SemVer$a = semver$2;
const major = (a, loose) => new SemVer$a(a, loose).major;
var major_1 = major;

const SemVer$9 = semver$2;
const minor = (a, loose) => new SemVer$9(a, loose).minor;
var minor_1 = minor;

const SemVer$8 = semver$2;
const patch = (a, loose) => new SemVer$8(a, loose).patch;
var patch_1 = patch;

const parse$1 = parse_1;
const prerelease = (version, options) => {
  const parsed = parse$1(version, options);
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
};
var prerelease_1 = prerelease;

const compare$8 = compare_1;
const rcompare = (a, b, loose) => compare$8(b, a, loose);
var rcompare_1 = rcompare;

const compare$7 = compare_1;
const compareLoose = (a, b) => compare$7(a, b, true);
var compareLoose_1 = compareLoose;

const SemVer$7 = semver$2;
const compareBuild$2 = (a, b, loose) => {
  const versionA = new SemVer$7(a, loose);
  const versionB = new SemVer$7(b, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB)
};
var compareBuild_1 = compareBuild$2;

const compareBuild$1 = compareBuild_1;
const sort = (list, loose) => list.sort((a, b) => compareBuild$1(a, b, loose));
var sort_1 = sort;

const compareBuild = compareBuild_1;
const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
var rsort_1 = rsort;

const compare$6 = compare_1;
const gt$3 = (a, b, loose) => compare$6(a, b, loose) > 0;
var gt_1 = gt$3;

const compare$5 = compare_1;
const lt$2 = (a, b, loose) => compare$5(a, b, loose) < 0;
var lt_1 = lt$2;

const compare$4 = compare_1;
const neq$1 = (a, b, loose) => compare$4(a, b, loose) !== 0;
var neq_1 = neq$1;

const compare$3 = compare_1;
const gte$2 = (a, b, loose) => compare$3(a, b, loose) >= 0;
var gte_1 = gte$2;

const compare$2 = compare_1;
const lte$2 = (a, b, loose) => compare$2(a, b, loose) <= 0;
var lte_1 = lte$2;

const eq = eq_1;
const neq = neq_1;
const gt$2 = gt_1;
const gte$1 = gte_1;
const lt$1 = lt_1;
const lte$1 = lte_1;

const cmp$1 = (a, op, b, loose) => {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version;
      if (typeof b === 'object')
        b = b.version;
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version;
      if (typeof b === 'object')
        b = b.version;
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt$2(a, b, loose)

    case '>=':
      return gte$1(a, b, loose)

    case '<':
      return lt$1(a, b, loose)

    case '<=':
      return lte$1(a, b, loose)

    default:
      throw new TypeError(`Invalid operator: ${op}`)
  }
};
var cmp_1 = cmp$1;

const SemVer$6 = semver$2;
const parse = parse_1;
const {re: re$2, t: t$2} = re$5.exports;

const coerce = (version, options) => {
  if (version instanceof SemVer$6) {
    return version
  }

  if (typeof version === 'number') {
    version = String(version);
  }

  if (typeof version !== 'string') {
    return null
  }

  options = options || {};

  let match = null;
  if (!options.rtl) {
    match = version.match(re$2[t$2.COERCE]);
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    let next;
    while ((next = re$2[t$2.COERCERTL].exec(version)) &&
        (!match || match.index + match[0].length !== version.length)
    ) {
      if (!match ||
            next.index + next[0].length !== match.index + match[0].length) {
        match = next;
      }
      re$2[t$2.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
    }
    // leave it in a clean state
    re$2[t$2.COERCERTL].lastIndex = -1;
  }

  if (match === null)
    return null

  return parse(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options)
};
var coerce_1 = coerce;

var yallist = Yallist$1;

Yallist$1.Node = Node;
Yallist$1.create = Yallist$1;

function Yallist$1 (list) {
  var self = this;
  if (!(self instanceof Yallist$1)) {
    self = new Yallist$1();
  }

  self.tail = null;
  self.head = null;
  self.length = 0;

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item);
    });
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i]);
    }
  }

  return self
}

Yallist$1.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list')
  }

  var next = node.next;
  var prev = node.prev;

  if (next) {
    next.prev = prev;
  }

  if (prev) {
    prev.next = next;
  }

  if (node === this.head) {
    this.head = next;
  }
  if (node === this.tail) {
    this.tail = prev;
  }

  node.list.length--;
  node.next = null;
  node.prev = null;
  node.list = null;

  return next
};

Yallist$1.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return
  }

  if (node.list) {
    node.list.removeNode(node);
  }

  var head = this.head;
  node.list = this;
  node.next = head;
  if (head) {
    head.prev = node;
  }

  this.head = node;
  if (!this.tail) {
    this.tail = node;
  }
  this.length++;
};

Yallist$1.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return
  }

  if (node.list) {
    node.list.removeNode(node);
  }

  var tail = this.tail;
  node.list = this;
  node.prev = tail;
  if (tail) {
    tail.next = node;
  }

  this.tail = node;
  if (!this.head) {
    this.head = node;
  }
  this.length++;
};

Yallist$1.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i]);
  }
  return this.length
};

Yallist$1.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i]);
  }
  return this.length
};

Yallist$1.prototype.pop = function () {
  if (!this.tail) {
    return undefined
  }

  var res = this.tail.value;
  this.tail = this.tail.prev;
  if (this.tail) {
    this.tail.next = null;
  } else {
    this.head = null;
  }
  this.length--;
  return res
};

Yallist$1.prototype.shift = function () {
  if (!this.head) {
    return undefined
  }

  var res = this.head.value;
  this.head = this.head.next;
  if (this.head) {
    this.head.prev = null;
  } else {
    this.tail = null;
  }
  this.length--;
  return res
};

Yallist$1.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.next;
  }
};

Yallist$1.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.prev;
  }
};

Yallist$1.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next;
  }
  if (i === n && walker !== null) {
    return walker.value
  }
};

Yallist$1.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev;
  }
  if (i === n && walker !== null) {
    return walker.value
  }
};

Yallist$1.prototype.map = function (fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist$1();
  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.next;
  }
  return res
};

Yallist$1.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist$1();
  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.prev;
  }
  return res
};

Yallist$1.prototype.reduce = function (fn, initial) {
  var acc;
  var walker = this.head;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.head) {
    walker = this.head.next;
    acc = this.head.value;
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i);
    walker = walker.next;
  }

  return acc
};

Yallist$1.prototype.reduceReverse = function (fn, initial) {
  var acc;
  var walker = this.tail;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.tail) {
    walker = this.tail.prev;
    acc = this.tail.value;
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i);
    walker = walker.prev;
  }

  return acc
};

Yallist$1.prototype.toArray = function () {
  var arr = new Array(this.length);
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.next;
  }
  return arr
};

Yallist$1.prototype.toArrayReverse = function () {
  var arr = new Array(this.length);
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.prev;
  }
  return arr
};

Yallist$1.prototype.slice = function (from, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from = from || 0;
  if (from < 0) {
    from += this.length;
  }
  var ret = new Yallist$1();
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next;
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value);
  }
  return ret
};

Yallist$1.prototype.sliceReverse = function (from, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from = from || 0;
  if (from < 0) {
    from += this.length;
  }
  var ret = new Yallist$1();
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev;
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value);
  }
  return ret
};

Yallist$1.prototype.splice = function (start, deleteCount, ...nodes) {
  if (start > this.length) {
    start = this.length - 1;
  }
  if (start < 0) {
    start = this.length + start;
  }

  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next;
  }

  var ret = [];
  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value);
    walker = this.removeNode(walker);
  }
  if (walker === null) {
    walker = this.tail;
  }

  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev;
  }

  for (var i = 0; i < nodes.length; i++) {
    walker = insert(this, walker, nodes[i]);
  }
  return ret;
};

Yallist$1.prototype.reverse = function () {
  var head = this.head;
  var tail = this.tail;
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev;
    walker.prev = walker.next;
    walker.next = p;
  }
  this.head = tail;
  this.tail = head;
  return this
};

function insert (self, node, value) {
  var inserted = node === self.head ?
    new Node(value, null, node, self) :
    new Node(value, node, node.next, self);

  if (inserted.next === null) {
    self.tail = inserted;
  }
  if (inserted.prev === null) {
    self.head = inserted;
  }

  self.length++;

  return inserted
}

function push (self, item) {
  self.tail = new Node(item, self.tail, null, self);
  if (!self.head) {
    self.head = self.tail;
  }
  self.length++;
}

function unshift (self, item) {
  self.head = new Node(item, null, self.head, self);
  if (!self.tail) {
    self.tail = self.head;
  }
  self.length++;
}

function Node (value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list)
  }

  this.list = list;
  this.value = value;

  if (prev) {
    prev.next = this;
    this.prev = prev;
  } else {
    this.prev = null;
  }

  if (next) {
    next.prev = this;
    this.next = next;
  } else {
    this.next = null;
  }
}

try {
  // add if support for Symbol.iterator is present
  require('./iterator.js')(Yallist$1);
} catch (er) {}

// A linked list to keep track of recently-used-ness
const Yallist = yallist;

const MAX = Symbol('max');
const LENGTH = Symbol('length');
const LENGTH_CALCULATOR = Symbol('lengthCalculator');
const ALLOW_STALE = Symbol('allowStale');
const MAX_AGE = Symbol('maxAge');
const DISPOSE = Symbol('dispose');
const NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet');
const LRU_LIST = Symbol('lruList');
const CACHE = Symbol('cache');
const UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet');

const naiveLength = () => 1;

// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
class LRUCache {
  constructor (options) {
    if (typeof options === 'number')
      options = { max: options };

    if (!options)
      options = {};

    if (options.max && (typeof options.max !== 'number' || options.max < 0))
      throw new TypeError('max must be a non-negative number')
    // Kind of weird to have a default max of Infinity, but oh well.
    this[MAX] = options.max || Infinity;

    const lc = options.length || naiveLength;
    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc;
    this[ALLOW_STALE] = options.stale || false;
    if (options.maxAge && typeof options.maxAge !== 'number')
      throw new TypeError('maxAge must be a number')
    this[MAX_AGE] = options.maxAge || 0;
    this[DISPOSE] = options.dispose;
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
    this.reset();
  }

  // resize the cache when the max changes.
  set max (mL) {
    if (typeof mL !== 'number' || mL < 0)
      throw new TypeError('max must be a non-negative number')

    this[MAX] = mL || Infinity;
    trim(this);
  }
  get max () {
    return this[MAX]
  }

  set allowStale (allowStale) {
    this[ALLOW_STALE] = !!allowStale;
  }
  get allowStale () {
    return this[ALLOW_STALE]
  }

  set maxAge (mA) {
    if (typeof mA !== 'number')
      throw new TypeError('maxAge must be a non-negative number')

    this[MAX_AGE] = mA;
    trim(this);
  }
  get maxAge () {
    return this[MAX_AGE]
  }

  // resize the cache when the lengthCalculator changes.
  set lengthCalculator (lC) {
    if (typeof lC !== 'function')
      lC = naiveLength;

    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC;
      this[LENGTH] = 0;
      this[LRU_LIST].forEach(hit => {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
        this[LENGTH] += hit.length;
      });
    }
    trim(this);
  }
  get lengthCalculator () { return this[LENGTH_CALCULATOR] }

  get length () { return this[LENGTH] }
  get itemCount () { return this[LRU_LIST].length }

  rforEach (fn, thisp) {
    thisp = thisp || this;
    for (let walker = this[LRU_LIST].tail; walker !== null;) {
      const prev = walker.prev;
      forEachStep(this, fn, walker, thisp);
      walker = prev;
    }
  }

  forEach (fn, thisp) {
    thisp = thisp || this;
    for (let walker = this[LRU_LIST].head; walker !== null;) {
      const next = walker.next;
      forEachStep(this, fn, walker, thisp);
      walker = next;
    }
  }

  keys () {
    return this[LRU_LIST].toArray().map(k => k.key)
  }

  values () {
    return this[LRU_LIST].toArray().map(k => k.value)
  }

  reset () {
    if (this[DISPOSE] &&
        this[LRU_LIST] &&
        this[LRU_LIST].length) {
      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value));
    }

    this[CACHE] = new Map(); // hash of items by key
    this[LRU_LIST] = new Yallist(); // list of items in order of use recency
    this[LENGTH] = 0; // length of items in the list
  }

  dump () {
    return this[LRU_LIST].map(hit =>
      isStale(this, hit) ? false : {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }).toArray().filter(h => h)
  }

  dumpLru () {
    return this[LRU_LIST]
  }

  set (key, value, maxAge) {
    maxAge = maxAge || this[MAX_AGE];

    if (maxAge && typeof maxAge !== 'number')
      throw new TypeError('maxAge must be a number')

    const now = maxAge ? Date.now() : 0;
    const len = this[LENGTH_CALCULATOR](value, key);

    if (this[CACHE].has(key)) {
      if (len > this[MAX]) {
        del(this, this[CACHE].get(key));
        return false
      }

      const node = this[CACHE].get(key);
      const item = node.value;

      // dispose of the old one before overwriting
      // split out into 2 ifs for better coverage tracking
      if (this[DISPOSE]) {
        if (!this[NO_DISPOSE_ON_SET])
          this[DISPOSE](key, item.value);
      }

      item.now = now;
      item.maxAge = maxAge;
      item.value = value;
      this[LENGTH] += len - item.length;
      item.length = len;
      this.get(key);
      trim(this);
      return true
    }

    const hit = new Entry$1(key, value, len, now, maxAge);

    // oversized objects fall out of cache automatically.
    if (hit.length > this[MAX]) {
      if (this[DISPOSE])
        this[DISPOSE](key, value);

      return false
    }

    this[LENGTH] += hit.length;
    this[LRU_LIST].unshift(hit);
    this[CACHE].set(key, this[LRU_LIST].head);
    trim(this);
    return true
  }

  has (key) {
    if (!this[CACHE].has(key)) return false
    const hit = this[CACHE].get(key).value;
    return !isStale(this, hit)
  }

  get (key) {
    return get(this, key, true)
  }

  peek (key) {
    return get(this, key, false)
  }

  pop () {
    const node = this[LRU_LIST].tail;
    if (!node)
      return null

    del(this, node);
    return node.value
  }

  del (key) {
    del(this, this[CACHE].get(key));
  }

  load (arr) {
    // reset the cache
    this.reset();

    const now = Date.now();
    // A previous serialized cache has the most recent items first
    for (let l = arr.length - 1; l >= 0; l--) {
      const hit = arr[l];
      const expiresAt = hit.e || 0;
      if (expiresAt === 0)
        // the item was created without expiration in a non aged cache
        this.set(hit.k, hit.v);
      else {
        const maxAge = expiresAt - now;
        // dont add already expired items
        if (maxAge > 0) {
          this.set(hit.k, hit.v, maxAge);
        }
      }
    }
  }

  prune () {
    this[CACHE].forEach((value, key) => get(this, key, false));
  }
}

const get = (self, key, doUse) => {
  const node = self[CACHE].get(key);
  if (node) {
    const hit = node.value;
    if (isStale(self, hit)) {
      del(self, node);
      if (!self[ALLOW_STALE])
        return undefined
    } else {
      if (doUse) {
        if (self[UPDATE_AGE_ON_GET])
          node.value.now = Date.now();
        self[LRU_LIST].unshiftNode(node);
      }
    }
    return hit.value
  }
};

const isStale = (self, hit) => {
  if (!hit || (!hit.maxAge && !self[MAX_AGE]))
    return false

  const diff = Date.now() - hit.now;
  return hit.maxAge ? diff > hit.maxAge
    : self[MAX_AGE] && (diff > self[MAX_AGE])
};

const trim = self => {
  if (self[LENGTH] > self[MAX]) {
    for (let walker = self[LRU_LIST].tail;
      self[LENGTH] > self[MAX] && walker !== null;) {
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      const prev = walker.prev;
      del(self, walker);
      walker = prev;
    }
  }
};

const del = (self, node) => {
  if (node) {
    const hit = node.value;
    if (self[DISPOSE])
      self[DISPOSE](hit.key, hit.value);

    self[LENGTH] -= hit.length;
    self[CACHE].delete(hit.key);
    self[LRU_LIST].removeNode(node);
  }
};

class Entry$1 {
  constructor (key, value, length, now, maxAge) {
    this.key = key;
    this.value = value;
    this.length = length;
    this.now = now;
    this.maxAge = maxAge || 0;
  }
}

const forEachStep = (self, fn, node, thisp) => {
  let hit = node.value;
  if (isStale(self, hit)) {
    del(self, node);
    if (!self[ALLOW_STALE])
      hit = undefined;
  }
  if (hit)
    fn.call(thisp, hit.value, hit.key, self);
};

var lruCache = LRUCache;

// hoisted class for cyclic dependency
class Range$a {
  constructor (range, options) {
    options = parseOptions$1(options);

    if (range instanceof Range$a) {
      if (
        range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease
      ) {
        return range
      } else {
        return new Range$a(range.raw, options)
      }
    }

    if (range instanceof Comparator$3) {
      // just put it in the set and return
      this.raw = range.value;
      this.set = [[range]];
      this.format();
      return this
    }

    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;

    // First, split based on boolean or ||
    this.raw = range;
    this.set = range
      .split(/\s*\|\|\s*/)
      // map the range to a 2d array of comparators
      .map(range => this.parseRange(range.trim()))
      // throw out any comparator lists that are empty
      // this generally means that it was not a valid range, which is allowed
      // in loose mode, but will still throw if the WHOLE range is invalid.
      .filter(c => c.length);

    if (!this.set.length) {
      throw new TypeError(`Invalid SemVer Range: ${range}`)
    }

    // if we have any that are not the null set, throw out null sets.
    if (this.set.length > 1) {
      // keep the first one, in case they're all null sets
      const first = this.set[0];
      this.set = this.set.filter(c => !isNullSet(c[0]));
      if (this.set.length === 0)
        this.set = [first];
      else if (this.set.length > 1) {
        // if we have any that are *, then the range is just *
        for (const c of this.set) {
          if (c.length === 1 && isAny(c[0])) {
            this.set = [c];
            break
          }
        }
      }
    }

    this.format();
  }

  format () {
    this.range = this.set
      .map((comps) => {
        return comps.join(' ').trim()
      })
      .join('||')
      .trim();
    return this.range
  }

  toString () {
    return this.range
  }

  parseRange (range) {
    range = range.trim();

    // memoize range parsing for performance.
    // this is a very hot path, and fully deterministic.
    const memoOpts = Object.keys(this.options).join(',');
    const memoKey = `parseRange:${memoOpts}:${range}`;
    const cached = cache.get(memoKey);
    if (cached)
      return cached

    const loose = this.options.loose;
    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
    const hr = loose ? re$1[t$1.HYPHENRANGELOOSE] : re$1[t$1.HYPHENRANGE];
    range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
    debug$1('hyphen replace', range);
    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
    range = range.replace(re$1[t$1.COMPARATORTRIM], comparatorTrimReplace);
    debug$1('comparator trim', range, re$1[t$1.COMPARATORTRIM]);

    // `~ 1.2.3` => `~1.2.3`
    range = range.replace(re$1[t$1.TILDETRIM], tildeTrimReplace);

    // `^ 1.2.3` => `^1.2.3`
    range = range.replace(re$1[t$1.CARETTRIM], caretTrimReplace);

    // normalize spaces
    range = range.split(/\s+/).join(' ');

    // At this point, the range is completely trimmed and
    // ready to be split into comparators.

    const compRe = loose ? re$1[t$1.COMPARATORLOOSE] : re$1[t$1.COMPARATOR];
    const rangeList = range
      .split(' ')
      .map(comp => parseComparator(comp, this.options))
      .join(' ')
      .split(/\s+/)
      // >=0.0.0 is equivalent to *
      .map(comp => replaceGTE0(comp, this.options))
      // in loose mode, throw out any that are not valid comparators
      .filter(this.options.loose ? comp => !!comp.match(compRe) : () => true)
      .map(comp => new Comparator$3(comp, this.options));

    // if any comparators are the null set, then replace with JUST null set
    // if more than one comparator, remove any * comparators
    // also, don't include the same comparator more than once
    rangeList.length;
    const rangeMap = new Map();
    for (const comp of rangeList) {
      if (isNullSet(comp))
        return [comp]
      rangeMap.set(comp.value, comp);
    }
    if (rangeMap.size > 1 && rangeMap.has(''))
      rangeMap.delete('');

    const result = [...rangeMap.values()];
    cache.set(memoKey, result);
    return result
  }

  intersects (range, options) {
    if (!(range instanceof Range$a)) {
      throw new TypeError('a Range is required')
    }

    return this.set.some((thisComparators) => {
      return (
        isSatisfiable(thisComparators, options) &&
        range.set.some((rangeComparators) => {
          return (
            isSatisfiable(rangeComparators, options) &&
            thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options)
              })
            })
          )
        })
      )
    })
  }

  // if ANY of the sets match ALL of its comparators, then pass
  test (version) {
    if (!version) {
      return false
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer$5(version, this.options);
      } catch (er) {
        return false
      }
    }

    for (let i = 0; i < this.set.length; i++) {
      if (testSet(this.set[i], version, this.options)) {
        return true
      }
    }
    return false
  }
}
var range = Range$a;

const LRU = lruCache;
const cache = new LRU({ max: 1000 });

const parseOptions$1 = parseOptions_1;
const Comparator$3 = comparator;
const debug$1 = debug_1;
const SemVer$5 = semver$2;
const {
  re: re$1,
  t: t$1,
  comparatorTrimReplace,
  tildeTrimReplace,
  caretTrimReplace
} = re$5.exports;

const isNullSet = c => c.value === '<0.0.0-0';
const isAny = c => c.value === '';

// take a set of comparators and determine whether there
// exists a version which can satisfy it
const isSatisfiable = (comparators, options) => {
  let result = true;
  const remainingComparators = comparators.slice();
  let testComparator = remainingComparators.pop();

  while (result && remainingComparators.length) {
    result = remainingComparators.every((otherComparator) => {
      return testComparator.intersects(otherComparator, options)
    });

    testComparator = remainingComparators.pop();
  }

  return result
};

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const parseComparator = (comp, options) => {
  debug$1('comp', comp, options);
  comp = replaceCarets(comp, options);
  debug$1('caret', comp);
  comp = replaceTildes(comp, options);
  debug$1('tildes', comp);
  comp = replaceXRanges(comp, options);
  debug$1('xrange', comp);
  comp = replaceStars(comp, options);
  debug$1('stars', comp);
  return comp
};

const isX = id => !id || id.toLowerCase() === 'x' || id === '*';

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
const replaceTildes = (comp, options) =>
  comp.trim().split(/\s+/).map((comp) => {
    return replaceTilde(comp, options)
  }).join(' ');

const replaceTilde = (comp, options) => {
  const r = options.loose ? re$1[t$1.TILDELOOSE] : re$1[t$1.TILDE];
  return comp.replace(r, (_, M, m, p, pr) => {
    debug$1('tilde', comp, _, M, m, p, pr);
    let ret;

    if (isX(M)) {
      ret = '';
    } else if (isX(m)) {
      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0-0
      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
    } else if (pr) {
      debug$1('replaceTilde pr', pr);
      ret = `>=${M}.${m}.${p}-${pr
      } <${M}.${+m + 1}.0-0`;
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0-0
      ret = `>=${M}.${m}.${p
      } <${M}.${+m + 1}.0-0`;
    }

    debug$1('tilde return', ret);
    return ret
  })
};

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
// ^1.2.3 --> >=1.2.3 <2.0.0-0
// ^1.2.0 --> >=1.2.0 <2.0.0-0
const replaceCarets = (comp, options) =>
  comp.trim().split(/\s+/).map((comp) => {
    return replaceCaret(comp, options)
  }).join(' ');

const replaceCaret = (comp, options) => {
  debug$1('caret', comp, options);
  const r = options.loose ? re$1[t$1.CARETLOOSE] : re$1[t$1.CARET];
  const z = options.includePrerelease ? '-0' : '';
  return comp.replace(r, (_, M, m, p, pr) => {
    debug$1('caret', comp, _, M, m, p, pr);
    let ret;

    if (isX(M)) {
      ret = '';
    } else if (isX(m)) {
      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
    } else if (isX(p)) {
      if (M === '0') {
        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
      }
    } else if (pr) {
      debug$1('replaceCaret pr', pr);
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${m}.${+p + 1}-0`;
        } else {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${+m + 1}.0-0`;
        }
      } else {
        ret = `>=${M}.${m}.${p}-${pr
        } <${+M + 1}.0.0-0`;
      }
    } else {
      debug$1('no pr');
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${m}.${+p + 1}-0`;
        } else {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${+m + 1}.0-0`;
        }
      } else {
        ret = `>=${M}.${m}.${p
        } <${+M + 1}.0.0-0`;
      }
    }

    debug$1('caret return', ret);
    return ret
  })
};

const replaceXRanges = (comp, options) => {
  debug$1('replaceXRanges', comp, options);
  return comp.split(/\s+/).map((comp) => {
    return replaceXRange(comp, options)
  }).join(' ')
};

const replaceXRange = (comp, options) => {
  comp = comp.trim();
  const r = options.loose ? re$1[t$1.XRANGELOOSE] : re$1[t$1.XRANGE];
  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
    debug$1('xRange', comp, ret, gtlt, M, m, p, pr);
    const xM = isX(M);
    const xm = xM || isX(m);
    const xp = xm || isX(p);
    const anyX = xp;

    if (gtlt === '=' && anyX) {
      gtlt = '';
    }

    // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? '-0' : '';

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0';
      } else {
        // nothing is forbidden
        ret = '*';
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0;
      }
      p = 0;

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        gtlt = '>=';
        if (xm) {
          M = +M + 1;
          m = 0;
          p = 0;
        } else {
          m = +m + 1;
          p = 0;
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<';
        if (xm) {
          M = +M + 1;
        } else {
          m = +m + 1;
        }
      }

      if (gtlt === '<')
        pr = '-0';

      ret = `${gtlt + M}.${m}.${p}${pr}`;
    } else if (xm) {
      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
    } else if (xp) {
      ret = `>=${M}.${m}.0${pr
      } <${M}.${+m + 1}.0-0`;
    }

    debug$1('xRange return', ret);

    return ret
  })
};

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
const replaceStars = (comp, options) => {
  debug$1('replaceStars', comp, options);
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re$1[t$1.STAR], '')
};

const replaceGTE0 = (comp, options) => {
  debug$1('replaceGTE0', comp, options);
  return comp.trim()
    .replace(re$1[options.includePrerelease ? t$1.GTE0PRE : t$1.GTE0], '')
};

// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
const hyphenReplace = incPr => ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) => {
  if (isX(fM)) {
    from = '';
  } else if (isX(fm)) {
    from = `>=${fM}.0.0${incPr ? '-0' : ''}`;
  } else if (isX(fp)) {
    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`;
  } else if (fpr) {
    from = `>=${from}`;
  } else {
    from = `>=${from}${incPr ? '-0' : ''}`;
  }

  if (isX(tM)) {
    to = '';
  } else if (isX(tm)) {
    to = `<${+tM + 1}.0.0-0`;
  } else if (isX(tp)) {
    to = `<${tM}.${+tm + 1}.0-0`;
  } else if (tpr) {
    to = `<=${tM}.${tm}.${tp}-${tpr}`;
  } else if (incPr) {
    to = `<${tM}.${tm}.${+tp + 1}-0`;
  } else {
    to = `<=${to}`;
  }

  return (`${from} ${to}`).trim()
};

const testSet = (set, version, options) => {
  for (let i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (let i = 0; i < set.length; i++) {
      debug$1(set[i].semver);
      if (set[i].semver === Comparator$3.ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        const allowed = set[i].semver;
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
};

const ANY$2 = Symbol('SemVer ANY');
// hoisted class for cyclic dependency
class Comparator$2 {
  static get ANY () {
    return ANY$2
  }
  constructor (comp, options) {
    options = parseOptions(options);

    if (comp instanceof Comparator$2) {
      if (comp.loose === !!options.loose) {
        return comp
      } else {
        comp = comp.value;
      }
    }

    debug('comparator', comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);

    if (this.semver === ANY$2) {
      this.value = '';
    } else {
      this.value = this.operator + this.semver.version;
    }

    debug('comp', this);
  }

  parse (comp) {
    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
    const m = comp.match(r);

    if (!m) {
      throw new TypeError(`Invalid comparator: ${comp}`)
    }

    this.operator = m[1] !== undefined ? m[1] : '';
    if (this.operator === '=') {
      this.operator = '';
    }

    // if it literally is just '>' or '' then allow anything.
    if (!m[2]) {
      this.semver = ANY$2;
    } else {
      this.semver = new SemVer$4(m[2], this.options.loose);
    }
  }

  toString () {
    return this.value
  }

  test (version) {
    debug('Comparator.test', version, this.options.loose);

    if (this.semver === ANY$2 || version === ANY$2) {
      return true
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer$4(version, this.options);
      } catch (er) {
        return false
      }
    }

    return cmp(version, this.operator, this.semver, this.options)
  }

  intersects (comp, options) {
    if (!(comp instanceof Comparator$2)) {
      throw new TypeError('a Comparator is required')
    }

    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }

    if (this.operator === '') {
      if (this.value === '') {
        return true
      }
      return new Range$9(comp.value, options).test(this.value)
    } else if (comp.operator === '') {
      if (comp.value === '') {
        return true
      }
      return new Range$9(this.value, options).test(comp.semver)
    }

    const sameDirectionIncreasing =
      (this.operator === '>=' || this.operator === '>') &&
      (comp.operator === '>=' || comp.operator === '>');
    const sameDirectionDecreasing =
      (this.operator === '<=' || this.operator === '<') &&
      (comp.operator === '<=' || comp.operator === '<');
    const sameSemVer = this.semver.version === comp.semver.version;
    const differentDirectionsInclusive =
      (this.operator === '>=' || this.operator === '<=') &&
      (comp.operator === '>=' || comp.operator === '<=');
    const oppositeDirectionsLessThan =
      cmp(this.semver, '<', comp.semver, options) &&
      (this.operator === '>=' || this.operator === '>') &&
        (comp.operator === '<=' || comp.operator === '<');
    const oppositeDirectionsGreaterThan =
      cmp(this.semver, '>', comp.semver, options) &&
      (this.operator === '<=' || this.operator === '<') &&
        (comp.operator === '>=' || comp.operator === '>');

    return (
      sameDirectionIncreasing ||
      sameDirectionDecreasing ||
      (sameSemVer && differentDirectionsInclusive) ||
      oppositeDirectionsLessThan ||
      oppositeDirectionsGreaterThan
    )
  }
}

var comparator = Comparator$2;

const parseOptions = parseOptions_1;
const {re, t} = re$5.exports;
const cmp = cmp_1;
const debug = debug_1;
const SemVer$4 = semver$2;
const Range$9 = range;

const Range$8 = range;
const satisfies$3 = (version, range, options) => {
  try {
    range = new Range$8(range, options);
  } catch (er) {
    return false
  }
  return range.test(version)
};
var satisfies_1 = satisfies$3;

const Range$7 = range;

// Mostly just for testing and legacy API reasons
const toComparators = (range, options) =>
  new Range$7(range, options).set
    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '));

var toComparators_1 = toComparators;

const SemVer$3 = semver$2;
const Range$6 = range;

const maxSatisfying = (versions, range, options) => {
  let max = null;
  let maxSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$6(range, options);
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v;
        maxSV = new SemVer$3(max, options);
      }
    }
  });
  return max
};
var maxSatisfying_1 = maxSatisfying;

const SemVer$2 = semver$2;
const Range$5 = range;
const minSatisfying = (versions, range, options) => {
  let min = null;
  let minSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$5(range, options);
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v;
        minSV = new SemVer$2(min, options);
      }
    }
  });
  return min
};
var minSatisfying_1 = minSatisfying;

const SemVer$1 = semver$2;
const Range$4 = range;
const gt$1 = gt_1;

const minVersion = (range, loose) => {
  range = new Range$4(range, loose);

  let minver = new SemVer$1('0.0.0');
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer$1('0.0.0-0');
  if (range.test(minver)) {
    return minver
  }

  minver = null;
  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i];

    let setMin = null;
    comparators.forEach((comparator) => {
      // Clone to avoid manipulating the comparator's semver object.
      const compver = new SemVer$1(comparator.semver.version);
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }
          compver.raw = compver.format();
          /* fallthrough */
        case '':
        case '>=':
          if (!setMin || gt$1(compver, setMin)) {
            setMin = compver;
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error(`Unexpected operation: ${comparator.operator}`)
      }
    });
    if (setMin && (!minver || gt$1(minver, setMin)))
      minver = setMin;
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
};
var minVersion_1 = minVersion;

const Range$3 = range;
const validRange = (range, options) => {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range$3(range, options).range || '*'
  } catch (er) {
    return null
  }
};
var valid = validRange;

const SemVer = semver$2;
const Comparator$1 = comparator;
const {ANY: ANY$1} = Comparator$1;
const Range$2 = range;
const satisfies$2 = satisfies_1;
const gt = gt_1;
const lt = lt_1;
const lte = lte_1;
const gte = gte_1;

const outside$2 = (version, range, hilo, options) => {
  version = new SemVer(version, options);
  range = new Range$2(range, options);

  let gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case '>':
      gtfn = gt;
      ltefn = lte;
      ltfn = lt;
      comp = '>';
      ecomp = '>=';
      break
    case '<':
      gtfn = lt;
      ltefn = gte;
      ltfn = gt;
      comp = '<';
      ecomp = '<=';
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisfies the range it is not outside
  if (satisfies$2(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i];

    let high = null;
    let low = null;

    comparators.forEach((comparator) => {
      if (comparator.semver === ANY$1) {
        comparator = new Comparator$1('>=0.0.0');
      }
      high = high || comparator;
      low = low || comparator;
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator;
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator;
      }
    });

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
};

var outside_1 = outside$2;

// Determine if version is greater than all the versions possible in the range.
const outside$1 = outside_1;
const gtr = (version, range, options) => outside$1(version, range, '>', options);
var gtr_1 = gtr;

const outside = outside_1;
// Determine if version is less than all the versions possible in the range
const ltr = (version, range, options) => outside(version, range, '<', options);
var ltr_1 = ltr;

const Range$1 = range;
const intersects = (r1, r2, options) => {
  r1 = new Range$1(r1, options);
  r2 = new Range$1(r2, options);
  return r1.intersects(r2)
};
var intersects_1 = intersects;

// given a set of versions and a range, create a "simplified" range
// that includes the same versions that the original range does
// If the original range is shorter than the simplified one, return that.
const satisfies$1 = satisfies_1;
const compare$1 = compare_1;
var simplify = (versions, range, options) => {
  const set = [];
  let min = null;
  let prev = null;
  const v = versions.sort((a, b) => compare$1(a, b, options));
  for (const version of v) {
    const included = satisfies$1(version, range, options);
    if (included) {
      prev = version;
      if (!min)
        min = version;
    } else {
      if (prev) {
        set.push([min, prev]);
      }
      prev = null;
      min = null;
    }
  }
  if (min)
    set.push([min, null]);

  const ranges = [];
  for (const [min, max] of set) {
    if (min === max)
      ranges.push(min);
    else if (!max && min === v[0])
      ranges.push('*');
    else if (!max)
      ranges.push(`>=${min}`);
    else if (min === v[0])
      ranges.push(`<=${max}`);
    else
      ranges.push(`${min} - ${max}`);
  }
  const simplified = ranges.join(' || ');
  const original = typeof range.raw === 'string' ? range.raw : String(range);
  return simplified.length < original.length ? simplified : range
};

const Range = range;
const Comparator = comparator;
const { ANY } = Comparator;
const satisfies = satisfies_1;
const compare = compare_1;

// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a null set, OR
// - Every simple range `r1, r2, ...` which is not a null set is a subset of
//   some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else if in prerelease mode, return false
//   - else replace c with `[>=0.0.0]`
// - If C is only the ANY comparator
//   - if in prerelease mode, return true
//   - else replace C with `[>=0.0.0]`
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If any C is a = range, and GT or LT are set, return false
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT.semver is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the GT.semver tuple, return false
// - If LT
//   - If LT.semver is greater than any < or <= comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the LT.semver tuple, return false
// - Else return true

const subset = (sub, dom, options = {}) => {
  if (sub === dom)
    return true

  sub = new Range(sub, options);
  dom = new Range(dom, options);
  let sawNonNull = false;

  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options);
      sawNonNull = sawNonNull || isSub !== null;
      if (isSub)
        continue OUTER
    }
    // the null set is a subset of everything, but null simple ranges in
    // a complex range should be ignored.  so if we saw a non-null range,
    // then we know this isn't a subset, but if EVERY simple range was null,
    // then it is a subset.
    if (sawNonNull)
      return false
  }
  return true
};

const simpleSubset = (sub, dom, options) => {
  if (sub === dom)
    return true

  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY)
      return true
    else if (options.includePrerelease)
      sub = [ new Comparator('>=0.0.0-0') ];
    else
      sub = [ new Comparator('>=0.0.0') ];
  }

  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease)
      return true
    else
      dom = [ new Comparator('>=0.0.0') ];
  }

  const eqSet = new Set();
  let gt, lt;
  for (const c of sub) {
    if (c.operator === '>' || c.operator === '>=')
      gt = higherGT(gt, c, options);
    else if (c.operator === '<' || c.operator === '<=')
      lt = lowerLT(lt, c, options);
    else
      eqSet.add(c.semver);
  }

  if (eqSet.size > 1)
    return null

  let gtltComp;
  if (gt && lt) {
    gtltComp = compare(gt.semver, lt.semver, options);
    if (gtltComp > 0)
      return null
    else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<='))
      return null
  }

  // will iterate one or zero times
  for (const eq of eqSet) {
    if (gt && !satisfies(eq, String(gt), options))
      return null

    if (lt && !satisfies(eq, String(lt), options))
      return null

    for (const c of dom) {
      if (!satisfies(eq, String(c), options))
        return false
    }

    return true
  }

  let higher, lower;
  let hasDomLT, hasDomGT;
  // if the subset has a prerelease, we need a comparator in the superset
  // with the same tuple and a prerelease, or it's not a subset
  let needDomLTPre = lt &&
    !options.includePrerelease &&
    lt.semver.prerelease.length ? lt.semver : false;
  let needDomGTPre = gt &&
    !options.includePrerelease &&
    gt.semver.prerelease.length ? gt.semver : false;
  // exception: <1.2.3-0 is the same as <1.2.3
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&
      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false;
  }

  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>=';
    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<=';
    if (gt) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomGTPre.major &&
            c.semver.minor === needDomGTPre.minor &&
            c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false;
        }
      }
      if (c.operator === '>' || c.operator === '>=') {
        higher = higherGT(gt, c, options);
        if (higher === c && higher !== gt)
          return false
      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options))
        return false
    }
    if (lt) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomLTPre.major &&
            c.semver.minor === needDomLTPre.minor &&
            c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false;
        }
      }
      if (c.operator === '<' || c.operator === '<=') {
        lower = lowerLT(lt, c, options);
        if (lower === c && lower !== lt)
          return false
      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options))
        return false
    }
    if (!c.operator && (lt || gt) && gtltComp !== 0)
      return false
  }

  // if there was a < or >, and nothing in the dom, then must be false
  // UNLESS it was limited by another range in the other direction.
  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
  if (gt && hasDomLT && !lt && gtltComp !== 0)
    return false

  if (lt && hasDomGT && !gt && gtltComp !== 0)
    return false

  // we needed a prerelease range in a specific tuple, but didn't get one
  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
  // because it includes prereleases in the 1.2.3 tuple
  if (needDomGTPre || needDomLTPre)
    return false

  return true
};

// >=1.2.3 is lower than >1.2.3
const higherGT = (a, b, options) => {
  if (!a)
    return b
  const comp = compare(a.semver, b.semver, options);
  return comp > 0 ? a
    : comp < 0 ? b
    : b.operator === '>' && a.operator === '>=' ? b
    : a
};

// <=1.2.3 is higher than <1.2.3
const lowerLT = (a, b, options) => {
  if (!a)
    return b
  const comp = compare(a.semver, b.semver, options);
  return comp < 0 ? a
    : comp > 0 ? b
    : b.operator === '<' && a.operator === '<=' ? b
    : a
};

var subset_1 = subset;

// just pre-load all the stuff that index.js lazily exports
const internalRe = re$5.exports;
var semver$1 = {
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
  SemVer: semver$2,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers,
  parse: parse_1,
  valid: valid_1,
  clean: clean_1,
  inc: inc_1,
  diff: diff_1,
  major: major_1,
  minor: minor_1,
  patch: patch_1,
  prerelease: prerelease_1,
  compare: compare_1,
  rcompare: rcompare_1,
  compareLoose: compareLoose_1,
  compareBuild: compareBuild_1,
  sort: sort_1,
  rsort: rsort_1,
  gt: gt_1,
  lt: lt_1,
  eq: eq_1,
  neq: neq_1,
  gte: gte_1,
  lte: lte_1,
  cmp: cmp_1,
  coerce: coerce_1,
  Comparator: comparator,
  Range: range,
  satisfies: satisfies_1,
  toComparators: toComparators_1,
  maxSatisfying: maxSatisfying_1,
  minSatisfying: minSatisfying_1,
  minVersion: minVersion_1,
  validRange: valid,
  outside: outside_1,
  gtr: gtr_1,
  ltr: ltr_1,
  intersects: intersects_1,
  simplifyRange: simplify,
  subset: subset_1,
};

var getStream$2 = {exports: {}};

const {PassThrough: PassThroughStream} = Stream__default["default"];

var bufferStream$1 = options => {
	options = {...options};

	const {array} = options;
	let {encoding} = options;
	const isBuffer = encoding === 'buffer';
	let objectMode = false;

	if (array) {
		objectMode = !(encoding || isBuffer);
	} else {
		encoding = encoding || 'utf8';
	}

	if (isBuffer) {
		encoding = null;
	}

	const stream = new PassThroughStream({objectMode});

	if (encoding) {
		stream.setEncoding(encoding);
	}

	let length = 0;
	const chunks = [];

	stream.on('data', chunk => {
		chunks.push(chunk);

		if (objectMode) {
			length = chunks.length;
		} else {
			length += chunk.length;
		}
	});

	stream.getBufferedValue = () => {
		if (array) {
			return chunks;
		}

		return isBuffer ? Buffer.concat(chunks, length) : chunks.join('');
	};

	stream.getBufferedLength = () => length;

	return stream;
};

const {constants: BufferConstants} = require$$0__default$2["default"];
const stream$2 = Stream__default["default"];
const {promisify: promisify$1} = require$$4__default["default"];
const bufferStream = bufferStream$1;

const streamPipelinePromisified = promisify$1(stream$2.pipeline);

class MaxBufferError extends Error {
	constructor() {
		super('maxBuffer exceeded');
		this.name = 'MaxBufferError';
	}
}

async function getStream$1(inputStream, options) {
	if (!inputStream) {
		throw new Error('Expected a stream');
	}

	options = {
		maxBuffer: Infinity,
		...options
	};

	const {maxBuffer} = options;
	const stream = bufferStream(options);

	await new Promise((resolve, reject) => {
		const rejectPromise = error => {
			// Don't retrieve an oversized buffer.
			if (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
				error.bufferedData = stream.getBufferedValue();
			}

			reject(error);
		};

		(async () => {
			try {
				await streamPipelinePromisified(inputStream, stream);
				resolve();
			} catch (error) {
				rejectPromise(error);
			}
		})();

		stream.on('data', () => {
			if (stream.getBufferedLength() > maxBuffer) {
				rejectPromise(new MaxBufferError());
			}
		});
	});

	return stream.getBufferedValue();
}

getStream$2.exports = getStream$1;
getStream$2.exports.buffer = (stream, options) => getStream$1(stream, {...options, encoding: 'buffer'});
getStream$2.exports.array = (stream, options) => getStream$1(stream, {...options, array: true});
getStream$2.exports.MaxBufferError = MaxBufferError;

var yauzl$1 = {};

var fdSlicer = {};

var pend = Pend$1;

function Pend$1() {
  this.pending = 0;
  this.max = Infinity;
  this.listeners = [];
  this.waiting = [];
  this.error = null;
}

Pend$1.prototype.go = function(fn) {
  if (this.pending < this.max) {
    pendGo(this, fn);
  } else {
    this.waiting.push(fn);
  }
};

Pend$1.prototype.wait = function(cb) {
  if (this.pending === 0) {
    cb(this.error);
  } else {
    this.listeners.push(cb);
  }
};

Pend$1.prototype.hold = function() {
  return pendHold(this);
};

function pendHold(self) {
  self.pending += 1;
  var called = false;
  return onCb;
  function onCb(err) {
    if (called) throw new Error("callback called twice");
    called = true;
    self.error = self.error || err;
    self.pending -= 1;
    if (self.waiting.length > 0 && self.pending < self.max) {
      pendGo(self, self.waiting.shift());
    } else if (self.pending === 0) {
      var listeners = self.listeners;
      self.listeners = [];
      listeners.forEach(cbListener);
    }
  }
  function cbListener(listener) {
    listener(self.error);
  }
}

function pendGo(self, fn) {
  fn(pendHold(self));
}

var fs$3 = require$$0__default$1["default"];
var util$2 = require$$4__default["default"];
var stream$1 = Stream__default["default"];
var Readable = stream$1.Readable;
var Writable$1 = stream$1.Writable;
var PassThrough$1 = stream$1.PassThrough;
var Pend = pend;
var EventEmitter$1 = require$$0__default$5["default"].EventEmitter;

fdSlicer.createFromBuffer = createFromBuffer;
fdSlicer.createFromFd = createFromFd;
fdSlicer.BufferSlicer = BufferSlicer;
fdSlicer.FdSlicer = FdSlicer;

util$2.inherits(FdSlicer, EventEmitter$1);
function FdSlicer(fd, options) {
  options = options || {};
  EventEmitter$1.call(this);

  this.fd = fd;
  this.pend = new Pend();
  this.pend.max = 1;
  this.refCount = 0;
  this.autoClose = !!options.autoClose;
}

FdSlicer.prototype.read = function(buffer, offset, length, position, callback) {
  var self = this;
  self.pend.go(function(cb) {
    fs$3.read(self.fd, buffer, offset, length, position, function(err, bytesRead, buffer) {
      cb();
      callback(err, bytesRead, buffer);
    });
  });
};

FdSlicer.prototype.write = function(buffer, offset, length, position, callback) {
  var self = this;
  self.pend.go(function(cb) {
    fs$3.write(self.fd, buffer, offset, length, position, function(err, written, buffer) {
      cb();
      callback(err, written, buffer);
    });
  });
};

FdSlicer.prototype.createReadStream = function(options) {
  return new ReadStream(this, options);
};

FdSlicer.prototype.createWriteStream = function(options) {
  return new WriteStream(this, options);
};

FdSlicer.prototype.ref = function() {
  this.refCount += 1;
};

FdSlicer.prototype.unref = function() {
  var self = this;
  self.refCount -= 1;

  if (self.refCount > 0) return;
  if (self.refCount < 0) throw new Error("invalid unref");

  if (self.autoClose) {
    fs$3.close(self.fd, onCloseDone);
  }

  function onCloseDone(err) {
    if (err) {
      self.emit('error', err);
    } else {
      self.emit('close');
    }
  }
};

util$2.inherits(ReadStream, Readable);
function ReadStream(context, options) {
  options = options || {};
  Readable.call(this, options);

  this.context = context;
  this.context.ref();

  this.start = options.start || 0;
  this.endOffset = options.end;
  this.pos = this.start;
  this.destroyed = false;
}

ReadStream.prototype._read = function(n) {
  var self = this;
  if (self.destroyed) return;

  var toRead = Math.min(self._readableState.highWaterMark, n);
  if (self.endOffset != null) {
    toRead = Math.min(toRead, self.endOffset - self.pos);
  }
  if (toRead <= 0) {
    self.destroyed = true;
    self.push(null);
    self.context.unref();
    return;
  }
  self.context.pend.go(function(cb) {
    if (self.destroyed) return cb();
    var buffer = new Buffer(toRead);
    fs$3.read(self.context.fd, buffer, 0, toRead, self.pos, function(err, bytesRead) {
      if (err) {
        self.destroy(err);
      } else if (bytesRead === 0) {
        self.destroyed = true;
        self.push(null);
        self.context.unref();
      } else {
        self.pos += bytesRead;
        self.push(buffer.slice(0, bytesRead));
      }
      cb();
    });
  });
};

ReadStream.prototype.destroy = function(err) {
  if (this.destroyed) return;
  err = err || new Error("stream destroyed");
  this.destroyed = true;
  this.emit('error', err);
  this.context.unref();
};

util$2.inherits(WriteStream, Writable$1);
function WriteStream(context, options) {
  options = options || {};
  Writable$1.call(this, options);

  this.context = context;
  this.context.ref();

  this.start = options.start || 0;
  this.endOffset = (options.end == null) ? Infinity : +options.end;
  this.bytesWritten = 0;
  this.pos = this.start;
  this.destroyed = false;

  this.on('finish', this.destroy.bind(this));
}

WriteStream.prototype._write = function(buffer, encoding, callback) {
  var self = this;
  if (self.destroyed) return;

  if (self.pos + buffer.length > self.endOffset) {
    var err = new Error("maximum file length exceeded");
    err.code = 'ETOOBIG';
    self.destroy();
    callback(err);
    return;
  }
  self.context.pend.go(function(cb) {
    if (self.destroyed) return cb();
    fs$3.write(self.context.fd, buffer, 0, buffer.length, self.pos, function(err, bytes) {
      if (err) {
        self.destroy();
        cb();
        callback(err);
      } else {
        self.bytesWritten += bytes;
        self.pos += bytes;
        self.emit('progress');
        cb();
        callback();
      }
    });
  });
};

WriteStream.prototype.destroy = function() {
  if (this.destroyed) return;
  this.destroyed = true;
  this.context.unref();
};

util$2.inherits(BufferSlicer, EventEmitter$1);
function BufferSlicer(buffer, options) {
  EventEmitter$1.call(this);

  options = options || {};
  this.refCount = 0;
  this.buffer = buffer;
  this.maxChunkSize = options.maxChunkSize || Number.MAX_SAFE_INTEGER;
}

BufferSlicer.prototype.read = function(buffer, offset, length, position, callback) {
  var end = position + length;
  var delta = end - this.buffer.length;
  var written = (delta > 0) ? delta : length;
  this.buffer.copy(buffer, offset, position, end);
  setImmediate(function() {
    callback(null, written);
  });
};

BufferSlicer.prototype.write = function(buffer, offset, length, position, callback) {
  buffer.copy(this.buffer, position, offset, offset + length);
  setImmediate(function() {
    callback(null, length, buffer);
  });
};

BufferSlicer.prototype.createReadStream = function(options) {
  options = options || {};
  var readStream = new PassThrough$1(options);
  readStream.destroyed = false;
  readStream.start = options.start || 0;
  readStream.endOffset = options.end;
  // by the time this function returns, we'll be done.
  readStream.pos = readStream.endOffset || this.buffer.length;

  // respect the maxChunkSize option to slice up the chunk into smaller pieces.
  var entireSlice = this.buffer.slice(readStream.start, readStream.pos);
  var offset = 0;
  while (true) {
    var nextOffset = offset + this.maxChunkSize;
    if (nextOffset >= entireSlice.length) {
      // last chunk
      if (offset < entireSlice.length) {
        readStream.write(entireSlice.slice(offset, entireSlice.length));
      }
      break;
    }
    readStream.write(entireSlice.slice(offset, nextOffset));
    offset = nextOffset;
  }

  readStream.end();
  readStream.destroy = function() {
    readStream.destroyed = true;
  };
  return readStream;
};

BufferSlicer.prototype.createWriteStream = function(options) {
  var bufferSlicer = this;
  options = options || {};
  var writeStream = new Writable$1(options);
  writeStream.start = options.start || 0;
  writeStream.endOffset = (options.end == null) ? this.buffer.length : +options.end;
  writeStream.bytesWritten = 0;
  writeStream.pos = writeStream.start;
  writeStream.destroyed = false;
  writeStream._write = function(buffer, encoding, callback) {
    if (writeStream.destroyed) return;

    var end = writeStream.pos + buffer.length;
    if (end > writeStream.endOffset) {
      var err = new Error("maximum file length exceeded");
      err.code = 'ETOOBIG';
      writeStream.destroyed = true;
      callback(err);
      return;
    }
    buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);

    writeStream.bytesWritten += buffer.length;
    writeStream.pos = end;
    writeStream.emit('progress');
    callback();
  };
  writeStream.destroy = function() {
    writeStream.destroyed = true;
  };
  return writeStream;
};

BufferSlicer.prototype.ref = function() {
  this.refCount += 1;
};

BufferSlicer.prototype.unref = function() {
  this.refCount -= 1;

  if (this.refCount < 0) {
    throw new Error("invalid unref");
  }
};

function createFromBuffer(buffer, options) {
  return new BufferSlicer(buffer, options);
}

function createFromFd(fd, options) {
  return new FdSlicer(fd, options);
}

var Buffer$1 = require$$0__default$2["default"].Buffer;

var CRC_TABLE = [
  0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,
  0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,
  0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,
  0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
  0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,
  0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
  0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,
  0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
  0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,
  0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,
  0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,
  0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
  0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,
  0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,
  0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,
  0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
  0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,
  0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
  0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,
  0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
  0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,
  0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,
  0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,
  0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
  0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,
  0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,
  0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,
  0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
  0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,
  0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
  0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,
  0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
  0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,
  0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,
  0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,
  0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
  0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,
  0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,
  0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,
  0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
  0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,
  0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
  0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,
  0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
  0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,
  0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,
  0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,
  0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
  0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,
  0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,
  0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,
  0x2d02ef8d
];

if (typeof Int32Array !== 'undefined') {
  CRC_TABLE = new Int32Array(CRC_TABLE);
}

function ensureBuffer(input) {
  if (Buffer$1.isBuffer(input)) {
    return input;
  }

  var hasNewBufferAPI =
      typeof Buffer$1.alloc === "function" &&
      typeof Buffer$1.from === "function";

  if (typeof input === "number") {
    return hasNewBufferAPI ? Buffer$1.alloc(input) : new Buffer$1(input);
  }
  else if (typeof input === "string") {
    return hasNewBufferAPI ? Buffer$1.from(input) : new Buffer$1(input);
  }
  else {
    throw new Error("input must be buffer, number, or string, received " +
                    typeof input);
  }
}

function bufferizeInt(num) {
  var tmp = ensureBuffer(4);
  tmp.writeInt32BE(num, 0);
  return tmp;
}

function _crc32(buf, previous) {
  buf = ensureBuffer(buf);
  if (Buffer$1.isBuffer(previous)) {
    previous = previous.readUInt32BE(0);
  }
  var crc = ~~previous ^ -1;
  for (var n = 0; n < buf.length; n++) {
    crc = CRC_TABLE[(crc ^ buf[n]) & 0xff] ^ (crc >>> 8);
  }
  return (crc ^ -1);
}

function crc32$1() {
  return bufferizeInt(_crc32.apply(null, arguments));
}
crc32$1.signed = function () {
  return _crc32.apply(null, arguments);
};
crc32$1.unsigned = function () {
  return _crc32.apply(null, arguments) >>> 0;
};

var bufferCrc32 = crc32$1;

var fs$2 = require$$0__default$1["default"];
var zlib = zlib__default["default"];
var fd_slicer = fdSlicer;
var crc32 = bufferCrc32;
var util$1 = require$$4__default["default"];
var EventEmitter = require$$0__default$5["default"].EventEmitter;
var Transform = Stream__default["default"].Transform;
var PassThrough = Stream__default["default"].PassThrough;
var Writable = Stream__default["default"].Writable;

yauzl$1.open = open;
yauzl$1.fromFd = fromFd;
yauzl$1.fromBuffer = fromBuffer;
yauzl$1.fromRandomAccessReader = fromRandomAccessReader;
yauzl$1.dosDateTimeToDate = dosDateTimeToDate;
yauzl$1.validateFileName = validateFileName;
yauzl$1.ZipFile = ZipFile;
yauzl$1.Entry = Entry;
yauzl$1.RandomAccessReader = RandomAccessReader;

function open(path, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = null;
  }
  if (options == null) options = {};
  if (options.autoClose == null) options.autoClose = true;
  if (options.lazyEntries == null) options.lazyEntries = false;
  if (options.decodeStrings == null) options.decodeStrings = true;
  if (options.validateEntrySizes == null) options.validateEntrySizes = true;
  if (options.strictFileNames == null) options.strictFileNames = false;
  if (callback == null) callback = defaultCallback;
  fs$2.open(path, "r", function(err, fd) {
    if (err) return callback(err);
    fromFd(fd, options, function(err, zipfile) {
      if (err) fs$2.close(fd, defaultCallback);
      callback(err, zipfile);
    });
  });
}

function fromFd(fd, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = null;
  }
  if (options == null) options = {};
  if (options.autoClose == null) options.autoClose = false;
  if (options.lazyEntries == null) options.lazyEntries = false;
  if (options.decodeStrings == null) options.decodeStrings = true;
  if (options.validateEntrySizes == null) options.validateEntrySizes = true;
  if (options.strictFileNames == null) options.strictFileNames = false;
  if (callback == null) callback = defaultCallback;
  fs$2.fstat(fd, function(err, stats) {
    if (err) return callback(err);
    var reader = fd_slicer.createFromFd(fd, {autoClose: true});
    fromRandomAccessReader(reader, stats.size, options, callback);
  });
}

function fromBuffer(buffer, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = null;
  }
  if (options == null) options = {};
  options.autoClose = false;
  if (options.lazyEntries == null) options.lazyEntries = false;
  if (options.decodeStrings == null) options.decodeStrings = true;
  if (options.validateEntrySizes == null) options.validateEntrySizes = true;
  if (options.strictFileNames == null) options.strictFileNames = false;
  // limit the max chunk size. see https://github.com/thejoshwolfe/yauzl/issues/87
  var reader = fd_slicer.createFromBuffer(buffer, {maxChunkSize: 0x10000});
  fromRandomAccessReader(reader, buffer.length, options, callback);
}

function fromRandomAccessReader(reader, totalSize, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = null;
  }
  if (options == null) options = {};
  if (options.autoClose == null) options.autoClose = true;
  if (options.lazyEntries == null) options.lazyEntries = false;
  if (options.decodeStrings == null) options.decodeStrings = true;
  var decodeStrings = !!options.decodeStrings;
  if (options.validateEntrySizes == null) options.validateEntrySizes = true;
  if (options.strictFileNames == null) options.strictFileNames = false;
  if (callback == null) callback = defaultCallback;
  if (typeof totalSize !== "number") throw new Error("expected totalSize parameter to be a number");
  if (totalSize > Number.MAX_SAFE_INTEGER) {
    throw new Error("zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.");
  }

  // the matching unref() call is in zipfile.close()
  reader.ref();

  // eocdr means End of Central Directory Record.
  // search backwards for the eocdr signature.
  // the last field of the eocdr is a variable-length comment.
  // the comment size is encoded in a 2-byte field in the eocdr, which we can't find without trudging backwards through the comment to find it.
  // as a consequence of this design decision, it's possible to have ambiguous zip file metadata if a coherent eocdr was in the comment.
  // we search backwards for a eocdr signature, and hope that whoever made the zip file was smart enough to forbid the eocdr signature in the comment.
  var eocdrWithoutCommentSize = 22;
  var maxCommentSize = 0xffff; // 2-byte size
  var bufferSize = Math.min(eocdrWithoutCommentSize + maxCommentSize, totalSize);
  var buffer = newBuffer(bufferSize);
  var bufferReadStart = totalSize - buffer.length;
  readAndAssertNoEof(reader, buffer, 0, bufferSize, bufferReadStart, function(err) {
    if (err) return callback(err);
    for (var i = bufferSize - eocdrWithoutCommentSize; i >= 0; i -= 1) {
      if (buffer.readUInt32LE(i) !== 0x06054b50) continue;
      // found eocdr
      var eocdrBuffer = buffer.slice(i);

      // 0 - End of central directory signature = 0x06054b50
      // 4 - Number of this disk
      var diskNumber = eocdrBuffer.readUInt16LE(4);
      if (diskNumber !== 0) {
        return callback(new Error("multi-disk zip files are not supported: found disk number: " + diskNumber));
      }
      // 6 - Disk where central directory starts
      // 8 - Number of central directory records on this disk
      // 10 - Total number of central directory records
      var entryCount = eocdrBuffer.readUInt16LE(10);
      // 12 - Size of central directory (bytes)
      // 16 - Offset of start of central directory, relative to start of archive
      var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);
      // 20 - Comment length
      var commentLength = eocdrBuffer.readUInt16LE(20);
      var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;
      if (commentLength !== expectedCommentLength) {
        return callback(new Error("invalid comment length. expected: " + expectedCommentLength + ". found: " + commentLength));
      }
      // 22 - Comment
      // the encoding is always cp437.
      var comment = decodeStrings ? decodeBuffer(eocdrBuffer, 22, eocdrBuffer.length, false)
                                  : eocdrBuffer.slice(22);

      if (!(entryCount === 0xffff || centralDirectoryOffset === 0xffffffff)) {
        return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
      }

      // ZIP64 format

      // ZIP64 Zip64 end of central directory locator
      var zip64EocdlBuffer = newBuffer(20);
      var zip64EocdlOffset = bufferReadStart + i - zip64EocdlBuffer.length;
      readAndAssertNoEof(reader, zip64EocdlBuffer, 0, zip64EocdlBuffer.length, zip64EocdlOffset, function(err) {
        if (err) return callback(err);

        // 0 - zip64 end of central dir locator signature = 0x07064b50
        if (zip64EocdlBuffer.readUInt32LE(0) !== 0x07064b50) {
          return callback(new Error("invalid zip64 end of central directory locator signature"));
        }
        // 4 - number of the disk with the start of the zip64 end of central directory
        // 8 - relative offset of the zip64 end of central directory record
        var zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8);
        // 16 - total number of disks

        // ZIP64 end of central directory record
        var zip64EocdrBuffer = newBuffer(56);
        readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function(err) {
          if (err) return callback(err);

          // 0 - zip64 end of central dir signature                           4 bytes  (0x06064b50)
          if (zip64EocdrBuffer.readUInt32LE(0) !== 0x06064b50) {
            return callback(new Error("invalid zip64 end of central directory record signature"));
          }
          // 4 - size of zip64 end of central directory record                8 bytes
          // 12 - version made by                                             2 bytes
          // 14 - version needed to extract                                   2 bytes
          // 16 - number of this disk                                         4 bytes
          // 20 - number of the disk with the start of the central directory  4 bytes
          // 24 - total number of entries in the central directory on this disk         8 bytes
          // 32 - total number of entries in the central directory            8 bytes
          entryCount = readUInt64LE(zip64EocdrBuffer, 32);
          // 40 - size of the central directory                               8 bytes
          // 48 - offset of start of central directory with respect to the starting disk number     8 bytes
          centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48);
          // 56 - zip64 extensible data sector                                (variable size)
          return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
        });
      });
      return;
    }
    callback(new Error("end of central directory record signature not found"));
  });
}

util$1.inherits(ZipFile, EventEmitter);
function ZipFile(reader, centralDirectoryOffset, fileSize, entryCount, comment, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {
  var self = this;
  EventEmitter.call(self);
  self.reader = reader;
  // forward close events
  self.reader.on("error", function(err) {
    // error closing the fd
    emitError(self, err);
  });
  self.reader.once("close", function() {
    self.emit("close");
  });
  self.readEntryCursor = centralDirectoryOffset;
  self.fileSize = fileSize;
  self.entryCount = entryCount;
  self.comment = comment;
  self.entriesRead = 0;
  self.autoClose = !!autoClose;
  self.lazyEntries = !!lazyEntries;
  self.decodeStrings = !!decodeStrings;
  self.validateEntrySizes = !!validateEntrySizes;
  self.strictFileNames = !!strictFileNames;
  self.isOpen = true;
  self.emittedError = false;

  if (!self.lazyEntries) self._readEntry();
}
ZipFile.prototype.close = function() {
  if (!this.isOpen) return;
  this.isOpen = false;
  this.reader.unref();
};

function emitErrorAndAutoClose(self, err) {
  if (self.autoClose) self.close();
  emitError(self, err);
}
function emitError(self, err) {
  if (self.emittedError) return;
  self.emittedError = true;
  self.emit("error", err);
}

ZipFile.prototype.readEntry = function() {
  if (!this.lazyEntries) throw new Error("readEntry() called without lazyEntries:true");
  this._readEntry();
};
ZipFile.prototype._readEntry = function() {
  var self = this;
  if (self.entryCount === self.entriesRead) {
    // done with metadata
    setImmediate(function() {
      if (self.autoClose) self.close();
      if (self.emittedError) return;
      self.emit("end");
    });
    return;
  }
  if (self.emittedError) return;
  var buffer = newBuffer(46);
  readAndAssertNoEof(self.reader, buffer, 0, buffer.length, self.readEntryCursor, function(err) {
    if (err) return emitErrorAndAutoClose(self, err);
    if (self.emittedError) return;
    var entry = new Entry();
    // 0 - Central directory file header signature
    var signature = buffer.readUInt32LE(0);
    if (signature !== 0x02014b50) return emitErrorAndAutoClose(self, new Error("invalid central directory file header signature: 0x" + signature.toString(16)));
    // 4 - Version made by
    entry.versionMadeBy = buffer.readUInt16LE(4);
    // 6 - Version needed to extract (minimum)
    entry.versionNeededToExtract = buffer.readUInt16LE(6);
    // 8 - General purpose bit flag
    entry.generalPurposeBitFlag = buffer.readUInt16LE(8);
    // 10 - Compression method
    entry.compressionMethod = buffer.readUInt16LE(10);
    // 12 - File last modification time
    entry.lastModFileTime = buffer.readUInt16LE(12);
    // 14 - File last modification date
    entry.lastModFileDate = buffer.readUInt16LE(14);
    // 16 - CRC-32
    entry.crc32 = buffer.readUInt32LE(16);
    // 20 - Compressed size
    entry.compressedSize = buffer.readUInt32LE(20);
    // 24 - Uncompressed size
    entry.uncompressedSize = buffer.readUInt32LE(24);
    // 28 - File name length (n)
    entry.fileNameLength = buffer.readUInt16LE(28);
    // 30 - Extra field length (m)
    entry.extraFieldLength = buffer.readUInt16LE(30);
    // 32 - File comment length (k)
    entry.fileCommentLength = buffer.readUInt16LE(32);
    // 34 - Disk number where file starts
    // 36 - Internal file attributes
    entry.internalFileAttributes = buffer.readUInt16LE(36);
    // 38 - External file attributes
    entry.externalFileAttributes = buffer.readUInt32LE(38);
    // 42 - Relative offset of local file header
    entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);

    if (entry.generalPurposeBitFlag & 0x40) return emitErrorAndAutoClose(self, new Error("strong encryption is not supported"));

    self.readEntryCursor += 46;

    buffer = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);
    readAndAssertNoEof(self.reader, buffer, 0, buffer.length, self.readEntryCursor, function(err) {
      if (err) return emitErrorAndAutoClose(self, err);
      if (self.emittedError) return;
      // 46 - File name
      var isUtf8 = (entry.generalPurposeBitFlag & 0x800) !== 0;
      entry.fileName = self.decodeStrings ? decodeBuffer(buffer, 0, entry.fileNameLength, isUtf8)
                                          : buffer.slice(0, entry.fileNameLength);

      // 46+n - Extra field
      var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;
      var extraFieldBuffer = buffer.slice(entry.fileNameLength, fileCommentStart);
      entry.extraFields = [];
      var i = 0;
      while (i < extraFieldBuffer.length - 3) {
        var headerId = extraFieldBuffer.readUInt16LE(i + 0);
        var dataSize = extraFieldBuffer.readUInt16LE(i + 2);
        var dataStart = i + 4;
        var dataEnd = dataStart + dataSize;
        if (dataEnd > extraFieldBuffer.length) return emitErrorAndAutoClose(self, new Error("extra field length exceeds extra field buffer size"));
        var dataBuffer = newBuffer(dataSize);
        extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd);
        entry.extraFields.push({
          id: headerId,
          data: dataBuffer,
        });
        i = dataEnd;
      }

      // 46+n+m - File comment
      entry.fileComment = self.decodeStrings ? decodeBuffer(buffer, fileCommentStart, fileCommentStart + entry.fileCommentLength, isUtf8)
                                             : buffer.slice(fileCommentStart, fileCommentStart + entry.fileCommentLength);
      // compatibility hack for https://github.com/thejoshwolfe/yauzl/issues/47
      entry.comment = entry.fileComment;

      self.readEntryCursor += buffer.length;
      self.entriesRead += 1;

      if (entry.uncompressedSize            === 0xffffffff ||
          entry.compressedSize              === 0xffffffff ||
          entry.relativeOffsetOfLocalHeader === 0xffffffff) {
        // ZIP64 format
        // find the Zip64 Extended Information Extra Field
        var zip64EiefBuffer = null;
        for (var i = 0; i < entry.extraFields.length; i++) {
          var extraField = entry.extraFields[i];
          if (extraField.id === 0x0001) {
            zip64EiefBuffer = extraField.data;
            break;
          }
        }
        if (zip64EiefBuffer == null) {
          return emitErrorAndAutoClose(self, new Error("expected zip64 extended information extra field"));
        }
        var index = 0;
        // 0 - Original Size          8 bytes
        if (entry.uncompressedSize === 0xffffffff) {
          if (index + 8 > zip64EiefBuffer.length) {
            return emitErrorAndAutoClose(self, new Error("zip64 extended information extra field does not include uncompressed size"));
          }
          entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index);
          index += 8;
        }
        // 8 - Compressed Size        8 bytes
        if (entry.compressedSize === 0xffffffff) {
          if (index + 8 > zip64EiefBuffer.length) {
            return emitErrorAndAutoClose(self, new Error("zip64 extended information extra field does not include compressed size"));
          }
          entry.compressedSize = readUInt64LE(zip64EiefBuffer, index);
          index += 8;
        }
        // 16 - Relative Header Offset 8 bytes
        if (entry.relativeOffsetOfLocalHeader === 0xffffffff) {
          if (index + 8 > zip64EiefBuffer.length) {
            return emitErrorAndAutoClose(self, new Error("zip64 extended information extra field does not include relative header offset"));
          }
          entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index);
          index += 8;
        }
        // 24 - Disk Start Number      4 bytes
      }

      // check for Info-ZIP Unicode Path Extra Field (0x7075)
      // see https://github.com/thejoshwolfe/yauzl/issues/33
      if (self.decodeStrings) {
        for (var i = 0; i < entry.extraFields.length; i++) {
          var extraField = entry.extraFields[i];
          if (extraField.id === 0x7075) {
            if (extraField.data.length < 6) {
              // too short to be meaningful
              continue;
            }
            // Version       1 byte      version of this extra field, currently 1
            if (extraField.data.readUInt8(0) !== 1) {
              // > Changes may not be backward compatible so this extra
              // > field should not be used if the version is not recognized.
              continue;
            }
            // NameCRC32     4 bytes     File Name Field CRC32 Checksum
            var oldNameCrc32 = extraField.data.readUInt32LE(1);
            if (crc32.unsigned(buffer.slice(0, entry.fileNameLength)) !== oldNameCrc32) {
              // > If the CRC check fails, this UTF-8 Path Extra Field should be
              // > ignored and the File Name field in the header should be used instead.
              continue;
            }
            // UnicodeName   Variable    UTF-8 version of the entry File Name
            entry.fileName = decodeBuffer(extraField.data, 5, extraField.data.length, true);
            break;
          }
        }
      }

      // validate file size
      if (self.validateEntrySizes && entry.compressionMethod === 0) {
        var expectedCompressedSize = entry.uncompressedSize;
        if (entry.isEncrypted()) {
          // traditional encryption prefixes the file data with a header
          expectedCompressedSize += 12;
        }
        if (entry.compressedSize !== expectedCompressedSize) {
          var msg = "compressed/uncompressed size mismatch for stored file: " + entry.compressedSize + " != " + entry.uncompressedSize;
          return emitErrorAndAutoClose(self, new Error(msg));
        }
      }

      if (self.decodeStrings) {
        if (!self.strictFileNames) {
          // allow backslash
          entry.fileName = entry.fileName.replace(/\\/g, "/");
        }
        var errorMessage = validateFileName(entry.fileName, self.validateFileNameOptions);
        if (errorMessage != null) return emitErrorAndAutoClose(self, new Error(errorMessage));
      }
      self.emit("entry", entry);

      if (!self.lazyEntries) self._readEntry();
    });
  });
};

ZipFile.prototype.openReadStream = function(entry, options, callback) {
  var self = this;
  // parameter validation
  var relativeStart = 0;
  var relativeEnd = entry.compressedSize;
  if (callback == null) {
    callback = options;
    options = {};
  } else {
    // validate options that the caller has no excuse to get wrong
    if (options.decrypt != null) {
      if (!entry.isEncrypted()) {
        throw new Error("options.decrypt can only be specified for encrypted entries");
      }
      if (options.decrypt !== false) throw new Error("invalid options.decrypt value: " + options.decrypt);
      if (entry.isCompressed()) {
        if (options.decompress !== false) throw new Error("entry is encrypted and compressed, and options.decompress !== false");
      }
    }
    if (options.decompress != null) {
      if (!entry.isCompressed()) {
        throw new Error("options.decompress can only be specified for compressed entries");
      }
      if (!(options.decompress === false || options.decompress === true)) {
        throw new Error("invalid options.decompress value: " + options.decompress);
      }
    }
    if (options.start != null || options.end != null) {
      if (entry.isCompressed() && options.decompress !== false) {
        throw new Error("start/end range not allowed for compressed entry without options.decompress === false");
      }
      if (entry.isEncrypted() && options.decrypt !== false) {
        throw new Error("start/end range not allowed for encrypted entry without options.decrypt === false");
      }
    }
    if (options.start != null) {
      relativeStart = options.start;
      if (relativeStart < 0) throw new Error("options.start < 0");
      if (relativeStart > entry.compressedSize) throw new Error("options.start > entry.compressedSize");
    }
    if (options.end != null) {
      relativeEnd = options.end;
      if (relativeEnd < 0) throw new Error("options.end < 0");
      if (relativeEnd > entry.compressedSize) throw new Error("options.end > entry.compressedSize");
      if (relativeEnd < relativeStart) throw new Error("options.end < options.start");
    }
  }
  // any further errors can either be caused by the zipfile,
  // or were introduced in a minor version of yauzl,
  // so should be passed to the client rather than thrown.
  if (!self.isOpen) return callback(new Error("closed"));
  if (entry.isEncrypted()) {
    if (options.decrypt !== false) return callback(new Error("entry is encrypted, and options.decrypt !== false"));
  }
  // make sure we don't lose the fd before we open the actual read stream
  self.reader.ref();
  var buffer = newBuffer(30);
  readAndAssertNoEof(self.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader, function(err) {
    try {
      if (err) return callback(err);
      // 0 - Local file header signature = 0x04034b50
      var signature = buffer.readUInt32LE(0);
      if (signature !== 0x04034b50) {
        return callback(new Error("invalid local file header signature: 0x" + signature.toString(16)));
      }
      // all this should be redundant
      // 4 - Version needed to extract (minimum)
      // 6 - General purpose bit flag
      // 8 - Compression method
      // 10 - File last modification time
      // 12 - File last modification date
      // 14 - CRC-32
      // 18 - Compressed size
      // 22 - Uncompressed size
      // 26 - File name length (n)
      var fileNameLength = buffer.readUInt16LE(26);
      // 28 - Extra field length (m)
      var extraFieldLength = buffer.readUInt16LE(28);
      // 30 - File name
      // 30+n - Extra field
      var localFileHeaderEnd = entry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;
      var decompress;
      if (entry.compressionMethod === 0) {
        // 0 - The file is stored (no compression)
        decompress = false;
      } else if (entry.compressionMethod === 8) {
        // 8 - The file is Deflated
        decompress = options.decompress != null ? options.decompress : true;
      } else {
        return callback(new Error("unsupported compression method: " + entry.compressionMethod));
      }
      var fileDataStart = localFileHeaderEnd;
      var fileDataEnd = fileDataStart + entry.compressedSize;
      if (entry.compressedSize !== 0) {
        // bounds check now, because the read streams will probably not complain loud enough.
        // since we're dealing with an unsigned offset plus an unsigned size,
        // we only have 1 thing to check for.
        if (fileDataEnd > self.fileSize) {
          return callback(new Error("file data overflows file bounds: " +
              fileDataStart + " + " + entry.compressedSize + " > " + self.fileSize));
        }
      }
      var readStream = self.reader.createReadStream({
        start: fileDataStart + relativeStart,
        end: fileDataStart + relativeEnd,
      });
      var endpointStream = readStream;
      if (decompress) {
        var destroyed = false;
        var inflateFilter = zlib.createInflateRaw();
        readStream.on("error", function(err) {
          // setImmediate here because errors can be emitted during the first call to pipe()
          setImmediate(function() {
            if (!destroyed) inflateFilter.emit("error", err);
          });
        });
        readStream.pipe(inflateFilter);

        if (self.validateEntrySizes) {
          endpointStream = new AssertByteCountStream(entry.uncompressedSize);
          inflateFilter.on("error", function(err) {
            // forward zlib errors to the client-visible stream
            setImmediate(function() {
              if (!destroyed) endpointStream.emit("error", err);
            });
          });
          inflateFilter.pipe(endpointStream);
        } else {
          // the zlib filter is the client-visible stream
          endpointStream = inflateFilter;
        }
        // this is part of yauzl's API, so implement this function on the client-visible stream
        endpointStream.destroy = function() {
          destroyed = true;
          if (inflateFilter !== endpointStream) inflateFilter.unpipe(endpointStream);
          readStream.unpipe(inflateFilter);
          // TODO: the inflateFilter may cause a memory leak. see Issue #27.
          readStream.destroy();
        };
      }
      callback(null, endpointStream);
    } finally {
      self.reader.unref();
    }
  });
};

function Entry() {
}
Entry.prototype.getLastModDate = function() {
  return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);
};
Entry.prototype.isEncrypted = function() {
  return (this.generalPurposeBitFlag & 0x1) !== 0;
};
Entry.prototype.isCompressed = function() {
  return this.compressionMethod === 8;
};

function dosDateTimeToDate(date, time) {
  var day = date & 0x1f; // 1-31
  var month = (date >> 5 & 0xf) - 1; // 1-12, 0-11
  var year = (date >> 9 & 0x7f) + 1980; // 0-128, 1980-2108

  var millisecond = 0;
  var second = (time & 0x1f) * 2; // 0-29, 0-58 (even numbers)
  var minute = time >> 5 & 0x3f; // 0-59
  var hour = time >> 11 & 0x1f; // 0-23

  return new Date(year, month, day, hour, minute, second, millisecond);
}

function validateFileName(fileName) {
  if (fileName.indexOf("\\") !== -1) {
    return "invalid characters in fileName: " + fileName;
  }
  if (/^[a-zA-Z]:/.test(fileName) || /^\//.test(fileName)) {
    return "absolute path: " + fileName;
  }
  if (fileName.split("/").indexOf("..") !== -1) {
    return "invalid relative path: " + fileName;
  }
  // all good
  return null;
}

function readAndAssertNoEof(reader, buffer, offset, length, position, callback) {
  if (length === 0) {
    // fs.read will throw an out-of-bounds error if you try to read 0 bytes from a 0 byte file
    return setImmediate(function() { callback(null, newBuffer(0)); });
  }
  reader.read(buffer, offset, length, position, function(err, bytesRead) {
    if (err) return callback(err);
    if (bytesRead < length) {
      return callback(new Error("unexpected EOF"));
    }
    callback();
  });
}

util$1.inherits(AssertByteCountStream, Transform);
function AssertByteCountStream(byteCount) {
  Transform.call(this);
  this.actualByteCount = 0;
  this.expectedByteCount = byteCount;
}
AssertByteCountStream.prototype._transform = function(chunk, encoding, cb) {
  this.actualByteCount += chunk.length;
  if (this.actualByteCount > this.expectedByteCount) {
    var msg = "too many bytes in the stream. expected " + this.expectedByteCount + ". got at least " + this.actualByteCount;
    return cb(new Error(msg));
  }
  cb(null, chunk);
};
AssertByteCountStream.prototype._flush = function(cb) {
  if (this.actualByteCount < this.expectedByteCount) {
    var msg = "not enough bytes in the stream. expected " + this.expectedByteCount + ". got only " + this.actualByteCount;
    return cb(new Error(msg));
  }
  cb();
};

util$1.inherits(RandomAccessReader, EventEmitter);
function RandomAccessReader() {
  EventEmitter.call(this);
  this.refCount = 0;
}
RandomAccessReader.prototype.ref = function() {
  this.refCount += 1;
};
RandomAccessReader.prototype.unref = function() {
  var self = this;
  self.refCount -= 1;

  if (self.refCount > 0) return;
  if (self.refCount < 0) throw new Error("invalid unref");

  self.close(onCloseDone);

  function onCloseDone(err) {
    if (err) return self.emit('error', err);
    self.emit('close');
  }
};
RandomAccessReader.prototype.createReadStream = function(options) {
  var start = options.start;
  var end = options.end;
  if (start === end) {
    var emptyStream = new PassThrough();
    setImmediate(function() {
      emptyStream.end();
    });
    return emptyStream;
  }
  var stream = this._readStreamForRange(start, end);

  var destroyed = false;
  var refUnrefFilter = new RefUnrefFilter(this);
  stream.on("error", function(err) {
    setImmediate(function() {
      if (!destroyed) refUnrefFilter.emit("error", err);
    });
  });
  refUnrefFilter.destroy = function() {
    stream.unpipe(refUnrefFilter);
    refUnrefFilter.unref();
    stream.destroy();
  };

  var byteCounter = new AssertByteCountStream(end - start);
  refUnrefFilter.on("error", function(err) {
    setImmediate(function() {
      if (!destroyed) byteCounter.emit("error", err);
    });
  });
  byteCounter.destroy = function() {
    destroyed = true;
    refUnrefFilter.unpipe(byteCounter);
    refUnrefFilter.destroy();
  };

  return stream.pipe(refUnrefFilter).pipe(byteCounter);
};
RandomAccessReader.prototype._readStreamForRange = function(start, end) {
  throw new Error("not implemented");
};
RandomAccessReader.prototype.read = function(buffer, offset, length, position, callback) {
  var readStream = this.createReadStream({start: position, end: position + length});
  var writeStream = new Writable();
  var written = 0;
  writeStream._write = function(chunk, encoding, cb) {
    chunk.copy(buffer, offset + written, 0, chunk.length);
    written += chunk.length;
    cb();
  };
  writeStream.on("finish", callback);
  readStream.on("error", function(error) {
    callback(error);
  });
  readStream.pipe(writeStream);
};
RandomAccessReader.prototype.close = function(callback) {
  setImmediate(callback);
};

util$1.inherits(RefUnrefFilter, PassThrough);
function RefUnrefFilter(context) {
  PassThrough.call(this);
  this.context = context;
  this.context.ref();
  this.unreffedYet = false;
}
RefUnrefFilter.prototype._flush = function(cb) {
  this.unref();
  cb();
};
RefUnrefFilter.prototype.unref = function(cb) {
  if (this.unreffedYet) return;
  this.unreffedYet = true;
  this.context.unref();
};

var cp437 = '\u0000 !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~';
function decodeBuffer(buffer, start, end, isUtf8) {
  if (isUtf8) {
    return buffer.toString("utf8", start, end);
  } else {
    var result = "";
    for (var i = start; i < end; i++) {
      result += cp437[buffer[i]];
    }
    return result;
  }
}

function readUInt64LE(buffer, offset) {
  // there is no native function for this, because we can't actually store 64-bit integers precisely.
  // after 53 bits, JavaScript's Number type (IEEE 754 double) can't store individual integers anymore.
  // but since 53 bits is a whole lot more than 32 bits, we do our best anyway.
  var lower32 = buffer.readUInt32LE(offset);
  var upper32 = buffer.readUInt32LE(offset + 4);
  // we can't use bitshifting here, because JavaScript bitshifting only works on 32-bit integers.
  return upper32 * 0x100000000 + lower32;
  // as long as we're bounds checking the result of this function against the total file size,
  // we'll catch any overflow errors, because we already made sure the total file size was within reason.
}

// Node 10 deprecated new Buffer().
var newBuffer;
if (typeof Buffer.allocUnsafe === "function") {
  newBuffer = function(len) {
    return Buffer.allocUnsafe(len);
  };
} else {
  newBuffer = function(len) {
    return new Buffer(len);
  };
}

function defaultCallback(err) {
  if (err) throw err;
}

const { createWriteStream, promises: fs$1 } = require$$0__default$6["default"];
const getStream = getStream$2.exports;
const path$1 = require$$1__default["default"];
const { promisify } = require$$4__default["default"];
const stream = Stream__default["default"];
const yauzl = yauzl$1;
const openZip = promisify(yauzl.open);
const pipeline = promisify(stream.pipeline);
class Extractor {
  constructor(zipPath, opts) {
    this.zipPath = zipPath;
    this.opts = opts;
  }
  async extract() {
    this.zipfile = await openZip(this.zipPath, { lazyEntries: true });
    this.canceled = false;
    return new Promise((resolve, reject) => {
      this.zipfile.on("error", (err) => {
        this.canceled = true;
        reject(err);
      });
      this.zipfile.readEntry();
      this.zipfile.on("close", () => {
        if (!this.canceled) {
          resolve();
        }
      });
      this.zipfile.on("entry", async (entry) => {
        if (this.canceled) {
          return;
        }
        if (entry.fileName.startsWith("__MACOSX/")) {
          this.zipfile.readEntry();
          return;
        }
        const destDir = path$1.dirname(path$1.join(this.opts.dir, entry.fileName));
        try {
          await fs$1.mkdir(destDir, { recursive: true });
          const canonicalDestDir = await fs$1.realpath(destDir);
          const relativeDestDir = path$1.relative(this.opts.dir, canonicalDestDir);
          if (relativeDestDir.split(path$1.sep).includes("..")) {
            throw new Error(`Out of bound path "${canonicalDestDir}" found while processing file ${entry.fileName}`);
          }
          await this.extractEntry(entry);
          this.zipfile.readEntry();
        } catch (err) {
          this.canceled = true;
          this.zipfile.close();
          reject(err);
        }
      });
    });
  }
  async extractEntry(entry) {
    if (this.canceled) {
      return;
    }
    if (this.opts.onEntry) {
      this.opts.onEntry(entry, this.zipfile);
    }
    const dest = path$1.join(this.opts.dir, entry.fileName);
    const mode = entry.externalFileAttributes >> 16 & 65535;
    const IFMT = 61440;
    const IFDIR = 16384;
    const IFLNK = 40960;
    const symlink = (mode & IFMT) === IFLNK;
    let isDir = (mode & IFMT) === IFDIR;
    if (!isDir && entry.fileName.endsWith("/")) {
      isDir = true;
    }
    const madeBy = entry.versionMadeBy >> 8;
    if (!isDir)
      isDir = madeBy === 0 && entry.externalFileAttributes === 16;
    const procMode = this.getExtractedMode(mode, isDir) & 511;
    const destDir = isDir ? dest : path$1.dirname(dest);
    const mkdirOptions = { recursive: true };
    if (isDir) {
      mkdirOptions.mode = procMode;
    }
    await fs$1.mkdir(destDir, mkdirOptions);
    if (isDir)
      return;
    const readStream = await promisify(this.zipfile.openReadStream.bind(this.zipfile))(entry);
    if (symlink) {
      const link = await getStream(readStream);
      await fs$1.symlink(link, dest);
    } else {
      await pipeline(readStream, createWriteStream(dest, { mode: procMode }));
    }
  }
  getExtractedMode(entryMode, isDir) {
    let mode = entryMode;
    if (mode === 0) {
      if (isDir) {
        if (this.opts.defaultDirMode) {
          mode = parseInt(this.opts.defaultDirMode, 10);
        }
        if (!mode) {
          mode = 493;
        }
      } else {
        if (this.opts.defaultFileMode) {
          mode = parseInt(this.opts.defaultFileMode, 10);
        }
        if (!mode) {
          mode = 420;
        }
      }
    }
    return mode;
  }
}
var extractZip = async function(zipPath, opts) {
  if (!path$1.isAbsolute(opts.dir)) {
    throw new Error("Target directory is expected to be absolute");
  }
  await fs$1.mkdir(opts.dir, { recursive: true });
  opts.dir = await fs$1.realpath(opts.dir);
  return new Extractor(zipPath, opts).extract();
};

const { app: app$1 } = require$$0__default$4["default"];
const fetch = require$$1$1.default;
const semver = semver$1;
const util = require$$4__default["default"];
const path = require$$1__default["default"];
const fs = lib$1;
const extract = extractZip;
const { version } = require$$7;
const { hash, sendMsg } = utils;
const config = config_1;
const i18n = i18n_1;
const streamPipeline = util.promisify(Stream__default["default"].pipeline);
async function download(url, filePath) {
  const response = await fetch(url);
  if (!response.ok)
    throw new Error(`unexpected response ${response.statusText}`);
  await streamPipeline(response.body, fs.createWriteStream(filePath));
}
const updateInfo = {
  status: "init"
};
const isDev$1 = !app$1.isPackaged;
const appPath = isDev$1 ? path.resolve(__dirname, "../../", "update-dev/app") : app$1.getAppPath();
const updatePath = isDev$1 ? path.resolve(__dirname, "../../", "update-dev/download") : path.resolve(appPath, "..", "..", "update");
const update = async () => {
  if (isDev$1)
    return;
  try {
    const url = "https://genshin-gacha-export.danmu9.com/update";
    const res = await fetch(`${url}/manifest.json?t=${Math.floor(Date.now() / (1e3 * 60 * 10))}`);
    const data = await res.json();
    if (!data.active)
      return;
    if (semver.gt(data.version, version) && semver.gte(version, data.from)) {
      await fs.emptyDir(updatePath);
      const filePath = path.join(updatePath, data.name);
      if (!config.autoUpdate) {
        sendMsg(data.version, "NEW_VERSION");
        return;
      }
      updateInfo.status = "downloading";
      await download(`${url}/${data.name}`, filePath);
      const buffer = await fs.readFile(filePath);
      const sha256 = hash(buffer);
      if (sha256 !== data.hash)
        return;
      const appPathTemp = path.join(updatePath, "app");
      await extract(filePath, { dir: appPathTemp });
      updateInfo.status = "moving";
      await fs.emptyDir(appPath);
      await fs.copy(appPathTemp, appPath);
      updateInfo.status = "finished";
      sendMsg(i18n.log.autoUpdate.success, "UPDATE_HINT");
    }
  } catch (e) {
    updateInfo.status = "failed";
    sendMsg(e, "ERROR");
  }
};
const getUpdateInfo$1 = () => updateInfo;
setTimeout(update, 1e3);
update$1.getUpdateInfo = getUpdateInfo$1;

const { app, BrowserWindow, ipcMain } = require$$0__default$4["default"];
const { initWindow } = utils;
const { disableProxy, proxyStatus } = systemProxy;
const { getUpdateInfo } = update$1;
const isDev = !app.isPackaged;
let win = null;
function createWindow() {
  win = initWindow();
  win.setMenuBarVisibility(false);
  isDev ? win.loadURL(`http://localhost:${process.env.PORT}`) : win.loadFile("dist/electron/renderer/index.html");
  if (isDev) {
    win.webContents.openDevTools({ mode: "undocked", activate: true });
  }
  ipcMain.on("window-minimize", () => {
    win.minimize();
  });
  ipcMain.on("window-maximize", () => {
    if (win.isMaximized()) {
      win.unmaximize();
      win.webContents.send("window-unmaximized");
    } else {
      win.maximize();
      win.webContents.send("window-maximized");
    }
  });
  ipcMain.on("window-close", () => {
    win.close();
  });
}
const isFirstInstance = app.requestSingleInstanceLock();
if (!isFirstInstance) {
  app.quit();
} else {
  app.on("second-instance", () => {
    if (win) {
      if (win.isMinimized())
        win.restore();
      win.focus();
    }
  });
  app.whenReady().then(createWindow);
  ipcMain.handle("RELAUNCH", async () => {
    app.relaunch();
    app.exit(0);
  });
  app.on("window-all-closed", () => {
    if (process.platform !== "darwin") {
      app.quit();
    }
  });
  app.on("activate", () => {
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow();
    }
  });
  app.on("will-quit", (e) => {
    if (proxyStatus.started) {
      disableProxy();
    }
    if (getUpdateInfo().status === "moving") {
      e.preventDefault();
      setTimeout(() => {
        app.quit();
      }, 3e3);
    }
  });
  app.on("quit", () => {
    if (proxyStatus.started) {
      disableProxy();
    }
  });
}

module.exports = main$1;
